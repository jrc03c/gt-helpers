(() => {
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };

  // node_modules/@vue/shared/dist/shared.cjs.js
  var require_shared_cjs = __commonJS({
    "node_modules/@vue/shared/dist/shared.cjs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function makeMap(str, expectsLowerCase) {
        const map = /* @__PURE__ */ Object.create(null);
        const list = str.split(",");
        for (let i = 0; i < list.length; i++) {
          map[list[i]] = true;
        }
        return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
      }
      var EMPTY_OBJ = Object.freeze({});
      var EMPTY_ARR = Object.freeze([]);
      var NOOP = () => {
      };
      var NO = () => false;
      var onRE = /^on[^a-z]/;
      var isOn = (key) => onRE.test(key);
      var isModelListener = (key) => key.startsWith("onUpdate:");
      var extend = Object.assign;
      var remove = (arr, el) => {
        const i = arr.indexOf(el);
        if (i > -1) {
          arr.splice(i, 1);
        }
      };
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var hasOwn = (val, key) => hasOwnProperty.call(val, key);
      var isArray = Array.isArray;
      var isMap = (val) => toTypeString(val) === "[object Map]";
      var isSet = (val) => toTypeString(val) === "[object Set]";
      var isDate = (val) => toTypeString(val) === "[object Date]";
      var isRegExp = (val) => toTypeString(val) === "[object RegExp]";
      var isFunction = (val) => typeof val === "function";
      var isString = (val) => typeof val === "string";
      var isSymbol = (val) => typeof val === "symbol";
      var isObject = (val) => val !== null && typeof val === "object";
      var isPromise = (val) => {
        return isObject(val) && isFunction(val.then) && isFunction(val.catch);
      };
      var objectToString = Object.prototype.toString;
      var toTypeString = (value) => objectToString.call(value);
      var toRawType = (value) => {
        return toTypeString(value).slice(8, -1);
      };
      var isPlainObject = (val) => toTypeString(val) === "[object Object]";
      var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
      var isReservedProp = /* @__PURE__ */ makeMap(
        // the leading comma is intentional so empty string "" is also included
        ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
      );
      var isBuiltInDirective = /* @__PURE__ */ makeMap(
        "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
      );
      var cacheStringFunction = (fn) => {
        const cache = /* @__PURE__ */ Object.create(null);
        return (str) => {
          const hit = cache[str];
          return hit || (cache[str] = fn(str));
        };
      };
      var camelizeRE = /-(\w)/g;
      var camelize = cacheStringFunction((str) => {
        return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
      });
      var hyphenateRE = /\B([A-Z])/g;
      var hyphenate = cacheStringFunction(
        (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
      );
      var capitalize = cacheStringFunction(
        (str) => str.charAt(0).toUpperCase() + str.slice(1)
      );
      var toHandlerKey = cacheStringFunction(
        (str) => str ? `on${capitalize(str)}` : ``
      );
      var hasChanged = (value, oldValue) => !Object.is(value, oldValue);
      var invokeArrayFns = (fns, arg) => {
        for (let i = 0; i < fns.length; i++) {
          fns[i](arg);
        }
      };
      var def = (obj, key, value) => {
        Object.defineProperty(obj, key, {
          configurable: true,
          enumerable: false,
          value
        });
      };
      var looseToNumber = (val) => {
        const n = parseFloat(val);
        return isNaN(n) ? val : n;
      };
      var toNumber = (val) => {
        const n = isString(val) ? Number(val) : NaN;
        return isNaN(n) ? val : n;
      };
      var _globalThis;
      var getGlobalThis = () => {
        return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
      };
      var identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
      function genPropsAccessExp(name) {
        return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
      }
      var PatchFlagNames = {
        [1]: `TEXT`,
        [2]: `CLASS`,
        [4]: `STYLE`,
        [8]: `PROPS`,
        [16]: `FULL_PROPS`,
        [32]: `HYDRATE_EVENTS`,
        [64]: `STABLE_FRAGMENT`,
        [128]: `KEYED_FRAGMENT`,
        [256]: `UNKEYED_FRAGMENT`,
        [512]: `NEED_PATCH`,
        [1024]: `DYNAMIC_SLOTS`,
        [2048]: `DEV_ROOT_FRAGMENT`,
        [-1]: `HOISTED`,
        [-2]: `BAIL`
      };
      var slotFlagsText = {
        [1]: "STABLE",
        [2]: "DYNAMIC",
        [3]: "FORWARDED"
      };
      var GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console";
      var isGloballyWhitelisted = /* @__PURE__ */ makeMap(GLOBALS_WHITE_LISTED);
      var range = 2;
      function generateCodeFrame(source, start = 0, end = source.length) {
        let lines = source.split(/(\r?\n)/);
        const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
        lines = lines.filter((_, idx) => idx % 2 === 0);
        let count = 0;
        const res = [];
        for (let i = 0; i < lines.length; i++) {
          count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
          if (count >= start) {
            for (let j = i - range; j <= i + range || end > count; j++) {
              if (j < 0 || j >= lines.length)
                continue;
              const line = j + 1;
              res.push(
                `${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`
              );
              const lineLength = lines[j].length;
              const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
              if (j === i) {
                const pad = start - (count - (lineLength + newLineSeqLength));
                const length = Math.max(
                  1,
                  end > count ? lineLength - pad : end - start
                );
                res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
              } else if (j > i) {
                if (end > count) {
                  const length = Math.max(Math.min(end - count, lineLength), 1);
                  res.push(`   |  ` + "^".repeat(length));
                }
                count += lineLength + newLineSeqLength;
              }
            }
            break;
          }
        }
        return res.join("\n");
      }
      function normalizeStyle(value) {
        if (isArray(value)) {
          const res = {};
          for (let i = 0; i < value.length; i++) {
            const item = value[i];
            const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
            if (normalized) {
              for (const key in normalized) {
                res[key] = normalized[key];
              }
            }
          }
          return res;
        } else if (isString(value)) {
          return value;
        } else if (isObject(value)) {
          return value;
        }
      }
      var listDelimiterRE = /;(?![^(]*\))/g;
      var propertyDelimiterRE = /:([^]+)/;
      var styleCommentRE = /\/\*[^]*?\*\//g;
      function parseStringStyle(cssText) {
        const ret = {};
        cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
          if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
          }
        });
        return ret;
      }
      function stringifyStyle(styles) {
        let ret = "";
        if (!styles || isString(styles)) {
          return ret;
        }
        for (const key in styles) {
          const value = styles[key];
          const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
          if (isString(value) || typeof value === "number") {
            ret += `${normalizedKey}:${value};`;
          }
        }
        return ret;
      }
      function normalizeClass(value) {
        let res = "";
        if (isString(value)) {
          res = value;
        } else if (isArray(value)) {
          for (let i = 0; i < value.length; i++) {
            const normalized = normalizeClass(value[i]);
            if (normalized) {
              res += normalized + " ";
            }
          }
        } else if (isObject(value)) {
          for (const name in value) {
            if (value[name]) {
              res += name + " ";
            }
          }
        }
        return res.trim();
      }
      function normalizeProps(props) {
        if (!props)
          return null;
        let { class: klass, style } = props;
        if (klass && !isString(klass)) {
          props.class = normalizeClass(klass);
        }
        if (style) {
          props.style = normalizeStyle(style);
        }
        return props;
      }
      var HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
      var SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
      var VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
      var isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
      var isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
      var isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
      var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
      var isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
      var isBooleanAttr = /* @__PURE__ */ makeMap(
        specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`
      );
      function includeBooleanAttr(value) {
        return !!value || value === "";
      }
      var unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
      var attrValidationCache = {};
      function isSSRSafeAttrName(name) {
        if (attrValidationCache.hasOwnProperty(name)) {
          return attrValidationCache[name];
        }
        const isUnsafe = unsafeAttrCharRE.test(name);
        if (isUnsafe) {
          console.error(`unsafe attribute name: ${name}`);
        }
        return attrValidationCache[name] = !isUnsafe;
      }
      var propsToAttrMap = {
        acceptCharset: "accept-charset",
        className: "class",
        htmlFor: "for",
        httpEquiv: "http-equiv"
      };
      var isKnownHtmlAttr = /* @__PURE__ */ makeMap(
        `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`
      );
      var isKnownSvgAttr = /* @__PURE__ */ makeMap(
        `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`
      );
      var escapeRE = /["'&<>]/;
      function escapeHtml(string) {
        const str = "" + string;
        const match = escapeRE.exec(str);
        if (!match) {
          return str;
        }
        let html = "";
        let escaped;
        let index;
        let lastIndex = 0;
        for (index = match.index; index < str.length; index++) {
          switch (str.charCodeAt(index)) {
            case 34:
              escaped = "&quot;";
              break;
            case 38:
              escaped = "&amp;";
              break;
            case 39:
              escaped = "&#39;";
              break;
            case 60:
              escaped = "&lt;";
              break;
            case 62:
              escaped = "&gt;";
              break;
            default:
              continue;
          }
          if (lastIndex !== index) {
            html += str.slice(lastIndex, index);
          }
          lastIndex = index + 1;
          html += escaped;
        }
        return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
      }
      var commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
      function escapeHtmlComment(src) {
        return src.replace(commentStripRE, "");
      }
      function looseCompareArrays(a, b) {
        if (a.length !== b.length)
          return false;
        let equal = true;
        for (let i = 0; equal && i < a.length; i++) {
          equal = looseEqual(a[i], b[i]);
        }
        return equal;
      }
      function looseEqual(a, b) {
        if (a === b)
          return true;
        let aValidType = isDate(a);
        let bValidType = isDate(b);
        if (aValidType || bValidType) {
          return aValidType && bValidType ? a.getTime() === b.getTime() : false;
        }
        aValidType = isSymbol(a);
        bValidType = isSymbol(b);
        if (aValidType || bValidType) {
          return a === b;
        }
        aValidType = isArray(a);
        bValidType = isArray(b);
        if (aValidType || bValidType) {
          return aValidType && bValidType ? looseCompareArrays(a, b) : false;
        }
        aValidType = isObject(a);
        bValidType = isObject(b);
        if (aValidType || bValidType) {
          if (!aValidType || !bValidType) {
            return false;
          }
          const aKeysCount = Object.keys(a).length;
          const bKeysCount = Object.keys(b).length;
          if (aKeysCount !== bKeysCount) {
            return false;
          }
          for (const key in a) {
            const aHasKey = a.hasOwnProperty(key);
            const bHasKey = b.hasOwnProperty(key);
            if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
              return false;
            }
          }
        }
        return String(a) === String(b);
      }
      function looseIndexOf(arr, val) {
        return arr.findIndex((item) => looseEqual(item, val));
      }
      var toDisplayString = (val) => {
        return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
      };
      var replacer = (_key, val) => {
        if (val && val.__v_isRef) {
          return replacer(_key, val.value);
        } else if (isMap(val)) {
          return {
            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
              entries[`${key} =>`] = val2;
              return entries;
            }, {})
          };
        } else if (isSet(val)) {
          return {
            [`Set(${val.size})`]: [...val.values()]
          };
        } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
          return String(val);
        }
        return val;
      };
      exports.EMPTY_ARR = EMPTY_ARR;
      exports.EMPTY_OBJ = EMPTY_OBJ;
      exports.NO = NO;
      exports.NOOP = NOOP;
      exports.PatchFlagNames = PatchFlagNames;
      exports.camelize = camelize;
      exports.capitalize = capitalize;
      exports.def = def;
      exports.escapeHtml = escapeHtml;
      exports.escapeHtmlComment = escapeHtmlComment;
      exports.extend = extend;
      exports.genPropsAccessExp = genPropsAccessExp;
      exports.generateCodeFrame = generateCodeFrame;
      exports.getGlobalThis = getGlobalThis;
      exports.hasChanged = hasChanged;
      exports.hasOwn = hasOwn;
      exports.hyphenate = hyphenate;
      exports.includeBooleanAttr = includeBooleanAttr;
      exports.invokeArrayFns = invokeArrayFns;
      exports.isArray = isArray;
      exports.isBooleanAttr = isBooleanAttr;
      exports.isBuiltInDirective = isBuiltInDirective;
      exports.isDate = isDate;
      exports.isFunction = isFunction;
      exports.isGloballyWhitelisted = isGloballyWhitelisted;
      exports.isHTMLTag = isHTMLTag;
      exports.isIntegerKey = isIntegerKey;
      exports.isKnownHtmlAttr = isKnownHtmlAttr;
      exports.isKnownSvgAttr = isKnownSvgAttr;
      exports.isMap = isMap;
      exports.isModelListener = isModelListener;
      exports.isObject = isObject;
      exports.isOn = isOn;
      exports.isPlainObject = isPlainObject;
      exports.isPromise = isPromise;
      exports.isRegExp = isRegExp;
      exports.isReservedProp = isReservedProp;
      exports.isSSRSafeAttrName = isSSRSafeAttrName;
      exports.isSVGTag = isSVGTag;
      exports.isSet = isSet;
      exports.isSpecialBooleanAttr = isSpecialBooleanAttr;
      exports.isString = isString;
      exports.isSymbol = isSymbol;
      exports.isVoidTag = isVoidTag;
      exports.looseEqual = looseEqual;
      exports.looseIndexOf = looseIndexOf;
      exports.looseToNumber = looseToNumber;
      exports.makeMap = makeMap;
      exports.normalizeClass = normalizeClass;
      exports.normalizeProps = normalizeProps;
      exports.normalizeStyle = normalizeStyle;
      exports.objectToString = objectToString;
      exports.parseStringStyle = parseStringStyle;
      exports.propsToAttrMap = propsToAttrMap;
      exports.remove = remove;
      exports.slotFlagsText = slotFlagsText;
      exports.stringifyStyle = stringifyStyle;
      exports.toDisplayString = toDisplayString;
      exports.toHandlerKey = toHandlerKey;
      exports.toNumber = toNumber;
      exports.toRawType = toRawType;
      exports.toTypeString = toTypeString;
    }
  });

  // node_modules/@vue/shared/index.js
  var require_shared = __commonJS({
    "node_modules/@vue/shared/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_shared_cjs();
      }
    }
  });

  // node_modules/@babel/parser/lib/index.js
  var require_lib = __commonJS({
    "node_modules/@babel/parser/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      function _objectWithoutPropertiesLoose(source, excluded) {
        if (source == null)
          return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key, i;
        for (i = 0; i < sourceKeys.length; i++) {
          key = sourceKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          target[key] = source[key];
        }
        return target;
      }
      var Position = class {
        constructor(line, col, index) {
          this.line = void 0;
          this.column = void 0;
          this.index = void 0;
          this.line = line;
          this.column = col;
          this.index = index;
        }
      };
      var SourceLocation = class {
        constructor(start, end) {
          this.start = void 0;
          this.end = void 0;
          this.filename = void 0;
          this.identifierName = void 0;
          this.start = start;
          this.end = end;
        }
      };
      function createPositionWithColumnOffset(position, columnOffset) {
        const {
          line,
          column,
          index
        } = position;
        return new Position(line, column + columnOffset, index + columnOffset);
      }
      var ParseErrorCode = {
        SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
        SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
      };
      var reflect = (keys, last = keys.length - 1) => ({
        get() {
          return keys.reduce((object, key) => object[key], this);
        },
        set(value) {
          keys.reduce((item, key, i) => i === last ? item[key] = value : item[key], this);
        }
      });
      var instantiate = (constructor, properties, descriptors) => Object.keys(descriptors).map((key) => [key, descriptors[key]]).filter(([, descriptor]) => !!descriptor).map(([key, descriptor]) => [key, typeof descriptor === "function" ? {
        value: descriptor,
        enumerable: false
      } : typeof descriptor.reflect === "string" ? Object.assign({}, descriptor, reflect(descriptor.reflect.split("."))) : descriptor]).reduce((instance, [key, descriptor]) => Object.defineProperty(instance, key, Object.assign({
        configurable: true
      }, descriptor)), Object.assign(new constructor(), properties));
      var ModuleErrors = {
        ImportMetaOutsideModule: {
          message: `import.meta may appear only with 'sourceType: "module"'`,
          code: ParseErrorCode.SourceTypeModuleError
        },
        ImportOutsideModule: {
          message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
          code: ParseErrorCode.SourceTypeModuleError
        }
      };
      var NodeDescriptions = {
        ArrayPattern: "array destructuring pattern",
        AssignmentExpression: "assignment expression",
        AssignmentPattern: "assignment expression",
        ArrowFunctionExpression: "arrow function expression",
        ConditionalExpression: "conditional expression",
        CatchClause: "catch clause",
        ForOfStatement: "for-of statement",
        ForInStatement: "for-in statement",
        ForStatement: "for-loop",
        FormalParameters: "function parameter list",
        Identifier: "identifier",
        ImportSpecifier: "import specifier",
        ImportDefaultSpecifier: "import default specifier",
        ImportNamespaceSpecifier: "import namespace specifier",
        ObjectPattern: "object destructuring pattern",
        ParenthesizedExpression: "parenthesized expression",
        RestElement: "rest element",
        UpdateExpression: {
          true: "prefix operation",
          false: "postfix operation"
        },
        VariableDeclarator: "variable declaration",
        YieldExpression: "yield expression"
      };
      var toNodeDescription = ({
        type,
        prefix: prefix2
      }) => type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[String(prefix2)] : NodeDescriptions[type];
      var StandardErrors = {
        AccessorIsGenerator: ({
          kind
        }) => `A ${kind}ter cannot be a generator.`,
        ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
        AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
        AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
        AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
        AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
        AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
        AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
        AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
        BadGetterArity: "A 'get' accessor must not have any formal parameters.",
        BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
        BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
        ConstructorClassField: "Classes may not have a field named 'constructor'.",
        ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
        ConstructorIsAccessor: "Class constructor may not be an accessor.",
        ConstructorIsAsync: "Constructor can't be an async function.",
        ConstructorIsGenerator: "Constructor can't be a generator.",
        DeclarationMissingInitializer: ({
          kind
        }) => `Missing initializer in ${kind} declaration.`,
        DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
        DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
        DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
        DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
        DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
        DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
        DecoratorStaticBlock: "Decorators can't be used with a static block.",
        DeletePrivateField: "Deleting a private field is not allowed.",
        DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
        DuplicateConstructor: "Duplicate constructor in the same class.",
        DuplicateDefaultExport: "Only one default export allowed per module.",
        DuplicateExport: ({
          exportName
        }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
        DuplicateProto: "Redefinition of __proto__ property.",
        DuplicateRegExpFlags: "Duplicate regular expression flag.",
        ElementAfterRest: "Rest element must be last element.",
        EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
        ExportBindingIsString: ({
          localName,
          exportName
        }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
        ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
        ForInOfLoopInitializer: ({
          type
        }) => `'${type === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
        ForInUsing: "For-in loop may not start with 'using' declaration.",
        ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
        ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
        GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
        IllegalBreakContinue: ({
          type
        }) => `Unsyntactic ${type === "BreakStatement" ? "break" : "continue"}.`,
        IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
        IllegalReturn: "'return' outside of function.",
        ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
        ImportBindingIsString: ({
          importName
        }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${importName}" as foo }\`?`,
        ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
        ImportCallArity: ({
          maxArgumentCount
        }) => `\`import()\` requires exactly ${maxArgumentCount === 1 ? "one argument" : "one or two arguments"}.`,
        ImportCallNotNewExpression: "Cannot use new with import(...).",
        ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
        ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
        ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
        ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
        IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
        InvalidBigIntLiteral: "Invalid BigIntLiteral.",
        InvalidCodePoint: "Code point out of bounds.",
        InvalidCoverInitializedName: "Invalid shorthand property initializer.",
        InvalidDecimal: "Invalid decimal.",
        InvalidDigit: ({
          radix
        }) => `Expected number in radix ${radix}.`,
        InvalidEscapeSequence: "Bad character escape sequence.",
        InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
        InvalidEscapedReservedWord: ({
          reservedWord
        }) => `Escape sequence in keyword ${reservedWord}.`,
        InvalidIdentifier: ({
          identifierName
        }) => `Invalid identifier ${identifierName}.`,
        InvalidLhs: ({
          ancestor
        }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
        InvalidLhsBinding: ({
          ancestor
        }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
        InvalidNumber: "Invalid number.",
        InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
        InvalidOrUnexpectedToken: ({
          unexpected
        }) => `Unexpected character '${unexpected}'.`,
        InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
        InvalidPrivateFieldResolution: ({
          identifierName
        }) => `Private name #${identifierName} is not defined.`,
        InvalidPropertyBindingPattern: "Binding member expression.",
        InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
        InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
        LabelRedeclaration: ({
          labelName
        }) => `Label '${labelName}' is already declared.`,
        LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
        LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
        MalformedRegExpFlags: "Invalid regular expression flag.",
        MissingClassName: "A class name is required.",
        MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
        MissingSemicolon: "Missing semicolon.",
        MissingPlugin: ({
          missingPlugin
        }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
        MissingOneOfPlugins: ({
          missingPlugin
        }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
        MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
        MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
        ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
        ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
        ModuleAttributesWithDuplicateKeys: ({
          key
        }) => `Duplicate key "${key}" is not allowed in module attributes.`,
        ModuleExportNameHasLoneSurrogate: ({
          surrogateCharCode
        }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
        ModuleExportUndefined: ({
          localName
        }) => `Export '${localName}' is not defined.`,
        MultipleDefaultsInSwitch: "Multiple default clauses.",
        NewlineAfterThrow: "Illegal newline after throw.",
        NoCatchOrFinally: "Missing catch or finally clause.",
        NumberIdentifier: "Identifier directly after number.",
        NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
        ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
        OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
        OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
        OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
        ParamDupe: "Argument name clash.",
        PatternHasAccessor: "Object pattern can't contain getter or setter.",
        PatternHasMethod: "Object pattern can't contain methods.",
        PrivateInExpectedIn: ({
          identifierName
        }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
        PrivateNameRedeclaration: ({
          identifierName
        }) => `Duplicate private name #${identifierName}.`,
        RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
        RecordNoProto: "'__proto__' is not allowed in Record expressions.",
        RestTrailingComma: "Unexpected trailing comma after rest element.",
        SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
        SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
        StaticPrototype: "Classes may not have static property named prototype.",
        SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
        SuperPrivateField: "Private fields can't be accessed on super.",
        TrailingDecorator: "Decorators must be attached to a class element.",
        TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
        UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
        UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
        UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
        UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
        UnexpectedKeyword: ({
          keyword
        }) => `Unexpected keyword '${keyword}'.`,
        UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
        UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
        UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
        UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
        UnexpectedPrivateField: "Unexpected private name.",
        UnexpectedReservedWord: ({
          reservedWord
        }) => `Unexpected reserved word '${reservedWord}'.`,
        UnexpectedSuper: "'super' is only allowed in object methods and classes.",
        UnexpectedToken: ({
          expected,
          unexpected
        }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`,
        UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
        UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
        UnsupportedBind: "Binding should be performed on object property.",
        UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
        UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
        UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
        UnsupportedMetaProperty: ({
          target,
          onlyValidPropertyName
        }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
        UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
        UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
        UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
        UnterminatedComment: "Unterminated comment.",
        UnterminatedRegExp: "Unterminated regular expression.",
        UnterminatedString: "Unterminated string constant.",
        UnterminatedTemplate: "Unterminated template.",
        UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
        VarRedeclaration: ({
          identifierName
        }) => `Identifier '${identifierName}' has already been declared.`,
        YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
        YieldInParameter: "Yield expression is not allowed in formal parameters.",
        ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
      };
      var StrictModeErrors = {
        StrictDelete: "Deleting local variable in strict mode.",
        StrictEvalArguments: ({
          referenceName
        }) => `Assigning to '${referenceName}' in strict mode.`,
        StrictEvalArgumentsBinding: ({
          bindingName
        }) => `Binding '${bindingName}' in strict mode.`,
        StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
        StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
        StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
        StrictWith: "'with' in strict mode."
      };
      var UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
      var PipelineOperatorErrors = {
        PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
        PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
        PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
        PipeTopicUnconfiguredToken: ({
          token
        }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,
        PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
        PipeUnparenthesizedBody: ({
          type
        }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
          type
        })}; please wrap it in parentheses.`,
        PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
        PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
        PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
        PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
        PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
        PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
      };
      var _excluded$1 = ["toMessage"];
      var _excluded2$1 = ["message"];
      function toParseErrorConstructor(_ref) {
        let {
          toMessage
        } = _ref, properties = _objectWithoutPropertiesLoose(_ref, _excluded$1);
        return function constructor({
          loc,
          details
        }) {
          return instantiate(SyntaxError, Object.assign({}, properties, {
            loc
          }), {
            clone(overrides = {}) {
              const loc2 = overrides.loc || {};
              return constructor({
                loc: new Position("line" in loc2 ? loc2.line : this.loc.line, "column" in loc2 ? loc2.column : this.loc.column, "index" in loc2 ? loc2.index : this.loc.index),
                details: Object.assign({}, this.details, overrides.details)
              });
            },
            details: {
              value: details,
              enumerable: false
            },
            message: {
              get() {
                return `${toMessage(this.details)} (${this.loc.line}:${this.loc.column})`;
              },
              set(value) {
                Object.defineProperty(this, "message", {
                  value
                });
              }
            },
            pos: {
              reflect: "loc.index",
              enumerable: true
            },
            missingPlugin: "missingPlugin" in details && {
              reflect: "details.missingPlugin",
              enumerable: true
            }
          });
        };
      }
      function ParseErrorEnum(argument, syntaxPlugin) {
        if (Array.isArray(argument)) {
          return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);
        }
        const ParseErrorConstructors = {};
        for (const reasonCode of Object.keys(argument)) {
          const template = argument[reasonCode];
          const _ref2 = typeof template === "string" ? {
            message: () => template
          } : typeof template === "function" ? {
            message: template
          } : template, {
            message
          } = _ref2, rest = _objectWithoutPropertiesLoose(_ref2, _excluded2$1);
          const toMessage = typeof message === "string" ? () => message : message;
          ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
            code: ParseErrorCode.SyntaxError,
            reasonCode,
            toMessage
          }, syntaxPlugin ? {
            syntaxPlugin
          } : {}, rest));
        }
        return ParseErrorConstructors;
      }
      var Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));
      var {
        defineProperty
      } = Object;
      var toUnenumerable = (object, key) => defineProperty(object, key, {
        enumerable: false,
        value: object[key]
      });
      function toESTreeLocation(node) {
        node.loc.start && toUnenumerable(node.loc.start, "index");
        node.loc.end && toUnenumerable(node.loc.end, "index");
        return node;
      }
      var estree = (superClass) => class ESTreeParserMixin extends superClass {
        parse() {
          const file = toESTreeLocation(super.parse());
          if (this.options.tokens) {
            file.tokens = file.tokens.map(toESTreeLocation);
          }
          return file;
        }
        parseRegExpLiteral({
          pattern,
          flags
        }) {
          let regex = null;
          try {
            regex = new RegExp(pattern, flags);
          } catch (e) {
          }
          const node = this.estreeParseLiteral(regex);
          node.regex = {
            pattern,
            flags
          };
          return node;
        }
        parseBigIntLiteral(value) {
          let bigInt;
          try {
            bigInt = BigInt(value);
          } catch (_unused) {
            bigInt = null;
          }
          const node = this.estreeParseLiteral(bigInt);
          node.bigint = String(node.value || value);
          return node;
        }
        parseDecimalLiteral(value) {
          const decimal = null;
          const node = this.estreeParseLiteral(decimal);
          node.decimal = String(node.value || value);
          return node;
        }
        estreeParseLiteral(value) {
          return this.parseLiteral(value, "Literal");
        }
        parseStringLiteral(value) {
          return this.estreeParseLiteral(value);
        }
        parseNumericLiteral(value) {
          return this.estreeParseLiteral(value);
        }
        parseNullLiteral() {
          return this.estreeParseLiteral(null);
        }
        parseBooleanLiteral(value) {
          return this.estreeParseLiteral(value);
        }
        directiveToStmt(directive) {
          const expression = directive.value;
          delete directive.value;
          expression.type = "Literal";
          expression.raw = expression.extra.raw;
          expression.value = expression.extra.expressionValue;
          const stmt = directive;
          stmt.type = "ExpressionStatement";
          stmt.expression = expression;
          stmt.directive = expression.extra.rawValue;
          delete expression.extra;
          return stmt;
        }
        initFunction(node, isAsync) {
          super.initFunction(node, isAsync);
          node.expression = false;
        }
        checkDeclaration(node) {
          if (node != null && this.isObjectProperty(node)) {
            this.checkDeclaration(node.value);
          } else {
            super.checkDeclaration(node);
          }
        }
        getObjectOrClassMethodParams(method) {
          return method.value.params;
        }
        isValidDirective(stmt) {
          var _stmt$expression$extr;
          return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
        }
        parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
          super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);
          const directiveStatements = node.directives.map((d) => this.directiveToStmt(d));
          node.body = directiveStatements.concat(node.body);
          delete node.directives;
        }
        pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);
          if (method.typeParameters) {
            method.value.typeParameters = method.typeParameters;
            delete method.typeParameters;
          }
          classBody.body.push(method);
        }
        parsePrivateName() {
          const node = super.parsePrivateName();
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return node;
            }
          }
          return this.convertPrivateNameToPrivateIdentifier(node);
        }
        convertPrivateNameToPrivateIdentifier(node) {
          const name = super.getPrivateNameSV(node);
          node = node;
          delete node.id;
          node.name = name;
          node.type = "PrivateIdentifier";
          return node;
        }
        isPrivateName(node) {
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return super.isPrivateName(node);
            }
          }
          return node.type === "PrivateIdentifier";
        }
        getPrivateNameSV(node) {
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return super.getPrivateNameSV(node);
            }
          }
          return node.name;
        }
        parseLiteral(value, type) {
          const node = super.parseLiteral(value, type);
          node.raw = node.extra.raw;
          delete node.extra;
          return node;
        }
        parseFunctionBody(node, allowExpression, isMethod = false) {
          super.parseFunctionBody(node, allowExpression, isMethod);
          node.expression = node.body.type !== "BlockStatement";
        }
        parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
          let funcNode = this.startNode();
          funcNode.kind = node.kind;
          funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
          funcNode.type = "FunctionExpression";
          delete funcNode.kind;
          node.value = funcNode;
          if (type === "ClassPrivateMethod") {
            node.computed = false;
          }
          return this.finishNode(node, "MethodDefinition");
        }
        parseClassProperty(...args) {
          const propertyNode = super.parseClassProperty(...args);
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return propertyNode;
            }
          }
          propertyNode.type = "PropertyDefinition";
          return propertyNode;
        }
        parseClassPrivateProperty(...args) {
          const propertyNode = super.parseClassPrivateProperty(...args);
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return propertyNode;
            }
          }
          propertyNode.type = "PropertyDefinition";
          propertyNode.computed = false;
          return propertyNode;
        }
        parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
          const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);
          if (node) {
            node.type = "Property";
            if (node.kind === "method") {
              node.kind = "init";
            }
            node.shorthand = false;
          }
          return node;
        }
        parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
          const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
          if (node) {
            node.kind = "init";
            node.type = "Property";
          }
          return node;
        }
        isValidLVal(type, isUnparenthesizedInAssign, binding) {
          return type === "Property" ? "value" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);
        }
        isAssignable(node, isBinding) {
          if (node != null && this.isObjectProperty(node)) {
            return this.isAssignable(node.value, isBinding);
          }
          return super.isAssignable(node, isBinding);
        }
        toAssignable(node, isLHS = false) {
          if (node != null && this.isObjectProperty(node)) {
            const {
              key,
              value
            } = node;
            if (this.isPrivateName(key)) {
              this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
            }
            this.toAssignable(value, isLHS);
          } else {
            super.toAssignable(node, isLHS);
          }
        }
        toAssignableObjectExpressionProp(prop, isLast, isLHS) {
          if (prop.kind === "get" || prop.kind === "set") {
            this.raise(Errors.PatternHasAccessor, {
              at: prop.key
            });
          } else if (prop.method) {
            this.raise(Errors.PatternHasMethod, {
              at: prop.key
            });
          } else {
            super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
          }
        }
        finishCallExpression(unfinished, optional) {
          const node = super.finishCallExpression(unfinished, optional);
          if (node.callee.type === "Import") {
            node.type = "ImportExpression";
            node.source = node.arguments[0];
            if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
              var _node$arguments$;
              node.attributes = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;
            }
            delete node.arguments;
            delete node.callee;
          }
          return node;
        }
        toReferencedArguments(node) {
          if (node.type === "ImportExpression") {
            return;
          }
          super.toReferencedArguments(node);
        }
        parseExport(unfinished, decorators) {
          const exportStartLoc = this.state.lastTokStartLoc;
          const node = super.parseExport(unfinished, decorators);
          switch (node.type) {
            case "ExportAllDeclaration":
              node.exported = null;
              break;
            case "ExportNamedDeclaration":
              if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
                node.type = "ExportAllDeclaration";
                node.exported = node.specifiers[0].exported;
                delete node.specifiers;
              }
            case "ExportDefaultDeclaration":
              {
                var _declaration$decorato;
                const {
                  declaration
                } = node;
                if ((declaration == null ? void 0 : declaration.type) === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) {
                  this.resetStartLocation(node, exportStartLoc);
                }
              }
              break;
          }
          return node;
        }
        parseSubscript(base, startLoc, noCalls, state) {
          const node = super.parseSubscript(base, startLoc, noCalls, state);
          if (state.optionalChainMember) {
            if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") {
              node.type = node.type.substring(8);
            }
            if (state.stop) {
              const chain = this.startNodeAtNode(node);
              chain.expression = node;
              return this.finishNode(chain, "ChainExpression");
            }
          } else if (node.type === "MemberExpression" || node.type === "CallExpression") {
            node.optional = false;
          }
          return node;
        }
        hasPropertyAsPrivateName(node) {
          if (node.type === "ChainExpression") {
            node = node.expression;
          }
          return super.hasPropertyAsPrivateName(node);
        }
        isObjectProperty(node) {
          return node.type === "Property" && node.kind === "init" && !node.method;
        }
        isObjectMethod(node) {
          return node.method || node.kind === "get" || node.kind === "set";
        }
        finishNodeAt(node, type, endLoc) {
          return toESTreeLocation(super.finishNodeAt(node, type, endLoc));
        }
        resetStartLocation(node, startLoc) {
          super.resetStartLocation(node, startLoc);
          toESTreeLocation(node);
        }
        resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
          super.resetEndLocation(node, endLoc);
          toESTreeLocation(node);
        }
      };
      var TokContext = class {
        constructor(token, preserveSpace) {
          this.token = void 0;
          this.preserveSpace = void 0;
          this.token = token;
          this.preserveSpace = !!preserveSpace;
        }
      };
      var types = {
        brace: new TokContext("{"),
        j_oTag: new TokContext("<tag"),
        j_cTag: new TokContext("</tag"),
        j_expr: new TokContext("<tag>...</tag>", true)
      };
      {
        types.template = new TokContext("`", true);
      }
      var beforeExpr = true;
      var startsExpr = true;
      var isLoop = true;
      var isAssign = true;
      var prefix = true;
      var postfix = true;
      var ExportedTokenType = class {
        constructor(label, conf = {}) {
          this.label = void 0;
          this.keyword = void 0;
          this.beforeExpr = void 0;
          this.startsExpr = void 0;
          this.rightAssociative = void 0;
          this.isLoop = void 0;
          this.isAssign = void 0;
          this.prefix = void 0;
          this.postfix = void 0;
          this.binop = void 0;
          this.label = label;
          this.keyword = conf.keyword;
          this.beforeExpr = !!conf.beforeExpr;
          this.startsExpr = !!conf.startsExpr;
          this.rightAssociative = !!conf.rightAssociative;
          this.isLoop = !!conf.isLoop;
          this.isAssign = !!conf.isAssign;
          this.prefix = !!conf.prefix;
          this.postfix = !!conf.postfix;
          this.binop = conf.binop != null ? conf.binop : null;
          {
            this.updateContext = null;
          }
        }
      };
      var keywords$1 = /* @__PURE__ */ new Map();
      function createKeyword(name, options = {}) {
        options.keyword = name;
        const token = createToken(name, options);
        keywords$1.set(name, token);
        return token;
      }
      function createBinop(name, binop) {
        return createToken(name, {
          beforeExpr,
          binop
        });
      }
      var tokenTypeCounter = -1;
      var tokenTypes = [];
      var tokenLabels = [];
      var tokenBinops = [];
      var tokenBeforeExprs = [];
      var tokenStartsExprs = [];
      var tokenPrefixes = [];
      function createToken(name, options = {}) {
        var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
        ++tokenTypeCounter;
        tokenLabels.push(name);
        tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
        tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
        tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
        tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
        tokenTypes.push(new ExportedTokenType(name, options));
        return tokenTypeCounter;
      }
      function createKeywordLike(name, options = {}) {
        var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
        ++tokenTypeCounter;
        keywords$1.set(name, tokenTypeCounter);
        tokenLabels.push(name);
        tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
        tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
        tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
        tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
        tokenTypes.push(new ExportedTokenType("name", options));
        return tokenTypeCounter;
      }
      var tt = {
        bracketL: createToken("[", {
          beforeExpr,
          startsExpr
        }),
        bracketHashL: createToken("#[", {
          beforeExpr,
          startsExpr
        }),
        bracketBarL: createToken("[|", {
          beforeExpr,
          startsExpr
        }),
        bracketR: createToken("]"),
        bracketBarR: createToken("|]"),
        braceL: createToken("{", {
          beforeExpr,
          startsExpr
        }),
        braceBarL: createToken("{|", {
          beforeExpr,
          startsExpr
        }),
        braceHashL: createToken("#{", {
          beforeExpr,
          startsExpr
        }),
        braceR: createToken("}"),
        braceBarR: createToken("|}"),
        parenL: createToken("(", {
          beforeExpr,
          startsExpr
        }),
        parenR: createToken(")"),
        comma: createToken(",", {
          beforeExpr
        }),
        semi: createToken(";", {
          beforeExpr
        }),
        colon: createToken(":", {
          beforeExpr
        }),
        doubleColon: createToken("::", {
          beforeExpr
        }),
        dot: createToken("."),
        question: createToken("?", {
          beforeExpr
        }),
        questionDot: createToken("?."),
        arrow: createToken("=>", {
          beforeExpr
        }),
        template: createToken("template"),
        ellipsis: createToken("...", {
          beforeExpr
        }),
        backQuote: createToken("`", {
          startsExpr
        }),
        dollarBraceL: createToken("${", {
          beforeExpr,
          startsExpr
        }),
        templateTail: createToken("...`", {
          startsExpr
        }),
        templateNonTail: createToken("...${", {
          beforeExpr,
          startsExpr
        }),
        at: createToken("@"),
        hash: createToken("#", {
          startsExpr
        }),
        interpreterDirective: createToken("#!..."),
        eq: createToken("=", {
          beforeExpr,
          isAssign
        }),
        assign: createToken("_=", {
          beforeExpr,
          isAssign
        }),
        slashAssign: createToken("_=", {
          beforeExpr,
          isAssign
        }),
        xorAssign: createToken("_=", {
          beforeExpr,
          isAssign
        }),
        moduloAssign: createToken("_=", {
          beforeExpr,
          isAssign
        }),
        incDec: createToken("++/--", {
          prefix,
          postfix,
          startsExpr
        }),
        bang: createToken("!", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        tilde: createToken("~", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        doubleCaret: createToken("^^", {
          startsExpr
        }),
        doubleAt: createToken("@@", {
          startsExpr
        }),
        pipeline: createBinop("|>", 0),
        nullishCoalescing: createBinop("??", 1),
        logicalOR: createBinop("||", 1),
        logicalAND: createBinop("&&", 2),
        bitwiseOR: createBinop("|", 3),
        bitwiseXOR: createBinop("^", 4),
        bitwiseAND: createBinop("&", 5),
        equality: createBinop("==/!=/===/!==", 6),
        lt: createBinop("</>/<=/>=", 7),
        gt: createBinop("</>/<=/>=", 7),
        relational: createBinop("</>/<=/>=", 7),
        bitShift: createBinop("<</>>/>>>", 8),
        bitShiftL: createBinop("<</>>/>>>", 8),
        bitShiftR: createBinop("<</>>/>>>", 8),
        plusMin: createToken("+/-", {
          beforeExpr,
          binop: 9,
          prefix,
          startsExpr
        }),
        modulo: createToken("%", {
          binop: 10,
          startsExpr
        }),
        star: createToken("*", {
          binop: 10
        }),
        slash: createBinop("/", 10),
        exponent: createToken("**", {
          beforeExpr,
          binop: 11,
          rightAssociative: true
        }),
        _in: createKeyword("in", {
          beforeExpr,
          binop: 7
        }),
        _instanceof: createKeyword("instanceof", {
          beforeExpr,
          binop: 7
        }),
        _break: createKeyword("break"),
        _case: createKeyword("case", {
          beforeExpr
        }),
        _catch: createKeyword("catch"),
        _continue: createKeyword("continue"),
        _debugger: createKeyword("debugger"),
        _default: createKeyword("default", {
          beforeExpr
        }),
        _else: createKeyword("else", {
          beforeExpr
        }),
        _finally: createKeyword("finally"),
        _function: createKeyword("function", {
          startsExpr
        }),
        _if: createKeyword("if"),
        _return: createKeyword("return", {
          beforeExpr
        }),
        _switch: createKeyword("switch"),
        _throw: createKeyword("throw", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        _try: createKeyword("try"),
        _var: createKeyword("var"),
        _const: createKeyword("const"),
        _with: createKeyword("with"),
        _new: createKeyword("new", {
          beforeExpr,
          startsExpr
        }),
        _this: createKeyword("this", {
          startsExpr
        }),
        _super: createKeyword("super", {
          startsExpr
        }),
        _class: createKeyword("class", {
          startsExpr
        }),
        _extends: createKeyword("extends", {
          beforeExpr
        }),
        _export: createKeyword("export"),
        _import: createKeyword("import", {
          startsExpr
        }),
        _null: createKeyword("null", {
          startsExpr
        }),
        _true: createKeyword("true", {
          startsExpr
        }),
        _false: createKeyword("false", {
          startsExpr
        }),
        _typeof: createKeyword("typeof", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        _void: createKeyword("void", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        _delete: createKeyword("delete", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        _do: createKeyword("do", {
          isLoop,
          beforeExpr
        }),
        _for: createKeyword("for", {
          isLoop
        }),
        _while: createKeyword("while", {
          isLoop
        }),
        _as: createKeywordLike("as", {
          startsExpr
        }),
        _assert: createKeywordLike("assert", {
          startsExpr
        }),
        _async: createKeywordLike("async", {
          startsExpr
        }),
        _await: createKeywordLike("await", {
          startsExpr
        }),
        _from: createKeywordLike("from", {
          startsExpr
        }),
        _get: createKeywordLike("get", {
          startsExpr
        }),
        _let: createKeywordLike("let", {
          startsExpr
        }),
        _meta: createKeywordLike("meta", {
          startsExpr
        }),
        _of: createKeywordLike("of", {
          startsExpr
        }),
        _sent: createKeywordLike("sent", {
          startsExpr
        }),
        _set: createKeywordLike("set", {
          startsExpr
        }),
        _static: createKeywordLike("static", {
          startsExpr
        }),
        _using: createKeywordLike("using", {
          startsExpr
        }),
        _yield: createKeywordLike("yield", {
          startsExpr
        }),
        _asserts: createKeywordLike("asserts", {
          startsExpr
        }),
        _checks: createKeywordLike("checks", {
          startsExpr
        }),
        _exports: createKeywordLike("exports", {
          startsExpr
        }),
        _global: createKeywordLike("global", {
          startsExpr
        }),
        _implements: createKeywordLike("implements", {
          startsExpr
        }),
        _intrinsic: createKeywordLike("intrinsic", {
          startsExpr
        }),
        _infer: createKeywordLike("infer", {
          startsExpr
        }),
        _is: createKeywordLike("is", {
          startsExpr
        }),
        _mixins: createKeywordLike("mixins", {
          startsExpr
        }),
        _proto: createKeywordLike("proto", {
          startsExpr
        }),
        _require: createKeywordLike("require", {
          startsExpr
        }),
        _satisfies: createKeywordLike("satisfies", {
          startsExpr
        }),
        _keyof: createKeywordLike("keyof", {
          startsExpr
        }),
        _readonly: createKeywordLike("readonly", {
          startsExpr
        }),
        _unique: createKeywordLike("unique", {
          startsExpr
        }),
        _abstract: createKeywordLike("abstract", {
          startsExpr
        }),
        _declare: createKeywordLike("declare", {
          startsExpr
        }),
        _enum: createKeywordLike("enum", {
          startsExpr
        }),
        _module: createKeywordLike("module", {
          startsExpr
        }),
        _namespace: createKeywordLike("namespace", {
          startsExpr
        }),
        _interface: createKeywordLike("interface", {
          startsExpr
        }),
        _type: createKeywordLike("type", {
          startsExpr
        }),
        _opaque: createKeywordLike("opaque", {
          startsExpr
        }),
        name: createToken("name", {
          startsExpr
        }),
        string: createToken("string", {
          startsExpr
        }),
        num: createToken("num", {
          startsExpr
        }),
        bigint: createToken("bigint", {
          startsExpr
        }),
        decimal: createToken("decimal", {
          startsExpr
        }),
        regexp: createToken("regexp", {
          startsExpr
        }),
        privateName: createToken("#name", {
          startsExpr
        }),
        eof: createToken("eof"),
        jsxName: createToken("jsxName"),
        jsxText: createToken("jsxText", {
          beforeExpr: true
        }),
        jsxTagStart: createToken("jsxTagStart", {
          startsExpr: true
        }),
        jsxTagEnd: createToken("jsxTagEnd"),
        placeholder: createToken("%%", {
          startsExpr: true
        })
      };
      function tokenIsIdentifier(token) {
        return token >= 93 && token <= 130;
      }
      function tokenKeywordOrIdentifierIsKeyword(token) {
        return token <= 92;
      }
      function tokenIsKeywordOrIdentifier(token) {
        return token >= 58 && token <= 130;
      }
      function tokenIsLiteralPropertyName(token) {
        return token >= 58 && token <= 134;
      }
      function tokenComesBeforeExpression(token) {
        return tokenBeforeExprs[token];
      }
      function tokenCanStartExpression(token) {
        return tokenStartsExprs[token];
      }
      function tokenIsAssignment(token) {
        return token >= 29 && token <= 33;
      }
      function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
        return token >= 127 && token <= 129;
      }
      function tokenIsLoop(token) {
        return token >= 90 && token <= 92;
      }
      function tokenIsKeyword(token) {
        return token >= 58 && token <= 92;
      }
      function tokenIsOperator(token) {
        return token >= 39 && token <= 59;
      }
      function tokenIsPostfix(token) {
        return token === 34;
      }
      function tokenIsPrefix(token) {
        return tokenPrefixes[token];
      }
      function tokenIsTSTypeOperator(token) {
        return token >= 119 && token <= 121;
      }
      function tokenIsTSDeclarationStart(token) {
        return token >= 122 && token <= 128;
      }
      function tokenLabelName(token) {
        return tokenLabels[token];
      }
      function tokenOperatorPrecedence(token) {
        return tokenBinops[token];
      }
      function tokenIsRightAssociative(token) {
        return token === 57;
      }
      function tokenIsTemplate(token) {
        return token >= 24 && token <= 25;
      }
      function getExportedToken(token) {
        return tokenTypes[token];
      }
      {
        tokenTypes[8].updateContext = (context) => {
          context.pop();
        };
        tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = (context) => {
          context.push(types.brace);
        };
        tokenTypes[22].updateContext = (context) => {
          if (context[context.length - 1] === types.template) {
            context.pop();
          } else {
            context.push(types.template);
          }
        };
        tokenTypes[140].updateContext = (context) => {
          context.push(types.j_expr, types.j_oTag);
        };
      }
      var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
      var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
      nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
      var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];
      var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      function isInAstralSet(code, set) {
        let pos = 65536;
        for (let i = 0, length = set.length; i < length; i += 2) {
          pos += set[i];
          if (pos > code)
            return false;
          pos += set[i + 1];
          if (pos >= code)
            return true;
        }
        return false;
      }
      function isIdentifierStart(code) {
        if (code < 65)
          return code === 36;
        if (code <= 90)
          return true;
        if (code < 97)
          return code === 95;
        if (code <= 122)
          return true;
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
        }
        return isInAstralSet(code, astralIdentifierStartCodes);
      }
      function isIdentifierChar(code) {
        if (code < 48)
          return code === 36;
        if (code < 58)
          return true;
        if (code < 65)
          return false;
        if (code <= 90)
          return true;
        if (code < 97)
          return code === 95;
        if (code <= 122)
          return true;
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
        }
        return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
      }
      var reservedWords = {
        keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
        strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
        strictBind: ["eval", "arguments"]
      };
      var keywords = new Set(reservedWords.keyword);
      var reservedWordsStrictSet = new Set(reservedWords.strict);
      var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
      function isReservedWord(word, inModule) {
        return inModule && word === "await" || word === "enum";
      }
      function isStrictReservedWord(word, inModule) {
        return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
      }
      function isStrictBindOnlyReservedWord(word) {
        return reservedWordsStrictBindSet.has(word);
      }
      function isStrictBindReservedWord(word, inModule) {
        return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
      }
      function isKeyword(word) {
        return keywords.has(word);
      }
      function isIteratorStart(current, next, next2) {
        return current === 64 && next === 64 && isIdentifierStart(next2);
      }
      var reservedWordLikeSet = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
      function canBeReservedWord(word) {
        return reservedWordLikeSet.has(word);
      }
      var SCOPE_OTHER = 0;
      var SCOPE_PROGRAM = 1;
      var SCOPE_FUNCTION = 2;
      var SCOPE_ARROW = 4;
      var SCOPE_SIMPLE_CATCH = 8;
      var SCOPE_SUPER = 16;
      var SCOPE_DIRECT_SUPER = 32;
      var SCOPE_CLASS = 64;
      var SCOPE_STATIC_BLOCK = 128;
      var SCOPE_TS_MODULE = 256;
      var SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_STATIC_BLOCK | SCOPE_TS_MODULE;
      var BIND_KIND_VALUE = 1;
      var BIND_KIND_TYPE = 2;
      var BIND_SCOPE_VAR = 4;
      var BIND_SCOPE_LEXICAL = 8;
      var BIND_SCOPE_FUNCTION = 16;
      var BIND_FLAGS_NONE = 64;
      var BIND_FLAGS_CLASS = 128;
      var BIND_FLAGS_TS_ENUM = 256;
      var BIND_FLAGS_TS_CONST_ENUM = 512;
      var BIND_FLAGS_TS_EXPORT_ONLY = 1024;
      var BIND_FLAGS_FLOW_DECLARE_FN = 2048;
      var BIND_FLAGS_TS_IMPORT = 4096;
      var BIND_FLAGS_NO_LET_IN_LEXICAL = 8192;
      var BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS | BIND_FLAGS_NO_LET_IN_LEXICAL;
      var BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | BIND_FLAGS_NO_LET_IN_LEXICAL;
      var BIND_CATCH_PARAM = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0;
      var BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0;
      var BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0;
      var BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS;
      var BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0;
      var BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM | BIND_FLAGS_NO_LET_IN_LEXICAL;
      var BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
      var BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE;
      var BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE;
      var BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM;
      var BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
      var BIND_TS_TYPE_IMPORT = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_TS_IMPORT;
      var BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;
      var CLASS_ELEMENT_FLAG_STATIC = 4;
      var CLASS_ELEMENT_KIND_GETTER = 2;
      var CLASS_ELEMENT_KIND_SETTER = 1;
      var CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
      var CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC;
      var CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC;
      var CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER;
      var CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER;
      var CLASS_ELEMENT_OTHER = 0;
      var Scope = class {
        constructor(flags) {
          this.var = /* @__PURE__ */ new Set();
          this.lexical = /* @__PURE__ */ new Set();
          this.functions = /* @__PURE__ */ new Set();
          this.flags = flags;
        }
      };
      var ScopeHandler = class {
        constructor(parser, inModule) {
          this.parser = void 0;
          this.scopeStack = [];
          this.inModule = void 0;
          this.undefinedExports = /* @__PURE__ */ new Map();
          this.parser = parser;
          this.inModule = inModule;
        }
        get inTopLevel() {
          return (this.currentScope().flags & SCOPE_PROGRAM) > 0;
        }
        get inFunction() {
          return (this.currentVarScopeFlags() & SCOPE_FUNCTION) > 0;
        }
        get allowSuper() {
          return (this.currentThisScopeFlags() & SCOPE_SUPER) > 0;
        }
        get allowDirectSuper() {
          return (this.currentThisScopeFlags() & SCOPE_DIRECT_SUPER) > 0;
        }
        get inClass() {
          return (this.currentThisScopeFlags() & SCOPE_CLASS) > 0;
        }
        get inClassAndNotInNonArrowFunction() {
          const flags = this.currentThisScopeFlags();
          return (flags & SCOPE_CLASS) > 0 && (flags & SCOPE_FUNCTION) === 0;
        }
        get inStaticBlock() {
          for (let i = this.scopeStack.length - 1; ; i--) {
            const {
              flags
            } = this.scopeStack[i];
            if (flags & SCOPE_STATIC_BLOCK) {
              return true;
            }
            if (flags & (SCOPE_VAR | SCOPE_CLASS)) {
              return false;
            }
          }
        }
        get inNonArrowFunction() {
          return (this.currentThisScopeFlags() & SCOPE_FUNCTION) > 0;
        }
        get treatFunctionsAsVar() {
          return this.treatFunctionsAsVarInScope(this.currentScope());
        }
        createScope(flags) {
          return new Scope(flags);
        }
        enter(flags) {
          this.scopeStack.push(this.createScope(flags));
        }
        exit() {
          const scope = this.scopeStack.pop();
          return scope.flags;
        }
        treatFunctionsAsVarInScope(scope) {
          return !!(scope.flags & (SCOPE_FUNCTION | SCOPE_STATIC_BLOCK) || !this.parser.inModule && scope.flags & SCOPE_PROGRAM);
        }
        declareName(name, bindingType, loc) {
          let scope = this.currentScope();
          if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
            this.checkRedeclarationInScope(scope, name, bindingType, loc);
            if (bindingType & BIND_SCOPE_FUNCTION) {
              scope.functions.add(name);
            } else {
              scope.lexical.add(name);
            }
            if (bindingType & BIND_SCOPE_LEXICAL) {
              this.maybeExportDefined(scope, name);
            }
          } else if (bindingType & BIND_SCOPE_VAR) {
            for (let i = this.scopeStack.length - 1; i >= 0; --i) {
              scope = this.scopeStack[i];
              this.checkRedeclarationInScope(scope, name, bindingType, loc);
              scope.var.add(name);
              this.maybeExportDefined(scope, name);
              if (scope.flags & SCOPE_VAR)
                break;
            }
          }
          if (this.parser.inModule && scope.flags & SCOPE_PROGRAM) {
            this.undefinedExports.delete(name);
          }
        }
        maybeExportDefined(scope, name) {
          if (this.parser.inModule && scope.flags & SCOPE_PROGRAM) {
            this.undefinedExports.delete(name);
          }
        }
        checkRedeclarationInScope(scope, name, bindingType, loc) {
          if (this.isRedeclaredInScope(scope, name, bindingType)) {
            this.parser.raise(Errors.VarRedeclaration, {
              at: loc,
              identifierName: name
            });
          }
        }
        isRedeclaredInScope(scope, name, bindingType) {
          if (!(bindingType & BIND_KIND_VALUE))
            return false;
          if (bindingType & BIND_SCOPE_LEXICAL) {
            return scope.lexical.has(name) || scope.functions.has(name) || scope.var.has(name);
          }
          if (bindingType & BIND_SCOPE_FUNCTION) {
            return scope.lexical.has(name) || !this.treatFunctionsAsVarInScope(scope) && scope.var.has(name);
          }
          return scope.lexical.has(name) && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical.values().next().value === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name);
        }
        checkLocalExport(id) {
          const {
            name
          } = id;
          const topLevelScope = this.scopeStack[0];
          if (!topLevelScope.lexical.has(name) && !topLevelScope.var.has(name) && !topLevelScope.functions.has(name)) {
            this.undefinedExports.set(name, id.loc.start);
          }
        }
        currentScope() {
          return this.scopeStack[this.scopeStack.length - 1];
        }
        currentVarScopeFlags() {
          for (let i = this.scopeStack.length - 1; ; i--) {
            const {
              flags
            } = this.scopeStack[i];
            if (flags & SCOPE_VAR) {
              return flags;
            }
          }
        }
        currentThisScopeFlags() {
          for (let i = this.scopeStack.length - 1; ; i--) {
            const {
              flags
            } = this.scopeStack[i];
            if (flags & (SCOPE_VAR | SCOPE_CLASS) && !(flags & SCOPE_ARROW)) {
              return flags;
            }
          }
        }
      };
      var FlowScope = class extends Scope {
        constructor(...args) {
          super(...args);
          this.declareFunctions = /* @__PURE__ */ new Set();
        }
      };
      var FlowScopeHandler = class extends ScopeHandler {
        createScope(flags) {
          return new FlowScope(flags);
        }
        declareName(name, bindingType, loc) {
          const scope = this.currentScope();
          if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
            this.checkRedeclarationInScope(scope, name, bindingType, loc);
            this.maybeExportDefined(scope, name);
            scope.declareFunctions.add(name);
            return;
          }
          super.declareName(name, bindingType, loc);
        }
        isRedeclaredInScope(scope, name, bindingType) {
          if (super.isRedeclaredInScope(scope, name, bindingType))
            return true;
          if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
            return !scope.declareFunctions.has(name) && (scope.lexical.has(name) || scope.functions.has(name));
          }
          return false;
        }
        checkLocalExport(id) {
          if (!this.scopeStack[0].declareFunctions.has(id.name)) {
            super.checkLocalExport(id);
          }
        }
      };
      var BaseParser = class {
        constructor() {
          this.sawUnambiguousESM = false;
          this.ambiguousScriptDifferentAst = false;
        }
        hasPlugin(pluginConfig) {
          if (typeof pluginConfig === "string") {
            return this.plugins.has(pluginConfig);
          } else {
            const [pluginName, pluginOptions] = pluginConfig;
            if (!this.hasPlugin(pluginName)) {
              return false;
            }
            const actualOptions = this.plugins.get(pluginName);
            for (const key of Object.keys(pluginOptions)) {
              if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
                return false;
              }
            }
            return true;
          }
        }
        getPluginOption(plugin, name) {
          var _this$plugins$get;
          return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];
        }
      };
      function setTrailingComments(node, comments) {
        if (node.trailingComments === void 0) {
          node.trailingComments = comments;
        } else {
          node.trailingComments.unshift(...comments);
        }
      }
      function setLeadingComments(node, comments) {
        if (node.leadingComments === void 0) {
          node.leadingComments = comments;
        } else {
          node.leadingComments.unshift(...comments);
        }
      }
      function setInnerComments(node, comments) {
        if (node.innerComments === void 0) {
          node.innerComments = comments;
        } else {
          node.innerComments.unshift(...comments);
        }
      }
      function adjustInnerComments(node, elements, commentWS) {
        let lastElement = null;
        let i = elements.length;
        while (lastElement === null && i > 0) {
          lastElement = elements[--i];
        }
        if (lastElement === null || lastElement.start > commentWS.start) {
          setInnerComments(node, commentWS.comments);
        } else {
          setTrailingComments(lastElement, commentWS.comments);
        }
      }
      var CommentsParser = class extends BaseParser {
        addComment(comment) {
          if (this.filename)
            comment.loc.filename = this.filename;
          this.state.comments.push(comment);
        }
        processComment(node) {
          const {
            commentStack
          } = this.state;
          const commentStackLength = commentStack.length;
          if (commentStackLength === 0)
            return;
          let i = commentStackLength - 1;
          const lastCommentWS = commentStack[i];
          if (lastCommentWS.start === node.end) {
            lastCommentWS.leadingNode = node;
            i--;
          }
          const {
            start: nodeStart
          } = node;
          for (; i >= 0; i--) {
            const commentWS = commentStack[i];
            const commentEnd = commentWS.end;
            if (commentEnd > nodeStart) {
              commentWS.containingNode = node;
              this.finalizeComment(commentWS);
              commentStack.splice(i, 1);
            } else {
              if (commentEnd === nodeStart) {
                commentWS.trailingNode = node;
              }
              break;
            }
          }
        }
        finalizeComment(commentWS) {
          const {
            comments
          } = commentWS;
          if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
            if (commentWS.leadingNode !== null) {
              setTrailingComments(commentWS.leadingNode, comments);
            }
            if (commentWS.trailingNode !== null) {
              setLeadingComments(commentWS.trailingNode, comments);
            }
          } else {
            const {
              containingNode: node,
              start: commentStart
            } = commentWS;
            if (this.input.charCodeAt(commentStart - 1) === 44) {
              switch (node.type) {
                case "ObjectExpression":
                case "ObjectPattern":
                case "RecordExpression":
                  adjustInnerComments(node, node.properties, commentWS);
                  break;
                case "CallExpression":
                case "OptionalCallExpression":
                  adjustInnerComments(node, node.arguments, commentWS);
                  break;
                case "FunctionDeclaration":
                case "FunctionExpression":
                case "ArrowFunctionExpression":
                case "ObjectMethod":
                case "ClassMethod":
                case "ClassPrivateMethod":
                  adjustInnerComments(node, node.params, commentWS);
                  break;
                case "ArrayExpression":
                case "ArrayPattern":
                case "TupleExpression":
                  adjustInnerComments(node, node.elements, commentWS);
                  break;
                case "ExportNamedDeclaration":
                case "ImportDeclaration":
                  adjustInnerComments(node, node.specifiers, commentWS);
                  break;
                default: {
                  setInnerComments(node, comments);
                }
              }
            } else {
              setInnerComments(node, comments);
            }
          }
        }
        finalizeRemainingComments() {
          const {
            commentStack
          } = this.state;
          for (let i = commentStack.length - 1; i >= 0; i--) {
            this.finalizeComment(commentStack[i]);
          }
          this.state.commentStack = [];
        }
        resetPreviousNodeTrailingComments(node) {
          const {
            commentStack
          } = this.state;
          const {
            length
          } = commentStack;
          if (length === 0)
            return;
          const commentWS = commentStack[length - 1];
          if (commentWS.leadingNode === node) {
            commentWS.leadingNode = null;
          }
        }
        resetPreviousIdentifierLeadingComments(node) {
          const {
            commentStack
          } = this.state;
          const {
            length
          } = commentStack;
          if (length === 0)
            return;
          if (commentStack[length - 1].trailingNode === node) {
            commentStack[length - 1].trailingNode = null;
          } else if (length >= 2 && commentStack[length - 2].trailingNode === node) {
            commentStack[length - 2].trailingNode = null;
          }
        }
        takeSurroundingComments(node, start, end) {
          const {
            commentStack
          } = this.state;
          const commentStackLength = commentStack.length;
          if (commentStackLength === 0)
            return;
          let i = commentStackLength - 1;
          for (; i >= 0; i--) {
            const commentWS = commentStack[i];
            const commentEnd = commentWS.end;
            const commentStart = commentWS.start;
            if (commentStart === end) {
              commentWS.leadingNode = node;
            } else if (commentEnd === start) {
              commentWS.trailingNode = node;
            } else if (commentEnd < start) {
              break;
            }
          }
        }
      };
      var lineBreak = /\r\n?|[\n\u2028\u2029]/;
      var lineBreakG = new RegExp(lineBreak.source, "g");
      function isNewLine(code) {
        switch (code) {
          case 10:
          case 13:
          case 8232:
          case 8233:
            return true;
          default:
            return false;
        }
      }
      var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
      var skipWhiteSpaceToLineBreak = new RegExp("(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
      function isWhitespace(code) {
        switch (code) {
          case 9:
          case 11:
          case 12:
          case 32:
          case 160:
          case 5760:
          case 8192:
          case 8193:
          case 8194:
          case 8195:
          case 8196:
          case 8197:
          case 8198:
          case 8199:
          case 8200:
          case 8201:
          case 8202:
          case 8239:
          case 8287:
          case 12288:
          case 65279:
            return true;
          default:
            return false;
        }
      }
      var State = class {
        constructor() {
          this.strict = void 0;
          this.curLine = void 0;
          this.lineStart = void 0;
          this.startLoc = void 0;
          this.endLoc = void 0;
          this.errors = [];
          this.potentialArrowAt = -1;
          this.noArrowAt = [];
          this.noArrowParamsConversionAt = [];
          this.maybeInArrowParameters = false;
          this.inType = false;
          this.noAnonFunctionType = false;
          this.hasFlowComment = false;
          this.isAmbientContext = false;
          this.inAbstractClass = false;
          this.inDisallowConditionalTypesContext = false;
          this.topicContext = {
            maxNumOfResolvableTopics: 0,
            maxTopicIndex: null
          };
          this.soloAwait = false;
          this.inFSharpPipelineDirectBody = false;
          this.labels = [];
          this.comments = [];
          this.commentStack = [];
          this.pos = 0;
          this.type = 137;
          this.value = null;
          this.start = 0;
          this.end = 0;
          this.lastTokEndLoc = null;
          this.lastTokStartLoc = null;
          this.lastTokStart = 0;
          this.context = [types.brace];
          this.canStartJSXElement = true;
          this.containsEsc = false;
          this.firstInvalidTemplateEscapePos = null;
          this.strictErrors = /* @__PURE__ */ new Map();
          this.tokensLength = 0;
        }
        init({
          strictMode,
          sourceType,
          startLine,
          startColumn
        }) {
          this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
          this.curLine = startLine;
          this.lineStart = -startColumn;
          this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);
        }
        curPosition() {
          return new Position(this.curLine, this.pos - this.lineStart, this.pos);
        }
        clone(skipArrays) {
          const state = new State();
          const keys = Object.keys(this);
          for (let i = 0, length = keys.length; i < length; i++) {
            const key = keys[i];
            let val = this[key];
            if (!skipArrays && Array.isArray(val)) {
              val = val.slice();
            }
            state[key] = val;
          }
          return state;
        }
      };
      var _isDigit = function isDigit(code) {
        return code >= 48 && code <= 57;
      };
      var forbiddenNumericSeparatorSiblings = {
        decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
        hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
      };
      var isAllowedNumericSeparatorSibling = {
        bin: (ch) => ch === 48 || ch === 49,
        oct: (ch) => ch >= 48 && ch <= 55,
        dec: (ch) => ch >= 48 && ch <= 57,
        hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
      };
      function readStringContents(type, input, pos, lineStart, curLine, errors) {
        const initialPos = pos;
        const initialLineStart = lineStart;
        const initialCurLine = curLine;
        let out = "";
        let firstInvalidLoc = null;
        let chunkStart = pos;
        const {
          length
        } = input;
        for (; ; ) {
          if (pos >= length) {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
            out += input.slice(chunkStart, pos);
            break;
          }
          const ch = input.charCodeAt(pos);
          if (isStringEnd(type, ch, input, pos)) {
            out += input.slice(chunkStart, pos);
            break;
          }
          if (ch === 92) {
            out += input.slice(chunkStart, pos);
            const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
            if (res.ch === null && !firstInvalidLoc) {
              firstInvalidLoc = {
                pos,
                lineStart,
                curLine
              };
            } else {
              out += res.ch;
            }
            ({
              pos,
              lineStart,
              curLine
            } = res);
            chunkStart = pos;
          } else if (ch === 8232 || ch === 8233) {
            ++pos;
            ++curLine;
            lineStart = pos;
          } else if (ch === 10 || ch === 13) {
            if (type === "template") {
              out += input.slice(chunkStart, pos) + "\n";
              ++pos;
              if (ch === 13 && input.charCodeAt(pos) === 10) {
                ++pos;
              }
              ++curLine;
              chunkStart = lineStart = pos;
            } else {
              errors.unterminated(initialPos, initialLineStart, initialCurLine);
            }
          } else {
            ++pos;
          }
        }
        return {
          pos,
          str: out,
          firstInvalidLoc,
          lineStart,
          curLine,
          containsInvalid: !!firstInvalidLoc
        };
      }
      function isStringEnd(type, ch, input, pos) {
        if (type === "template") {
          return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
        }
        return ch === (type === "double" ? 34 : 39);
      }
      function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
        const throwOnInvalid = !inTemplate;
        pos++;
        const res = (ch2) => ({
          pos,
          ch: ch2,
          lineStart,
          curLine
        });
        const ch = input.charCodeAt(pos++);
        switch (ch) {
          case 110:
            return res("\n");
          case 114:
            return res("\r");
          case 120: {
            let code;
            ({
              code,
              pos
            } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
            return res(code === null ? null : String.fromCharCode(code));
          }
          case 117: {
            let code;
            ({
              code,
              pos
            } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
            return res(code === null ? null : String.fromCodePoint(code));
          }
          case 116:
            return res("	");
          case 98:
            return res("\b");
          case 118:
            return res("\v");
          case 102:
            return res("\f");
          case 13:
            if (input.charCodeAt(pos) === 10) {
              ++pos;
            }
          case 10:
            lineStart = pos;
            ++curLine;
          case 8232:
          case 8233:
            return res("");
          case 56:
          case 57:
            if (inTemplate) {
              return res(null);
            } else {
              errors.strictNumericEscape(pos - 1, lineStart, curLine);
            }
          default:
            if (ch >= 48 && ch <= 55) {
              const startPos = pos - 1;
              const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
              let octalStr = match[0];
              let octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              pos += octalStr.length - 1;
              const next = input.charCodeAt(pos);
              if (octalStr !== "0" || next === 56 || next === 57) {
                if (inTemplate) {
                  return res(null);
                } else {
                  errors.strictNumericEscape(startPos, lineStart, curLine);
                }
              }
              return res(String.fromCharCode(octal));
            }
            return res(String.fromCharCode(ch));
        }
      }
      function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
        const initialPos = pos;
        let n;
        ({
          n,
          pos
        } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
        if (n === null) {
          if (throwOnInvalid) {
            errors.invalidEscapeSequence(initialPos, lineStart, curLine);
          } else {
            pos = initialPos - 1;
          }
        }
        return {
          code: n,
          pos
        };
      }
      function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
        const start = pos;
        const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
        const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
        let invalid = false;
        let total = 0;
        for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
          const code = input.charCodeAt(pos);
          let val;
          if (code === 95 && allowNumSeparator !== "bail") {
            const prev = input.charCodeAt(pos - 1);
            const next = input.charCodeAt(pos + 1);
            if (!allowNumSeparator) {
              if (bailOnError)
                return {
                  n: null,
                  pos
                };
              errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
            } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
              if (bailOnError)
                return {
                  n: null,
                  pos
                };
              errors.unexpectedNumericSeparator(pos, lineStart, curLine);
            }
            ++pos;
            continue;
          }
          if (code >= 97) {
            val = code - 97 + 10;
          } else if (code >= 65) {
            val = code - 65 + 10;
          } else if (_isDigit(code)) {
            val = code - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            if (val <= 9 && bailOnError) {
              return {
                n: null,
                pos
              };
            } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
              val = 0;
            } else if (forceLen) {
              val = 0;
              invalid = true;
            } else {
              break;
            }
          }
          ++pos;
          total = total * radix + val;
        }
        if (pos === start || len != null && pos - start !== len || invalid) {
          return {
            n: null,
            pos
          };
        }
        return {
          n: total,
          pos
        };
      }
      function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
        const ch = input.charCodeAt(pos);
        let code;
        if (ch === 123) {
          ++pos;
          ({
            code,
            pos
          } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
          ++pos;
          if (code !== null && code > 1114111) {
            if (throwOnInvalid) {
              errors.invalidCodePoint(pos, lineStart, curLine);
            } else {
              return {
                code: null,
                pos
              };
            }
          }
        } else {
          ({
            code,
            pos
          } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
        }
        return {
          code,
          pos
        };
      }
      var _excluded = ["at"];
      var _excluded2 = ["at"];
      function buildPosition(pos, lineStart, curLine) {
        return new Position(curLine, pos - lineStart, pos);
      }
      var VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
      var Token = class {
        constructor(state) {
          this.type = state.type;
          this.value = state.value;
          this.start = state.start;
          this.end = state.end;
          this.loc = new SourceLocation(state.startLoc, state.endLoc);
        }
      };
      var Tokenizer = class extends CommentsParser {
        constructor(options, input) {
          super();
          this.isLookahead = void 0;
          this.tokens = [];
          this.errorHandlers_readInt = {
            invalidDigit: (pos, lineStart, curLine, radix) => {
              if (!this.options.errorRecovery)
                return false;
              this.raise(Errors.InvalidDigit, {
                at: buildPosition(pos, lineStart, curLine),
                radix
              });
              return true;
            },
            numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
            unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
          };
          this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
            invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
            invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
          });
          this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
            strictNumericEscape: (pos, lineStart, curLine) => {
              this.recordStrictModeErrors(Errors.StrictNumericEscape, {
                at: buildPosition(pos, lineStart, curLine)
              });
            },
            unterminated: (pos, lineStart, curLine) => {
              throw this.raise(Errors.UnterminatedString, {
                at: buildPosition(pos - 1, lineStart, curLine)
              });
            }
          });
          this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
            strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
            unterminated: (pos, lineStart, curLine) => {
              throw this.raise(Errors.UnterminatedTemplate, {
                at: buildPosition(pos, lineStart, curLine)
              });
            }
          });
          this.state = new State();
          this.state.init(options);
          this.input = input;
          this.length = input.length;
          this.isLookahead = false;
        }
        pushToken(token) {
          this.tokens.length = this.state.tokensLength;
          this.tokens.push(token);
          ++this.state.tokensLength;
        }
        next() {
          this.checkKeywordEscapes();
          if (this.options.tokens) {
            this.pushToken(new Token(this.state));
          }
          this.state.lastTokStart = this.state.start;
          this.state.lastTokEndLoc = this.state.endLoc;
          this.state.lastTokStartLoc = this.state.startLoc;
          this.nextToken();
        }
        eat(type) {
          if (this.match(type)) {
            this.next();
            return true;
          } else {
            return false;
          }
        }
        match(type) {
          return this.state.type === type;
        }
        createLookaheadState(state) {
          return {
            pos: state.pos,
            value: null,
            type: state.type,
            start: state.start,
            end: state.end,
            context: [this.curContext()],
            inType: state.inType,
            startLoc: state.startLoc,
            lastTokEndLoc: state.lastTokEndLoc,
            curLine: state.curLine,
            lineStart: state.lineStart,
            curPosition: state.curPosition
          };
        }
        lookahead() {
          const old = this.state;
          this.state = this.createLookaheadState(old);
          this.isLookahead = true;
          this.nextToken();
          this.isLookahead = false;
          const curr = this.state;
          this.state = old;
          return curr;
        }
        nextTokenStart() {
          return this.nextTokenStartSince(this.state.pos);
        }
        nextTokenStartSince(pos) {
          skipWhiteSpace.lastIndex = pos;
          return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
        }
        lookaheadCharCode() {
          return this.input.charCodeAt(this.nextTokenStart());
        }
        nextTokenInLineStart() {
          return this.nextTokenInLineStartSince(this.state.pos);
        }
        nextTokenInLineStartSince(pos) {
          skipWhiteSpaceInLine.lastIndex = pos;
          return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;
        }
        lookaheadInLineCharCode() {
          return this.input.charCodeAt(this.nextTokenInLineStart());
        }
        codePointAtPos(pos) {
          let cp = this.input.charCodeAt(pos);
          if ((cp & 64512) === 55296 && ++pos < this.input.length) {
            const trail = this.input.charCodeAt(pos);
            if ((trail & 64512) === 56320) {
              cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
            }
          }
          return cp;
        }
        setStrict(strict) {
          this.state.strict = strict;
          if (strict) {
            this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, {
              at
            }));
            this.state.strictErrors.clear();
          }
        }
        curContext() {
          return this.state.context[this.state.context.length - 1];
        }
        nextToken() {
          this.skipSpace();
          this.state.start = this.state.pos;
          if (!this.isLookahead)
            this.state.startLoc = this.state.curPosition();
          if (this.state.pos >= this.length) {
            this.finishToken(137);
            return;
          }
          this.getTokenFromCode(this.codePointAtPos(this.state.pos));
        }
        skipBlockComment(commentEnd) {
          let startLoc;
          if (!this.isLookahead)
            startLoc = this.state.curPosition();
          const start = this.state.pos;
          const end = this.input.indexOf(commentEnd, start + 2);
          if (end === -1) {
            throw this.raise(Errors.UnterminatedComment, {
              at: this.state.curPosition()
            });
          }
          this.state.pos = end + commentEnd.length;
          lineBreakG.lastIndex = start + 2;
          while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
            ++this.state.curLine;
            this.state.lineStart = lineBreakG.lastIndex;
          }
          if (this.isLookahead)
            return;
          const comment = {
            type: "CommentBlock",
            value: this.input.slice(start + 2, end),
            start,
            end: end + commentEnd.length,
            loc: new SourceLocation(startLoc, this.state.curPosition())
          };
          if (this.options.tokens)
            this.pushToken(comment);
          return comment;
        }
        skipLineComment(startSkip) {
          const start = this.state.pos;
          let startLoc;
          if (!this.isLookahead)
            startLoc = this.state.curPosition();
          let ch = this.input.charCodeAt(this.state.pos += startSkip);
          if (this.state.pos < this.length) {
            while (!isNewLine(ch) && ++this.state.pos < this.length) {
              ch = this.input.charCodeAt(this.state.pos);
            }
          }
          if (this.isLookahead)
            return;
          const end = this.state.pos;
          const value = this.input.slice(start + startSkip, end);
          const comment = {
            type: "CommentLine",
            value,
            start,
            end,
            loc: new SourceLocation(startLoc, this.state.curPosition())
          };
          if (this.options.tokens)
            this.pushToken(comment);
          return comment;
        }
        skipSpace() {
          const spaceStart = this.state.pos;
          const comments = [];
          loop:
            while (this.state.pos < this.length) {
              const ch = this.input.charCodeAt(this.state.pos);
              switch (ch) {
                case 32:
                case 160:
                case 9:
                  ++this.state.pos;
                  break;
                case 13:
                  if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                    ++this.state.pos;
                  }
                case 10:
                case 8232:
                case 8233:
                  ++this.state.pos;
                  ++this.state.curLine;
                  this.state.lineStart = this.state.pos;
                  break;
                case 47:
                  switch (this.input.charCodeAt(this.state.pos + 1)) {
                    case 42: {
                      const comment = this.skipBlockComment("*/");
                      if (comment !== void 0) {
                        this.addComment(comment);
                        if (this.options.attachComment)
                          comments.push(comment);
                      }
                      break;
                    }
                    case 47: {
                      const comment = this.skipLineComment(2);
                      if (comment !== void 0) {
                        this.addComment(comment);
                        if (this.options.attachComment)
                          comments.push(comment);
                      }
                      break;
                    }
                    default:
                      break loop;
                  }
                  break;
                default:
                  if (isWhitespace(ch)) {
                    ++this.state.pos;
                  } else if (ch === 45 && !this.inModule && this.options.annexB) {
                    const pos = this.state.pos;
                    if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                      const comment = this.skipLineComment(3);
                      if (comment !== void 0) {
                        this.addComment(comment);
                        if (this.options.attachComment)
                          comments.push(comment);
                      }
                    } else {
                      break loop;
                    }
                  } else if (ch === 60 && !this.inModule && this.options.annexB) {
                    const pos = this.state.pos;
                    if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
                      const comment = this.skipLineComment(4);
                      if (comment !== void 0) {
                        this.addComment(comment);
                        if (this.options.attachComment)
                          comments.push(comment);
                      }
                    } else {
                      break loop;
                    }
                  } else {
                    break loop;
                  }
              }
            }
          if (comments.length > 0) {
            const end = this.state.pos;
            const commentWhitespace = {
              start: spaceStart,
              end,
              comments,
              leadingNode: null,
              trailingNode: null,
              containingNode: null
            };
            this.state.commentStack.push(commentWhitespace);
          }
        }
        finishToken(type, val) {
          this.state.end = this.state.pos;
          this.state.endLoc = this.state.curPosition();
          const prevType = this.state.type;
          this.state.type = type;
          this.state.value = val;
          if (!this.isLookahead) {
            this.updateContext(prevType);
          }
        }
        replaceToken(type) {
          this.state.type = type;
          this.updateContext();
        }
        readToken_numberSign() {
          if (this.state.pos === 0 && this.readToken_interpreter()) {
            return;
          }
          const nextPos = this.state.pos + 1;
          const next = this.codePointAtPos(nextPos);
          if (next >= 48 && next <= 57) {
            throw this.raise(Errors.UnexpectedDigitAfterHash, {
              at: this.state.curPosition()
            });
          }
          if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
            this.expectPlugin("recordAndTuple");
            if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") {
              throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, {
                at: this.state.curPosition()
              });
            }
            this.state.pos += 2;
            if (next === 123) {
              this.finishToken(7);
            } else {
              this.finishToken(1);
            }
          } else if (isIdentifierStart(next)) {
            ++this.state.pos;
            this.finishToken(136, this.readWord1(next));
          } else if (next === 92) {
            ++this.state.pos;
            this.finishToken(136, this.readWord1());
          } else {
            this.finishOp(27, 1);
          }
        }
        readToken_dot() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next >= 48 && next <= 57) {
            this.readNumber(true);
            return;
          }
          if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
            this.state.pos += 3;
            this.finishToken(21);
          } else {
            ++this.state.pos;
            this.finishToken(16);
          }
        }
        readToken_slash() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === 61) {
            this.finishOp(31, 2);
          } else {
            this.finishOp(56, 1);
          }
        }
        readToken_interpreter() {
          if (this.state.pos !== 0 || this.length < 2)
            return false;
          let ch = this.input.charCodeAt(this.state.pos + 1);
          if (ch !== 33)
            return false;
          const start = this.state.pos;
          this.state.pos += 1;
          while (!isNewLine(ch) && ++this.state.pos < this.length) {
            ch = this.input.charCodeAt(this.state.pos);
          }
          const value = this.input.slice(start + 2, this.state.pos);
          this.finishToken(28, value);
          return true;
        }
        readToken_mult_modulo(code) {
          let type = code === 42 ? 55 : 54;
          let width = 1;
          let next = this.input.charCodeAt(this.state.pos + 1);
          if (code === 42 && next === 42) {
            width++;
            next = this.input.charCodeAt(this.state.pos + 2);
            type = 57;
          }
          if (next === 61 && !this.state.inType) {
            width++;
            type = code === 37 ? 33 : 30;
          }
          this.finishOp(type, width);
        }
        readToken_pipe_amp(code) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === code) {
            if (this.input.charCodeAt(this.state.pos + 2) === 61) {
              this.finishOp(30, 3);
            } else {
              this.finishOp(code === 124 ? 41 : 42, 2);
            }
            return;
          }
          if (code === 124) {
            if (next === 62) {
              this.finishOp(39, 2);
              return;
            }
            if (this.hasPlugin("recordAndTuple") && next === 125) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, {
                  at: this.state.curPosition()
                });
              }
              this.state.pos += 2;
              this.finishToken(9);
              return;
            }
            if (this.hasPlugin("recordAndTuple") && next === 93) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, {
                  at: this.state.curPosition()
                });
              }
              this.state.pos += 2;
              this.finishToken(4);
              return;
            }
          }
          if (next === 61) {
            this.finishOp(30, 2);
            return;
          }
          this.finishOp(code === 124 ? 43 : 45, 1);
        }
        readToken_caret() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === 61 && !this.state.inType) {
            this.finishOp(32, 2);
          } else if (next === 94 && this.hasPlugin(["pipelineOperator", {
            proposal: "hack",
            topicToken: "^^"
          }])) {
            this.finishOp(37, 2);
            const lookaheadCh = this.input.codePointAt(this.state.pos);
            if (lookaheadCh === 94) {
              this.unexpected();
            }
          } else {
            this.finishOp(44, 1);
          }
        }
        readToken_atSign() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === 64 && this.hasPlugin(["pipelineOperator", {
            proposal: "hack",
            topicToken: "@@"
          }])) {
            this.finishOp(38, 2);
          } else {
            this.finishOp(26, 1);
          }
        }
        readToken_plus_min(code) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === code) {
            this.finishOp(34, 2);
            return;
          }
          if (next === 61) {
            this.finishOp(30, 2);
          } else {
            this.finishOp(53, 1);
          }
        }
        readToken_lt() {
          const {
            pos
          } = this.state;
          const next = this.input.charCodeAt(pos + 1);
          if (next === 60) {
            if (this.input.charCodeAt(pos + 2) === 61) {
              this.finishOp(30, 3);
              return;
            }
            this.finishOp(51, 2);
            return;
          }
          if (next === 61) {
            this.finishOp(49, 2);
            return;
          }
          this.finishOp(47, 1);
        }
        readToken_gt() {
          const {
            pos
          } = this.state;
          const next = this.input.charCodeAt(pos + 1);
          if (next === 62) {
            const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
            if (this.input.charCodeAt(pos + size) === 61) {
              this.finishOp(30, size + 1);
              return;
            }
            this.finishOp(52, size);
            return;
          }
          if (next === 61) {
            this.finishOp(49, 2);
            return;
          }
          this.finishOp(48, 1);
        }
        readToken_eq_excl(code) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === 61) {
            this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
            return;
          }
          if (code === 61 && next === 62) {
            this.state.pos += 2;
            this.finishToken(19);
            return;
          }
          this.finishOp(code === 61 ? 29 : 35, 1);
        }
        readToken_question() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          const next2 = this.input.charCodeAt(this.state.pos + 2);
          if (next === 63) {
            if (next2 === 61) {
              this.finishOp(30, 3);
            } else {
              this.finishOp(40, 2);
            }
          } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
            this.state.pos += 2;
            this.finishToken(18);
          } else {
            ++this.state.pos;
            this.finishToken(17);
          }
        }
        getTokenFromCode(code) {
          switch (code) {
            case 46:
              this.readToken_dot();
              return;
            case 40:
              ++this.state.pos;
              this.finishToken(10);
              return;
            case 41:
              ++this.state.pos;
              this.finishToken(11);
              return;
            case 59:
              ++this.state.pos;
              this.finishToken(13);
              return;
            case 44:
              ++this.state.pos;
              this.finishToken(12);
              return;
            case 91:
              if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                  throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, {
                    at: this.state.curPosition()
                  });
                }
                this.state.pos += 2;
                this.finishToken(2);
              } else {
                ++this.state.pos;
                this.finishToken(0);
              }
              return;
            case 93:
              ++this.state.pos;
              this.finishToken(3);
              return;
            case 123:
              if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                  throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, {
                    at: this.state.curPosition()
                  });
                }
                this.state.pos += 2;
                this.finishToken(6);
              } else {
                ++this.state.pos;
                this.finishToken(5);
              }
              return;
            case 125:
              ++this.state.pos;
              this.finishToken(8);
              return;
            case 58:
              if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
                this.finishOp(15, 2);
              } else {
                ++this.state.pos;
                this.finishToken(14);
              }
              return;
            case 63:
              this.readToken_question();
              return;
            case 96:
              this.readTemplateToken();
              return;
            case 48: {
              const next = this.input.charCodeAt(this.state.pos + 1);
              if (next === 120 || next === 88) {
                this.readRadixNumber(16);
                return;
              }
              if (next === 111 || next === 79) {
                this.readRadixNumber(8);
                return;
              }
              if (next === 98 || next === 66) {
                this.readRadixNumber(2);
                return;
              }
            }
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              this.readNumber(false);
              return;
            case 34:
            case 39:
              this.readString(code);
              return;
            case 47:
              this.readToken_slash();
              return;
            case 37:
            case 42:
              this.readToken_mult_modulo(code);
              return;
            case 124:
            case 38:
              this.readToken_pipe_amp(code);
              return;
            case 94:
              this.readToken_caret();
              return;
            case 43:
            case 45:
              this.readToken_plus_min(code);
              return;
            case 60:
              this.readToken_lt();
              return;
            case 62:
              this.readToken_gt();
              return;
            case 61:
            case 33:
              this.readToken_eq_excl(code);
              return;
            case 126:
              this.finishOp(36, 1);
              return;
            case 64:
              this.readToken_atSign();
              return;
            case 35:
              this.readToken_numberSign();
              return;
            case 92:
              this.readWord();
              return;
            default:
              if (isIdentifierStart(code)) {
                this.readWord(code);
                return;
              }
          }
          throw this.raise(Errors.InvalidOrUnexpectedToken, {
            at: this.state.curPosition(),
            unexpected: String.fromCodePoint(code)
          });
        }
        finishOp(type, size) {
          const str = this.input.slice(this.state.pos, this.state.pos + size);
          this.state.pos += size;
          this.finishToken(type, str);
        }
        readRegexp() {
          const startLoc = this.state.startLoc;
          const start = this.state.start + 1;
          let escaped, inClass;
          let {
            pos
          } = this.state;
          for (; ; ++pos) {
            if (pos >= this.length) {
              throw this.raise(Errors.UnterminatedRegExp, {
                at: createPositionWithColumnOffset(startLoc, 1)
              });
            }
            const ch = this.input.charCodeAt(pos);
            if (isNewLine(ch)) {
              throw this.raise(Errors.UnterminatedRegExp, {
                at: createPositionWithColumnOffset(startLoc, 1)
              });
            }
            if (escaped) {
              escaped = false;
            } else {
              if (ch === 91) {
                inClass = true;
              } else if (ch === 93 && inClass) {
                inClass = false;
              } else if (ch === 47 && !inClass) {
                break;
              }
              escaped = ch === 92;
            }
          }
          const content = this.input.slice(start, pos);
          ++pos;
          let mods = "";
          const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
          while (pos < this.length) {
            const cp = this.codePointAtPos(pos);
            const char = String.fromCharCode(cp);
            if (VALID_REGEX_FLAGS.has(cp)) {
              if (cp === 118) {
                if (mods.includes("u")) {
                  this.raise(Errors.IncompatibleRegExpUVFlags, {
                    at: nextPos()
                  });
                }
              } else if (cp === 117) {
                if (mods.includes("v")) {
                  this.raise(Errors.IncompatibleRegExpUVFlags, {
                    at: nextPos()
                  });
                }
              }
              if (mods.includes(char)) {
                this.raise(Errors.DuplicateRegExpFlags, {
                  at: nextPos()
                });
              }
            } else if (isIdentifierChar(cp) || cp === 92) {
              this.raise(Errors.MalformedRegExpFlags, {
                at: nextPos()
              });
            } else {
              break;
            }
            ++pos;
            mods += char;
          }
          this.state.pos = pos;
          this.finishToken(135, {
            pattern: content,
            flags: mods
          });
        }
        readInt(radix, len, forceLen = false, allowNumSeparator = true) {
          const {
            n,
            pos
          } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);
          this.state.pos = pos;
          return n;
        }
        readRadixNumber(radix) {
          const startLoc = this.state.curPosition();
          let isBigInt = false;
          this.state.pos += 2;
          const val = this.readInt(radix);
          if (val == null) {
            this.raise(Errors.InvalidDigit, {
              at: createPositionWithColumnOffset(startLoc, 2),
              radix
            });
          }
          const next = this.input.charCodeAt(this.state.pos);
          if (next === 110) {
            ++this.state.pos;
            isBigInt = true;
          } else if (next === 109) {
            throw this.raise(Errors.InvalidDecimal, {
              at: startLoc
            });
          }
          if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
            throw this.raise(Errors.NumberIdentifier, {
              at: this.state.curPosition()
            });
          }
          if (isBigInt) {
            const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, "");
            this.finishToken(133, str);
            return;
          }
          this.finishToken(132, val);
        }
        readNumber(startsWithDot) {
          const start = this.state.pos;
          const startLoc = this.state.curPosition();
          let isFloat = false;
          let isBigInt = false;
          let isDecimal = false;
          let hasExponent = false;
          let isOctal = false;
          if (!startsWithDot && this.readInt(10) === null) {
            this.raise(Errors.InvalidNumber, {
              at: this.state.curPosition()
            });
          }
          const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
          if (hasLeadingZero) {
            const integer = this.input.slice(start, this.state.pos);
            this.recordStrictModeErrors(Errors.StrictOctalLiteral, {
              at: startLoc
            });
            if (!this.state.strict) {
              const underscorePos = integer.indexOf("_");
              if (underscorePos > 0) {
                this.raise(Errors.ZeroDigitNumericSeparator, {
                  at: createPositionWithColumnOffset(startLoc, underscorePos)
                });
              }
            }
            isOctal = hasLeadingZero && !/[89]/.test(integer);
          }
          let next = this.input.charCodeAt(this.state.pos);
          if (next === 46 && !isOctal) {
            ++this.state.pos;
            this.readInt(10);
            isFloat = true;
            next = this.input.charCodeAt(this.state.pos);
          }
          if ((next === 69 || next === 101) && !isOctal) {
            next = this.input.charCodeAt(++this.state.pos);
            if (next === 43 || next === 45) {
              ++this.state.pos;
            }
            if (this.readInt(10) === null) {
              this.raise(Errors.InvalidOrMissingExponent, {
                at: startLoc
              });
            }
            isFloat = true;
            hasExponent = true;
            next = this.input.charCodeAt(this.state.pos);
          }
          if (next === 110) {
            if (isFloat || hasLeadingZero) {
              this.raise(Errors.InvalidBigIntLiteral, {
                at: startLoc
              });
            }
            ++this.state.pos;
            isBigInt = true;
          }
          if (next === 109) {
            this.expectPlugin("decimal", this.state.curPosition());
            if (hasExponent || hasLeadingZero) {
              this.raise(Errors.InvalidDecimal, {
                at: startLoc
              });
            }
            ++this.state.pos;
            isDecimal = true;
          }
          if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
            throw this.raise(Errors.NumberIdentifier, {
              at: this.state.curPosition()
            });
          }
          const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
          if (isBigInt) {
            this.finishToken(133, str);
            return;
          }
          if (isDecimal) {
            this.finishToken(134, str);
            return;
          }
          const val = isOctal ? parseInt(str, 8) : parseFloat(str);
          this.finishToken(132, val);
        }
        readCodePoint(throwOnInvalid) {
          const {
            code,
            pos
          } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
          this.state.pos = pos;
          return code;
        }
        readString(quote) {
          const {
            str,
            pos,
            curLine,
            lineStart
          } = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
          this.state.pos = pos + 1;
          this.state.lineStart = lineStart;
          this.state.curLine = curLine;
          this.finishToken(131, str);
        }
        readTemplateContinuation() {
          if (!this.match(8)) {
            this.unexpected(null, 8);
          }
          this.state.pos--;
          this.readTemplateToken();
        }
        readTemplateToken() {
          const opening = this.input[this.state.pos];
          const {
            str,
            firstInvalidLoc,
            pos,
            curLine,
            lineStart
          } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
          this.state.pos = pos + 1;
          this.state.lineStart = lineStart;
          this.state.curLine = curLine;
          if (firstInvalidLoc) {
            this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, firstInvalidLoc.pos);
          }
          if (this.input.codePointAt(pos) === 96) {
            this.finishToken(24, firstInvalidLoc ? null : opening + str + "`");
          } else {
            this.state.pos++;
            this.finishToken(25, firstInvalidLoc ? null : opening + str + "${");
          }
        }
        recordStrictModeErrors(toParseError, {
          at
        }) {
          const index = at.index;
          if (this.state.strict && !this.state.strictErrors.has(index)) {
            this.raise(toParseError, {
              at
            });
          } else {
            this.state.strictErrors.set(index, [toParseError, at]);
          }
        }
        readWord1(firstCode) {
          this.state.containsEsc = false;
          let word = "";
          const start = this.state.pos;
          let chunkStart = this.state.pos;
          if (firstCode !== void 0) {
            this.state.pos += firstCode <= 65535 ? 1 : 2;
          }
          while (this.state.pos < this.length) {
            const ch = this.codePointAtPos(this.state.pos);
            if (isIdentifierChar(ch)) {
              this.state.pos += ch <= 65535 ? 1 : 2;
            } else if (ch === 92) {
              this.state.containsEsc = true;
              word += this.input.slice(chunkStart, this.state.pos);
              const escStart = this.state.curPosition();
              const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
              if (this.input.charCodeAt(++this.state.pos) !== 117) {
                this.raise(Errors.MissingUnicodeEscape, {
                  at: this.state.curPosition()
                });
                chunkStart = this.state.pos - 1;
                continue;
              }
              ++this.state.pos;
              const esc = this.readCodePoint(true);
              if (esc !== null) {
                if (!identifierCheck(esc)) {
                  this.raise(Errors.EscapedCharNotAnIdentifier, {
                    at: escStart
                  });
                }
                word += String.fromCodePoint(esc);
              }
              chunkStart = this.state.pos;
            } else {
              break;
            }
          }
          return word + this.input.slice(chunkStart, this.state.pos);
        }
        readWord(firstCode) {
          const word = this.readWord1(firstCode);
          const type = keywords$1.get(word);
          if (type !== void 0) {
            this.finishToken(type, tokenLabelName(type));
          } else {
            this.finishToken(130, word);
          }
        }
        checkKeywordEscapes() {
          const {
            type
          } = this.state;
          if (tokenIsKeyword(type) && this.state.containsEsc) {
            this.raise(Errors.InvalidEscapedReservedWord, {
              at: this.state.startLoc,
              reservedWord: tokenLabelName(type)
            });
          }
        }
        raise(toParseError, raiseProperties) {
          const {
            at
          } = raiseProperties, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded);
          const loc = at instanceof Position ? at : at.loc.start;
          const error = toParseError({
            loc,
            details
          });
          if (!this.options.errorRecovery)
            throw error;
          if (!this.isLookahead)
            this.state.errors.push(error);
          return error;
        }
        raiseOverwrite(toParseError, raiseProperties) {
          const {
            at
          } = raiseProperties, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded2);
          const loc = at instanceof Position ? at : at.loc.start;
          const pos = loc.index;
          const errors = this.state.errors;
          for (let i = errors.length - 1; i >= 0; i--) {
            const error = errors[i];
            if (error.loc.index === pos) {
              return errors[i] = toParseError({
                loc,
                details
              });
            }
            if (error.loc.index < pos)
              break;
          }
          return this.raise(toParseError, raiseProperties);
        }
        updateContext(prevType) {
        }
        unexpected(loc, type) {
          throw this.raise(Errors.UnexpectedToken, {
            expected: type ? tokenLabelName(type) : null,
            at: loc != null ? loc : this.state.startLoc
          });
        }
        expectPlugin(pluginName, loc) {
          if (this.hasPlugin(pluginName)) {
            return true;
          }
          throw this.raise(Errors.MissingPlugin, {
            at: loc != null ? loc : this.state.startLoc,
            missingPlugin: [pluginName]
          });
        }
        expectOnePlugin(pluginNames) {
          if (!pluginNames.some((name) => this.hasPlugin(name))) {
            throw this.raise(Errors.MissingOneOfPlugins, {
              at: this.state.startLoc,
              missingPlugin: pluginNames
            });
          }
        }
        errorBuilder(error) {
          return (pos, lineStart, curLine) => {
            this.raise(error, {
              at: buildPosition(pos, lineStart, curLine)
            });
          };
        }
      };
      var ClassScope = class {
        constructor() {
          this.privateNames = /* @__PURE__ */ new Set();
          this.loneAccessors = /* @__PURE__ */ new Map();
          this.undefinedPrivateNames = /* @__PURE__ */ new Map();
        }
      };
      var ClassScopeHandler = class {
        constructor(parser) {
          this.parser = void 0;
          this.stack = [];
          this.undefinedPrivateNames = /* @__PURE__ */ new Map();
          this.parser = parser;
        }
        current() {
          return this.stack[this.stack.length - 1];
        }
        enter() {
          this.stack.push(new ClassScope());
        }
        exit() {
          const oldClassScope = this.stack.pop();
          const current = this.current();
          for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
            if (current) {
              if (!current.undefinedPrivateNames.has(name)) {
                current.undefinedPrivateNames.set(name, loc);
              }
            } else {
              this.parser.raise(Errors.InvalidPrivateFieldResolution, {
                at: loc,
                identifierName: name
              });
            }
          }
        }
        declarePrivateName(name, elementType, loc) {
          const {
            privateNames,
            loneAccessors,
            undefinedPrivateNames
          } = this.current();
          let redefined = privateNames.has(name);
          if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
            const accessor = redefined && loneAccessors.get(name);
            if (accessor) {
              const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;
              const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;
              const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;
              const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;
              redefined = oldKind === newKind || oldStatic !== newStatic;
              if (!redefined)
                loneAccessors.delete(name);
            } else if (!redefined) {
              loneAccessors.set(name, elementType);
            }
          }
          if (redefined) {
            this.parser.raise(Errors.PrivateNameRedeclaration, {
              at: loc,
              identifierName: name
            });
          }
          privateNames.add(name);
          undefinedPrivateNames.delete(name);
        }
        usePrivateName(name, loc) {
          let classScope;
          for (classScope of this.stack) {
            if (classScope.privateNames.has(name))
              return;
          }
          if (classScope) {
            classScope.undefinedPrivateNames.set(name, loc);
          } else {
            this.parser.raise(Errors.InvalidPrivateFieldResolution, {
              at: loc,
              identifierName: name
            });
          }
        }
      };
      var kExpression = 0;
      var kMaybeArrowParameterDeclaration = 1;
      var kMaybeAsyncArrowParameterDeclaration = 2;
      var kParameterDeclaration = 3;
      var ExpressionScope = class {
        constructor(type = kExpression) {
          this.type = void 0;
          this.type = type;
        }
        canBeArrowParameterDeclaration() {
          return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;
        }
        isCertainlyParameterDeclaration() {
          return this.type === kParameterDeclaration;
        }
      };
      var ArrowHeadParsingScope = class extends ExpressionScope {
        constructor(type) {
          super(type);
          this.declarationErrors = /* @__PURE__ */ new Map();
        }
        recordDeclarationError(ParsingErrorClass, {
          at
        }) {
          const index = at.index;
          this.declarationErrors.set(index, [ParsingErrorClass, at]);
        }
        clearDeclarationError(index) {
          this.declarationErrors.delete(index);
        }
        iterateErrors(iterator) {
          this.declarationErrors.forEach(iterator);
        }
      };
      var ExpressionScopeHandler = class {
        constructor(parser) {
          this.parser = void 0;
          this.stack = [new ExpressionScope()];
          this.parser = parser;
        }
        enter(scope) {
          this.stack.push(scope);
        }
        exit() {
          this.stack.pop();
        }
        recordParameterInitializerError(toParseError, {
          at: node
        }) {
          const origin = {
            at: node.loc.start
          };
          const {
            stack
          } = this;
          let i = stack.length - 1;
          let scope = stack[i];
          while (!scope.isCertainlyParameterDeclaration()) {
            if (scope.canBeArrowParameterDeclaration()) {
              scope.recordDeclarationError(toParseError, origin);
            } else {
              return;
            }
            scope = stack[--i];
          }
          this.parser.raise(toParseError, origin);
        }
        recordArrowParameterBindingError(error, {
          at: node
        }) {
          const {
            stack
          } = this;
          const scope = stack[stack.length - 1];
          const origin = {
            at: node.loc.start
          };
          if (scope.isCertainlyParameterDeclaration()) {
            this.parser.raise(error, origin);
          } else if (scope.canBeArrowParameterDeclaration()) {
            scope.recordDeclarationError(error, origin);
          } else {
            return;
          }
        }
        recordAsyncArrowParametersError({
          at
        }) {
          const {
            stack
          } = this;
          let i = stack.length - 1;
          let scope = stack[i];
          while (scope.canBeArrowParameterDeclaration()) {
            if (scope.type === kMaybeAsyncArrowParameterDeclaration) {
              scope.recordDeclarationError(Errors.AwaitBindingIdentifier, {
                at
              });
            }
            scope = stack[--i];
          }
        }
        validateAsPattern() {
          const {
            stack
          } = this;
          const currentScope = stack[stack.length - 1];
          if (!currentScope.canBeArrowParameterDeclaration())
            return;
          currentScope.iterateErrors(([toParseError, loc]) => {
            this.parser.raise(toParseError, {
              at: loc
            });
            let i = stack.length - 2;
            let scope = stack[i];
            while (scope.canBeArrowParameterDeclaration()) {
              scope.clearDeclarationError(loc.index);
              scope = stack[--i];
            }
          });
        }
      };
      function newParameterDeclarationScope() {
        return new ExpressionScope(kParameterDeclaration);
      }
      function newArrowHeadScope() {
        return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);
      }
      function newAsyncArrowScope() {
        return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);
      }
      function newExpressionScope() {
        return new ExpressionScope();
      }
      var PARAM = 0;
      var PARAM_YIELD = 1;
      var PARAM_AWAIT = 2;
      var PARAM_RETURN = 4;
      var PARAM_IN = 8;
      var ProductionParameterHandler = class {
        constructor() {
          this.stacks = [];
        }
        enter(flags) {
          this.stacks.push(flags);
        }
        exit() {
          this.stacks.pop();
        }
        currentFlags() {
          return this.stacks[this.stacks.length - 1];
        }
        get hasAwait() {
          return (this.currentFlags() & PARAM_AWAIT) > 0;
        }
        get hasYield() {
          return (this.currentFlags() & PARAM_YIELD) > 0;
        }
        get hasReturn() {
          return (this.currentFlags() & PARAM_RETURN) > 0;
        }
        get hasIn() {
          return (this.currentFlags() & PARAM_IN) > 0;
        }
      };
      function functionFlags(isAsync, isGenerator) {
        return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
      }
      var UtilParser = class extends Tokenizer {
        addExtra(node, key, value, enumerable = true) {
          if (!node)
            return;
          const extra = node.extra = node.extra || {};
          if (enumerable) {
            extra[key] = value;
          } else {
            Object.defineProperty(extra, key, {
              enumerable,
              value
            });
          }
        }
        isContextual(token) {
          return this.state.type === token && !this.state.containsEsc;
        }
        isUnparsedContextual(nameStart, name) {
          const nameEnd = nameStart + name.length;
          if (this.input.slice(nameStart, nameEnd) === name) {
            const nextCh = this.input.charCodeAt(nameEnd);
            return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
          }
          return false;
        }
        isLookaheadContextual(name) {
          const next = this.nextTokenStart();
          return this.isUnparsedContextual(next, name);
        }
        eatContextual(token) {
          if (this.isContextual(token)) {
            this.next();
            return true;
          }
          return false;
        }
        expectContextual(token, toParseError) {
          if (!this.eatContextual(token)) {
            if (toParseError != null) {
              throw this.raise(toParseError, {
                at: this.state.startLoc
              });
            }
            this.unexpected(null, token);
          }
        }
        canInsertSemicolon() {
          return this.match(137) || this.match(8) || this.hasPrecedingLineBreak();
        }
        hasPrecedingLineBreak() {
          return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
        }
        hasFollowingLineBreak() {
          skipWhiteSpaceToLineBreak.lastIndex = this.state.end;
          return skipWhiteSpaceToLineBreak.test(this.input);
        }
        isLineTerminator() {
          return this.eat(13) || this.canInsertSemicolon();
        }
        semicolon(allowAsi = true) {
          if (allowAsi ? this.isLineTerminator() : this.eat(13))
            return;
          this.raise(Errors.MissingSemicolon, {
            at: this.state.lastTokEndLoc
          });
        }
        expect(type, loc) {
          this.eat(type) || this.unexpected(loc, type);
        }
        tryParse(fn, oldState = this.state.clone()) {
          const abortSignal = {
            node: null
          };
          try {
            const node = fn((node2 = null) => {
              abortSignal.node = node2;
              throw abortSignal;
            });
            if (this.state.errors.length > oldState.errors.length) {
              const failState = this.state;
              this.state = oldState;
              this.state.tokensLength = failState.tokensLength;
              return {
                node,
                error: failState.errors[oldState.errors.length],
                thrown: false,
                aborted: false,
                failState
              };
            }
            return {
              node,
              error: null,
              thrown: false,
              aborted: false,
              failState: null
            };
          } catch (error) {
            const failState = this.state;
            this.state = oldState;
            if (error instanceof SyntaxError) {
              return {
                node: null,
                error,
                thrown: true,
                aborted: false,
                failState
              };
            }
            if (error === abortSignal) {
              return {
                node: abortSignal.node,
                error: null,
                thrown: false,
                aborted: true,
                failState
              };
            }
            throw error;
          }
        }
        checkExpressionErrors(refExpressionErrors, andThrow) {
          if (!refExpressionErrors)
            return false;
          const {
            shorthandAssignLoc,
            doubleProtoLoc,
            privateKeyLoc,
            optionalParametersLoc
          } = refExpressionErrors;
          const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
          if (!andThrow) {
            return hasErrors;
          }
          if (shorthandAssignLoc != null) {
            this.raise(Errors.InvalidCoverInitializedName, {
              at: shorthandAssignLoc
            });
          }
          if (doubleProtoLoc != null) {
            this.raise(Errors.DuplicateProto, {
              at: doubleProtoLoc
            });
          }
          if (privateKeyLoc != null) {
            this.raise(Errors.UnexpectedPrivateField, {
              at: privateKeyLoc
            });
          }
          if (optionalParametersLoc != null) {
            this.unexpected(optionalParametersLoc);
          }
        }
        isLiteralPropertyName() {
          return tokenIsLiteralPropertyName(this.state.type);
        }
        isPrivateName(node) {
          return node.type === "PrivateName";
        }
        getPrivateNameSV(node) {
          return node.id.name;
        }
        hasPropertyAsPrivateName(node) {
          return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
        }
        isObjectProperty(node) {
          return node.type === "ObjectProperty";
        }
        isObjectMethod(node) {
          return node.type === "ObjectMethod";
        }
        initializeScopes(inModule = this.options.sourceType === "module") {
          const oldLabels = this.state.labels;
          this.state.labels = [];
          const oldExportedIdentifiers = this.exportedIdentifiers;
          this.exportedIdentifiers = /* @__PURE__ */ new Set();
          const oldInModule = this.inModule;
          this.inModule = inModule;
          const oldScope = this.scope;
          const ScopeHandler2 = this.getScopeHandler();
          this.scope = new ScopeHandler2(this, inModule);
          const oldProdParam = this.prodParam;
          this.prodParam = new ProductionParameterHandler();
          const oldClassScope = this.classScope;
          this.classScope = new ClassScopeHandler(this);
          const oldExpressionScope = this.expressionScope;
          this.expressionScope = new ExpressionScopeHandler(this);
          return () => {
            this.state.labels = oldLabels;
            this.exportedIdentifiers = oldExportedIdentifiers;
            this.inModule = oldInModule;
            this.scope = oldScope;
            this.prodParam = oldProdParam;
            this.classScope = oldClassScope;
            this.expressionScope = oldExpressionScope;
          };
        }
        enterInitialScopes() {
          let paramFlags = PARAM;
          if (this.inModule) {
            paramFlags |= PARAM_AWAIT;
          }
          this.scope.enter(SCOPE_PROGRAM);
          this.prodParam.enter(paramFlags);
        }
        checkDestructuringPrivate(refExpressionErrors) {
          const {
            privateKeyLoc
          } = refExpressionErrors;
          if (privateKeyLoc !== null) {
            this.expectPlugin("destructuringPrivate", privateKeyLoc);
          }
        }
      };
      var ExpressionErrors = class {
        constructor() {
          this.shorthandAssignLoc = null;
          this.doubleProtoLoc = null;
          this.privateKeyLoc = null;
          this.optionalParametersLoc = null;
        }
      };
      var Node = class {
        constructor(parser, pos, loc) {
          this.type = "";
          this.start = pos;
          this.end = 0;
          this.loc = new SourceLocation(loc);
          if (parser != null && parser.options.ranges)
            this.range = [pos, 0];
          if (parser != null && parser.filename)
            this.loc.filename = parser.filename;
        }
      };
      var NodePrototype = Node.prototype;
      {
        NodePrototype.__clone = function() {
          const newNode = new Node(void 0, this.start, this.loc.start);
          const keys = Object.keys(this);
          for (let i = 0, length = keys.length; i < length; i++) {
            const key = keys[i];
            if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
              newNode[key] = this[key];
            }
          }
          return newNode;
        };
      }
      function clonePlaceholder(node) {
        return cloneIdentifier(node);
      }
      function cloneIdentifier(node) {
        const {
          type,
          start,
          end,
          loc,
          range,
          extra,
          name
        } = node;
        const cloned = Object.create(NodePrototype);
        cloned.type = type;
        cloned.start = start;
        cloned.end = end;
        cloned.loc = loc;
        cloned.range = range;
        cloned.extra = extra;
        cloned.name = name;
        if (type === "Placeholder") {
          cloned.expectedNode = node.expectedNode;
        }
        return cloned;
      }
      function cloneStringLiteral(node) {
        const {
          type,
          start,
          end,
          loc,
          range,
          extra
        } = node;
        if (type === "Placeholder") {
          return clonePlaceholder(node);
        }
        const cloned = Object.create(NodePrototype);
        cloned.type = type;
        cloned.start = start;
        cloned.end = end;
        cloned.loc = loc;
        cloned.range = range;
        if (node.raw !== void 0) {
          cloned.raw = node.raw;
        } else {
          cloned.extra = extra;
        }
        cloned.value = node.value;
        return cloned;
      }
      var NodeUtils = class extends UtilParser {
        startNode() {
          return new Node(this, this.state.start, this.state.startLoc);
        }
        startNodeAt(loc) {
          return new Node(this, loc.index, loc);
        }
        startNodeAtNode(type) {
          return this.startNodeAt(type.loc.start);
        }
        finishNode(node, type) {
          return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
        }
        finishNodeAt(node, type, endLoc) {
          node.type = type;
          node.end = endLoc.index;
          node.loc.end = endLoc;
          if (this.options.ranges)
            node.range[1] = endLoc.index;
          if (this.options.attachComment)
            this.processComment(node);
          return node;
        }
        resetStartLocation(node, startLoc) {
          node.start = startLoc.index;
          node.loc.start = startLoc;
          if (this.options.ranges)
            node.range[0] = startLoc.index;
        }
        resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
          node.end = endLoc.index;
          node.loc.end = endLoc;
          if (this.options.ranges)
            node.range[1] = endLoc.index;
        }
        resetStartLocationFromNode(node, locationNode) {
          this.resetStartLocation(node, locationNode.loc.start);
        }
      };
      var reservedTypes = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
      var FlowErrors = ParseErrorEnum`flow`({
        AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
        AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
        AssignReservedType: ({
          reservedType
        }) => `Cannot overwrite reserved type ${reservedType}.`,
        DeclareClassElement: "The `declare` modifier can only appear on class fields.",
        DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
        DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
        EnumBooleanMemberNotInitialized: ({
          memberName,
          enumName
        }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
        EnumDuplicateMemberName: ({
          memberName,
          enumName
        }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
        EnumInconsistentMemberValues: ({
          enumName
        }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
        EnumInvalidExplicitType: ({
          invalidEnumType,
          enumName
        }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
        EnumInvalidExplicitTypeUnknownSupplied: ({
          enumName
        }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
        EnumInvalidMemberInitializerPrimaryType: ({
          enumName,
          memberName,
          explicitType
        }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
        EnumInvalidMemberInitializerSymbolType: ({
          enumName,
          memberName
        }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
        EnumInvalidMemberInitializerUnknownType: ({
          enumName,
          memberName
        }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
        EnumInvalidMemberName: ({
          enumName,
          memberName,
          suggestion
        }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
        EnumNumberMemberNotInitialized: ({
          enumName,
          memberName
        }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
        EnumStringMemberInconsistentlyInitailized: ({
          enumName
        }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
        GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
        ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
        ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
        InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
        InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
        InexactVariance: "Explicit inexact syntax cannot have variance.",
        InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
        MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
        NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
        NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
        PatternIsOptional: Object.assign({
          message: "A binding pattern parameter cannot be optional in an implementation signature."
        }, {
          reasonCode: "OptionalBindingPattern"
        }),
        SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
        SpreadVariance: "Spread properties cannot have variance.",
        ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
        ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
        ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
        ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
        ThisParamNoDefault: "The `this` parameter may not have a default value.",
        TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
        TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
        UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
        UnexpectedReservedType: ({
          reservedType
        }) => `Unexpected reserved type ${reservedType}.`,
        UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
        UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
        UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
        UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
        UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
        UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
        UnsupportedDeclareExportKind: ({
          unsupportedExportKind,
          suggestion
        }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
        UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
        UnterminatedFlowComment: "Unterminated flow-comment."
      });
      function isEsModuleType(bodyElement) {
        return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
      }
      function hasTypeImportKind(node) {
        return node.importKind === "type" || node.importKind === "typeof";
      }
      var exportSuggestions = {
        const: "declare export var",
        let: "declare export var",
        type: "export type",
        interface: "export interface"
      };
      function partition(list, test) {
        const list1 = [];
        const list2 = [];
        for (let i = 0; i < list.length; i++) {
          (test(list[i], i, list) ? list1 : list2).push(list[i]);
        }
        return [list1, list2];
      }
      var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
      var flow = (superClass) => class FlowParserMixin extends superClass {
        constructor(...args) {
          super(...args);
          this.flowPragma = void 0;
        }
        getScopeHandler() {
          return FlowScopeHandler;
        }
        shouldParseTypes() {
          return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
        }
        shouldParseEnums() {
          return !!this.getPluginOption("flow", "enums");
        }
        finishToken(type, val) {
          if (type !== 131 && type !== 13 && type !== 28) {
            if (this.flowPragma === void 0) {
              this.flowPragma = null;
            }
          }
          super.finishToken(type, val);
        }
        addComment(comment) {
          if (this.flowPragma === void 0) {
            const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
            if (!matches)
              ;
            else if (matches[1] === "flow") {
              this.flowPragma = "flow";
            } else if (matches[1] === "noflow") {
              this.flowPragma = "noflow";
            } else {
              throw new Error("Unexpected flow pragma");
            }
          }
          super.addComment(comment);
        }
        flowParseTypeInitialiser(tok) {
          const oldInType = this.state.inType;
          this.state.inType = true;
          this.expect(tok || 14);
          const type = this.flowParseType();
          this.state.inType = oldInType;
          return type;
        }
        flowParsePredicate() {
          const node = this.startNode();
          const moduloLoc = this.state.startLoc;
          this.next();
          this.expectContextual(108);
          if (this.state.lastTokStart > moduloLoc.index + 1) {
            this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {
              at: moduloLoc
            });
          }
          if (this.eat(10)) {
            node.value = super.parseExpression();
            this.expect(11);
            return this.finishNode(node, "DeclaredPredicate");
          } else {
            return this.finishNode(node, "InferredPredicate");
          }
        }
        flowParseTypeAndPredicateInitialiser() {
          const oldInType = this.state.inType;
          this.state.inType = true;
          this.expect(14);
          let type = null;
          let predicate = null;
          if (this.match(54)) {
            this.state.inType = oldInType;
            predicate = this.flowParsePredicate();
          } else {
            type = this.flowParseType();
            this.state.inType = oldInType;
            if (this.match(54)) {
              predicate = this.flowParsePredicate();
            }
          }
          return [type, predicate];
        }
        flowParseDeclareClass(node) {
          this.next();
          this.flowParseInterfaceish(node, true);
          return this.finishNode(node, "DeclareClass");
        }
        flowParseDeclareFunction(node) {
          this.next();
          const id = node.id = this.parseIdentifier();
          const typeNode = this.startNode();
          const typeContainer = this.startNode();
          if (this.match(47)) {
            typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            typeNode.typeParameters = null;
          }
          this.expect(10);
          const tmp = this.flowParseFunctionTypeParams();
          typeNode.params = tmp.params;
          typeNode.rest = tmp.rest;
          typeNode.this = tmp._this;
          this.expect(11);
          [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
          typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
          id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
          this.resetEndLocation(id);
          this.semicolon();
          this.scope.declareName(node.id.name, BIND_FLOW_DECLARE_FN, node.id.loc.start);
          return this.finishNode(node, "DeclareFunction");
        }
        flowParseDeclare(node, insideModule) {
          if (this.match(80)) {
            return this.flowParseDeclareClass(node);
          } else if (this.match(68)) {
            return this.flowParseDeclareFunction(node);
          } else if (this.match(74)) {
            return this.flowParseDeclareVariable(node);
          } else if (this.eatContextual(125)) {
            if (this.match(16)) {
              return this.flowParseDeclareModuleExports(node);
            } else {
              if (insideModule) {
                this.raise(FlowErrors.NestedDeclareModule, {
                  at: this.state.lastTokStartLoc
                });
              }
              return this.flowParseDeclareModule(node);
            }
          } else if (this.isContextual(128)) {
            return this.flowParseDeclareTypeAlias(node);
          } else if (this.isContextual(129)) {
            return this.flowParseDeclareOpaqueType(node);
          } else if (this.isContextual(127)) {
            return this.flowParseDeclareInterface(node);
          } else if (this.match(82)) {
            return this.flowParseDeclareExportDeclaration(node, insideModule);
          } else {
            this.unexpected();
          }
        }
        flowParseDeclareVariable(node) {
          this.next();
          node.id = this.flowParseTypeAnnotatableIdentifier(true);
          this.scope.declareName(node.id.name, BIND_VAR, node.id.loc.start);
          this.semicolon();
          return this.finishNode(node, "DeclareVariable");
        }
        flowParseDeclareModule(node) {
          this.scope.enter(SCOPE_OTHER);
          if (this.match(131)) {
            node.id = super.parseExprAtom();
          } else {
            node.id = this.parseIdentifier();
          }
          const bodyNode = node.body = this.startNode();
          const body = bodyNode.body = [];
          this.expect(5);
          while (!this.match(8)) {
            let bodyNode2 = this.startNode();
            if (this.match(83)) {
              this.next();
              if (!this.isContextual(128) && !this.match(87)) {
                this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {
                  at: this.state.lastTokStartLoc
                });
              }
              super.parseImport(bodyNode2);
            } else {
              this.expectContextual(123, FlowErrors.UnsupportedStatementInDeclareModule);
              bodyNode2 = this.flowParseDeclare(bodyNode2, true);
            }
            body.push(bodyNode2);
          }
          this.scope.exit();
          this.expect(8);
          this.finishNode(bodyNode, "BlockStatement");
          let kind = null;
          let hasModuleExport = false;
          body.forEach((bodyElement) => {
            if (isEsModuleType(bodyElement)) {
              if (kind === "CommonJS") {
                this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
                  at: bodyElement
                });
              }
              kind = "ES";
            } else if (bodyElement.type === "DeclareModuleExports") {
              if (hasModuleExport) {
                this.raise(FlowErrors.DuplicateDeclareModuleExports, {
                  at: bodyElement
                });
              }
              if (kind === "ES") {
                this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
                  at: bodyElement
                });
              }
              kind = "CommonJS";
              hasModuleExport = true;
            }
          });
          node.kind = kind || "CommonJS";
          return this.finishNode(node, "DeclareModule");
        }
        flowParseDeclareExportDeclaration(node, insideModule) {
          this.expect(82);
          if (this.eat(65)) {
            if (this.match(68) || this.match(80)) {
              node.declaration = this.flowParseDeclare(this.startNode());
            } else {
              node.declaration = this.flowParseType();
              this.semicolon();
            }
            node.default = true;
            return this.finishNode(node, "DeclareExportDeclaration");
          } else {
            if (this.match(75) || this.isLet() || (this.isContextual(128) || this.isContextual(127)) && !insideModule) {
              const label = this.state.value;
              throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {
                at: this.state.startLoc,
                unsupportedExportKind: label,
                suggestion: exportSuggestions[label]
              });
            }
            if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(129)) {
              node.declaration = this.flowParseDeclare(this.startNode());
              node.default = false;
              return this.finishNode(node, "DeclareExportDeclaration");
            } else if (this.match(55) || this.match(5) || this.isContextual(127) || this.isContextual(128) || this.isContextual(129)) {
              node = this.parseExport(node, null);
              if (node.type === "ExportNamedDeclaration") {
                node.type = "ExportDeclaration";
                node.default = false;
                delete node.exportKind;
              }
              node.type = "Declare" + node.type;
              return node;
            }
          }
          this.unexpected();
        }
        flowParseDeclareModuleExports(node) {
          this.next();
          this.expectContextual(109);
          node.typeAnnotation = this.flowParseTypeAnnotation();
          this.semicolon();
          return this.finishNode(node, "DeclareModuleExports");
        }
        flowParseDeclareTypeAlias(node) {
          this.next();
          const finished = this.flowParseTypeAlias(node);
          finished.type = "DeclareTypeAlias";
          return finished;
        }
        flowParseDeclareOpaqueType(node) {
          this.next();
          const finished = this.flowParseOpaqueType(node, true);
          finished.type = "DeclareOpaqueType";
          return finished;
        }
        flowParseDeclareInterface(node) {
          this.next();
          this.flowParseInterfaceish(node, false);
          return this.finishNode(node, "DeclareInterface");
        }
        flowParseInterfaceish(node, isClass) {
          node.id = this.flowParseRestrictedIdentifier(!isClass, true);
          this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.loc.start);
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }
          node.extends = [];
          if (this.eat(81)) {
            do {
              node.extends.push(this.flowParseInterfaceExtends());
            } while (!isClass && this.eat(12));
          }
          if (isClass) {
            node.implements = [];
            node.mixins = [];
            if (this.eatContextual(115)) {
              do {
                node.mixins.push(this.flowParseInterfaceExtends());
              } while (this.eat(12));
            }
            if (this.eatContextual(111)) {
              do {
                node.implements.push(this.flowParseInterfaceExtends());
              } while (this.eat(12));
            }
          }
          node.body = this.flowParseObjectType({
            allowStatic: isClass,
            allowExact: false,
            allowSpread: false,
            allowProto: isClass,
            allowInexact: false
          });
        }
        flowParseInterfaceExtends() {
          const node = this.startNode();
          node.id = this.flowParseQualifiedTypeIdentifier();
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterInstantiation();
          } else {
            node.typeParameters = null;
          }
          return this.finishNode(node, "InterfaceExtends");
        }
        flowParseInterface(node) {
          this.flowParseInterfaceish(node, false);
          return this.finishNode(node, "InterfaceDeclaration");
        }
        checkNotUnderscore(word) {
          if (word === "_") {
            this.raise(FlowErrors.UnexpectedReservedUnderscore, {
              at: this.state.startLoc
            });
          }
        }
        checkReservedType(word, startLoc, declaration) {
          if (!reservedTypes.has(word))
            return;
          this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, {
            at: startLoc,
            reservedType: word
          });
        }
        flowParseRestrictedIdentifier(liberal, declaration) {
          this.checkReservedType(this.state.value, this.state.startLoc, declaration);
          return this.parseIdentifier(liberal);
        }
        flowParseTypeAlias(node) {
          node.id = this.flowParseRestrictedIdentifier(false, true);
          this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }
          node.right = this.flowParseTypeInitialiser(29);
          this.semicolon();
          return this.finishNode(node, "TypeAlias");
        }
        flowParseOpaqueType(node, declare) {
          this.expectContextual(128);
          node.id = this.flowParseRestrictedIdentifier(true, true);
          this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }
          node.supertype = null;
          if (this.match(14)) {
            node.supertype = this.flowParseTypeInitialiser(14);
          }
          node.impltype = null;
          if (!declare) {
            node.impltype = this.flowParseTypeInitialiser(29);
          }
          this.semicolon();
          return this.finishNode(node, "OpaqueType");
        }
        flowParseTypeParameter(requireDefault = false) {
          const nodeStartLoc = this.state.startLoc;
          const node = this.startNode();
          const variance = this.flowParseVariance();
          const ident = this.flowParseTypeAnnotatableIdentifier();
          node.name = ident.name;
          node.variance = variance;
          node.bound = ident.typeAnnotation;
          if (this.match(29)) {
            this.eat(29);
            node.default = this.flowParseType();
          } else {
            if (requireDefault) {
              this.raise(FlowErrors.MissingTypeParamDefault, {
                at: nodeStartLoc
              });
            }
          }
          return this.finishNode(node, "TypeParameter");
        }
        flowParseTypeParameterDeclaration() {
          const oldInType = this.state.inType;
          const node = this.startNode();
          node.params = [];
          this.state.inType = true;
          if (this.match(47) || this.match(140)) {
            this.next();
          } else {
            this.unexpected();
          }
          let defaultRequired = false;
          do {
            const typeParameter = this.flowParseTypeParameter(defaultRequired);
            node.params.push(typeParameter);
            if (typeParameter.default) {
              defaultRequired = true;
            }
            if (!this.match(48)) {
              this.expect(12);
            }
          } while (!this.match(48));
          this.expect(48);
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterDeclaration");
        }
        flowParseTypeParameterInstantiation() {
          const node = this.startNode();
          const oldInType = this.state.inType;
          node.params = [];
          this.state.inType = true;
          this.expect(47);
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = false;
          while (!this.match(48)) {
            node.params.push(this.flowParseType());
            if (!this.match(48)) {
              this.expect(12);
            }
          }
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
          this.expect(48);
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterInstantiation");
        }
        flowParseTypeParameterInstantiationCallOrNew() {
          const node = this.startNode();
          const oldInType = this.state.inType;
          node.params = [];
          this.state.inType = true;
          this.expect(47);
          while (!this.match(48)) {
            node.params.push(this.flowParseTypeOrImplicitInstantiation());
            if (!this.match(48)) {
              this.expect(12);
            }
          }
          this.expect(48);
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterInstantiation");
        }
        flowParseInterfaceType() {
          const node = this.startNode();
          this.expectContextual(127);
          node.extends = [];
          if (this.eat(81)) {
            do {
              node.extends.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          node.body = this.flowParseObjectType({
            allowStatic: false,
            allowExact: false,
            allowSpread: false,
            allowProto: false,
            allowInexact: false
          });
          return this.finishNode(node, "InterfaceTypeAnnotation");
        }
        flowParseObjectPropertyKey() {
          return this.match(132) || this.match(131) ? super.parseExprAtom() : this.parseIdentifier(true);
        }
        flowParseObjectTypeIndexer(node, isStatic, variance) {
          node.static = isStatic;
          if (this.lookahead().type === 14) {
            node.id = this.flowParseObjectPropertyKey();
            node.key = this.flowParseTypeInitialiser();
          } else {
            node.id = null;
            node.key = this.flowParseType();
          }
          this.expect(3);
          node.value = this.flowParseTypeInitialiser();
          node.variance = variance;
          return this.finishNode(node, "ObjectTypeIndexer");
        }
        flowParseObjectTypeInternalSlot(node, isStatic) {
          node.static = isStatic;
          node.id = this.flowParseObjectPropertyKey();
          this.expect(3);
          this.expect(3);
          if (this.match(47) || this.match(10)) {
            node.method = true;
            node.optional = false;
            node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
          } else {
            node.method = false;
            if (this.eat(17)) {
              node.optional = true;
            }
            node.value = this.flowParseTypeInitialiser();
          }
          return this.finishNode(node, "ObjectTypeInternalSlot");
        }
        flowParseObjectTypeMethodish(node) {
          node.params = [];
          node.rest = null;
          node.typeParameters = null;
          node.this = null;
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }
          this.expect(10);
          if (this.match(78)) {
            node.this = this.flowParseFunctionTypeParam(true);
            node.this.name = null;
            if (!this.match(11)) {
              this.expect(12);
            }
          }
          while (!this.match(11) && !this.match(21)) {
            node.params.push(this.flowParseFunctionTypeParam(false));
            if (!this.match(11)) {
              this.expect(12);
            }
          }
          if (this.eat(21)) {
            node.rest = this.flowParseFunctionTypeParam(false);
          }
          this.expect(11);
          node.returnType = this.flowParseTypeInitialiser();
          return this.finishNode(node, "FunctionTypeAnnotation");
        }
        flowParseObjectTypeCallProperty(node, isStatic) {
          const valueNode = this.startNode();
          node.static = isStatic;
          node.value = this.flowParseObjectTypeMethodish(valueNode);
          return this.finishNode(node, "ObjectTypeCallProperty");
        }
        flowParseObjectType({
          allowStatic,
          allowExact,
          allowSpread,
          allowProto,
          allowInexact
        }) {
          const oldInType = this.state.inType;
          this.state.inType = true;
          const nodeStart = this.startNode();
          nodeStart.callProperties = [];
          nodeStart.properties = [];
          nodeStart.indexers = [];
          nodeStart.internalSlots = [];
          let endDelim;
          let exact;
          let inexact = false;
          if (allowExact && this.match(6)) {
            this.expect(6);
            endDelim = 9;
            exact = true;
          } else {
            this.expect(5);
            endDelim = 8;
            exact = false;
          }
          nodeStart.exact = exact;
          while (!this.match(endDelim)) {
            let isStatic = false;
            let protoStartLoc = null;
            let inexactStartLoc = null;
            const node = this.startNode();
            if (allowProto && this.isContextual(116)) {
              const lookahead = this.lookahead();
              if (lookahead.type !== 14 && lookahead.type !== 17) {
                this.next();
                protoStartLoc = this.state.startLoc;
                allowStatic = false;
              }
            }
            if (allowStatic && this.isContextual(104)) {
              const lookahead = this.lookahead();
              if (lookahead.type !== 14 && lookahead.type !== 17) {
                this.next();
                isStatic = true;
              }
            }
            const variance = this.flowParseVariance();
            if (this.eat(0)) {
              if (protoStartLoc != null) {
                this.unexpected(protoStartLoc);
              }
              if (this.eat(0)) {
                if (variance) {
                  this.unexpected(variance.loc.start);
                }
                nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
              } else {
                nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
              }
            } else if (this.match(10) || this.match(47)) {
              if (protoStartLoc != null) {
                this.unexpected(protoStartLoc);
              }
              if (variance) {
                this.unexpected(variance.loc.start);
              }
              nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
            } else {
              let kind = "init";
              if (this.isContextual(98) || this.isContextual(103)) {
                const lookahead = this.lookahead();
                if (tokenIsLiteralPropertyName(lookahead.type)) {
                  kind = this.state.value;
                  this.next();
                }
              }
              const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
              if (propOrInexact === null) {
                inexact = true;
                inexactStartLoc = this.state.lastTokStartLoc;
              } else {
                nodeStart.properties.push(propOrInexact);
              }
            }
            this.flowObjectTypeSemicolon();
            if (inexactStartLoc && !this.match(8) && !this.match(9)) {
              this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {
                at: inexactStartLoc
              });
            }
          }
          this.expect(endDelim);
          if (allowSpread) {
            nodeStart.inexact = inexact;
          }
          const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
          this.state.inType = oldInType;
          return out;
        }
        flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
          if (this.eat(21)) {
            const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
            if (isInexactToken) {
              if (!allowSpread) {
                this.raise(FlowErrors.InexactInsideNonObject, {
                  at: this.state.lastTokStartLoc
                });
              } else if (!allowInexact) {
                this.raise(FlowErrors.InexactInsideExact, {
                  at: this.state.lastTokStartLoc
                });
              }
              if (variance) {
                this.raise(FlowErrors.InexactVariance, {
                  at: variance
                });
              }
              return null;
            }
            if (!allowSpread) {
              this.raise(FlowErrors.UnexpectedSpreadType, {
                at: this.state.lastTokStartLoc
              });
            }
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.raise(FlowErrors.SpreadVariance, {
                at: variance
              });
            }
            node.argument = this.flowParseType();
            return this.finishNode(node, "ObjectTypeSpreadProperty");
          } else {
            node.key = this.flowParseObjectPropertyKey();
            node.static = isStatic;
            node.proto = protoStartLoc != null;
            node.kind = kind;
            let optional = false;
            if (this.match(47) || this.match(10)) {
              node.method = true;
              if (protoStartLoc != null) {
                this.unexpected(protoStartLoc);
              }
              if (variance) {
                this.unexpected(variance.loc.start);
              }
              node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
              if (kind === "get" || kind === "set") {
                this.flowCheckGetterSetterParams(node);
              }
              if (!allowSpread && node.key.name === "constructor" && node.value.this) {
                this.raise(FlowErrors.ThisParamBannedInConstructor, {
                  at: node.value.this
                });
              }
            } else {
              if (kind !== "init")
                this.unexpected();
              node.method = false;
              if (this.eat(17)) {
                optional = true;
              }
              node.value = this.flowParseTypeInitialiser();
              node.variance = variance;
            }
            node.optional = optional;
            return this.finishNode(node, "ObjectTypeProperty");
          }
        }
        flowCheckGetterSetterParams(property) {
          const paramCount = property.kind === "get" ? 0 : 1;
          const length = property.value.params.length + (property.value.rest ? 1 : 0);
          if (property.value.this) {
            this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, {
              at: property.value.this
            });
          }
          if (length !== paramCount) {
            this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
              at: property
            });
          }
          if (property.kind === "set" && property.value.rest) {
            this.raise(Errors.BadSetterRestParameter, {
              at: property
            });
          }
        }
        flowObjectTypeSemicolon() {
          if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
            this.unexpected();
          }
        }
        flowParseQualifiedTypeIdentifier(startLoc, id) {
          var _startLoc;
          (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;
          let node = id || this.flowParseRestrictedIdentifier(true);
          while (this.eat(16)) {
            const node2 = this.startNodeAt(startLoc);
            node2.qualification = node;
            node2.id = this.flowParseRestrictedIdentifier(true);
            node = this.finishNode(node2, "QualifiedTypeIdentifier");
          }
          return node;
        }
        flowParseGenericType(startLoc, id) {
          const node = this.startNodeAt(startLoc);
          node.typeParameters = null;
          node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterInstantiation();
          }
          return this.finishNode(node, "GenericTypeAnnotation");
        }
        flowParseTypeofType() {
          const node = this.startNode();
          this.expect(87);
          node.argument = this.flowParsePrimaryType();
          return this.finishNode(node, "TypeofTypeAnnotation");
        }
        flowParseTupleType() {
          const node = this.startNode();
          node.types = [];
          this.expect(0);
          while (this.state.pos < this.length && !this.match(3)) {
            node.types.push(this.flowParseType());
            if (this.match(3))
              break;
            this.expect(12);
          }
          this.expect(3);
          return this.finishNode(node, "TupleTypeAnnotation");
        }
        flowParseFunctionTypeParam(first) {
          let name = null;
          let optional = false;
          let typeAnnotation = null;
          const node = this.startNode();
          const lh = this.lookahead();
          const isThis = this.state.type === 78;
          if (lh.type === 14 || lh.type === 17) {
            if (isThis && !first) {
              this.raise(FlowErrors.ThisParamMustBeFirst, {
                at: node
              });
            }
            name = this.parseIdentifier(isThis);
            if (this.eat(17)) {
              optional = true;
              if (isThis) {
                this.raise(FlowErrors.ThisParamMayNotBeOptional, {
                  at: node
                });
              }
            }
            typeAnnotation = this.flowParseTypeInitialiser();
          } else {
            typeAnnotation = this.flowParseType();
          }
          node.name = name;
          node.optional = optional;
          node.typeAnnotation = typeAnnotation;
          return this.finishNode(node, "FunctionTypeParam");
        }
        reinterpretTypeAsFunctionTypeParam(type) {
          const node = this.startNodeAt(type.loc.start);
          node.name = null;
          node.optional = false;
          node.typeAnnotation = type;
          return this.finishNode(node, "FunctionTypeParam");
        }
        flowParseFunctionTypeParams(params = []) {
          let rest = null;
          let _this = null;
          if (this.match(78)) {
            _this = this.flowParseFunctionTypeParam(true);
            _this.name = null;
            if (!this.match(11)) {
              this.expect(12);
            }
          }
          while (!this.match(11) && !this.match(21)) {
            params.push(this.flowParseFunctionTypeParam(false));
            if (!this.match(11)) {
              this.expect(12);
            }
          }
          if (this.eat(21)) {
            rest = this.flowParseFunctionTypeParam(false);
          }
          return {
            params,
            rest,
            _this
          };
        }
        flowIdentToTypeAnnotation(startLoc, node, id) {
          switch (id.name) {
            case "any":
              return this.finishNode(node, "AnyTypeAnnotation");
            case "bool":
            case "boolean":
              return this.finishNode(node, "BooleanTypeAnnotation");
            case "mixed":
              return this.finishNode(node, "MixedTypeAnnotation");
            case "empty":
              return this.finishNode(node, "EmptyTypeAnnotation");
            case "number":
              return this.finishNode(node, "NumberTypeAnnotation");
            case "string":
              return this.finishNode(node, "StringTypeAnnotation");
            case "symbol":
              return this.finishNode(node, "SymbolTypeAnnotation");
            default:
              this.checkNotUnderscore(id.name);
              return this.flowParseGenericType(startLoc, id);
          }
        }
        flowParsePrimaryType() {
          const startLoc = this.state.startLoc;
          const node = this.startNode();
          let tmp;
          let type;
          let isGroupedType = false;
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          switch (this.state.type) {
            case 5:
              return this.flowParseObjectType({
                allowStatic: false,
                allowExact: false,
                allowSpread: true,
                allowProto: false,
                allowInexact: true
              });
            case 6:
              return this.flowParseObjectType({
                allowStatic: false,
                allowExact: true,
                allowSpread: true,
                allowProto: false,
                allowInexact: false
              });
            case 0:
              this.state.noAnonFunctionType = false;
              type = this.flowParseTupleType();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              return type;
            case 47:
              node.typeParameters = this.flowParseTypeParameterDeclaration();
              this.expect(10);
              tmp = this.flowParseFunctionTypeParams();
              node.params = tmp.params;
              node.rest = tmp.rest;
              node.this = tmp._this;
              this.expect(11);
              this.expect(19);
              node.returnType = this.flowParseType();
              return this.finishNode(node, "FunctionTypeAnnotation");
            case 10:
              this.next();
              if (!this.match(11) && !this.match(21)) {
                if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                  const token = this.lookahead().type;
                  isGroupedType = token !== 17 && token !== 14;
                } else {
                  isGroupedType = true;
                }
              }
              if (isGroupedType) {
                this.state.noAnonFunctionType = false;
                type = this.flowParseType();
                this.state.noAnonFunctionType = oldNoAnonFunctionType;
                if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
                  this.expect(11);
                  return type;
                } else {
                  this.eat(12);
                }
              }
              if (type) {
                tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
              } else {
                tmp = this.flowParseFunctionTypeParams();
              }
              node.params = tmp.params;
              node.rest = tmp.rest;
              node.this = tmp._this;
              this.expect(11);
              this.expect(19);
              node.returnType = this.flowParseType();
              node.typeParameters = null;
              return this.finishNode(node, "FunctionTypeAnnotation");
            case 131:
              return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
            case 85:
            case 86:
              node.value = this.match(85);
              this.next();
              return this.finishNode(node, "BooleanLiteralTypeAnnotation");
            case 53:
              if (this.state.value === "-") {
                this.next();
                if (this.match(132)) {
                  return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
                }
                if (this.match(133)) {
                  return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
                }
                throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {
                  at: this.state.startLoc
                });
              }
              this.unexpected();
              return;
            case 132:
              return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
            case 133:
              return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
            case 88:
              this.next();
              return this.finishNode(node, "VoidTypeAnnotation");
            case 84:
              this.next();
              return this.finishNode(node, "NullLiteralTypeAnnotation");
            case 78:
              this.next();
              return this.finishNode(node, "ThisTypeAnnotation");
            case 55:
              this.next();
              return this.finishNode(node, "ExistsTypeAnnotation");
            case 87:
              return this.flowParseTypeofType();
            default:
              if (tokenIsKeyword(this.state.type)) {
                const label = tokenLabelName(this.state.type);
                this.next();
                return super.createIdentifier(node, label);
              } else if (tokenIsIdentifier(this.state.type)) {
                if (this.isContextual(127)) {
                  return this.flowParseInterfaceType();
                }
                return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());
              }
          }
          this.unexpected();
        }
        flowParsePostfixType() {
          const startLoc = this.state.startLoc;
          let type = this.flowParsePrimaryType();
          let seenOptionalIndexedAccess = false;
          while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
            const node = this.startNodeAt(startLoc);
            const optional = this.eat(18);
            seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
            this.expect(0);
            if (!optional && this.match(3)) {
              node.elementType = type;
              this.next();
              type = this.finishNode(node, "ArrayTypeAnnotation");
            } else {
              node.objectType = type;
              node.indexType = this.flowParseType();
              this.expect(3);
              if (seenOptionalIndexedAccess) {
                node.optional = optional;
                type = this.finishNode(node, "OptionalIndexedAccessType");
              } else {
                type = this.finishNode(node, "IndexedAccessType");
              }
            }
          }
          return type;
        }
        flowParsePrefixType() {
          const node = this.startNode();
          if (this.eat(17)) {
            node.typeAnnotation = this.flowParsePrefixType();
            return this.finishNode(node, "NullableTypeAnnotation");
          } else {
            return this.flowParsePostfixType();
          }
        }
        flowParseAnonFunctionWithoutParens() {
          const param = this.flowParsePrefixType();
          if (!this.state.noAnonFunctionType && this.eat(19)) {
            const node = this.startNodeAt(param.loc.start);
            node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
            node.rest = null;
            node.this = null;
            node.returnType = this.flowParseType();
            node.typeParameters = null;
            return this.finishNode(node, "FunctionTypeAnnotation");
          }
          return param;
        }
        flowParseIntersectionType() {
          const node = this.startNode();
          this.eat(45);
          const type = this.flowParseAnonFunctionWithoutParens();
          node.types = [type];
          while (this.eat(45)) {
            node.types.push(this.flowParseAnonFunctionWithoutParens());
          }
          return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
        }
        flowParseUnionType() {
          const node = this.startNode();
          this.eat(43);
          const type = this.flowParseIntersectionType();
          node.types = [type];
          while (this.eat(43)) {
            node.types.push(this.flowParseIntersectionType());
          }
          return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
        }
        flowParseType() {
          const oldInType = this.state.inType;
          this.state.inType = true;
          const type = this.flowParseUnionType();
          this.state.inType = oldInType;
          return type;
        }
        flowParseTypeOrImplicitInstantiation() {
          if (this.state.type === 130 && this.state.value === "_") {
            const startLoc = this.state.startLoc;
            const node = this.parseIdentifier();
            return this.flowParseGenericType(startLoc, node);
          } else {
            return this.flowParseType();
          }
        }
        flowParseTypeAnnotation() {
          const node = this.startNode();
          node.typeAnnotation = this.flowParseTypeInitialiser();
          return this.finishNode(node, "TypeAnnotation");
        }
        flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
          const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
          if (this.match(14)) {
            ident.typeAnnotation = this.flowParseTypeAnnotation();
            this.resetEndLocation(ident);
          }
          return ident;
        }
        typeCastToParameter(node) {
          node.expression.typeAnnotation = node.typeAnnotation;
          this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
          return node.expression;
        }
        flowParseVariance() {
          let variance = null;
          if (this.match(53)) {
            variance = this.startNode();
            if (this.state.value === "+") {
              variance.kind = "plus";
            } else {
              variance.kind = "minus";
            }
            this.next();
            return this.finishNode(variance, "Variance");
          }
          return variance;
        }
        parseFunctionBody(node, allowExpressionBody, isMethod = false) {
          if (allowExpressionBody) {
            this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));
            return;
          }
          super.parseFunctionBody(node, false, isMethod);
        }
        parseFunctionBodyAndFinish(node, type, isMethod = false) {
          if (this.match(14)) {
            const typeNode = this.startNode();
            [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
            node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
          }
          return super.parseFunctionBodyAndFinish(node, type, isMethod);
        }
        parseStatementLike(flags) {
          if (this.state.strict && this.isContextual(127)) {
            const lookahead = this.lookahead();
            if (tokenIsKeywordOrIdentifier(lookahead.type)) {
              const node = this.startNode();
              this.next();
              return this.flowParseInterface(node);
            }
          } else if (this.shouldParseEnums() && this.isContextual(124)) {
            const node = this.startNode();
            this.next();
            return this.flowParseEnumDeclaration(node);
          }
          const stmt = super.parseStatementLike(flags);
          if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
            this.flowPragma = null;
          }
          return stmt;
        }
        parseExpressionStatement(node, expr, decorators) {
          if (expr.type === "Identifier") {
            if (expr.name === "declare") {
              if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
                return this.flowParseDeclare(node);
              }
            } else if (tokenIsIdentifier(this.state.type)) {
              if (expr.name === "interface") {
                return this.flowParseInterface(node);
              } else if (expr.name === "type") {
                return this.flowParseTypeAlias(node);
              } else if (expr.name === "opaque") {
                return this.flowParseOpaqueType(node, false);
              }
            }
          }
          return super.parseExpressionStatement(node, expr, decorators);
        }
        shouldParseExportDeclaration() {
          const {
            type
          } = this.state;
          if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 124) {
            return !this.state.containsEsc;
          }
          return super.shouldParseExportDeclaration();
        }
        isExportDefaultSpecifier() {
          const {
            type
          } = this.state;
          if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 124) {
            return this.state.containsEsc;
          }
          return super.isExportDefaultSpecifier();
        }
        parseExportDefaultExpression() {
          if (this.shouldParseEnums() && this.isContextual(124)) {
            const node = this.startNode();
            this.next();
            return this.flowParseEnumDeclaration(node);
          }
          return super.parseExportDefaultExpression();
        }
        parseConditional(expr, startLoc, refExpressionErrors) {
          if (!this.match(17))
            return expr;
          if (this.state.maybeInArrowParameters) {
            const nextCh = this.lookaheadCharCode();
            if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
              this.setOptionalParametersError(refExpressionErrors);
              return expr;
            }
          }
          this.expect(17);
          const state = this.state.clone();
          const originalNoArrowAt = this.state.noArrowAt;
          const node = this.startNodeAt(startLoc);
          let {
            consequent,
            failed
          } = this.tryParseConditionalConsequent();
          let [valid, invalid] = this.getArrowLikeExpressions(consequent);
          if (failed || invalid.length > 0) {
            const noArrowAt = [...originalNoArrowAt];
            if (invalid.length > 0) {
              this.state = state;
              this.state.noArrowAt = noArrowAt;
              for (let i = 0; i < invalid.length; i++) {
                noArrowAt.push(invalid[i].start);
              }
              ({
                consequent,
                failed
              } = this.tryParseConditionalConsequent());
              [valid, invalid] = this.getArrowLikeExpressions(consequent);
            }
            if (failed && valid.length > 1) {
              this.raise(FlowErrors.AmbiguousConditionalArrow, {
                at: state.startLoc
              });
            }
            if (failed && valid.length === 1) {
              this.state = state;
              noArrowAt.push(valid[0].start);
              this.state.noArrowAt = noArrowAt;
              ({
                consequent,
                failed
              } = this.tryParseConditionalConsequent());
            }
          }
          this.getArrowLikeExpressions(consequent, true);
          this.state.noArrowAt = originalNoArrowAt;
          this.expect(14);
          node.test = expr;
          node.consequent = consequent;
          node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(void 0, void 0));
          return this.finishNode(node, "ConditionalExpression");
        }
        tryParseConditionalConsequent() {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          const consequent = this.parseMaybeAssignAllowIn();
          const failed = !this.match(14);
          this.state.noArrowParamsConversionAt.pop();
          return {
            consequent,
            failed
          };
        }
        getArrowLikeExpressions(node, disallowInvalid) {
          const stack = [node];
          const arrows = [];
          while (stack.length !== 0) {
            const node2 = stack.pop();
            if (node2.type === "ArrowFunctionExpression") {
              if (node2.typeParameters || !node2.returnType) {
                this.finishArrowValidation(node2);
              } else {
                arrows.push(node2);
              }
              stack.push(node2.body);
            } else if (node2.type === "ConditionalExpression") {
              stack.push(node2.consequent);
              stack.push(node2.alternate);
            }
          }
          if (disallowInvalid) {
            arrows.forEach((node2) => this.finishArrowValidation(node2));
            return [arrows, []];
          }
          return partition(arrows, (node2) => node2.params.every((param) => this.isAssignable(param, true)));
        }
        finishArrowValidation(node) {
          var _node$extra;
          this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);
          this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
          super.checkParams(node, false, true);
          this.scope.exit();
        }
        forwardNoArrowParamsConversionAt(node, parse2) {
          let result;
          if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            result = parse2();
            this.state.noArrowParamsConversionAt.pop();
          } else {
            result = parse2();
          }
          return result;
        }
        parseParenItem(node, startLoc) {
          node = super.parseParenItem(node, startLoc);
          if (this.eat(17)) {
            node.optional = true;
            this.resetEndLocation(node);
          }
          if (this.match(14)) {
            const typeCastNode = this.startNodeAt(startLoc);
            typeCastNode.expression = node;
            typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
            return this.finishNode(typeCastNode, "TypeCastExpression");
          }
          return node;
        }
        assertModuleNodeAllowed(node) {
          if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
            return;
          }
          super.assertModuleNodeAllowed(node);
        }
        parseExportDeclaration(node) {
          if (this.isContextual(128)) {
            node.exportKind = "type";
            const declarationNode = this.startNode();
            this.next();
            if (this.match(5)) {
              node.specifiers = this.parseExportSpecifiers(true);
              super.parseExportFrom(node);
              return null;
            } else {
              return this.flowParseTypeAlias(declarationNode);
            }
          } else if (this.isContextual(129)) {
            node.exportKind = "type";
            const declarationNode = this.startNode();
            this.next();
            return this.flowParseOpaqueType(declarationNode, false);
          } else if (this.isContextual(127)) {
            node.exportKind = "type";
            const declarationNode = this.startNode();
            this.next();
            return this.flowParseInterface(declarationNode);
          } else if (this.shouldParseEnums() && this.isContextual(124)) {
            node.exportKind = "value";
            const declarationNode = this.startNode();
            this.next();
            return this.flowParseEnumDeclaration(declarationNode);
          } else {
            return super.parseExportDeclaration(node);
          }
        }
        eatExportStar(node) {
          if (super.eatExportStar(node))
            return true;
          if (this.isContextual(128) && this.lookahead().type === 55) {
            node.exportKind = "type";
            this.next();
            this.next();
            return true;
          }
          return false;
        }
        maybeParseExportNamespaceSpecifier(node) {
          const {
            startLoc
          } = this.state;
          const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
          if (hasNamespace && node.exportKind === "type") {
            this.unexpected(startLoc);
          }
          return hasNamespace;
        }
        parseClassId(node, isStatement, optionalId) {
          super.parseClassId(node, isStatement, optionalId);
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }
        }
        parseClassMember(classBody, member, state) {
          const {
            startLoc
          } = this.state;
          if (this.isContextual(123)) {
            if (super.parseClassMemberFromModifier(classBody, member)) {
              return;
            }
            member.declare = true;
          }
          super.parseClassMember(classBody, member, state);
          if (member.declare) {
            if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
              this.raise(FlowErrors.DeclareClassElement, {
                at: startLoc
              });
            } else if (member.value) {
              this.raise(FlowErrors.DeclareClassFieldInitializer, {
                at: member.value
              });
            }
          }
        }
        isIterator(word) {
          return word === "iterator" || word === "asyncIterator";
        }
        readIterator() {
          const word = super.readWord1();
          const fullWord = "@@" + word;
          if (!this.isIterator(word) || !this.state.inType) {
            this.raise(Errors.InvalidIdentifier, {
              at: this.state.curPosition(),
              identifierName: fullWord
            });
          }
          this.finishToken(130, fullWord);
        }
        getTokenFromCode(code) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (code === 123 && next === 124) {
            this.finishOp(6, 2);
          } else if (this.state.inType && (code === 62 || code === 60)) {
            this.finishOp(code === 62 ? 48 : 47, 1);
          } else if (this.state.inType && code === 63) {
            if (next === 46) {
              this.finishOp(18, 2);
            } else {
              this.finishOp(17, 1);
            }
          } else if (isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))) {
            this.state.pos += 2;
            this.readIterator();
          } else {
            super.getTokenFromCode(code);
          }
        }
        isAssignable(node, isBinding) {
          if (node.type === "TypeCastExpression") {
            return this.isAssignable(node.expression, isBinding);
          } else {
            return super.isAssignable(node, isBinding);
          }
        }
        toAssignable(node, isLHS = false) {
          if (!isLHS && node.type === "AssignmentExpression" && node.left.type === "TypeCastExpression") {
            node.left = this.typeCastToParameter(node.left);
          }
          super.toAssignable(node, isLHS);
        }
        toAssignableList(exprList, trailingCommaLoc, isLHS) {
          for (let i = 0; i < exprList.length; i++) {
            const expr = exprList[i];
            if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
              exprList[i] = this.typeCastToParameter(expr);
            }
          }
          super.toAssignableList(exprList, trailingCommaLoc, isLHS);
        }
        toReferencedList(exprList, isParenthesizedExpr) {
          for (let i = 0; i < exprList.length; i++) {
            var _expr$extra;
            const expr = exprList[i];
            if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
              this.raise(FlowErrors.TypeCastInPattern, {
                at: expr.typeAnnotation
              });
            }
          }
          return exprList;
        }
        parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
          const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
          if (canBePattern && !this.state.maybeInArrowParameters) {
            this.toReferencedList(node.elements);
          }
          return node;
        }
        isValidLVal(type, isParenthesized, binding) {
          return type === "TypeCastExpression" || super.isValidLVal(type, isParenthesized, binding);
        }
        parseClassProperty(node) {
          if (this.match(14)) {
            node.typeAnnotation = this.flowParseTypeAnnotation();
          }
          return super.parseClassProperty(node);
        }
        parseClassPrivateProperty(node) {
          if (this.match(14)) {
            node.typeAnnotation = this.flowParseTypeAnnotation();
          }
          return super.parseClassPrivateProperty(node);
        }
        isClassMethod() {
          return this.match(47) || super.isClassMethod();
        }
        isClassProperty() {
          return this.match(14) || super.isClassProperty();
        }
        isNonstaticConstructor(method) {
          return !this.match(14) && super.isNonstaticConstructor(method);
        }
        pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          if (method.variance) {
            this.unexpected(method.variance.loc.start);
          }
          delete method.variance;
          if (this.match(47)) {
            method.typeParameters = this.flowParseTypeParameterDeclaration();
          }
          super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
          if (method.params && isConstructor) {
            const params = method.params;
            if (params.length > 0 && this.isThisParam(params[0])) {
              this.raise(FlowErrors.ThisParamBannedInConstructor, {
                at: method
              });
            }
          } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
            const params = method.value.params;
            if (params.length > 0 && this.isThisParam(params[0])) {
              this.raise(FlowErrors.ThisParamBannedInConstructor, {
                at: method
              });
            }
          }
        }
        pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
          if (method.variance) {
            this.unexpected(method.variance.loc.start);
          }
          delete method.variance;
          if (this.match(47)) {
            method.typeParameters = this.flowParseTypeParameterDeclaration();
          }
          super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
        }
        parseClassSuper(node) {
          super.parseClassSuper(node);
          if (node.superClass && this.match(47)) {
            node.superTypeParameters = this.flowParseTypeParameterInstantiation();
          }
          if (this.isContextual(111)) {
            this.next();
            const implemented = node.implements = [];
            do {
              const node2 = this.startNode();
              node2.id = this.flowParseRestrictedIdentifier(true);
              if (this.match(47)) {
                node2.typeParameters = this.flowParseTypeParameterInstantiation();
              } else {
                node2.typeParameters = null;
              }
              implemented.push(this.finishNode(node2, "ClassImplements"));
            } while (this.eat(12));
          }
        }
        checkGetterSetterParams(method) {
          super.checkGetterSetterParams(method);
          const params = this.getObjectOrClassMethodParams(method);
          if (params.length > 0) {
            const param = params[0];
            if (this.isThisParam(param) && method.kind === "get") {
              this.raise(FlowErrors.GetterMayNotHaveThisParam, {
                at: param
              });
            } else if (this.isThisParam(param)) {
              this.raise(FlowErrors.SetterMayNotHaveThisParam, {
                at: param
              });
            }
          }
        }
        parsePropertyNamePrefixOperator(node) {
          node.variance = this.flowParseVariance();
        }
        parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
          if (prop.variance) {
            this.unexpected(prop.variance.loc.start);
          }
          delete prop.variance;
          let typeParameters;
          if (this.match(47) && !isAccessor) {
            typeParameters = this.flowParseTypeParameterDeclaration();
            if (!this.match(10))
              this.unexpected();
          }
          const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
          if (typeParameters) {
            (result.value || result).typeParameters = typeParameters;
          }
          return result;
        }
        parseAssignableListItemTypes(param) {
          if (this.eat(17)) {
            if (param.type !== "Identifier") {
              this.raise(FlowErrors.PatternIsOptional, {
                at: param
              });
            }
            if (this.isThisParam(param)) {
              this.raise(FlowErrors.ThisParamMayNotBeOptional, {
                at: param
              });
            }
            param.optional = true;
          }
          if (this.match(14)) {
            param.typeAnnotation = this.flowParseTypeAnnotation();
          } else if (this.isThisParam(param)) {
            this.raise(FlowErrors.ThisParamAnnotationRequired, {
              at: param
            });
          }
          if (this.match(29) && this.isThisParam(param)) {
            this.raise(FlowErrors.ThisParamNoDefault, {
              at: param
            });
          }
          this.resetEndLocation(param);
          return param;
        }
        parseMaybeDefault(startLoc, left) {
          const node = super.parseMaybeDefault(startLoc, left);
          if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
            this.raise(FlowErrors.TypeBeforeInitializer, {
              at: node.typeAnnotation
            });
          }
          return node;
        }
        checkImportReflection(node) {
          super.checkImportReflection(node);
          if (node.module && node.importKind !== "value") {
            this.raise(FlowErrors.ImportReflectionHasImportType, {
              at: node.specifiers[0].loc.start
            });
          }
        }
        parseImportSpecifierLocal(node, specifier, type) {
          specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
          node.specifiers.push(this.finishImportSpecifier(specifier, type));
        }
        isPotentialImportPhase(isExport) {
          if (super.isPotentialImportPhase(isExport))
            return true;
          if (this.isContextual(128)) {
            if (!isExport)
              return true;
            const ch = this.lookaheadCharCode();
            return ch === 123 || ch === 42;
          }
          return !isExport && this.isContextual(87);
        }
        applyImportPhase(node, isExport, phase, loc) {
          super.applyImportPhase(node, isExport, phase, loc);
          if (isExport) {
            if (!phase && this.match(65)) {
              return;
            }
            node.exportKind = phase === "type" ? phase : "value";
          } else {
            if (phase === "type" && this.match(55))
              this.unexpected();
            node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
          }
        }
        parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
          const firstIdent = specifier.imported;
          let specifierTypeKind = null;
          if (firstIdent.type === "Identifier") {
            if (firstIdent.name === "type") {
              specifierTypeKind = "type";
            } else if (firstIdent.name === "typeof") {
              specifierTypeKind = "typeof";
            }
          }
          let isBinding = false;
          if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
            const as_ident = this.parseIdentifier(true);
            if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
              specifier.imported = as_ident;
              specifier.importKind = specifierTypeKind;
              specifier.local = cloneIdentifier(as_ident);
            } else {
              specifier.imported = firstIdent;
              specifier.importKind = null;
              specifier.local = this.parseIdentifier();
            }
          } else {
            if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
              specifier.imported = this.parseIdentifier(true);
              specifier.importKind = specifierTypeKind;
            } else {
              if (importedIsString) {
                throw this.raise(Errors.ImportBindingIsString, {
                  at: specifier,
                  importName: firstIdent.value
                });
              }
              specifier.imported = firstIdent;
              specifier.importKind = null;
            }
            if (this.eatContextual(93)) {
              specifier.local = this.parseIdentifier();
            } else {
              isBinding = true;
              specifier.local = cloneIdentifier(specifier.imported);
            }
          }
          const specifierIsTypeImport = hasTypeImportKind(specifier);
          if (isInTypeOnlyImport && specifierIsTypeImport) {
            this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {
              at: specifier
            });
          }
          if (isInTypeOnlyImport || specifierIsTypeImport) {
            this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
          }
          if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
            this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
          }
          return this.finishImportSpecifier(specifier, "ImportSpecifier");
        }
        parseBindingAtom() {
          switch (this.state.type) {
            case 78:
              return this.parseIdentifier(true);
            default:
              return super.parseBindingAtom();
          }
        }
        parseFunctionParams(node, isConstructor) {
          const kind = node.kind;
          if (kind !== "get" && kind !== "set" && this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }
          super.parseFunctionParams(node, isConstructor);
        }
        parseVarId(decl, kind) {
          super.parseVarId(decl, kind);
          if (this.match(14)) {
            decl.id.typeAnnotation = this.flowParseTypeAnnotation();
            this.resetEndLocation(decl.id);
          }
        }
        parseAsyncArrowFromCallExpression(node, call) {
          if (this.match(14)) {
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = true;
            node.returnType = this.flowParseTypeAnnotation();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
          }
          return super.parseAsyncArrowFromCallExpression(node, call);
        }
        shouldParseAsyncArrow() {
          return this.match(14) || super.shouldParseAsyncArrow();
        }
        parseMaybeAssign(refExpressionErrors, afterLeftParse) {
          var _jsx;
          let state = null;
          let jsx2;
          if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
            state = this.state.clone();
            jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
            if (!jsx2.error)
              return jsx2.node;
            const {
              context
            } = this.state;
            const currentContext = context[context.length - 1];
            if (currentContext === types.j_oTag || currentContext === types.j_expr) {
              context.pop();
            }
          }
          if ((_jsx = jsx2) != null && _jsx.error || this.match(47)) {
            var _jsx2, _jsx3;
            state = state || this.state.clone();
            let typeParameters;
            const arrow = this.tryParse((abort) => {
              var _arrowExpression$extr;
              typeParameters = this.flowParseTypeParameterDeclaration();
              const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
                const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
                this.resetStartLocationFromNode(result, typeParameters);
                return result;
              });
              if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized)
                abort();
              const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
              if (expr.type !== "ArrowFunctionExpression")
                abort();
              expr.typeParameters = typeParameters;
              this.resetStartLocationFromNode(expr, typeParameters);
              return arrowExpression2;
            }, state);
            let arrowExpression = null;
            if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
              if (!arrow.error && !arrow.aborted) {
                if (arrow.node.async) {
                  this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
                    at: typeParameters
                  });
                }
                return arrow.node;
              }
              arrowExpression = arrow.node;
            }
            if ((_jsx2 = jsx2) != null && _jsx2.node) {
              this.state = jsx2.failState;
              return jsx2.node;
            }
            if (arrowExpression) {
              this.state = arrow.failState;
              return arrowExpression;
            }
            if ((_jsx3 = jsx2) != null && _jsx3.thrown)
              throw jsx2.error;
            if (arrow.thrown)
              throw arrow.error;
            throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {
              at: typeParameters
            });
          }
          return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
        }
        parseArrow(node) {
          if (this.match(14)) {
            const result = this.tryParse(() => {
              const oldNoAnonFunctionType = this.state.noAnonFunctionType;
              this.state.noAnonFunctionType = true;
              const typeNode = this.startNode();
              [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              if (this.canInsertSemicolon())
                this.unexpected();
              if (!this.match(19))
                this.unexpected();
              return typeNode;
            });
            if (result.thrown)
              return null;
            if (result.error)
              this.state = result.failState;
            node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
          }
          return super.parseArrow(node);
        }
        shouldParseArrow(params) {
          return this.match(14) || super.shouldParseArrow(params);
        }
        setArrowFunctionParameters(node, params) {
          if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            node.params = params;
          } else {
            super.setArrowFunctionParameters(node, params);
          }
        }
        checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
          if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            return;
          }
          for (let i = 0; i < node.params.length; i++) {
            if (this.isThisParam(node.params[i]) && i > 0) {
              this.raise(FlowErrors.ThisParamMustBeFirst, {
                at: node.params[i]
              });
            }
          }
          super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);
        }
        parseParenAndDistinguishExpression(canBeArrow) {
          return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
        }
        parseSubscripts(base, startLoc, noCalls) {
          if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startLoc.index) !== -1) {
            this.next();
            const node = this.startNodeAt(startLoc);
            node.callee = base;
            node.arguments = super.parseCallExpressionArguments(11, false);
            base = this.finishNode(node, "CallExpression");
          } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
            const state = this.state.clone();
            const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);
            if (!arrow.error && !arrow.aborted)
              return arrow.node;
            const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);
            if (result.node && !result.error)
              return result.node;
            if (arrow.node) {
              this.state = arrow.failState;
              return arrow.node;
            }
            if (result.node) {
              this.state = result.failState;
              return result.node;
            }
            throw arrow.error || result.error;
          }
          return super.parseSubscripts(base, startLoc, noCalls);
        }
        parseSubscript(base, startLoc, noCalls, subscriptState) {
          if (this.match(18) && this.isLookaheadToken_lt()) {
            subscriptState.optionalChainMember = true;
            if (noCalls) {
              subscriptState.stop = true;
              return base;
            }
            this.next();
            const node = this.startNodeAt(startLoc);
            node.callee = base;
            node.typeArguments = this.flowParseTypeParameterInstantiation();
            this.expect(10);
            node.arguments = this.parseCallExpressionArguments(11, false);
            node.optional = true;
            return this.finishCallExpression(node, true);
          } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {
            const node = this.startNodeAt(startLoc);
            node.callee = base;
            const result = this.tryParse(() => {
              node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
              this.expect(10);
              node.arguments = super.parseCallExpressionArguments(11, false);
              if (subscriptState.optionalChainMember) {
                node.optional = false;
              }
              return this.finishCallExpression(node, subscriptState.optionalChainMember);
            });
            if (result.node) {
              if (result.error)
                this.state = result.failState;
              return result.node;
            }
          }
          return super.parseSubscript(base, startLoc, noCalls, subscriptState);
        }
        parseNewCallee(node) {
          super.parseNewCallee(node);
          let targs = null;
          if (this.shouldParseTypes() && this.match(47)) {
            targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
          }
          node.typeArguments = targs;
        }
        parseAsyncArrowWithTypeParameters(startLoc) {
          const node = this.startNodeAt(startLoc);
          this.parseFunctionParams(node, false);
          if (!this.parseArrow(node))
            return;
          return super.parseArrowExpression(node, void 0, true);
        }
        readToken_mult_modulo(code) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (code === 42 && next === 47 && this.state.hasFlowComment) {
            this.state.hasFlowComment = false;
            this.state.pos += 2;
            this.nextToken();
            return;
          }
          super.readToken_mult_modulo(code);
        }
        readToken_pipe_amp(code) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (code === 124 && next === 125) {
            this.finishOp(9, 2);
            return;
          }
          super.readToken_pipe_amp(code);
        }
        parseTopLevel(file, program) {
          const fileNode = super.parseTopLevel(file, program);
          if (this.state.hasFlowComment) {
            this.raise(FlowErrors.UnterminatedFlowComment, {
              at: this.state.curPosition()
            });
          }
          return fileNode;
        }
        skipBlockComment() {
          if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
            if (this.state.hasFlowComment) {
              throw this.raise(FlowErrors.NestedFlowComment, {
                at: this.state.startLoc
              });
            }
            this.hasFlowCommentCompletion();
            const commentSkip = this.skipFlowComment();
            if (commentSkip) {
              this.state.pos += commentSkip;
              this.state.hasFlowComment = true;
            }
            return;
          }
          return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
        }
        skipFlowComment() {
          const {
            pos
          } = this.state;
          let shiftToFirstNonWhiteSpace = 2;
          while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
            shiftToFirstNonWhiteSpace++;
          }
          const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
          const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
          if (ch2 === 58 && ch3 === 58) {
            return shiftToFirstNonWhiteSpace + 2;
          }
          if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
            return shiftToFirstNonWhiteSpace + 12;
          }
          if (ch2 === 58 && ch3 !== 58) {
            return shiftToFirstNonWhiteSpace;
          }
          return false;
        }
        hasFlowCommentCompletion() {
          const end = this.input.indexOf("*/", this.state.pos);
          if (end === -1) {
            throw this.raise(Errors.UnterminatedComment, {
              at: this.state.curPosition()
            });
          }
        }
        flowEnumErrorBooleanMemberNotInitialized(loc, {
          enumName,
          memberName
        }) {
          this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {
            at: loc,
            memberName,
            enumName
          });
        }
        flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
          return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, Object.assign({
            at: loc
          }, enumContext));
        }
        flowEnumErrorNumberMemberNotInitialized(loc, {
          enumName,
          memberName
        }) {
          this.raise(FlowErrors.EnumNumberMemberNotInitialized, {
            at: loc,
            enumName,
            memberName
          });
        }
        flowEnumErrorStringMemberInconsistentlyInitailized(node, {
          enumName
        }) {
          this.raise(FlowErrors.EnumStringMemberInconsistentlyInitailized, {
            at: node,
            enumName
          });
        }
        flowEnumMemberInit() {
          const startLoc = this.state.startLoc;
          const endOfInit = () => this.match(12) || this.match(8);
          switch (this.state.type) {
            case 132: {
              const literal = this.parseNumericLiteral(this.state.value);
              if (endOfInit()) {
                return {
                  type: "number",
                  loc: literal.loc.start,
                  value: literal
                };
              }
              return {
                type: "invalid",
                loc: startLoc
              };
            }
            case 131: {
              const literal = this.parseStringLiteral(this.state.value);
              if (endOfInit()) {
                return {
                  type: "string",
                  loc: literal.loc.start,
                  value: literal
                };
              }
              return {
                type: "invalid",
                loc: startLoc
              };
            }
            case 85:
            case 86: {
              const literal = this.parseBooleanLiteral(this.match(85));
              if (endOfInit()) {
                return {
                  type: "boolean",
                  loc: literal.loc.start,
                  value: literal
                };
              }
              return {
                type: "invalid",
                loc: startLoc
              };
            }
            default:
              return {
                type: "invalid",
                loc: startLoc
              };
          }
        }
        flowEnumMemberRaw() {
          const loc = this.state.startLoc;
          const id = this.parseIdentifier(true);
          const init = this.eat(29) ? this.flowEnumMemberInit() : {
            type: "none",
            loc
          };
          return {
            id,
            init
          };
        }
        flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
          const {
            explicitType
          } = context;
          if (explicitType === null) {
            return;
          }
          if (explicitType !== expectedType) {
            this.flowEnumErrorInvalidMemberInitializer(loc, context);
          }
        }
        flowEnumMembers({
          enumName,
          explicitType
        }) {
          const seenNames = /* @__PURE__ */ new Set();
          const members = {
            booleanMembers: [],
            numberMembers: [],
            stringMembers: [],
            defaultedMembers: []
          };
          let hasUnknownMembers = false;
          while (!this.match(8)) {
            if (this.eat(21)) {
              hasUnknownMembers = true;
              break;
            }
            const memberNode = this.startNode();
            const {
              id,
              init
            } = this.flowEnumMemberRaw();
            const memberName = id.name;
            if (memberName === "") {
              continue;
            }
            if (/^[a-z]/.test(memberName)) {
              this.raise(FlowErrors.EnumInvalidMemberName, {
                at: id,
                memberName,
                suggestion: memberName[0].toUpperCase() + memberName.slice(1),
                enumName
              });
            }
            if (seenNames.has(memberName)) {
              this.raise(FlowErrors.EnumDuplicateMemberName, {
                at: id,
                memberName,
                enumName
              });
            }
            seenNames.add(memberName);
            const context = {
              enumName,
              explicitType,
              memberName
            };
            memberNode.id = id;
            switch (init.type) {
              case "boolean": {
                this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean");
                memberNode.init = init.value;
                members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
                break;
              }
              case "number": {
                this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number");
                memberNode.init = init.value;
                members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
                break;
              }
              case "string": {
                this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string");
                memberNode.init = init.value;
                members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
                break;
              }
              case "invalid": {
                throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
              }
              case "none": {
                switch (explicitType) {
                  case "boolean":
                    this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
                    break;
                  case "number":
                    this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
                    break;
                  default:
                    members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
                }
              }
            }
            if (!this.match(8)) {
              this.expect(12);
            }
          }
          return {
            members,
            hasUnknownMembers
          };
        }
        flowEnumStringMembers(initializedMembers, defaultedMembers, {
          enumName
        }) {
          if (initializedMembers.length === 0) {
            return defaultedMembers;
          } else if (defaultedMembers.length === 0) {
            return initializedMembers;
          } else if (defaultedMembers.length > initializedMembers.length) {
            for (const member of initializedMembers) {
              this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
                enumName
              });
            }
            return defaultedMembers;
          } else {
            for (const member of defaultedMembers) {
              this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
                enumName
              });
            }
            return initializedMembers;
          }
        }
        flowEnumParseExplicitType({
          enumName
        }) {
          if (!this.eatContextual(101))
            return null;
          if (!tokenIsIdentifier(this.state.type)) {
            throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, {
              at: this.state.startLoc,
              enumName
            });
          }
          const {
            value
          } = this.state;
          this.next();
          if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
            this.raise(FlowErrors.EnumInvalidExplicitType, {
              at: this.state.startLoc,
              enumName,
              invalidEnumType: value
            });
          }
          return value;
        }
        flowEnumBody(node, id) {
          const enumName = id.name;
          const nameLoc = id.loc.start;
          const explicitType = this.flowEnumParseExplicitType({
            enumName
          });
          this.expect(5);
          const {
            members,
            hasUnknownMembers
          } = this.flowEnumMembers({
            enumName,
            explicitType
          });
          node.hasUnknownMembers = hasUnknownMembers;
          switch (explicitType) {
            case "boolean":
              node.explicitType = true;
              node.members = members.booleanMembers;
              this.expect(8);
              return this.finishNode(node, "EnumBooleanBody");
            case "number":
              node.explicitType = true;
              node.members = members.numberMembers;
              this.expect(8);
              return this.finishNode(node, "EnumNumberBody");
            case "string":
              node.explicitType = true;
              node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                enumName
              });
              this.expect(8);
              return this.finishNode(node, "EnumStringBody");
            case "symbol":
              node.members = members.defaultedMembers;
              this.expect(8);
              return this.finishNode(node, "EnumSymbolBody");
            default: {
              const empty = () => {
                node.members = [];
                this.expect(8);
                return this.finishNode(node, "EnumStringBody");
              };
              node.explicitType = false;
              const boolsLen = members.booleanMembers.length;
              const numsLen = members.numberMembers.length;
              const strsLen = members.stringMembers.length;
              const defaultedLen = members.defaultedMembers.length;
              if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
                return empty();
              } else if (!boolsLen && !numsLen) {
                node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                  enumName
                });
                this.expect(8);
                return this.finishNode(node, "EnumStringBody");
              } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
                for (const member of members.defaultedMembers) {
                  this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                    enumName,
                    memberName: member.id.name
                  });
                }
                node.members = members.booleanMembers;
                this.expect(8);
                return this.finishNode(node, "EnumBooleanBody");
              } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
                for (const member of members.defaultedMembers) {
                  this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                    enumName,
                    memberName: member.id.name
                  });
                }
                node.members = members.numberMembers;
                this.expect(8);
                return this.finishNode(node, "EnumNumberBody");
              } else {
                this.raise(FlowErrors.EnumInconsistentMemberValues, {
                  at: nameLoc,
                  enumName
                });
                return empty();
              }
            }
          }
        }
        flowParseEnumDeclaration(node) {
          const id = this.parseIdentifier();
          node.id = id;
          node.body = this.flowEnumBody(this.startNode(), id);
          return this.finishNode(node, "EnumDeclaration");
        }
        isLookaheadToken_lt() {
          const next = this.nextTokenStart();
          if (this.input.charCodeAt(next) === 60) {
            const afterNext = this.input.charCodeAt(next + 1);
            return afterNext !== 60 && afterNext !== 61;
          }
          return false;
        }
        maybeUnwrapTypeCastExpression(node) {
          return node.type === "TypeCastExpression" ? node.expression : node;
        }
      };
      var entities = {
        __proto__: null,
        quot: '"',
        amp: "&",
        apos: "'",
        lt: "<",
        gt: ">",
        nbsp: "\xA0",
        iexcl: "\xA1",
        cent: "\xA2",
        pound: "\xA3",
        curren: "\xA4",
        yen: "\xA5",
        brvbar: "\xA6",
        sect: "\xA7",
        uml: "\xA8",
        copy: "\xA9",
        ordf: "\xAA",
        laquo: "\xAB",
        not: "\xAC",
        shy: "\xAD",
        reg: "\xAE",
        macr: "\xAF",
        deg: "\xB0",
        plusmn: "\xB1",
        sup2: "\xB2",
        sup3: "\xB3",
        acute: "\xB4",
        micro: "\xB5",
        para: "\xB6",
        middot: "\xB7",
        cedil: "\xB8",
        sup1: "\xB9",
        ordm: "\xBA",
        raquo: "\xBB",
        frac14: "\xBC",
        frac12: "\xBD",
        frac34: "\xBE",
        iquest: "\xBF",
        Agrave: "\xC0",
        Aacute: "\xC1",
        Acirc: "\xC2",
        Atilde: "\xC3",
        Auml: "\xC4",
        Aring: "\xC5",
        AElig: "\xC6",
        Ccedil: "\xC7",
        Egrave: "\xC8",
        Eacute: "\xC9",
        Ecirc: "\xCA",
        Euml: "\xCB",
        Igrave: "\xCC",
        Iacute: "\xCD",
        Icirc: "\xCE",
        Iuml: "\xCF",
        ETH: "\xD0",
        Ntilde: "\xD1",
        Ograve: "\xD2",
        Oacute: "\xD3",
        Ocirc: "\xD4",
        Otilde: "\xD5",
        Ouml: "\xD6",
        times: "\xD7",
        Oslash: "\xD8",
        Ugrave: "\xD9",
        Uacute: "\xDA",
        Ucirc: "\xDB",
        Uuml: "\xDC",
        Yacute: "\xDD",
        THORN: "\xDE",
        szlig: "\xDF",
        agrave: "\xE0",
        aacute: "\xE1",
        acirc: "\xE2",
        atilde: "\xE3",
        auml: "\xE4",
        aring: "\xE5",
        aelig: "\xE6",
        ccedil: "\xE7",
        egrave: "\xE8",
        eacute: "\xE9",
        ecirc: "\xEA",
        euml: "\xEB",
        igrave: "\xEC",
        iacute: "\xED",
        icirc: "\xEE",
        iuml: "\xEF",
        eth: "\xF0",
        ntilde: "\xF1",
        ograve: "\xF2",
        oacute: "\xF3",
        ocirc: "\xF4",
        otilde: "\xF5",
        ouml: "\xF6",
        divide: "\xF7",
        oslash: "\xF8",
        ugrave: "\xF9",
        uacute: "\xFA",
        ucirc: "\xFB",
        uuml: "\xFC",
        yacute: "\xFD",
        thorn: "\xFE",
        yuml: "\xFF",
        OElig: "\u0152",
        oelig: "\u0153",
        Scaron: "\u0160",
        scaron: "\u0161",
        Yuml: "\u0178",
        fnof: "\u0192",
        circ: "\u02C6",
        tilde: "\u02DC",
        Alpha: "\u0391",
        Beta: "\u0392",
        Gamma: "\u0393",
        Delta: "\u0394",
        Epsilon: "\u0395",
        Zeta: "\u0396",
        Eta: "\u0397",
        Theta: "\u0398",
        Iota: "\u0399",
        Kappa: "\u039A",
        Lambda: "\u039B",
        Mu: "\u039C",
        Nu: "\u039D",
        Xi: "\u039E",
        Omicron: "\u039F",
        Pi: "\u03A0",
        Rho: "\u03A1",
        Sigma: "\u03A3",
        Tau: "\u03A4",
        Upsilon: "\u03A5",
        Phi: "\u03A6",
        Chi: "\u03A7",
        Psi: "\u03A8",
        Omega: "\u03A9",
        alpha: "\u03B1",
        beta: "\u03B2",
        gamma: "\u03B3",
        delta: "\u03B4",
        epsilon: "\u03B5",
        zeta: "\u03B6",
        eta: "\u03B7",
        theta: "\u03B8",
        iota: "\u03B9",
        kappa: "\u03BA",
        lambda: "\u03BB",
        mu: "\u03BC",
        nu: "\u03BD",
        xi: "\u03BE",
        omicron: "\u03BF",
        pi: "\u03C0",
        rho: "\u03C1",
        sigmaf: "\u03C2",
        sigma: "\u03C3",
        tau: "\u03C4",
        upsilon: "\u03C5",
        phi: "\u03C6",
        chi: "\u03C7",
        psi: "\u03C8",
        omega: "\u03C9",
        thetasym: "\u03D1",
        upsih: "\u03D2",
        piv: "\u03D6",
        ensp: "\u2002",
        emsp: "\u2003",
        thinsp: "\u2009",
        zwnj: "\u200C",
        zwj: "\u200D",
        lrm: "\u200E",
        rlm: "\u200F",
        ndash: "\u2013",
        mdash: "\u2014",
        lsquo: "\u2018",
        rsquo: "\u2019",
        sbquo: "\u201A",
        ldquo: "\u201C",
        rdquo: "\u201D",
        bdquo: "\u201E",
        dagger: "\u2020",
        Dagger: "\u2021",
        bull: "\u2022",
        hellip: "\u2026",
        permil: "\u2030",
        prime: "\u2032",
        Prime: "\u2033",
        lsaquo: "\u2039",
        rsaquo: "\u203A",
        oline: "\u203E",
        frasl: "\u2044",
        euro: "\u20AC",
        image: "\u2111",
        weierp: "\u2118",
        real: "\u211C",
        trade: "\u2122",
        alefsym: "\u2135",
        larr: "\u2190",
        uarr: "\u2191",
        rarr: "\u2192",
        darr: "\u2193",
        harr: "\u2194",
        crarr: "\u21B5",
        lArr: "\u21D0",
        uArr: "\u21D1",
        rArr: "\u21D2",
        dArr: "\u21D3",
        hArr: "\u21D4",
        forall: "\u2200",
        part: "\u2202",
        exist: "\u2203",
        empty: "\u2205",
        nabla: "\u2207",
        isin: "\u2208",
        notin: "\u2209",
        ni: "\u220B",
        prod: "\u220F",
        sum: "\u2211",
        minus: "\u2212",
        lowast: "\u2217",
        radic: "\u221A",
        prop: "\u221D",
        infin: "\u221E",
        ang: "\u2220",
        and: "\u2227",
        or: "\u2228",
        cap: "\u2229",
        cup: "\u222A",
        int: "\u222B",
        there4: "\u2234",
        sim: "\u223C",
        cong: "\u2245",
        asymp: "\u2248",
        ne: "\u2260",
        equiv: "\u2261",
        le: "\u2264",
        ge: "\u2265",
        sub: "\u2282",
        sup: "\u2283",
        nsub: "\u2284",
        sube: "\u2286",
        supe: "\u2287",
        oplus: "\u2295",
        otimes: "\u2297",
        perp: "\u22A5",
        sdot: "\u22C5",
        lceil: "\u2308",
        rceil: "\u2309",
        lfloor: "\u230A",
        rfloor: "\u230B",
        lang: "\u2329",
        rang: "\u232A",
        loz: "\u25CA",
        spades: "\u2660",
        clubs: "\u2663",
        hearts: "\u2665",
        diams: "\u2666"
      };
      var JsxErrors = ParseErrorEnum`jsx`({
        AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
        MissingClosingTagElement: ({
          openingTagName
        }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
        MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
        UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
        UnexpectedToken: ({
          unexpected,
          HTMLEntity
        }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
        UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
        UnterminatedJsxContent: "Unterminated JSX contents.",
        UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
      });
      function isFragment(object) {
        return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
      }
      function getQualifiedJSXName(object) {
        if (object.type === "JSXIdentifier") {
          return object.name;
        }
        if (object.type === "JSXNamespacedName") {
          return object.namespace.name + ":" + object.name.name;
        }
        if (object.type === "JSXMemberExpression") {
          return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
        }
        throw new Error("Node had unexpected type: " + object.type);
      }
      var jsx = (superClass) => class JSXParserMixin extends superClass {
        jsxReadToken() {
          let out = "";
          let chunkStart = this.state.pos;
          for (; ; ) {
            if (this.state.pos >= this.length) {
              throw this.raise(JsxErrors.UnterminatedJsxContent, {
                at: this.state.startLoc
              });
            }
            const ch = this.input.charCodeAt(this.state.pos);
            switch (ch) {
              case 60:
              case 123:
                if (this.state.pos === this.state.start) {
                  if (ch === 60 && this.state.canStartJSXElement) {
                    ++this.state.pos;
                    this.finishToken(140);
                  } else {
                    super.getTokenFromCode(ch);
                  }
                  return;
                }
                out += this.input.slice(chunkStart, this.state.pos);
                this.finishToken(139, out);
                return;
              case 38:
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadEntity();
                chunkStart = this.state.pos;
                break;
              case 62:
              case 125:
              default:
                if (isNewLine(ch)) {
                  out += this.input.slice(chunkStart, this.state.pos);
                  out += this.jsxReadNewLine(true);
                  chunkStart = this.state.pos;
                } else {
                  ++this.state.pos;
                }
            }
          }
        }
        jsxReadNewLine(normalizeCRLF) {
          const ch = this.input.charCodeAt(this.state.pos);
          let out;
          ++this.state.pos;
          if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
            ++this.state.pos;
            out = normalizeCRLF ? "\n" : "\r\n";
          } else {
            out = String.fromCharCode(ch);
          }
          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          return out;
        }
        jsxReadString(quote) {
          let out = "";
          let chunkStart = ++this.state.pos;
          for (; ; ) {
            if (this.state.pos >= this.length) {
              throw this.raise(Errors.UnterminatedString, {
                at: this.state.startLoc
              });
            }
            const ch = this.input.charCodeAt(this.state.pos);
            if (ch === quote)
              break;
            if (ch === 38) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
            } else if (isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadNewLine(false);
              chunkStart = this.state.pos;
            } else {
              ++this.state.pos;
            }
          }
          out += this.input.slice(chunkStart, this.state.pos++);
          this.finishToken(131, out);
        }
        jsxReadEntity() {
          const startPos = ++this.state.pos;
          if (this.codePointAtPos(this.state.pos) === 35) {
            ++this.state.pos;
            let radix = 10;
            if (this.codePointAtPos(this.state.pos) === 120) {
              radix = 16;
              ++this.state.pos;
            }
            const codePoint = this.readInt(radix, void 0, false, "bail");
            if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
              ++this.state.pos;
              return String.fromCodePoint(codePoint);
            }
          } else {
            let count = 0;
            let semi = false;
            while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) == 59)) {
              ++this.state.pos;
            }
            if (semi) {
              const desc = this.input.slice(startPos, this.state.pos);
              const entity = entities[desc];
              ++this.state.pos;
              if (entity) {
                return entity;
              }
            }
          }
          this.state.pos = startPos;
          return "&";
        }
        jsxReadWord() {
          let ch;
          const start = this.state.pos;
          do {
            ch = this.input.charCodeAt(++this.state.pos);
          } while (isIdentifierChar(ch) || ch === 45);
          this.finishToken(138, this.input.slice(start, this.state.pos));
        }
        jsxParseIdentifier() {
          const node = this.startNode();
          if (this.match(138)) {
            node.name = this.state.value;
          } else if (tokenIsKeyword(this.state.type)) {
            node.name = tokenLabelName(this.state.type);
          } else {
            this.unexpected();
          }
          this.next();
          return this.finishNode(node, "JSXIdentifier");
        }
        jsxParseNamespacedName() {
          const startLoc = this.state.startLoc;
          const name = this.jsxParseIdentifier();
          if (!this.eat(14))
            return name;
          const node = this.startNodeAt(startLoc);
          node.namespace = name;
          node.name = this.jsxParseIdentifier();
          return this.finishNode(node, "JSXNamespacedName");
        }
        jsxParseElementName() {
          const startLoc = this.state.startLoc;
          let node = this.jsxParseNamespacedName();
          if (node.type === "JSXNamespacedName") {
            return node;
          }
          while (this.eat(16)) {
            const newNode = this.startNodeAt(startLoc);
            newNode.object = node;
            newNode.property = this.jsxParseIdentifier();
            node = this.finishNode(newNode, "JSXMemberExpression");
          }
          return node;
        }
        jsxParseAttributeValue() {
          let node;
          switch (this.state.type) {
            case 5:
              node = this.startNode();
              this.setContext(types.brace);
              this.next();
              node = this.jsxParseExpressionContainer(node, types.j_oTag);
              if (node.expression.type === "JSXEmptyExpression") {
                this.raise(JsxErrors.AttributeIsEmpty, {
                  at: node
                });
              }
              return node;
            case 140:
            case 131:
              return this.parseExprAtom();
            default:
              throw this.raise(JsxErrors.UnsupportedJsxValue, {
                at: this.state.startLoc
              });
          }
        }
        jsxParseEmptyExpression() {
          const node = this.startNodeAt(this.state.lastTokEndLoc);
          return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
        }
        jsxParseSpreadChild(node) {
          this.next();
          node.expression = this.parseExpression();
          this.setContext(types.j_expr);
          this.state.canStartJSXElement = true;
          this.expect(8);
          return this.finishNode(node, "JSXSpreadChild");
        }
        jsxParseExpressionContainer(node, previousContext) {
          if (this.match(8)) {
            node.expression = this.jsxParseEmptyExpression();
          } else {
            const expression = this.parseExpression();
            node.expression = expression;
          }
          this.setContext(previousContext);
          this.state.canStartJSXElement = true;
          this.expect(8);
          return this.finishNode(node, "JSXExpressionContainer");
        }
        jsxParseAttribute() {
          const node = this.startNode();
          if (this.match(5)) {
            this.setContext(types.brace);
            this.next();
            this.expect(21);
            node.argument = this.parseMaybeAssignAllowIn();
            this.setContext(types.j_oTag);
            this.state.canStartJSXElement = true;
            this.expect(8);
            return this.finishNode(node, "JSXSpreadAttribute");
          }
          node.name = this.jsxParseNamespacedName();
          node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
          return this.finishNode(node, "JSXAttribute");
        }
        jsxParseOpeningElementAt(startLoc) {
          const node = this.startNodeAt(startLoc);
          if (this.eat(141)) {
            return this.finishNode(node, "JSXOpeningFragment");
          }
          node.name = this.jsxParseElementName();
          return this.jsxParseOpeningElementAfterName(node);
        }
        jsxParseOpeningElementAfterName(node) {
          const attributes = [];
          while (!this.match(56) && !this.match(141)) {
            attributes.push(this.jsxParseAttribute());
          }
          node.attributes = attributes;
          node.selfClosing = this.eat(56);
          this.expect(141);
          return this.finishNode(node, "JSXOpeningElement");
        }
        jsxParseClosingElementAt(startLoc) {
          const node = this.startNodeAt(startLoc);
          if (this.eat(141)) {
            return this.finishNode(node, "JSXClosingFragment");
          }
          node.name = this.jsxParseElementName();
          this.expect(141);
          return this.finishNode(node, "JSXClosingElement");
        }
        jsxParseElementAt(startLoc) {
          const node = this.startNodeAt(startLoc);
          const children = [];
          const openingElement = this.jsxParseOpeningElementAt(startLoc);
          let closingElement = null;
          if (!openingElement.selfClosing) {
            contents:
              for (; ; ) {
                switch (this.state.type) {
                  case 140:
                    startLoc = this.state.startLoc;
                    this.next();
                    if (this.eat(56)) {
                      closingElement = this.jsxParseClosingElementAt(startLoc);
                      break contents;
                    }
                    children.push(this.jsxParseElementAt(startLoc));
                    break;
                  case 139:
                    children.push(this.parseExprAtom());
                    break;
                  case 5: {
                    const node2 = this.startNode();
                    this.setContext(types.brace);
                    this.next();
                    if (this.match(21)) {
                      children.push(this.jsxParseSpreadChild(node2));
                    } else {
                      children.push(this.jsxParseExpressionContainer(node2, types.j_expr));
                    }
                    break;
                  }
                  default:
                    this.unexpected();
                }
              }
            if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
              this.raise(JsxErrors.MissingClosingTagFragment, {
                at: closingElement
              });
            } else if (!isFragment(openingElement) && isFragment(closingElement)) {
              this.raise(JsxErrors.MissingClosingTagElement, {
                at: closingElement,
                openingTagName: getQualifiedJSXName(openingElement.name)
              });
            } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
              if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
                this.raise(JsxErrors.MissingClosingTagElement, {
                  at: closingElement,
                  openingTagName: getQualifiedJSXName(openingElement.name)
                });
              }
            }
          }
          if (isFragment(openingElement)) {
            node.openingFragment = openingElement;
            node.closingFragment = closingElement;
          } else {
            node.openingElement = openingElement;
            node.closingElement = closingElement;
          }
          node.children = children;
          if (this.match(47)) {
            throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, {
              at: this.state.startLoc
            });
          }
          return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
        }
        jsxParseElement() {
          const startLoc = this.state.startLoc;
          this.next();
          return this.jsxParseElementAt(startLoc);
        }
        setContext(newContext) {
          const {
            context
          } = this.state;
          context[context.length - 1] = newContext;
        }
        parseExprAtom(refExpressionErrors) {
          if (this.match(139)) {
            return this.parseLiteral(this.state.value, "JSXText");
          } else if (this.match(140)) {
            return this.jsxParseElement();
          } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
            this.replaceToken(140);
            return this.jsxParseElement();
          } else {
            return super.parseExprAtom(refExpressionErrors);
          }
        }
        skipSpace() {
          const curContext = this.curContext();
          if (!curContext.preserveSpace)
            super.skipSpace();
        }
        getTokenFromCode(code) {
          const context = this.curContext();
          if (context === types.j_expr) {
            this.jsxReadToken();
            return;
          }
          if (context === types.j_oTag || context === types.j_cTag) {
            if (isIdentifierStart(code)) {
              this.jsxReadWord();
              return;
            }
            if (code === 62) {
              ++this.state.pos;
              this.finishToken(141);
              return;
            }
            if ((code === 34 || code === 39) && context === types.j_oTag) {
              this.jsxReadString(code);
              return;
            }
          }
          if (code === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
            ++this.state.pos;
            this.finishToken(140);
            return;
          }
          super.getTokenFromCode(code);
        }
        updateContext(prevType) {
          const {
            context,
            type
          } = this.state;
          if (type === 56 && prevType === 140) {
            context.splice(-2, 2, types.j_cTag);
            this.state.canStartJSXElement = false;
          } else if (type === 140) {
            context.push(types.j_oTag);
          } else if (type === 141) {
            const out = context[context.length - 1];
            if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {
              context.pop();
              this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;
            } else {
              this.setContext(types.j_expr);
              this.state.canStartJSXElement = true;
            }
          } else {
            this.state.canStartJSXElement = tokenComesBeforeExpression(type);
          }
        }
      };
      var TypeScriptScope = class extends Scope {
        constructor(...args) {
          super(...args);
          this.types = /* @__PURE__ */ new Set();
          this.enums = /* @__PURE__ */ new Set();
          this.constEnums = /* @__PURE__ */ new Set();
          this.classes = /* @__PURE__ */ new Set();
          this.exportOnlyBindings = /* @__PURE__ */ new Set();
        }
      };
      var TypeScriptScopeHandler = class extends ScopeHandler {
        constructor(...args) {
          super(...args);
          this.importsStack = [];
        }
        createScope(flags) {
          this.importsStack.push(/* @__PURE__ */ new Set());
          return new TypeScriptScope(flags);
        }
        enter(flags) {
          if (flags == SCOPE_TS_MODULE) {
            this.importsStack.push(/* @__PURE__ */ new Set());
          }
          super.enter(flags);
        }
        exit() {
          const flags = super.exit();
          if (flags == SCOPE_TS_MODULE) {
            this.importsStack.pop();
          }
          return flags;
        }
        hasImport(name, allowShadow) {
          const len = this.importsStack.length;
          if (this.importsStack[len - 1].has(name)) {
            return true;
          }
          if (!allowShadow && len > 1) {
            for (let i = 0; i < len - 1; i++) {
              if (this.importsStack[i].has(name))
                return true;
            }
          }
          return false;
        }
        declareName(name, bindingType, loc) {
          if (bindingType & BIND_FLAGS_TS_IMPORT) {
            if (this.hasImport(name, true)) {
              this.parser.raise(Errors.VarRedeclaration, {
                at: loc,
                identifierName: name
              });
            }
            this.importsStack[this.importsStack.length - 1].add(name);
            return;
          }
          const scope = this.currentScope();
          if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
            this.maybeExportDefined(scope, name);
            scope.exportOnlyBindings.add(name);
            return;
          }
          super.declareName(name, bindingType, loc);
          if (bindingType & BIND_KIND_TYPE) {
            if (!(bindingType & BIND_KIND_VALUE)) {
              this.checkRedeclarationInScope(scope, name, bindingType, loc);
              this.maybeExportDefined(scope, name);
            }
            scope.types.add(name);
          }
          if (bindingType & BIND_FLAGS_TS_ENUM)
            scope.enums.add(name);
          if (bindingType & BIND_FLAGS_TS_CONST_ENUM)
            scope.constEnums.add(name);
          if (bindingType & BIND_FLAGS_CLASS)
            scope.classes.add(name);
        }
        isRedeclaredInScope(scope, name, bindingType) {
          if (scope.enums.has(name)) {
            if (bindingType & BIND_FLAGS_TS_ENUM) {
              const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);
              const wasConst = scope.constEnums.has(name);
              return isConst !== wasConst;
            }
            return true;
          }
          if (bindingType & BIND_FLAGS_CLASS && scope.classes.has(name)) {
            if (scope.lexical.has(name)) {
              return !!(bindingType & BIND_KIND_VALUE);
            } else {
              return false;
            }
          }
          if (bindingType & BIND_KIND_TYPE && scope.types.has(name)) {
            return true;
          }
          return super.isRedeclaredInScope(scope, name, bindingType);
        }
        checkLocalExport(id) {
          const {
            name
          } = id;
          if (this.hasImport(name))
            return;
          const len = this.scopeStack.length;
          for (let i = len - 1; i >= 0; i--) {
            const scope = this.scopeStack[i];
            if (scope.types.has(name) || scope.exportOnlyBindings.has(name))
              return;
          }
          super.checkLocalExport(id);
        }
      };
      var getOwn$1 = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];
      var unwrapParenthesizedExpression = (node) => {
        return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
      };
      var LValParser = class extends NodeUtils {
        toAssignable(node, isLHS = false) {
          var _node$extra, _node$extra3;
          let parenthesized = void 0;
          if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
            parenthesized = unwrapParenthesizedExpression(node);
            if (isLHS) {
              if (parenthesized.type === "Identifier") {
                this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, {
                  at: node
                });
              } else if (parenthesized.type !== "MemberExpression") {
                this.raise(Errors.InvalidParenthesizedAssignment, {
                  at: node
                });
              }
            } else {
              this.raise(Errors.InvalidParenthesizedAssignment, {
                at: node
              });
            }
          }
          switch (node.type) {
            case "Identifier":
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              node.type = "ObjectPattern";
              for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
                var _node$extra2;
                const prop = node.properties[i];
                const isLast = i === last;
                this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
                if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {
                  this.raise(Errors.RestTrailingComma, {
                    at: node.extra.trailingCommaLoc
                  });
                }
              }
              break;
            case "ObjectProperty": {
              const {
                key,
                value
              } = node;
              if (this.isPrivateName(key)) {
                this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
              }
              this.toAssignable(value, isLHS);
              break;
            }
            case "SpreadElement": {
              throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
            }
            case "ArrayExpression":
              node.type = "ArrayPattern";
              this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
              break;
            case "AssignmentExpression":
              if (node.operator !== "=") {
                this.raise(Errors.MissingEqInAssignment, {
                  at: node.left.loc.end
                });
              }
              node.type = "AssignmentPattern";
              delete node.operator;
              this.toAssignable(node.left, isLHS);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(parenthesized, isLHS);
              break;
          }
        }
        toAssignableObjectExpressionProp(prop, isLast, isLHS) {
          if (prop.type === "ObjectMethod") {
            this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, {
              at: prop.key
            });
          } else if (prop.type === "SpreadElement") {
            prop.type = "RestElement";
            const arg = prop.argument;
            this.checkToRestConversion(arg, false);
            this.toAssignable(arg, isLHS);
            if (!isLast) {
              this.raise(Errors.RestTrailingComma, {
                at: prop
              });
            }
          } else {
            this.toAssignable(prop, isLHS);
          }
        }
        toAssignableList(exprList, trailingCommaLoc, isLHS) {
          const end = exprList.length - 1;
          for (let i = 0; i <= end; i++) {
            const elt = exprList[i];
            if (!elt)
              continue;
            if (elt.type === "SpreadElement") {
              elt.type = "RestElement";
              const arg = elt.argument;
              this.checkToRestConversion(arg, true);
              this.toAssignable(arg, isLHS);
            } else {
              this.toAssignable(elt, isLHS);
            }
            if (elt.type === "RestElement") {
              if (i < end) {
                this.raise(Errors.RestTrailingComma, {
                  at: elt
                });
              } else if (trailingCommaLoc) {
                this.raise(Errors.RestTrailingComma, {
                  at: trailingCommaLoc
                });
              }
            }
          }
        }
        isAssignable(node, isBinding) {
          switch (node.type) {
            case "Identifier":
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              return true;
            case "ObjectExpression": {
              const last = node.properties.length - 1;
              return node.properties.every((prop, i) => {
                return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
              });
            }
            case "ObjectProperty":
              return this.isAssignable(node.value);
            case "SpreadElement":
              return this.isAssignable(node.argument);
            case "ArrayExpression":
              return node.elements.every((element) => element === null || this.isAssignable(element));
            case "AssignmentExpression":
              return node.operator === "=";
            case "ParenthesizedExpression":
              return this.isAssignable(node.expression);
            case "MemberExpression":
            case "OptionalMemberExpression":
              return !isBinding;
            default:
              return false;
          }
        }
        toReferencedList(exprList, isParenthesizedExpr) {
          return exprList;
        }
        toReferencedListDeep(exprList, isParenthesizedExpr) {
          this.toReferencedList(exprList, isParenthesizedExpr);
          for (const expr of exprList) {
            if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
              this.toReferencedListDeep(expr.elements);
            }
          }
        }
        parseSpread(refExpressionErrors) {
          const node = this.startNode();
          this.next();
          node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0);
          return this.finishNode(node, "SpreadElement");
        }
        parseRestBinding() {
          const node = this.startNode();
          this.next();
          node.argument = this.parseBindingAtom();
          return this.finishNode(node, "RestElement");
        }
        parseBindingAtom() {
          switch (this.state.type) {
            case 0: {
              const node = this.startNode();
              this.next();
              node.elements = this.parseBindingList(3, 93, 1);
              return this.finishNode(node, "ArrayPattern");
            }
            case 5:
              return this.parseObjectLike(8, true);
          }
          return this.parseIdentifier();
        }
        parseBindingList(close, closeCharCode, flags) {
          const allowEmpty = flags & 1;
          const elts = [];
          let first = true;
          while (!this.eat(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
            }
            if (allowEmpty && this.match(12)) {
              elts.push(null);
            } else if (this.eat(close)) {
              break;
            } else if (this.match(21)) {
              elts.push(this.parseAssignableListItemTypes(this.parseRestBinding(), flags));
              if (!this.checkCommaAfterRest(closeCharCode)) {
                this.expect(close);
                break;
              }
            } else {
              const decorators = [];
              if (this.match(26) && this.hasPlugin("decorators")) {
                this.raise(Errors.UnsupportedParameterDecorator, {
                  at: this.state.startLoc
                });
              }
              while (this.match(26)) {
                decorators.push(this.parseDecorator());
              }
              elts.push(this.parseAssignableListItem(flags, decorators));
            }
          }
          return elts;
        }
        parseBindingRestProperty(prop) {
          this.next();
          prop.argument = this.parseIdentifier();
          this.checkCommaAfterRest(125);
          return this.finishNode(prop, "RestElement");
        }
        parseBindingProperty() {
          const prop = this.startNode();
          const {
            type,
            startLoc
          } = this.state;
          if (type === 21) {
            return this.parseBindingRestProperty(prop);
          } else if (type === 136) {
            this.expectPlugin("destructuringPrivate", startLoc);
            this.classScope.usePrivateName(this.state.value, startLoc);
            prop.key = this.parsePrivateName();
          } else {
            this.parsePropertyName(prop);
          }
          prop.method = false;
          return this.parseObjPropValue(prop, startLoc, false, false, true, false);
        }
        parseAssignableListItem(flags, decorators) {
          const left = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(left, flags);
          const elt = this.parseMaybeDefault(left.loc.start, left);
          if (decorators.length) {
            left.decorators = decorators;
          }
          return elt;
        }
        parseAssignableListItemTypes(param, flags) {
          return param;
        }
        parseMaybeDefault(startLoc, left) {
          var _startLoc, _left;
          (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;
          left = (_left = left) != null ? _left : this.parseBindingAtom();
          if (!this.eat(29))
            return left;
          const node = this.startNodeAt(startLoc);
          node.left = left;
          node.right = this.parseMaybeAssignAllowIn();
          return this.finishNode(node, "AssignmentPattern");
        }
        isValidLVal(type, isUnparenthesizedInAssign, binding) {
          return getOwn$1({
            AssignmentPattern: "left",
            RestElement: "argument",
            ObjectProperty: "value",
            ParenthesizedExpression: "expression",
            ArrayPattern: "elements",
            ObjectPattern: "properties"
          }, type);
        }
        checkLVal(expression, {
          in: ancestor,
          binding = BIND_NONE,
          checkClashes = false,
          strictModeChanged = false,
          hasParenthesizedAncestor = false
        }) {
          var _expression$extra;
          const type = expression.type;
          if (this.isObjectMethod(expression))
            return;
          if (type === "MemberExpression") {
            if (binding !== BIND_NONE) {
              this.raise(Errors.InvalidPropertyBindingPattern, {
                at: expression
              });
            }
            return;
          }
          if (type === "Identifier") {
            this.checkIdentifier(expression, binding, strictModeChanged);
            const {
              name
            } = expression;
            if (checkClashes) {
              if (checkClashes.has(name)) {
                this.raise(Errors.ParamDupe, {
                  at: expression
                });
              } else {
                checkClashes.add(name);
              }
            }
            return;
          }
          const validity = this.isValidLVal(type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
          if (validity === true)
            return;
          if (validity === false) {
            const ParseErrorClass = binding === BIND_NONE ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
            this.raise(ParseErrorClass, {
              at: expression,
              ancestor
            });
            return;
          }
          const [key, isParenthesizedExpression] = Array.isArray(validity) ? validity : [validity, type === "ParenthesizedExpression"];
          const nextAncestor = type === "ArrayPattern" || type === "ObjectPattern" || type === "ParenthesizedExpression" ? {
            type
          } : ancestor;
          for (const child of [].concat(expression[key])) {
            if (child) {
              this.checkLVal(child, {
                in: nextAncestor,
                binding,
                checkClashes,
                strictModeChanged,
                hasParenthesizedAncestor: isParenthesizedExpression
              });
            }
          }
        }
        checkIdentifier(at, bindingType, strictModeChanged = false) {
          if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {
            if (bindingType === BIND_NONE) {
              this.raise(Errors.StrictEvalArguments, {
                at,
                referenceName: at.name
              });
            } else {
              this.raise(Errors.StrictEvalArgumentsBinding, {
                at,
                bindingName: at.name
              });
            }
          }
          if (bindingType & BIND_FLAGS_NO_LET_IN_LEXICAL && at.name === "let") {
            this.raise(Errors.LetInLexicalBinding, {
              at
            });
          }
          if (!(bindingType & BIND_NONE)) {
            this.declareNameFromIdentifier(at, bindingType);
          }
        }
        declareNameFromIdentifier(identifier, binding) {
          this.scope.declareName(identifier.name, binding, identifier.loc.start);
        }
        checkToRestConversion(node, allowPattern) {
          switch (node.type) {
            case "ParenthesizedExpression":
              this.checkToRestConversion(node.expression, allowPattern);
              break;
            case "Identifier":
            case "MemberExpression":
              break;
            case "ArrayExpression":
            case "ObjectExpression":
              if (allowPattern)
                break;
            default:
              this.raise(Errors.InvalidRestAssignmentPattern, {
                at: node
              });
          }
        }
        checkCommaAfterRest(close) {
          if (!this.match(12)) {
            return false;
          }
          this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, {
            at: this.state.startLoc
          });
          return true;
        }
      };
      var getOwn = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];
      function nonNull(x) {
        if (x == null) {
          throw new Error(`Unexpected ${x} value.`);
        }
        return x;
      }
      function assert(x) {
        if (!x) {
          throw new Error("Assert fail");
        }
      }
      var TSErrors = ParseErrorEnum`typescript`({
        AbstractMethodHasImplementation: ({
          methodName
        }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
        AbstractPropertyHasInitializer: ({
          propertyName
        }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
        AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
        AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
        AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
        ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
        ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
        ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
        ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
        DeclareAccessor: ({
          kind
        }) => `'declare' is not allowed in ${kind}ters.`,
        DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
        DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
        DuplicateAccessibilityModifier: ({
          modifier
        }) => `Accessibility modifier already seen.`,
        DuplicateModifier: ({
          modifier
        }) => `Duplicate modifier: '${modifier}'.`,
        EmptyHeritageClauseType: ({
          token
        }) => `'${token}' list cannot be empty.`,
        EmptyTypeArguments: "Type argument list cannot be empty.",
        EmptyTypeParameters: "Type parameter list cannot be empty.",
        ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
        ImportAliasHasImportType: "An import alias can not use 'import type'.",
        ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
        IncompatibleModifiers: ({
          modifiers
        }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
        IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
        IndexSignatureHasAccessibility: ({
          modifier
        }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
        IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
        IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
        IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
        InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
        InvalidModifierOnTypeMember: ({
          modifier
        }) => `'${modifier}' modifier cannot appear on a type member.`,
        InvalidModifierOnTypeParameter: ({
          modifier
        }) => `'${modifier}' modifier cannot appear on a type parameter.`,
        InvalidModifierOnTypeParameterPositions: ({
          modifier
        }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
        InvalidModifiersOrder: ({
          orderedModifiers
        }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
        InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
        InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
        MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
        MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
        NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
        NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
        OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
        OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
        PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
        PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
        PrivateElementHasAccessibility: ({
          modifier
        }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
        ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
        ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
        ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
        SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
        SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
        SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
        SingleTypeParameterWithoutTrailingComma: ({
          typeParameterName
        }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
        StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
        TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
        TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
        TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
        TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
        TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
        UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
        UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
        UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
        UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
        UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
        UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
        UnsupportedSignatureParameterKind: ({
          type
        }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`
      });
      function keywordTypeFromName(value) {
        switch (value) {
          case "any":
            return "TSAnyKeyword";
          case "boolean":
            return "TSBooleanKeyword";
          case "bigint":
            return "TSBigIntKeyword";
          case "never":
            return "TSNeverKeyword";
          case "number":
            return "TSNumberKeyword";
          case "object":
            return "TSObjectKeyword";
          case "string":
            return "TSStringKeyword";
          case "symbol":
            return "TSSymbolKeyword";
          case "undefined":
            return "TSUndefinedKeyword";
          case "unknown":
            return "TSUnknownKeyword";
          default:
            return void 0;
        }
      }
      function tsIsAccessModifier(modifier) {
        return modifier === "private" || modifier === "public" || modifier === "protected";
      }
      function tsIsVarianceAnnotations(modifier) {
        return modifier === "in" || modifier === "out";
      }
      var typescript = (superClass) => class TypeScriptParserMixin extends superClass {
        constructor(...args) {
          super(...args);
          this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
            allowedModifiers: ["in", "out"],
            disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
            errorTemplate: TSErrors.InvalidModifierOnTypeParameter
          });
          this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
            allowedModifiers: ["const"],
            disallowedModifiers: ["in", "out"],
            errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
          });
          this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
            allowedModifiers: ["in", "out", "const"],
            disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
            errorTemplate: TSErrors.InvalidModifierOnTypeParameter
          });
        }
        getScopeHandler() {
          return TypeScriptScopeHandler;
        }
        tsIsIdentifier() {
          return tokenIsIdentifier(this.state.type);
        }
        tsTokenCanFollowModifier() {
          return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(136) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
        }
        tsNextTokenCanFollowModifier() {
          this.next();
          return this.tsTokenCanFollowModifier();
        }
        tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
          if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {
            return void 0;
          }
          const modifier = this.state.value;
          if (allowedModifiers.indexOf(modifier) !== -1) {
            if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
              return void 0;
            }
            if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
              return modifier;
            }
          }
          return void 0;
        }
        tsParseModifiers({
          allowedModifiers,
          disallowedModifiers,
          stopOnStartOfClassStaticBlock,
          errorTemplate = TSErrors.InvalidModifierOnTypeMember
        }, modified) {
          const enforceOrder = (loc, modifier, before, after) => {
            if (modifier === before && modified[after]) {
              this.raise(TSErrors.InvalidModifiersOrder, {
                at: loc,
                orderedModifiers: [before, after]
              });
            }
          };
          const incompatible = (loc, modifier, mod1, mod2) => {
            if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
              this.raise(TSErrors.IncompatibleModifiers, {
                at: loc,
                modifiers: [mod1, mod2]
              });
            }
          };
          for (; ; ) {
            const {
              startLoc
            } = this.state;
            const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
            if (!modifier)
              break;
            if (tsIsAccessModifier(modifier)) {
              if (modified.accessibility) {
                this.raise(TSErrors.DuplicateAccessibilityModifier, {
                  at: startLoc,
                  modifier
                });
              } else {
                enforceOrder(startLoc, modifier, modifier, "override");
                enforceOrder(startLoc, modifier, modifier, "static");
                enforceOrder(startLoc, modifier, modifier, "readonly");
                modified.accessibility = modifier;
              }
            } else if (tsIsVarianceAnnotations(modifier)) {
              if (modified[modifier]) {
                this.raise(TSErrors.DuplicateModifier, {
                  at: startLoc,
                  modifier
                });
              }
              modified[modifier] = true;
              enforceOrder(startLoc, modifier, "in", "out");
            } else {
              if (Object.hasOwnProperty.call(modified, modifier)) {
                this.raise(TSErrors.DuplicateModifier, {
                  at: startLoc,
                  modifier
                });
              } else {
                enforceOrder(startLoc, modifier, "static", "readonly");
                enforceOrder(startLoc, modifier, "static", "override");
                enforceOrder(startLoc, modifier, "override", "readonly");
                enforceOrder(startLoc, modifier, "abstract", "override");
                incompatible(startLoc, modifier, "declare", "override");
                incompatible(startLoc, modifier, "static", "abstract");
              }
              modified[modifier] = true;
            }
            if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
              this.raise(errorTemplate, {
                at: startLoc,
                modifier
              });
            }
          }
        }
        tsIsListTerminator(kind) {
          switch (kind) {
            case "EnumMembers":
            case "TypeMembers":
              return this.match(8);
            case "HeritageClauseElement":
              return this.match(5);
            case "TupleElementTypes":
              return this.match(3);
            case "TypeParametersOrArguments":
              return this.match(48);
          }
        }
        tsParseList(kind, parseElement) {
          const result = [];
          while (!this.tsIsListTerminator(kind)) {
            result.push(parseElement());
          }
          return result;
        }
        tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
          return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
        }
        tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
          const result = [];
          let trailingCommaPos = -1;
          for (; ; ) {
            if (this.tsIsListTerminator(kind)) {
              break;
            }
            trailingCommaPos = -1;
            const element = parseElement();
            if (element == null) {
              return void 0;
            }
            result.push(element);
            if (this.eat(12)) {
              trailingCommaPos = this.state.lastTokStart;
              continue;
            }
            if (this.tsIsListTerminator(kind)) {
              break;
            }
            if (expectSuccess) {
              this.expect(12);
            }
            return void 0;
          }
          if (refTrailingCommaPos) {
            refTrailingCommaPos.value = trailingCommaPos;
          }
          return result;
        }
        tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
          if (!skipFirstToken) {
            if (bracket) {
              this.expect(0);
            } else {
              this.expect(47);
            }
          }
          const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
          if (bracket) {
            this.expect(3);
          } else {
            this.expect(48);
          }
          return result;
        }
        tsParseImportType() {
          const node = this.startNode();
          this.expect(83);
          this.expect(10);
          if (!this.match(131)) {
            this.raise(TSErrors.UnsupportedImportTypeArgument, {
              at: this.state.startLoc
            });
          }
          node.argument = super.parseExprAtom();
          this.expect(11);
          if (this.eat(16)) {
            node.qualifier = this.tsParseEntityName();
          }
          if (this.match(47)) {
            node.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node, "TSImportType");
        }
        tsParseEntityName(allowReservedWords = true) {
          let entity = this.parseIdentifier(allowReservedWords);
          while (this.eat(16)) {
            const node = this.startNodeAtNode(entity);
            node.left = entity;
            node.right = this.parseIdentifier(allowReservedWords);
            entity = this.finishNode(node, "TSQualifiedName");
          }
          return entity;
        }
        tsParseTypeReference() {
          const node = this.startNode();
          node.typeName = this.tsParseEntityName();
          if (!this.hasPrecedingLineBreak() && this.match(47)) {
            node.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node, "TSTypeReference");
        }
        tsParseThisTypePredicate(lhs) {
          this.next();
          const node = this.startNodeAtNode(lhs);
          node.parameterName = lhs;
          node.typeAnnotation = this.tsParseTypeAnnotation(false);
          node.asserts = false;
          return this.finishNode(node, "TSTypePredicate");
        }
        tsParseThisTypeNode() {
          const node = this.startNode();
          this.next();
          return this.finishNode(node, "TSThisType");
        }
        tsParseTypeQuery() {
          const node = this.startNode();
          this.expect(87);
          if (this.match(83)) {
            node.exprName = this.tsParseImportType();
          } else {
            node.exprName = this.tsParseEntityName();
          }
          if (!this.hasPrecedingLineBreak() && this.match(47)) {
            node.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node, "TSTypeQuery");
        }
        tsParseTypeParameter(parseModifiers) {
          const node = this.startNode();
          parseModifiers(node);
          node.name = this.tsParseTypeParameterName();
          node.constraint = this.tsEatThenParseType(81);
          node.default = this.tsEatThenParseType(29);
          return this.finishNode(node, "TSTypeParameter");
        }
        tsTryParseTypeParameters(parseModifiers) {
          if (this.match(47)) {
            return this.tsParseTypeParameters(parseModifiers);
          }
        }
        tsParseTypeParameters(parseModifiers) {
          const node = this.startNode();
          if (this.match(47) || this.match(140)) {
            this.next();
          } else {
            this.unexpected();
          }
          const refTrailingCommaPos = {
            value: -1
          };
          node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
          if (node.params.length === 0) {
            this.raise(TSErrors.EmptyTypeParameters, {
              at: node
            });
          }
          if (refTrailingCommaPos.value !== -1) {
            this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
          }
          return this.finishNode(node, "TSTypeParameterDeclaration");
        }
        tsFillSignature(returnToken, signature) {
          const returnTokenRequired = returnToken === 19;
          const paramsKey = "parameters";
          const returnTypeKey = "typeAnnotation";
          signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
          this.expect(10);
          signature[paramsKey] = this.tsParseBindingListForSignature();
          if (returnTokenRequired) {
            signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
          } else if (this.match(returnToken)) {
            signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
          }
        }
        tsParseBindingListForSignature() {
          const list = super.parseBindingList(11, 41, 2);
          for (const pattern of list) {
            const {
              type
            } = pattern;
            if (type === "AssignmentPattern" || type === "TSParameterProperty") {
              this.raise(TSErrors.UnsupportedSignatureParameterKind, {
                at: pattern,
                type
              });
            }
          }
          return list;
        }
        tsParseTypeMemberSemicolon() {
          if (!this.eat(12) && !this.isLineTerminator()) {
            this.expect(13);
          }
        }
        tsParseSignatureMember(kind, node) {
          this.tsFillSignature(14, node);
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(node, kind);
        }
        tsIsUnambiguouslyIndexSignature() {
          this.next();
          if (tokenIsIdentifier(this.state.type)) {
            this.next();
            return this.match(14);
          }
          return false;
        }
        tsTryParseIndexSignature(node) {
          if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
            return;
          }
          this.expect(0);
          const id = this.parseIdentifier();
          id.typeAnnotation = this.tsParseTypeAnnotation();
          this.resetEndLocation(id);
          this.expect(3);
          node.parameters = [id];
          const type = this.tsTryParseTypeAnnotation();
          if (type)
            node.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(node, "TSIndexSignature");
        }
        tsParsePropertyOrMethodSignature(node, readonly) {
          if (this.eat(17))
            node.optional = true;
          const nodeAny = node;
          if (this.match(10) || this.match(47)) {
            if (readonly) {
              this.raise(TSErrors.ReadonlyForMethodSignature, {
                at: node
              });
            }
            const method = nodeAny;
            if (method.kind && this.match(47)) {
              this.raise(TSErrors.AccesorCannotHaveTypeParameters, {
                at: this.state.curPosition()
              });
            }
            this.tsFillSignature(14, method);
            this.tsParseTypeMemberSemicolon();
            const paramsKey = "parameters";
            const returnTypeKey = "typeAnnotation";
            if (method.kind === "get") {
              if (method[paramsKey].length > 0) {
                this.raise(Errors.BadGetterArity, {
                  at: this.state.curPosition()
                });
                if (this.isThisParam(method[paramsKey][0])) {
                  this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                    at: this.state.curPosition()
                  });
                }
              }
            } else if (method.kind === "set") {
              if (method[paramsKey].length !== 1) {
                this.raise(Errors.BadSetterArity, {
                  at: this.state.curPosition()
                });
              } else {
                const firstParameter = method[paramsKey][0];
                if (this.isThisParam(firstParameter)) {
                  this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                    at: this.state.curPosition()
                  });
                }
                if (firstParameter.type === "Identifier" && firstParameter.optional) {
                  this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {
                    at: this.state.curPosition()
                  });
                }
                if (firstParameter.type === "RestElement") {
                  this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {
                    at: this.state.curPosition()
                  });
                }
              }
              if (method[returnTypeKey]) {
                this.raise(TSErrors.SetAccesorCannotHaveReturnType, {
                  at: method[returnTypeKey]
                });
              }
            } else {
              method.kind = "method";
            }
            return this.finishNode(method, "TSMethodSignature");
          } else {
            const property = nodeAny;
            if (readonly)
              property.readonly = true;
            const type = this.tsTryParseTypeAnnotation();
            if (type)
              property.typeAnnotation = type;
            this.tsParseTypeMemberSemicolon();
            return this.finishNode(property, "TSPropertySignature");
          }
        }
        tsParseTypeMember() {
          const node = this.startNode();
          if (this.match(10) || this.match(47)) {
            return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
          }
          if (this.match(77)) {
            const id = this.startNode();
            this.next();
            if (this.match(10) || this.match(47)) {
              return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
            } else {
              node.key = this.createIdentifier(id, "new");
              return this.tsParsePropertyOrMethodSignature(node, false);
            }
          }
          this.tsParseModifiers({
            allowedModifiers: ["readonly"],
            disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
          }, node);
          const idx = this.tsTryParseIndexSignature(node);
          if (idx) {
            return idx;
          }
          super.parsePropertyName(node);
          if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
            node.kind = node.key.name;
            super.parsePropertyName(node);
          }
          return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
        }
        tsParseTypeLiteral() {
          const node = this.startNode();
          node.members = this.tsParseObjectTypeMembers();
          return this.finishNode(node, "TSTypeLiteral");
        }
        tsParseObjectTypeMembers() {
          this.expect(5);
          const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
          this.expect(8);
          return members;
        }
        tsIsStartOfMappedType() {
          this.next();
          if (this.eat(53)) {
            return this.isContextual(120);
          }
          if (this.isContextual(120)) {
            this.next();
          }
          if (!this.match(0)) {
            return false;
          }
          this.next();
          if (!this.tsIsIdentifier()) {
            return false;
          }
          this.next();
          return this.match(58);
        }
        tsParseMappedTypeParameter() {
          const node = this.startNode();
          node.name = this.tsParseTypeParameterName();
          node.constraint = this.tsExpectThenParseType(58);
          return this.finishNode(node, "TSTypeParameter");
        }
        tsParseMappedType() {
          const node = this.startNode();
          this.expect(5);
          if (this.match(53)) {
            node.readonly = this.state.value;
            this.next();
            this.expectContextual(120);
          } else if (this.eatContextual(120)) {
            node.readonly = true;
          }
          this.expect(0);
          node.typeParameter = this.tsParseMappedTypeParameter();
          node.nameType = this.eatContextual(93) ? this.tsParseType() : null;
          this.expect(3);
          if (this.match(53)) {
            node.optional = this.state.value;
            this.next();
            this.expect(17);
          } else if (this.eat(17)) {
            node.optional = true;
          }
          node.typeAnnotation = this.tsTryParseType();
          this.semicolon();
          this.expect(8);
          return this.finishNode(node, "TSMappedType");
        }
        tsParseTupleType() {
          const node = this.startNode();
          node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
          let seenOptionalElement = false;
          let labeledElements = null;
          node.elementTypes.forEach((elementNode) => {
            var _labeledElements;
            const {
              type
            } = elementNode;
            if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
              this.raise(TSErrors.OptionalTypeBeforeRequired, {
                at: elementNode
              });
            }
            seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
            let checkType = type;
            if (type === "TSRestType") {
              elementNode = elementNode.typeAnnotation;
              checkType = elementNode.type;
            }
            const isLabeled = checkType === "TSNamedTupleMember";
            (_labeledElements = labeledElements) != null ? _labeledElements : labeledElements = isLabeled;
            if (labeledElements !== isLabeled) {
              this.raise(TSErrors.MixedLabeledAndUnlabeledElements, {
                at: elementNode
              });
            }
          });
          return this.finishNode(node, "TSTupleType");
        }
        tsParseTupleElementType() {
          const {
            startLoc
          } = this.state;
          const rest = this.eat(21);
          let labeled;
          let label;
          let optional;
          let type;
          const isWord = tokenIsKeywordOrIdentifier(this.state.type);
          const chAfterWord = isWord ? this.lookaheadCharCode() : null;
          if (chAfterWord === 58) {
            labeled = true;
            optional = false;
            label = this.parseIdentifier(true);
            this.expect(14);
            type = this.tsParseType();
          } else if (chAfterWord === 63) {
            optional = true;
            const startLoc2 = this.state.startLoc;
            const wordName = this.state.value;
            const typeOrLabel = this.tsParseNonArrayType();
            if (this.lookaheadCharCode() === 58) {
              labeled = true;
              label = this.createIdentifier(this.startNodeAt(startLoc2), wordName);
              this.expect(17);
              this.expect(14);
              type = this.tsParseType();
            } else {
              labeled = false;
              type = typeOrLabel;
              this.expect(17);
            }
          } else {
            type = this.tsParseType();
            optional = this.eat(17);
            labeled = this.eat(14);
          }
          if (labeled) {
            let labeledNode;
            if (label) {
              labeledNode = this.startNodeAtNode(label);
              labeledNode.optional = optional;
              labeledNode.label = label;
              labeledNode.elementType = type;
              if (this.eat(17)) {
                labeledNode.optional = true;
                this.raise(TSErrors.TupleOptionalAfterType, {
                  at: this.state.lastTokStartLoc
                });
              }
            } else {
              labeledNode = this.startNodeAtNode(type);
              labeledNode.optional = optional;
              this.raise(TSErrors.InvalidTupleMemberLabel, {
                at: type
              });
              labeledNode.label = type;
              labeledNode.elementType = this.tsParseType();
            }
            type = this.finishNode(labeledNode, "TSNamedTupleMember");
          } else if (optional) {
            const optionalTypeNode = this.startNodeAtNode(type);
            optionalTypeNode.typeAnnotation = type;
            type = this.finishNode(optionalTypeNode, "TSOptionalType");
          }
          if (rest) {
            const restNode = this.startNodeAt(startLoc);
            restNode.typeAnnotation = type;
            type = this.finishNode(restNode, "TSRestType");
          }
          return type;
        }
        tsParseParenthesizedType() {
          const node = this.startNode();
          this.expect(10);
          node.typeAnnotation = this.tsParseType();
          this.expect(11);
          return this.finishNode(node, "TSParenthesizedType");
        }
        tsParseFunctionOrConstructorType(type, abstract) {
          const node = this.startNode();
          if (type === "TSConstructorType") {
            node.abstract = !!abstract;
            if (abstract)
              this.next();
            this.next();
          }
          this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));
          return this.finishNode(node, type);
        }
        tsParseLiteralTypeNode() {
          const node = this.startNode();
          switch (this.state.type) {
            case 132:
            case 133:
            case 131:
            case 85:
            case 86:
              node.literal = super.parseExprAtom();
              break;
            default:
              this.unexpected();
          }
          return this.finishNode(node, "TSLiteralType");
        }
        tsParseTemplateLiteralType() {
          const node = this.startNode();
          node.literal = super.parseTemplate(false);
          return this.finishNode(node, "TSLiteralType");
        }
        parseTemplateSubstitution() {
          if (this.state.inType)
            return this.tsParseType();
          return super.parseTemplateSubstitution();
        }
        tsParseThisTypeOrThisTypePredicate() {
          const thisKeyword = this.tsParseThisTypeNode();
          if (this.isContextual(114) && !this.hasPrecedingLineBreak()) {
            return this.tsParseThisTypePredicate(thisKeyword);
          } else {
            return thisKeyword;
          }
        }
        tsParseNonArrayType() {
          switch (this.state.type) {
            case 131:
            case 132:
            case 133:
            case 85:
            case 86:
              return this.tsParseLiteralTypeNode();
            case 53:
              if (this.state.value === "-") {
                const node = this.startNode();
                const nextToken = this.lookahead();
                if (nextToken.type !== 132 && nextToken.type !== 133) {
                  this.unexpected();
                }
                node.literal = this.parseMaybeUnary();
                return this.finishNode(node, "TSLiteralType");
              }
              break;
            case 78:
              return this.tsParseThisTypeOrThisTypePredicate();
            case 87:
              return this.tsParseTypeQuery();
            case 83:
              return this.tsParseImportType();
            case 5:
              return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
            case 0:
              return this.tsParseTupleType();
            case 10:
              return this.tsParseParenthesizedType();
            case 25:
            case 24:
              return this.tsParseTemplateLiteralType();
            default: {
              const {
                type
              } = this.state;
              if (tokenIsIdentifier(type) || type === 88 || type === 84) {
                const nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
                if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                  const node = this.startNode();
                  this.next();
                  return this.finishNode(node, nodeType);
                }
                return this.tsParseTypeReference();
              }
            }
          }
          this.unexpected();
        }
        tsParseArrayTypeOrHigher() {
          let type = this.tsParseNonArrayType();
          while (!this.hasPrecedingLineBreak() && this.eat(0)) {
            if (this.match(3)) {
              const node = this.startNodeAtNode(type);
              node.elementType = type;
              this.expect(3);
              type = this.finishNode(node, "TSArrayType");
            } else {
              const node = this.startNodeAtNode(type);
              node.objectType = type;
              node.indexType = this.tsParseType();
              this.expect(3);
              type = this.finishNode(node, "TSIndexedAccessType");
            }
          }
          return type;
        }
        tsParseTypeOperator() {
          const node = this.startNode();
          const operator = this.state.value;
          this.next();
          node.operator = operator;
          node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
          if (operator === "readonly") {
            this.tsCheckTypeAnnotationForReadOnly(node);
          }
          return this.finishNode(node, "TSTypeOperator");
        }
        tsCheckTypeAnnotationForReadOnly(node) {
          switch (node.typeAnnotation.type) {
            case "TSTupleType":
            case "TSArrayType":
              return;
            default:
              this.raise(TSErrors.UnexpectedReadonly, {
                at: node
              });
          }
        }
        tsParseInferType() {
          const node = this.startNode();
          this.expectContextual(113);
          const typeParameter = this.startNode();
          typeParameter.name = this.tsParseTypeParameterName();
          typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
          node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
          return this.finishNode(node, "TSInferType");
        }
        tsParseConstraintForInferType() {
          if (this.eat(81)) {
            const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
            if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
              return constraint;
            }
          }
        }
        tsParseTypeOperatorOrHigher() {
          const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
          return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(113) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
        }
        tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
          const node = this.startNode();
          const hasLeadingOperator = this.eat(operator);
          const types2 = [];
          do {
            types2.push(parseConstituentType());
          } while (this.eat(operator));
          if (types2.length === 1 && !hasLeadingOperator) {
            return types2[0];
          }
          node.types = types2;
          return this.finishNode(node, kind);
        }
        tsParseIntersectionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
        }
        tsParseUnionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
        }
        tsIsStartOfFunctionType() {
          if (this.match(47)) {
            return true;
          }
          return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
        }
        tsSkipParameterStart() {
          if (tokenIsIdentifier(this.state.type) || this.match(78)) {
            this.next();
            return true;
          }
          if (this.match(5)) {
            const {
              errors
            } = this.state;
            const previousErrorCount = errors.length;
            try {
              this.parseObjectLike(8, true);
              return errors.length === previousErrorCount;
            } catch (_unused) {
              return false;
            }
          }
          if (this.match(0)) {
            this.next();
            const {
              errors
            } = this.state;
            const previousErrorCount = errors.length;
            try {
              super.parseBindingList(3, 93, 1);
              return errors.length === previousErrorCount;
            } catch (_unused2) {
              return false;
            }
          }
          return false;
        }
        tsIsUnambiguouslyStartOfFunctionType() {
          this.next();
          if (this.match(11) || this.match(21)) {
            return true;
          }
          if (this.tsSkipParameterStart()) {
            if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
              return true;
            }
            if (this.match(11)) {
              this.next();
              if (this.match(19)) {
                return true;
              }
            }
          }
          return false;
        }
        tsParseTypeOrTypePredicateAnnotation(returnToken) {
          return this.tsInType(() => {
            const t = this.startNode();
            this.expect(returnToken);
            const node = this.startNode();
            const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
            if (asserts && this.match(78)) {
              let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
              if (thisTypePredicate.type === "TSThisType") {
                node.parameterName = thisTypePredicate;
                node.asserts = true;
                node.typeAnnotation = null;
                thisTypePredicate = this.finishNode(node, "TSTypePredicate");
              } else {
                this.resetStartLocationFromNode(thisTypePredicate, node);
                thisTypePredicate.asserts = true;
              }
              t.typeAnnotation = thisTypePredicate;
              return this.finishNode(t, "TSTypeAnnotation");
            }
            const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
            if (!typePredicateVariable) {
              if (!asserts) {
                return this.tsParseTypeAnnotation(false, t);
              }
              node.parameterName = this.parseIdentifier();
              node.asserts = asserts;
              node.typeAnnotation = null;
              t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
              return this.finishNode(t, "TSTypeAnnotation");
            }
            const type = this.tsParseTypeAnnotation(false);
            node.parameterName = typePredicateVariable;
            node.typeAnnotation = type;
            node.asserts = asserts;
            t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
            return this.finishNode(t, "TSTypeAnnotation");
          });
        }
        tsTryParseTypeOrTypePredicateAnnotation() {
          if (this.match(14)) {
            return this.tsParseTypeOrTypePredicateAnnotation(14);
          }
        }
        tsTryParseTypeAnnotation() {
          if (this.match(14)) {
            return this.tsParseTypeAnnotation();
          }
        }
        tsTryParseType() {
          return this.tsEatThenParseType(14);
        }
        tsParseTypePredicatePrefix() {
          const id = this.parseIdentifier();
          if (this.isContextual(114) && !this.hasPrecedingLineBreak()) {
            this.next();
            return id;
          }
        }
        tsParseTypePredicateAsserts() {
          if (this.state.type !== 107) {
            return false;
          }
          const containsEsc = this.state.containsEsc;
          this.next();
          if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
            return false;
          }
          if (containsEsc) {
            this.raise(Errors.InvalidEscapedReservedWord, {
              at: this.state.lastTokStartLoc,
              reservedWord: "asserts"
            });
          }
          return true;
        }
        tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
          this.tsInType(() => {
            if (eatColon)
              this.expect(14);
            t.typeAnnotation = this.tsParseType();
          });
          return this.finishNode(t, "TSTypeAnnotation");
        }
        tsParseType() {
          assert(this.state.inType);
          const type = this.tsParseNonConditionalType();
          if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
            return type;
          }
          const node = this.startNodeAtNode(type);
          node.checkType = type;
          node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
          this.expect(17);
          node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
          this.expect(14);
          node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
          return this.finishNode(node, "TSConditionalType");
        }
        isAbstractConstructorSignature() {
          return this.isContextual(122) && this.lookahead().type === 77;
        }
        tsParseNonConditionalType() {
          if (this.tsIsStartOfFunctionType()) {
            return this.tsParseFunctionOrConstructorType("TSFunctionType");
          }
          if (this.match(77)) {
            return this.tsParseFunctionOrConstructorType("TSConstructorType");
          } else if (this.isAbstractConstructorSignature()) {
            return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
          }
          return this.tsParseUnionTypeOrHigher();
        }
        tsParseTypeAssertion() {
          if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
            this.raise(TSErrors.ReservedTypeAssertion, {
              at: this.state.startLoc
            });
          }
          const node = this.startNode();
          node.typeAnnotation = this.tsInType(() => {
            this.next();
            return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();
          });
          this.expect(48);
          node.expression = this.parseMaybeUnary();
          return this.finishNode(node, "TSTypeAssertion");
        }
        tsParseHeritageClause(token) {
          const originalStartLoc = this.state.startLoc;
          const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
            const node = this.startNode();
            node.expression = this.tsParseEntityName();
            if (this.match(47)) {
              node.typeParameters = this.tsParseTypeArguments();
            }
            return this.finishNode(node, "TSExpressionWithTypeArguments");
          });
          if (!delimitedList.length) {
            this.raise(TSErrors.EmptyHeritageClauseType, {
              at: originalStartLoc,
              token
            });
          }
          return delimitedList;
        }
        tsParseInterfaceDeclaration(node, properties = {}) {
          if (this.hasFollowingLineBreak())
            return null;
          this.expectContextual(127);
          if (properties.declare)
            node.declare = true;
          if (tokenIsIdentifier(this.state.type)) {
            node.id = this.parseIdentifier();
            this.checkIdentifier(node.id, BIND_TS_INTERFACE);
          } else {
            node.id = null;
            this.raise(TSErrors.MissingInterfaceName, {
              at: this.state.startLoc
            });
          }
          node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
          if (this.eat(81)) {
            node.extends = this.tsParseHeritageClause("extends");
          }
          const body = this.startNode();
          body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
          node.body = this.finishNode(body, "TSInterfaceBody");
          return this.finishNode(node, "TSInterfaceDeclaration");
        }
        tsParseTypeAliasDeclaration(node) {
          node.id = this.parseIdentifier();
          this.checkIdentifier(node.id, BIND_TS_TYPE);
          node.typeAnnotation = this.tsInType(() => {
            node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);
            this.expect(29);
            if (this.isContextual(112) && this.lookahead().type !== 16) {
              const node2 = this.startNode();
              this.next();
              return this.finishNode(node2, "TSIntrinsicKeyword");
            }
            return this.tsParseType();
          });
          this.semicolon();
          return this.finishNode(node, "TSTypeAliasDeclaration");
        }
        tsInNoContext(cb) {
          const oldContext = this.state.context;
          this.state.context = [oldContext[0]];
          try {
            return cb();
          } finally {
            this.state.context = oldContext;
          }
        }
        tsInType(cb) {
          const oldInType = this.state.inType;
          this.state.inType = true;
          try {
            return cb();
          } finally {
            this.state.inType = oldInType;
          }
        }
        tsInDisallowConditionalTypesContext(cb) {
          const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
          this.state.inDisallowConditionalTypesContext = true;
          try {
            return cb();
          } finally {
            this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
          }
        }
        tsInAllowConditionalTypesContext(cb) {
          const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
          this.state.inDisallowConditionalTypesContext = false;
          try {
            return cb();
          } finally {
            this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
          }
        }
        tsEatThenParseType(token) {
          if (this.match(token)) {
            return this.tsNextThenParseType();
          }
        }
        tsExpectThenParseType(token) {
          return this.tsInType(() => {
            this.expect(token);
            return this.tsParseType();
          });
        }
        tsNextThenParseType() {
          return this.tsInType(() => {
            this.next();
            return this.tsParseType();
          });
        }
        tsParseEnumMember() {
          const node = this.startNode();
          node.id = this.match(131) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
          if (this.eat(29)) {
            node.initializer = super.parseMaybeAssignAllowIn();
          }
          return this.finishNode(node, "TSEnumMember");
        }
        tsParseEnumDeclaration(node, properties = {}) {
          if (properties.const)
            node.const = true;
          if (properties.declare)
            node.declare = true;
          this.expectContextual(124);
          node.id = this.parseIdentifier();
          this.checkIdentifier(node.id, node.const ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);
          this.expect(5);
          node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
          this.expect(8);
          return this.finishNode(node, "TSEnumDeclaration");
        }
        tsParseModuleBlock() {
          const node = this.startNode();
          this.scope.enter(SCOPE_OTHER);
          this.expect(5);
          super.parseBlockOrModuleBlockBody(node.body = [], void 0, true, 8);
          this.scope.exit();
          return this.finishNode(node, "TSModuleBlock");
        }
        tsParseModuleOrNamespaceDeclaration(node, nested = false) {
          node.id = this.parseIdentifier();
          if (!nested) {
            this.checkIdentifier(node.id, BIND_TS_NAMESPACE);
          }
          if (this.eat(16)) {
            const inner = this.startNode();
            this.tsParseModuleOrNamespaceDeclaration(inner, true);
            node.body = inner;
          } else {
            this.scope.enter(SCOPE_TS_MODULE);
            this.prodParam.enter(PARAM);
            node.body = this.tsParseModuleBlock();
            this.prodParam.exit();
            this.scope.exit();
          }
          return this.finishNode(node, "TSModuleDeclaration");
        }
        tsParseAmbientExternalModuleDeclaration(node) {
          if (this.isContextual(110)) {
            node.global = true;
            node.id = this.parseIdentifier();
          } else if (this.match(131)) {
            node.id = super.parseStringLiteral(this.state.value);
          } else {
            this.unexpected();
          }
          if (this.match(5)) {
            this.scope.enter(SCOPE_TS_MODULE);
            this.prodParam.enter(PARAM);
            node.body = this.tsParseModuleBlock();
            this.prodParam.exit();
            this.scope.exit();
          } else {
            this.semicolon();
          }
          return this.finishNode(node, "TSModuleDeclaration");
        }
        tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {
          node.isExport = isExport || false;
          node.id = maybeDefaultIdentifier || this.parseIdentifier();
          this.checkIdentifier(node.id, BIND_FLAGS_TS_IMPORT);
          this.expect(29);
          const moduleReference = this.tsParseModuleReference();
          if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
            this.raise(TSErrors.ImportAliasHasImportType, {
              at: moduleReference
            });
          }
          node.moduleReference = moduleReference;
          this.semicolon();
          return this.finishNode(node, "TSImportEqualsDeclaration");
        }
        tsIsExternalModuleReference() {
          return this.isContextual(117) && this.lookaheadCharCode() === 40;
        }
        tsParseModuleReference() {
          return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
        }
        tsParseExternalModuleReference() {
          const node = this.startNode();
          this.expectContextual(117);
          this.expect(10);
          if (!this.match(131)) {
            this.unexpected();
          }
          node.expression = super.parseExprAtom();
          this.expect(11);
          this.sawUnambiguousESM = true;
          return this.finishNode(node, "TSExternalModuleReference");
        }
        tsLookAhead(f) {
          const state = this.state.clone();
          const res = f();
          this.state = state;
          return res;
        }
        tsTryParseAndCatch(f) {
          const result = this.tryParse((abort) => f() || abort());
          if (result.aborted || !result.node)
            return;
          if (result.error)
            this.state = result.failState;
          return result.node;
        }
        tsTryParse(f) {
          const state = this.state.clone();
          const result = f();
          if (result !== void 0 && result !== false) {
            return result;
          }
          this.state = state;
        }
        tsTryParseDeclare(nany) {
          if (this.isLineTerminator()) {
            return;
          }
          let startType = this.state.type;
          let kind;
          if (this.isContextual(99)) {
            startType = 74;
            kind = "let";
          }
          return this.tsInAmbientContext(() => {
            switch (startType) {
              case 68:
                nany.declare = true;
                return super.parseFunctionStatement(nany, false, false);
              case 80:
                nany.declare = true;
                return this.parseClass(nany, true, false);
              case 124:
                return this.tsParseEnumDeclaration(nany, {
                  declare: true
                });
              case 110:
                return this.tsParseAmbientExternalModuleDeclaration(nany);
              case 75:
              case 74:
                if (!this.match(75) || !this.isLookaheadContextual("enum")) {
                  nany.declare = true;
                  return this.parseVarStatement(nany, kind || this.state.value, true);
                }
                this.expect(75);
                return this.tsParseEnumDeclaration(nany, {
                  const: true,
                  declare: true
                });
              case 127: {
                const result = this.tsParseInterfaceDeclaration(nany, {
                  declare: true
                });
                if (result)
                  return result;
              }
              default:
                if (tokenIsIdentifier(startType)) {
                  return this.tsParseDeclaration(nany, this.state.value, true, null);
                }
            }
          });
        }
        tsTryParseExportDeclaration() {
          return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
        }
        tsParseExpressionStatement(node, expr, decorators) {
          switch (expr.name) {
            case "declare": {
              const declaration = this.tsTryParseDeclare(node);
              if (declaration) {
                declaration.declare = true;
              }
              return declaration;
            }
            case "global":
              if (this.match(5)) {
                this.scope.enter(SCOPE_TS_MODULE);
                this.prodParam.enter(PARAM);
                const mod = node;
                mod.global = true;
                mod.id = expr;
                mod.body = this.tsParseModuleBlock();
                this.scope.exit();
                this.prodParam.exit();
                return this.finishNode(mod, "TSModuleDeclaration");
              }
              break;
            default:
              return this.tsParseDeclaration(node, expr.name, false, decorators);
          }
        }
        tsParseDeclaration(node, value, next, decorators) {
          switch (value) {
            case "abstract":
              if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
                return this.tsParseAbstractDeclaration(node, decorators);
              }
              break;
            case "module":
              if (this.tsCheckLineTerminator(next)) {
                if (this.match(131)) {
                  return this.tsParseAmbientExternalModuleDeclaration(node);
                } else if (tokenIsIdentifier(this.state.type)) {
                  return this.tsParseModuleOrNamespaceDeclaration(node);
                }
              }
              break;
            case "namespace":
              if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }
              break;
            case "type":
              if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
                return this.tsParseTypeAliasDeclaration(node);
              }
              break;
          }
        }
        tsCheckLineTerminator(next) {
          if (next) {
            if (this.hasFollowingLineBreak())
              return false;
            this.next();
            return true;
          }
          return !this.isLineTerminator();
        }
        tsTryParseGenericAsyncArrowFunction(startLoc) {
          if (!this.match(47))
            return;
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          this.state.maybeInArrowParameters = true;
          const res = this.tsTryParseAndCatch(() => {
            const node = this.startNodeAt(startLoc);
            node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
            super.parseFunctionParams(node);
            node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
            this.expect(19);
            return node;
          });
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          if (!res)
            return;
          return super.parseArrowExpression(res, null, true);
        }
        tsParseTypeArgumentsInExpression() {
          if (this.reScan_lt() !== 47)
            return;
          return this.tsParseTypeArguments();
        }
        tsParseTypeArguments() {
          const node = this.startNode();
          node.params = this.tsInType(() => this.tsInNoContext(() => {
            this.expect(47);
            return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
          }));
          if (node.params.length === 0) {
            this.raise(TSErrors.EmptyTypeArguments, {
              at: node
            });
          } else if (!this.state.inType && this.curContext() === types.brace) {
            this.reScan_lt_gt();
          }
          this.expect(48);
          return this.finishNode(node, "TSTypeParameterInstantiation");
        }
        tsIsDeclarationStart() {
          return tokenIsTSDeclarationStart(this.state.type);
        }
        isExportDefaultSpecifier() {
          if (this.tsIsDeclarationStart())
            return false;
          return super.isExportDefaultSpecifier();
        }
        parseAssignableListItem(flags, decorators) {
          const startLoc = this.state.startLoc;
          const modified = {};
          this.tsParseModifiers({
            allowedModifiers: ["public", "private", "protected", "override", "readonly"]
          }, modified);
          const accessibility = modified.accessibility;
          const override = modified.override;
          const readonly = modified.readonly;
          if (!(flags & 4) && (accessibility || readonly || override)) {
            this.raise(TSErrors.UnexpectedParameterModifier, {
              at: startLoc
            });
          }
          const left = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(left, flags);
          const elt = this.parseMaybeDefault(left.loc.start, left);
          if (accessibility || readonly || override) {
            const pp = this.startNodeAt(startLoc);
            if (decorators.length) {
              pp.decorators = decorators;
            }
            if (accessibility)
              pp.accessibility = accessibility;
            if (readonly)
              pp.readonly = readonly;
            if (override)
              pp.override = override;
            if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
              this.raise(TSErrors.UnsupportedParameterPropertyKind, {
                at: pp
              });
            }
            pp.parameter = elt;
            return this.finishNode(pp, "TSParameterProperty");
          }
          if (decorators.length) {
            left.decorators = decorators;
          }
          return elt;
        }
        isSimpleParameter(node) {
          return node.type === "TSParameterProperty" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);
        }
        tsDisallowOptionalPattern(node) {
          for (const param of node.params) {
            if (param.type !== "Identifier" && param.optional && !this.state.isAmbientContext) {
              this.raise(TSErrors.PatternIsOptional, {
                at: param
              });
            }
          }
        }
        setArrowFunctionParameters(node, params, trailingCommaLoc) {
          super.setArrowFunctionParameters(node, params, trailingCommaLoc);
          this.tsDisallowOptionalPattern(node);
        }
        parseFunctionBodyAndFinish(node, type, isMethod = false) {
          if (this.match(14)) {
            node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
          }
          const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
          if (bodilessType && !this.match(5) && this.isLineTerminator()) {
            return this.finishNode(node, bodilessType);
          }
          if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
            this.raise(TSErrors.DeclareFunctionHasImplementation, {
              at: node
            });
            if (node.declare) {
              return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);
            }
          }
          this.tsDisallowOptionalPattern(node);
          return super.parseFunctionBodyAndFinish(node, type, isMethod);
        }
        registerFunctionStatementId(node) {
          if (!node.body && node.id) {
            this.checkIdentifier(node.id, BIND_TS_AMBIENT);
          } else {
            super.registerFunctionStatementId(node);
          }
        }
        tsCheckForInvalidTypeCasts(items) {
          items.forEach((node) => {
            if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
              this.raise(TSErrors.UnexpectedTypeAnnotation, {
                at: node.typeAnnotation
              });
            }
          });
        }
        toReferencedList(exprList, isInParens) {
          this.tsCheckForInvalidTypeCasts(exprList);
          return exprList;
        }
        parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
          const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
          if (node.type === "ArrayExpression") {
            this.tsCheckForInvalidTypeCasts(node.elements);
          }
          return node;
        }
        parseSubscript(base, startLoc, noCalls, state) {
          if (!this.hasPrecedingLineBreak() && this.match(35)) {
            this.state.canStartJSXElement = false;
            this.next();
            const nonNullExpression = this.startNodeAt(startLoc);
            nonNullExpression.expression = base;
            return this.finishNode(nonNullExpression, "TSNonNullExpression");
          }
          let isOptionalCall = false;
          if (this.match(18) && this.lookaheadCharCode() === 60) {
            if (noCalls) {
              state.stop = true;
              return base;
            }
            state.optionalChainMember = isOptionalCall = true;
            this.next();
          }
          if (this.match(47) || this.match(51)) {
            let missingParenErrorLoc;
            const result = this.tsTryParseAndCatch(() => {
              if (!noCalls && this.atPossibleAsyncArrow(base)) {
                const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);
                if (asyncArrowFn) {
                  return asyncArrowFn;
                }
              }
              const typeArguments = this.tsParseTypeArgumentsInExpression();
              if (!typeArguments)
                return;
              if (isOptionalCall && !this.match(10)) {
                missingParenErrorLoc = this.state.curPosition();
                return;
              }
              if (tokenIsTemplate(this.state.type)) {
                const result2 = super.parseTaggedTemplateExpression(base, startLoc, state);
                result2.typeParameters = typeArguments;
                return result2;
              }
              if (!noCalls && this.eat(10)) {
                const node2 = this.startNodeAt(startLoc);
                node2.callee = base;
                node2.arguments = this.parseCallExpressionArguments(11, false);
                this.tsCheckForInvalidTypeCasts(node2.arguments);
                node2.typeParameters = typeArguments;
                if (state.optionalChainMember) {
                  node2.optional = isOptionalCall;
                }
                return this.finishCallExpression(node2, state.optionalChainMember);
              }
              const tokenType = this.state.type;
              if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {
                return;
              }
              const node = this.startNodeAt(startLoc);
              node.expression = base;
              node.typeParameters = typeArguments;
              return this.finishNode(node, "TSInstantiationExpression");
            });
            if (missingParenErrorLoc) {
              this.unexpected(missingParenErrorLoc, 10);
            }
            if (result) {
              if (result.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {
                this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, {
                  at: this.state.startLoc
                });
              }
              return result;
            }
          }
          return super.parseSubscript(base, startLoc, noCalls, state);
        }
        parseNewCallee(node) {
          var _callee$extra;
          super.parseNewCallee(node);
          const {
            callee
          } = node;
          if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
            node.typeParameters = callee.typeParameters;
            node.callee = callee.expression;
          }
        }
        parseExprOp(left, leftStartLoc, minPrec) {
          let isSatisfies;
          if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(118)))) {
            const node = this.startNodeAt(leftStartLoc);
            node.expression = left;
            node.typeAnnotation = this.tsInType(() => {
              this.next();
              if (this.match(75)) {
                if (isSatisfies) {
                  this.raise(Errors.UnexpectedKeyword, {
                    at: this.state.startLoc,
                    keyword: "const"
                  });
                }
                return this.tsParseTypeReference();
              }
              return this.tsParseType();
            });
            this.finishNode(node, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression");
            this.reScan_lt_gt();
            return this.parseExprOp(node, leftStartLoc, minPrec);
          }
          return super.parseExprOp(left, leftStartLoc, minPrec);
        }
        checkReservedWord(word, startLoc, checkKeywords, isBinding) {
          if (!this.state.isAmbientContext) {
            super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
          }
        }
        checkImportReflection(node) {
          super.checkImportReflection(node);
          if (node.module && node.importKind !== "value") {
            this.raise(TSErrors.ImportReflectionHasImportType, {
              at: node.specifiers[0].loc.start
            });
          }
        }
        checkDuplicateExports() {
        }
        isPotentialImportPhase(isExport) {
          if (super.isPotentialImportPhase(isExport))
            return true;
          if (this.isContextual(128)) {
            const ch = this.lookaheadCharCode();
            return isExport ? ch === 123 || ch === 42 : ch !== 61;
          }
          return !isExport && this.isContextual(87);
        }
        applyImportPhase(node, isExport, phase, loc) {
          super.applyImportPhase(node, isExport, phase, loc);
          if (isExport) {
            node.exportKind = phase === "type" ? "type" : "value";
          } else {
            node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
          }
        }
        parseImport(node) {
          if (this.match(131)) {
            node.importKind = "value";
            return super.parseImport(node);
          }
          let importNode;
          if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {
            node.importKind = "value";
            return this.tsParseImportEqualsDeclaration(node);
          } else if (this.isContextual(128)) {
            const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);
            if (this.lookaheadCharCode() === 61) {
              return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);
            } else {
              importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);
            }
          } else {
            importNode = super.parseImport(node);
          }
          if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
            this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {
              at: importNode
            });
          }
          return importNode;
        }
        parseExport(node, decorators) {
          if (this.match(83)) {
            this.next();
            let maybeDefaultIdentifier = null;
            if (this.isContextual(128) && this.isPotentialImportPhase(false)) {
              maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);
            } else {
              node.importKind = "value";
            }
            return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, true);
          } else if (this.eat(29)) {
            const assign = node;
            assign.expression = super.parseExpression();
            this.semicolon();
            this.sawUnambiguousESM = true;
            return this.finishNode(assign, "TSExportAssignment");
          } else if (this.eatContextual(93)) {
            const decl = node;
            this.expectContextual(126);
            decl.id = this.parseIdentifier();
            this.semicolon();
            return this.finishNode(decl, "TSNamespaceExportDeclaration");
          } else {
            return super.parseExport(node, decorators);
          }
        }
        isAbstractClass() {
          return this.isContextual(122) && this.lookahead().type === 80;
        }
        parseExportDefaultExpression() {
          if (this.isAbstractClass()) {
            const cls = this.startNode();
            this.next();
            cls.abstract = true;
            return this.parseClass(cls, true, true);
          }
          if (this.match(127)) {
            const result = this.tsParseInterfaceDeclaration(this.startNode());
            if (result)
              return result;
          }
          return super.parseExportDefaultExpression();
        }
        parseVarStatement(node, kind, allowMissingInitializer = false) {
          const {
            isAmbientContext
          } = this.state;
          const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);
          if (!isAmbientContext)
            return declaration;
          for (const {
            id,
            init
          } of declaration.declarations) {
            if (!init)
              continue;
            if (kind !== "const" || !!id.typeAnnotation) {
              this.raise(TSErrors.InitializerNotAllowedInAmbientContext, {
                at: init
              });
            } else if (!isValidAmbientConstInitializer(init, this.hasPlugin("estree"))) {
              this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {
                at: init
              });
            }
          }
          return declaration;
        }
        parseStatementContent(flags, decorators) {
          if (this.match(75) && this.isLookaheadContextual("enum")) {
            const node = this.startNode();
            this.expect(75);
            return this.tsParseEnumDeclaration(node, {
              const: true
            });
          }
          if (this.isContextual(124)) {
            return this.tsParseEnumDeclaration(this.startNode());
          }
          if (this.isContextual(127)) {
            const result = this.tsParseInterfaceDeclaration(this.startNode());
            if (result)
              return result;
          }
          return super.parseStatementContent(flags, decorators);
        }
        parseAccessModifier() {
          return this.tsParseModifier(["public", "protected", "private"]);
        }
        tsHasSomeModifiers(member, modifiers) {
          return modifiers.some((modifier) => {
            if (tsIsAccessModifier(modifier)) {
              return member.accessibility === modifier;
            }
            return !!member[modifier];
          });
        }
        tsIsStartOfStaticBlocks() {
          return this.isContextual(104) && this.lookaheadCharCode() === 123;
        }
        parseClassMember(classBody, member, state) {
          const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
          this.tsParseModifiers({
            allowedModifiers: modifiers,
            disallowedModifiers: ["in", "out"],
            stopOnStartOfClassStaticBlock: true,
            errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
          }, member);
          const callParseClassMemberWithIsStatic = () => {
            if (this.tsIsStartOfStaticBlocks()) {
              this.next();
              this.next();
              if (this.tsHasSomeModifiers(member, modifiers)) {
                this.raise(TSErrors.StaticBlockCannotHaveModifier, {
                  at: this.state.curPosition()
                });
              }
              super.parseClassStaticBlock(classBody, member);
            } else {
              this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
            }
          };
          if (member.declare) {
            this.tsInAmbientContext(callParseClassMemberWithIsStatic);
          } else {
            callParseClassMemberWithIsStatic();
          }
        }
        parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
          const idx = this.tsTryParseIndexSignature(member);
          if (idx) {
            classBody.body.push(idx);
            if (member.abstract) {
              this.raise(TSErrors.IndexSignatureHasAbstract, {
                at: member
              });
            }
            if (member.accessibility) {
              this.raise(TSErrors.IndexSignatureHasAccessibility, {
                at: member,
                modifier: member.accessibility
              });
            }
            if (member.declare) {
              this.raise(TSErrors.IndexSignatureHasDeclare, {
                at: member
              });
            }
            if (member.override) {
              this.raise(TSErrors.IndexSignatureHasOverride, {
                at: member
              });
            }
            return;
          }
          if (!this.state.inAbstractClass && member.abstract) {
            this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {
              at: member
            });
          }
          if (member.override) {
            if (!state.hadSuperClass) {
              this.raise(TSErrors.OverrideNotInSubClass, {
                at: member
              });
            }
          }
          super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
        }
        parsePostMemberNameModifiers(methodOrProp) {
          const optional = this.eat(17);
          if (optional)
            methodOrProp.optional = true;
          if (methodOrProp.readonly && this.match(10)) {
            this.raise(TSErrors.ClassMethodHasReadonly, {
              at: methodOrProp
            });
          }
          if (methodOrProp.declare && this.match(10)) {
            this.raise(TSErrors.ClassMethodHasDeclare, {
              at: methodOrProp
            });
          }
        }
        parseExpressionStatement(node, expr, decorators) {
          const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr, decorators) : void 0;
          return decl || super.parseExpressionStatement(node, expr, decorators);
        }
        shouldParseExportDeclaration() {
          if (this.tsIsDeclarationStart())
            return true;
          return super.shouldParseExportDeclaration();
        }
        parseConditional(expr, startLoc, refExpressionErrors) {
          if (!this.state.maybeInArrowParameters || !this.match(17)) {
            return super.parseConditional(expr, startLoc, refExpressionErrors);
          }
          const result = this.tryParse(() => super.parseConditional(expr, startLoc));
          if (!result.node) {
            if (result.error) {
              super.setOptionalParametersError(refExpressionErrors, result.error);
            }
            return expr;
          }
          if (result.error)
            this.state = result.failState;
          return result.node;
        }
        parseParenItem(node, startLoc) {
          node = super.parseParenItem(node, startLoc);
          if (this.eat(17)) {
            node.optional = true;
            this.resetEndLocation(node);
          }
          if (this.match(14)) {
            const typeCastNode = this.startNodeAt(startLoc);
            typeCastNode.expression = node;
            typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
            return this.finishNode(typeCastNode, "TSTypeCastExpression");
          }
          return node;
        }
        parseExportDeclaration(node) {
          if (!this.state.isAmbientContext && this.isContextual(123)) {
            return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
          }
          const startLoc = this.state.startLoc;
          const isDeclare = this.eatContextual(123);
          if (isDeclare && (this.isContextual(123) || !this.shouldParseExportDeclaration())) {
            throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {
              at: this.state.startLoc
            });
          }
          const isIdentifier = tokenIsIdentifier(this.state.type);
          const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);
          if (!declaration)
            return null;
          if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
            node.exportKind = "type";
          }
          if (isDeclare) {
            this.resetStartLocation(declaration, startLoc);
            declaration.declare = true;
          }
          return declaration;
        }
        parseClassId(node, isStatement, optionalId, bindingType) {
          if ((!isStatement || optionalId) && this.isContextual(111)) {
            return;
          }
          super.parseClassId(node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);
          const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
          if (typeParameters)
            node.typeParameters = typeParameters;
        }
        parseClassPropertyAnnotation(node) {
          if (!node.optional) {
            if (this.eat(35)) {
              node.definite = true;
            } else if (this.eat(17)) {
              node.optional = true;
            }
          }
          const type = this.tsTryParseTypeAnnotation();
          if (type)
            node.typeAnnotation = type;
        }
        parseClassProperty(node) {
          this.parseClassPropertyAnnotation(node);
          if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {
            this.raise(TSErrors.DeclareClassFieldHasInitializer, {
              at: this.state.startLoc
            });
          }
          if (node.abstract && this.match(29)) {
            const {
              key
            } = node;
            this.raise(TSErrors.AbstractPropertyHasInitializer, {
              at: this.state.startLoc,
              propertyName: key.type === "Identifier" && !node.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
            });
          }
          return super.parseClassProperty(node);
        }
        parseClassPrivateProperty(node) {
          if (node.abstract) {
            this.raise(TSErrors.PrivateElementHasAbstract, {
              at: node
            });
          }
          if (node.accessibility) {
            this.raise(TSErrors.PrivateElementHasAccessibility, {
              at: node,
              modifier: node.accessibility
            });
          }
          this.parseClassPropertyAnnotation(node);
          return super.parseClassPrivateProperty(node);
        }
        parseClassAccessorProperty(node) {
          this.parseClassPropertyAnnotation(node);
          if (node.optional) {
            this.raise(TSErrors.AccessorCannotBeOptional, {
              at: node
            });
          }
          return super.parseClassAccessorProperty(node);
        }
        pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
          if (typeParameters && isConstructor) {
            this.raise(TSErrors.ConstructorHasTypeParameters, {
              at: typeParameters
            });
          }
          const {
            declare = false,
            kind
          } = method;
          if (declare && (kind === "get" || kind === "set")) {
            this.raise(TSErrors.DeclareAccessor, {
              at: method,
              kind
            });
          }
          if (typeParameters)
            method.typeParameters = typeParameters;
          super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
        }
        pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
          const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
          if (typeParameters)
            method.typeParameters = typeParameters;
          super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
        }
        declareClassPrivateMethodInScope(node, kind) {
          if (node.type === "TSDeclareMethod")
            return;
          if (node.type === "MethodDefinition" && !node.value.body)
            return;
          super.declareClassPrivateMethodInScope(node, kind);
        }
        parseClassSuper(node) {
          super.parseClassSuper(node);
          if (node.superClass && (this.match(47) || this.match(51))) {
            node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
          }
          if (this.eatContextual(111)) {
            node.implements = this.tsParseHeritageClause("implements");
          }
        }
        parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
          const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
          if (typeParameters)
            prop.typeParameters = typeParameters;
          return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
        }
        parseFunctionParams(node, isConstructor) {
          const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
          if (typeParameters)
            node.typeParameters = typeParameters;
          super.parseFunctionParams(node, isConstructor);
        }
        parseVarId(decl, kind) {
          super.parseVarId(decl, kind);
          if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
            decl.definite = true;
          }
          const type = this.tsTryParseTypeAnnotation();
          if (type) {
            decl.id.typeAnnotation = type;
            this.resetEndLocation(decl.id);
          }
        }
        parseAsyncArrowFromCallExpression(node, call) {
          if (this.match(14)) {
            node.returnType = this.tsParseTypeAnnotation();
          }
          return super.parseAsyncArrowFromCallExpression(node, call);
        }
        parseMaybeAssign(refExpressionErrors, afterLeftParse) {
          var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;
          let state;
          let jsx2;
          let typeCast;
          if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
            state = this.state.clone();
            jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
            if (!jsx2.error)
              return jsx2.node;
            const {
              context
            } = this.state;
            const currentContext = context[context.length - 1];
            if (currentContext === types.j_oTag || currentContext === types.j_expr) {
              context.pop();
            }
          }
          if (!((_jsx = jsx2) != null && _jsx.error) && !this.match(47)) {
            return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
          }
          if (!state || state === this.state)
            state = this.state.clone();
          let typeParameters;
          const arrow = this.tryParse((abort) => {
            var _expr$extra, _typeParameters;
            typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
            const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
            if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
              abort();
            }
            if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
              this.resetStartLocationFromNode(expr, typeParameters);
            }
            expr.typeParameters = typeParameters;
            return expr;
          }, state);
          if (!arrow.error && !arrow.aborted) {
            if (typeParameters)
              this.reportReservedArrowTypeParam(typeParameters);
            return arrow.node;
          }
          if (!jsx2) {
            assert(!this.hasPlugin("jsx"));
            typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
            if (!typeCast.error)
              return typeCast.node;
          }
          if ((_jsx2 = jsx2) != null && _jsx2.node) {
            this.state = jsx2.failState;
            return jsx2.node;
          }
          if (arrow.node) {
            this.state = arrow.failState;
            if (typeParameters)
              this.reportReservedArrowTypeParam(typeParameters);
            return arrow.node;
          }
          if ((_typeCast = typeCast) != null && _typeCast.node) {
            this.state = typeCast.failState;
            return typeCast.node;
          }
          throw ((_jsx3 = jsx2) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);
        }
        reportReservedArrowTypeParam(node) {
          var _node$extra;
          if (node.params.length === 1 && !node.params[0].constraint && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
            this.raise(TSErrors.ReservedArrowTypeParam, {
              at: node
            });
          }
        }
        parseMaybeUnary(refExpressionErrors, sawUnary) {
          if (!this.hasPlugin("jsx") && this.match(47)) {
            return this.tsParseTypeAssertion();
          }
          return super.parseMaybeUnary(refExpressionErrors, sawUnary);
        }
        parseArrow(node) {
          if (this.match(14)) {
            const result = this.tryParse((abort) => {
              const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
              if (this.canInsertSemicolon() || !this.match(19))
                abort();
              return returnType;
            });
            if (result.aborted)
              return;
            if (!result.thrown) {
              if (result.error)
                this.state = result.failState;
              node.returnType = result.node;
            }
          }
          return super.parseArrow(node);
        }
        parseAssignableListItemTypes(param, flags) {
          if (!(flags & 2))
            return param;
          if (this.eat(17)) {
            param.optional = true;
          }
          const type = this.tsTryParseTypeAnnotation();
          if (type)
            param.typeAnnotation = type;
          this.resetEndLocation(param);
          return param;
        }
        isAssignable(node, isBinding) {
          switch (node.type) {
            case "TSTypeCastExpression":
              return this.isAssignable(node.expression, isBinding);
            case "TSParameterProperty":
              return true;
            default:
              return super.isAssignable(node, isBinding);
          }
        }
        toAssignable(node, isLHS = false) {
          switch (node.type) {
            case "ParenthesizedExpression":
              this.toAssignableParenthesizedExpression(node, isLHS);
              break;
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSNonNullExpression":
            case "TSTypeAssertion":
              if (isLHS) {
                this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, {
                  at: node
                });
              } else {
                this.raise(TSErrors.UnexpectedTypeCastInParameter, {
                  at: node
                });
              }
              this.toAssignable(node.expression, isLHS);
              break;
            case "AssignmentExpression":
              if (!isLHS && node.left.type === "TSTypeCastExpression") {
                node.left = this.typeCastToParameter(node.left);
              }
            default:
              super.toAssignable(node, isLHS);
          }
        }
        toAssignableParenthesizedExpression(node, isLHS) {
          switch (node.expression.type) {
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSNonNullExpression":
            case "TSTypeAssertion":
            case "ParenthesizedExpression":
              this.toAssignable(node.expression, isLHS);
              break;
            default:
              super.toAssignable(node, isLHS);
          }
        }
        checkToRestConversion(node, allowPattern) {
          switch (node.type) {
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSTypeAssertion":
            case "TSNonNullExpression":
              this.checkToRestConversion(node.expression, false);
              break;
            default:
              super.checkToRestConversion(node, allowPattern);
          }
        }
        isValidLVal(type, isUnparenthesizedInAssign, binding) {
          return getOwn({
            TSTypeCastExpression: true,
            TSParameterProperty: "parameter",
            TSNonNullExpression: "expression",
            TSAsExpression: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && ["expression", true],
            TSSatisfiesExpression: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && ["expression", true],
            TSTypeAssertion: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && ["expression", true]
          }, type) || super.isValidLVal(type, isUnparenthesizedInAssign, binding);
        }
        parseBindingAtom() {
          if (this.state.type === 78) {
            return this.parseIdentifier(true);
          }
          return super.parseBindingAtom();
        }
        parseMaybeDecoratorArguments(expr) {
          if (this.match(47) || this.match(51)) {
            const typeArguments = this.tsParseTypeArgumentsInExpression();
            if (this.match(10)) {
              const call = super.parseMaybeDecoratorArguments(expr);
              call.typeParameters = typeArguments;
              return call;
            }
            this.unexpected(null, 10);
          }
          return super.parseMaybeDecoratorArguments(expr);
        }
        checkCommaAfterRest(close) {
          if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
            this.next();
            return false;
          }
          return super.checkCommaAfterRest(close);
        }
        isClassMethod() {
          return this.match(47) || super.isClassMethod();
        }
        isClassProperty() {
          return this.match(35) || this.match(14) || super.isClassProperty();
        }
        parseMaybeDefault(startLoc, left) {
          const node = super.parseMaybeDefault(startLoc, left);
          if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
            this.raise(TSErrors.TypeAnnotationAfterAssign, {
              at: node.typeAnnotation
            });
          }
          return node;
        }
        getTokenFromCode(code) {
          if (this.state.inType) {
            if (code === 62) {
              this.finishOp(48, 1);
              return;
            }
            if (code === 60) {
              this.finishOp(47, 1);
              return;
            }
          }
          super.getTokenFromCode(code);
        }
        reScan_lt_gt() {
          const {
            type
          } = this.state;
          if (type === 47) {
            this.state.pos -= 1;
            this.readToken_lt();
          } else if (type === 48) {
            this.state.pos -= 1;
            this.readToken_gt();
          }
        }
        reScan_lt() {
          const {
            type
          } = this.state;
          if (type === 51) {
            this.state.pos -= 2;
            this.finishOp(47, 1);
            return 47;
          }
          return type;
        }
        toAssignableList(exprList, trailingCommaLoc, isLHS) {
          for (let i = 0; i < exprList.length; i++) {
            const expr = exprList[i];
            if ((expr == null ? void 0 : expr.type) === "TSTypeCastExpression") {
              exprList[i] = this.typeCastToParameter(expr);
            }
          }
          super.toAssignableList(exprList, trailingCommaLoc, isLHS);
        }
        typeCastToParameter(node) {
          node.expression.typeAnnotation = node.typeAnnotation;
          this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
          return node.expression;
        }
        shouldParseArrow(params) {
          if (this.match(14)) {
            return params.every((expr) => this.isAssignable(expr, true));
          }
          return super.shouldParseArrow(params);
        }
        shouldParseAsyncArrow() {
          return this.match(14) || super.shouldParseAsyncArrow();
        }
        canHaveLeadingDecorator() {
          return super.canHaveLeadingDecorator() || this.isAbstractClass();
        }
        jsxParseOpeningElementAfterName(node) {
          if (this.match(47) || this.match(51)) {
            const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
            if (typeArguments)
              node.typeParameters = typeArguments;
          }
          return super.jsxParseOpeningElementAfterName(node);
        }
        getGetterSetterExpectedParamCount(method) {
          const baseCount = super.getGetterSetterExpectedParamCount(method);
          const params = this.getObjectOrClassMethodParams(method);
          const firstParam = params[0];
          const hasContextParam = firstParam && this.isThisParam(firstParam);
          return hasContextParam ? baseCount + 1 : baseCount;
        }
        parseCatchClauseParam() {
          const param = super.parseCatchClauseParam();
          const type = this.tsTryParseTypeAnnotation();
          if (type) {
            param.typeAnnotation = type;
            this.resetEndLocation(param);
          }
          return param;
        }
        tsInAmbientContext(cb) {
          const oldIsAmbientContext = this.state.isAmbientContext;
          this.state.isAmbientContext = true;
          try {
            return cb();
          } finally {
            this.state.isAmbientContext = oldIsAmbientContext;
          }
        }
        parseClass(node, isStatement, optionalId) {
          const oldInAbstractClass = this.state.inAbstractClass;
          this.state.inAbstractClass = !!node.abstract;
          try {
            return super.parseClass(node, isStatement, optionalId);
          } finally {
            this.state.inAbstractClass = oldInAbstractClass;
          }
        }
        tsParseAbstractDeclaration(node, decorators) {
          if (this.match(80)) {
            node.abstract = true;
            return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));
          } else if (this.isContextual(127)) {
            if (!this.hasFollowingLineBreak()) {
              node.abstract = true;
              this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {
                at: node
              });
              return this.tsParseInterfaceDeclaration(node);
            }
          } else {
            this.unexpected(null, 80);
          }
        }
        parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
          const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
          if (method.abstract) {
            const hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;
            if (hasBody) {
              const {
                key
              } = method;
              this.raise(TSErrors.AbstractMethodHasImplementation, {
                at: method,
                methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
              });
            }
          }
          return method;
        }
        tsParseTypeParameterName() {
          const typeName = this.parseIdentifier();
          return typeName.name;
        }
        shouldParseAsAmbientContext() {
          return !!this.getPluginOption("typescript", "dts");
        }
        parse() {
          if (this.shouldParseAsAmbientContext()) {
            this.state.isAmbientContext = true;
          }
          return super.parse();
        }
        getExpression() {
          if (this.shouldParseAsAmbientContext()) {
            this.state.isAmbientContext = true;
          }
          return super.getExpression();
        }
        parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
          if (!isString && isMaybeTypeOnly) {
            this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
            return this.finishNode(node, "ExportSpecifier");
          }
          node.exportKind = "value";
          return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);
        }
        parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
          if (!importedIsString && isMaybeTypeOnly) {
            this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
            return this.finishNode(specifier, "ImportSpecifier");
          }
          specifier.importKind = "value";
          return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? BIND_TS_TYPE_IMPORT : BIND_FLAGS_TS_IMPORT);
        }
        parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
          const leftOfAsKey = isImport ? "imported" : "local";
          const rightOfAsKey = isImport ? "local" : "exported";
          let leftOfAs = node[leftOfAsKey];
          let rightOfAs;
          let hasTypeSpecifier = false;
          let canParseAsKeyword = true;
          const loc = leftOfAs.loc.start;
          if (this.isContextual(93)) {
            const firstAs = this.parseIdentifier();
            if (this.isContextual(93)) {
              const secondAs = this.parseIdentifier();
              if (tokenIsKeywordOrIdentifier(this.state.type)) {
                hasTypeSpecifier = true;
                leftOfAs = firstAs;
                rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
                canParseAsKeyword = false;
              } else {
                rightOfAs = secondAs;
                canParseAsKeyword = false;
              }
            } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
              canParseAsKeyword = false;
              rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
            } else {
              hasTypeSpecifier = true;
              leftOfAs = firstAs;
            }
          } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
            hasTypeSpecifier = true;
            if (isImport) {
              leftOfAs = this.parseIdentifier(true);
              if (!this.isContextual(93)) {
                this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
              }
            } else {
              leftOfAs = this.parseModuleExportName();
            }
          }
          if (hasTypeSpecifier && isInTypeOnlyImportExport) {
            this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, {
              at: loc
            });
          }
          node[leftOfAsKey] = leftOfAs;
          node[rightOfAsKey] = rightOfAs;
          const kindKey = isImport ? "importKind" : "exportKind";
          node[kindKey] = hasTypeSpecifier ? "type" : "value";
          if (canParseAsKeyword && this.eatContextual(93)) {
            node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
          }
          if (!node[rightOfAsKey]) {
            node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);
          }
          if (isImport) {
            this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? BIND_TS_TYPE_IMPORT : BIND_FLAGS_TS_IMPORT);
          }
        }
      };
      function isPossiblyLiteralEnum(expression) {
        if (expression.type !== "MemberExpression")
          return false;
        const {
          computed,
          property
        } = expression;
        if (computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
          return false;
        }
        return isUncomputedMemberExpressionChain(expression.object);
      }
      function isValidAmbientConstInitializer(expression, estree2) {
        var _expression$extra;
        const {
          type
        } = expression;
        if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {
          return false;
        }
        if (estree2) {
          if (type === "Literal") {
            const {
              value
            } = expression;
            if (typeof value === "string" || typeof value === "boolean") {
              return true;
            }
          }
        } else {
          if (type === "StringLiteral" || type === "BooleanLiteral") {
            return true;
          }
        }
        if (isNumber(expression, estree2) || isNegativeNumber(expression, estree2)) {
          return true;
        }
        if (type === "TemplateLiteral" && expression.expressions.length === 0) {
          return true;
        }
        if (isPossiblyLiteralEnum(expression)) {
          return true;
        }
        return false;
      }
      function isNumber(expression, estree2) {
        if (estree2) {
          return expression.type === "Literal" && (typeof expression.value === "number" || "bigint" in expression);
        }
        return expression.type === "NumericLiteral" || expression.type === "BigIntLiteral";
      }
      function isNegativeNumber(expression, estree2) {
        if (expression.type === "UnaryExpression") {
          const {
            operator,
            argument
          } = expression;
          if (operator === "-" && isNumber(argument, estree2)) {
            return true;
          }
        }
        return false;
      }
      function isUncomputedMemberExpressionChain(expression) {
        if (expression.type === "Identifier")
          return true;
        if (expression.type !== "MemberExpression" || expression.computed) {
          return false;
        }
        return isUncomputedMemberExpressionChain(expression.object);
      }
      var PlaceholderErrors = ParseErrorEnum`placeholders`({
        ClassNameIsRequired: "A class name is required.",
        UnexpectedSpace: "Unexpected space in placeholder."
      });
      var placeholders = (superClass) => class PlaceholdersParserMixin extends superClass {
        parsePlaceholder(expectedNode) {
          if (this.match(142)) {
            const node = this.startNode();
            this.next();
            this.assertNoSpace();
            node.name = super.parseIdentifier(true);
            this.assertNoSpace();
            this.expect(142);
            return this.finishPlaceholder(node, expectedNode);
          }
        }
        finishPlaceholder(node, expectedNode) {
          const isFinished = !!(node.expectedNode && node.type === "Placeholder");
          node.expectedNode = expectedNode;
          return isFinished ? node : this.finishNode(node, "Placeholder");
        }
        getTokenFromCode(code) {
          if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
            this.finishOp(142, 2);
          } else {
            super.getTokenFromCode(code);
          }
        }
        parseExprAtom(refExpressionErrors) {
          return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
        }
        parseIdentifier(liberal) {
          return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
        }
        checkReservedWord(word, startLoc, checkKeywords, isBinding) {
          if (word !== void 0) {
            super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
          }
        }
        parseBindingAtom() {
          return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
        }
        isValidLVal(type, isParenthesized, binding) {
          return type === "Placeholder" || super.isValidLVal(type, isParenthesized, binding);
        }
        toAssignable(node, isLHS) {
          if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
            node.expectedNode = "Pattern";
          } else {
            super.toAssignable(node, isLHS);
          }
        }
        chStartsBindingIdentifier(ch, pos) {
          if (super.chStartsBindingIdentifier(ch, pos)) {
            return true;
          }
          const nextToken = this.lookahead();
          if (nextToken.type === 142) {
            return true;
          }
          return false;
        }
        verifyBreakContinue(node, isBreak) {
          if (node.label && node.label.type === "Placeholder")
            return;
          super.verifyBreakContinue(node, isBreak);
        }
        parseExpressionStatement(node, expr) {
          if (expr.type !== "Placeholder" || expr.extra && expr.extra.parenthesized) {
            return super.parseExpressionStatement(node, expr);
          }
          if (this.match(14)) {
            const stmt = node;
            stmt.label = this.finishPlaceholder(expr, "Identifier");
            this.next();
            stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();
            return this.finishNode(stmt, "LabeledStatement");
          }
          this.semicolon();
          node.name = expr.name;
          return this.finishPlaceholder(node, "Statement");
        }
        parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
          return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
        }
        parseFunctionId(requireId) {
          return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
        }
        parseClass(node, isStatement, optionalId) {
          const type = isStatement ? "ClassDeclaration" : "ClassExpression";
          this.next();
          const oldStrict = this.state.strict;
          const placeholder = this.parsePlaceholder("Identifier");
          if (placeholder) {
            if (this.match(81) || this.match(142) || this.match(5)) {
              node.id = placeholder;
            } else if (optionalId || !isStatement) {
              node.id = null;
              node.body = this.finishPlaceholder(placeholder, "ClassBody");
              return this.finishNode(node, type);
            } else {
              throw this.raise(PlaceholderErrors.ClassNameIsRequired, {
                at: this.state.startLoc
              });
            }
          } else {
            this.parseClassId(node, isStatement, optionalId);
          }
          super.parseClassSuper(node);
          node.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node.superClass, oldStrict);
          return this.finishNode(node, type);
        }
        parseExport(node, decorators) {
          const placeholder = this.parsePlaceholder("Identifier");
          if (!placeholder)
            return super.parseExport(node, decorators);
          if (!this.isContextual(97) && !this.match(12)) {
            node.specifiers = [];
            node.source = null;
            node.declaration = this.finishPlaceholder(placeholder, "Declaration");
            return this.finishNode(node, "ExportNamedDeclaration");
          }
          this.expectPlugin("exportDefaultFrom");
          const specifier = this.startNode();
          specifier.exported = placeholder;
          node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
          return super.parseExport(node, decorators);
        }
        isExportDefaultSpecifier() {
          if (this.match(65)) {
            const next = this.nextTokenStart();
            if (this.isUnparsedContextual(next, "from")) {
              if (this.input.startsWith(tokenLabelName(142), this.nextTokenStartSince(next + 4))) {
                return true;
              }
            }
          }
          return super.isExportDefaultSpecifier();
        }
        maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
          var _specifiers;
          if ((_specifiers = node.specifiers) != null && _specifiers.length) {
            return true;
          }
          return super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
        }
        checkExport(node) {
          const {
            specifiers
          } = node;
          if (specifiers != null && specifiers.length) {
            node.specifiers = specifiers.filter((node2) => node2.exported.type === "Placeholder");
          }
          super.checkExport(node);
          node.specifiers = specifiers;
        }
        parseImport(node) {
          const placeholder = this.parsePlaceholder("Identifier");
          if (!placeholder)
            return super.parseImport(node);
          node.specifiers = [];
          if (!this.isContextual(97) && !this.match(12)) {
            node.source = this.finishPlaceholder(placeholder, "StringLiteral");
            this.semicolon();
            return this.finishNode(node, "ImportDeclaration");
          }
          const specifier = this.startNodeAtNode(placeholder);
          specifier.local = placeholder;
          node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
          if (this.eat(12)) {
            const hasStarImport = this.maybeParseStarImportSpecifier(node);
            if (!hasStarImport)
              this.parseNamedImportSpecifiers(node);
          }
          this.expectContextual(97);
          node.source = this.parseImportSource();
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }
        parseImportSource() {
          return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
        }
        assertNoSpace() {
          if (this.state.start > this.state.lastTokEndLoc.index) {
            this.raise(PlaceholderErrors.UnexpectedSpace, {
              at: this.state.lastTokEndLoc
            });
          }
        }
      };
      var v8intrinsic = (superClass) => class V8IntrinsicMixin extends superClass {
        parseV8Intrinsic() {
          if (this.match(54)) {
            const v8IntrinsicStartLoc = this.state.startLoc;
            const node = this.startNode();
            this.next();
            if (tokenIsIdentifier(this.state.type)) {
              const name = this.parseIdentifierName();
              const identifier = this.createIdentifier(node, name);
              identifier.type = "V8IntrinsicIdentifier";
              if (this.match(10)) {
                return identifier;
              }
            }
            this.unexpected(v8IntrinsicStartLoc);
          }
        }
        parseExprAtom(refExpressionErrors) {
          return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
        }
      };
      function hasPlugin(plugins, expectedConfig) {
        const [expectedName, expectedOptions] = typeof expectedConfig === "string" ? [expectedConfig, {}] : expectedConfig;
        const expectedKeys = Object.keys(expectedOptions);
        const expectedOptionsIsEmpty = expectedKeys.length === 0;
        return plugins.some((p) => {
          if (typeof p === "string") {
            return expectedOptionsIsEmpty && p === expectedName;
          } else {
            const [pluginName, pluginOptions] = p;
            if (pluginName !== expectedName) {
              return false;
            }
            for (const key of expectedKeys) {
              if (pluginOptions[key] !== expectedOptions[key]) {
                return false;
              }
            }
            return true;
          }
        });
      }
      function getPluginOption(plugins, name, option) {
        const plugin = plugins.find((plugin2) => {
          if (Array.isArray(plugin2)) {
            return plugin2[0] === name;
          } else {
            return plugin2 === name;
          }
        });
        if (plugin && Array.isArray(plugin) && plugin.length > 1) {
          return plugin[1][option];
        }
        return null;
      }
      var PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
      var TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];
      var RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
      function validatePlugins(plugins) {
        if (hasPlugin(plugins, "decorators")) {
          if (hasPlugin(plugins, "decorators-legacy")) {
            throw new Error("Cannot use the decorators and decorators-legacy plugin together");
          }
          const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
          if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== "boolean") {
            throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
          }
          const allowCallParenthesized = getPluginOption(plugins, "decorators", "allowCallParenthesized");
          if (allowCallParenthesized != null && typeof allowCallParenthesized !== "boolean") {
            throw new Error("'allowCallParenthesized' must be a boolean.");
          }
        }
        if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
          throw new Error("Cannot combine flow and typescript plugins.");
        }
        if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
          throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
        }
        if (hasPlugin(plugins, "pipelineOperator")) {
          const proposal = getPluginOption(plugins, "pipelineOperator", "proposal");
          if (!PIPELINE_PROPOSALS.includes(proposal)) {
            const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(", ");
            throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
          }
          const tupleSyntaxIsHash = hasPlugin(plugins, ["recordAndTuple", {
            syntaxType: "hash"
          }]);
          if (proposal === "hack") {
            if (hasPlugin(plugins, "placeholders")) {
              throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
            }
            if (hasPlugin(plugins, "v8intrinsic")) {
              throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
            }
            const topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");
            if (!TOPIC_TOKENS.includes(topicToken)) {
              const tokenList = TOPIC_TOKENS.map((t) => `"${t}"`).join(", ");
              throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
            }
            if (topicToken === "#" && tupleSyntaxIsHash) {
              throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
            }
          } else if (proposal === "smart" && tupleSyntaxIsHash) {
            throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
          }
        }
        if (hasPlugin(plugins, "moduleAttributes")) {
          {
            if (hasPlugin(plugins, "importAssertions") || hasPlugin(plugins, "importAttributes")) {
              throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
            }
            const moduleAttributesVersionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");
            if (moduleAttributesVersionPluginOption !== "may-2020") {
              throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
            }
          }
        }
        if (hasPlugin(plugins, "importAssertions") && hasPlugin(plugins, "importAttributes")) {
          throw new Error("Cannot combine importAssertions and importAttributes plugins.");
        }
        if (hasPlugin(plugins, "recordAndTuple") && getPluginOption(plugins, "recordAndTuple", "syntaxType") != null && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
          throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
        }
        if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
          const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
          error.missingPlugins = "doExpressions";
          throw error;
        }
      }
      var mixinPlugins = {
        estree,
        jsx,
        flow,
        typescript,
        v8intrinsic,
        placeholders
      };
      var mixinPluginNames = Object.keys(mixinPlugins);
      var defaultOptions = {
        sourceType: "script",
        sourceFilename: void 0,
        startColumn: 0,
        startLine: 1,
        allowAwaitOutsideFunction: false,
        allowReturnOutsideFunction: false,
        allowNewTargetOutsideFunction: false,
        allowImportExportEverywhere: false,
        allowSuperOutsideMethod: false,
        allowUndeclaredExports: false,
        plugins: [],
        strictMode: null,
        ranges: false,
        tokens: false,
        createParenthesizedExpressions: false,
        errorRecovery: false,
        attachComment: true,
        annexB: true
      };
      function getOptions(opts) {
        if (opts && opts.annexB != null && opts.annexB !== false) {
          throw new Error("The `annexB` option can only be set to `false`.");
        }
        const options = {};
        for (const key of Object.keys(defaultOptions)) {
          options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
        }
        return options;
      }
      var ExpressionParser = class extends LValParser {
        checkProto(prop, isRecord, protoRef, refExpressionErrors) {
          if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
            return;
          }
          const key = prop.key;
          const name = key.type === "Identifier" ? key.name : key.value;
          if (name === "__proto__") {
            if (isRecord) {
              this.raise(Errors.RecordNoProto, {
                at: key
              });
              return;
            }
            if (protoRef.used) {
              if (refExpressionErrors) {
                if (refExpressionErrors.doubleProtoLoc === null) {
                  refExpressionErrors.doubleProtoLoc = key.loc.start;
                }
              } else {
                this.raise(Errors.DuplicateProto, {
                  at: key
                });
              }
            }
            protoRef.used = true;
          }
        }
        shouldExitDescending(expr, potentialArrowAt) {
          return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
        }
        getExpression() {
          this.enterInitialScopes();
          this.nextToken();
          const expr = this.parseExpression();
          if (!this.match(137)) {
            this.unexpected();
          }
          this.finalizeRemainingComments();
          expr.comments = this.state.comments;
          expr.errors = this.state.errors;
          if (this.options.tokens) {
            expr.tokens = this.tokens;
          }
          return expr;
        }
        parseExpression(disallowIn, refExpressionErrors) {
          if (disallowIn) {
            return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
          }
          return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
        }
        parseExpressionBase(refExpressionErrors) {
          const startLoc = this.state.startLoc;
          const expr = this.parseMaybeAssign(refExpressionErrors);
          if (this.match(12)) {
            const node = this.startNodeAt(startLoc);
            node.expressions = [expr];
            while (this.eat(12)) {
              node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
            }
            this.toReferencedList(node.expressions);
            return this.finishNode(node, "SequenceExpression");
          }
          return expr;
        }
        parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
          return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
        }
        parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
          return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
        }
        setOptionalParametersError(refExpressionErrors, resultError) {
          var _resultError$loc;
          refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;
        }
        parseMaybeAssign(refExpressionErrors, afterLeftParse) {
          const startLoc = this.state.startLoc;
          if (this.isContextual(106)) {
            if (this.prodParam.hasYield) {
              let left2 = this.parseYield();
              if (afterLeftParse) {
                left2 = afterLeftParse.call(this, left2, startLoc);
              }
              return left2;
            }
          }
          let ownExpressionErrors;
          if (refExpressionErrors) {
            ownExpressionErrors = false;
          } else {
            refExpressionErrors = new ExpressionErrors();
            ownExpressionErrors = true;
          }
          const {
            type
          } = this.state;
          if (type === 10 || tokenIsIdentifier(type)) {
            this.state.potentialArrowAt = this.state.start;
          }
          let left = this.parseMaybeConditional(refExpressionErrors);
          if (afterLeftParse) {
            left = afterLeftParse.call(this, left, startLoc);
          }
          if (tokenIsAssignment(this.state.type)) {
            const node = this.startNodeAt(startLoc);
            const operator = this.state.value;
            node.operator = operator;
            if (this.match(29)) {
              this.toAssignable(left, true);
              node.left = left;
              const startIndex = startLoc.index;
              if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {
                refExpressionErrors.doubleProtoLoc = null;
              }
              if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {
                refExpressionErrors.shorthandAssignLoc = null;
              }
              if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {
                this.checkDestructuringPrivate(refExpressionErrors);
                refExpressionErrors.privateKeyLoc = null;
              }
            } else {
              node.left = left;
            }
            this.next();
            node.right = this.parseMaybeAssign();
            this.checkLVal(left, {
              in: this.finishNode(node, "AssignmentExpression")
            });
            return node;
          } else if (ownExpressionErrors) {
            this.checkExpressionErrors(refExpressionErrors, true);
          }
          return left;
        }
        parseMaybeConditional(refExpressionErrors) {
          const startLoc = this.state.startLoc;
          const potentialArrowAt = this.state.potentialArrowAt;
          const expr = this.parseExprOps(refExpressionErrors);
          if (this.shouldExitDescending(expr, potentialArrowAt)) {
            return expr;
          }
          return this.parseConditional(expr, startLoc, refExpressionErrors);
        }
        parseConditional(expr, startLoc, refExpressionErrors) {
          if (this.eat(17)) {
            const node = this.startNodeAt(startLoc);
            node.test = expr;
            node.consequent = this.parseMaybeAssignAllowIn();
            this.expect(14);
            node.alternate = this.parseMaybeAssign();
            return this.finishNode(node, "ConditionalExpression");
          }
          return expr;
        }
        parseMaybeUnaryOrPrivate(refExpressionErrors) {
          return this.match(136) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
        }
        parseExprOps(refExpressionErrors) {
          const startLoc = this.state.startLoc;
          const potentialArrowAt = this.state.potentialArrowAt;
          const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
          if (this.shouldExitDescending(expr, potentialArrowAt)) {
            return expr;
          }
          return this.parseExprOp(expr, startLoc, -1);
        }
        parseExprOp(left, leftStartLoc, minPrec) {
          if (this.isPrivateName(left)) {
            const value = this.getPrivateNameSV(left);
            if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
              this.raise(Errors.PrivateInExpectedIn, {
                at: left,
                identifierName: value
              });
            }
            this.classScope.usePrivateName(value, left.loc.start);
          }
          const op = this.state.type;
          if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
            let prec = tokenOperatorPrecedence(op);
            if (prec > minPrec) {
              if (op === 39) {
                this.expectPlugin("pipelineOperator");
                if (this.state.inFSharpPipelineDirectBody) {
                  return left;
                }
                this.checkPipelineAtInfixOperator(left, leftStartLoc);
              }
              const node = this.startNodeAt(leftStartLoc);
              node.left = left;
              node.operator = this.state.value;
              const logical = op === 41 || op === 42;
              const coalesce = op === 40;
              if (coalesce) {
                prec = tokenOperatorPrecedence(42);
              }
              this.next();
              if (op === 39 && this.hasPlugin(["pipelineOperator", {
                proposal: "minimal"
              }])) {
                if (this.state.type === 96 && this.prodParam.hasAwait) {
                  throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, {
                    at: this.state.startLoc
                  });
                }
              }
              node.right = this.parseExprOpRightExpr(op, prec);
              const finishedNode = this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
              const nextOp = this.state.type;
              if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
                throw this.raise(Errors.MixingCoalesceWithLogical, {
                  at: this.state.startLoc
                });
              }
              return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
            }
          }
          return left;
        }
        parseExprOpRightExpr(op, prec) {
          const startLoc = this.state.startLoc;
          switch (op) {
            case 39:
              switch (this.getPluginOption("pipelineOperator", "proposal")) {
                case "hack":
                  return this.withTopicBindingContext(() => {
                    return this.parseHackPipeBody();
                  });
                case "smart":
                  return this.withTopicBindingContext(() => {
                    if (this.prodParam.hasYield && this.isContextual(106)) {
                      throw this.raise(Errors.PipeBodyIsTighter, {
                        at: this.state.startLoc
                      });
                    }
                    return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);
                  });
                case "fsharp":
                  return this.withSoloAwaitPermittingContext(() => {
                    return this.parseFSharpPipelineBody(prec);
                  });
              }
            default:
              return this.parseExprOpBaseRightExpr(op, prec);
          }
        }
        parseExprOpBaseRightExpr(op, prec) {
          const startLoc = this.state.startLoc;
          return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
        }
        parseHackPipeBody() {
          var _body$extra;
          const {
            startLoc
          } = this.state;
          const body = this.parseMaybeAssign();
          const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
          if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
            this.raise(Errors.PipeUnparenthesizedBody, {
              at: startLoc,
              type: body.type
            });
          }
          if (!this.topicReferenceWasUsedInCurrentContext()) {
            this.raise(Errors.PipeTopicUnused, {
              at: startLoc
            });
          }
          return body;
        }
        checkExponentialAfterUnary(node) {
          if (this.match(57)) {
            this.raise(Errors.UnexpectedTokenUnaryExponentiation, {
              at: node.argument
            });
          }
        }
        parseMaybeUnary(refExpressionErrors, sawUnary) {
          const startLoc = this.state.startLoc;
          const isAwait = this.isContextual(96);
          if (isAwait && this.isAwaitAllowed()) {
            this.next();
            const expr2 = this.parseAwait(startLoc);
            if (!sawUnary)
              this.checkExponentialAfterUnary(expr2);
            return expr2;
          }
          const update = this.match(34);
          const node = this.startNode();
          if (tokenIsPrefix(this.state.type)) {
            node.operator = this.state.value;
            node.prefix = true;
            if (this.match(72)) {
              this.expectPlugin("throwExpressions");
            }
            const isDelete = this.match(89);
            this.next();
            node.argument = this.parseMaybeUnary(null, true);
            this.checkExpressionErrors(refExpressionErrors, true);
            if (this.state.strict && isDelete) {
              const arg = node.argument;
              if (arg.type === "Identifier") {
                this.raise(Errors.StrictDelete, {
                  at: node
                });
              } else if (this.hasPropertyAsPrivateName(arg)) {
                this.raise(Errors.DeletePrivateField, {
                  at: node
                });
              }
            }
            if (!update) {
              if (!sawUnary) {
                this.checkExponentialAfterUnary(node);
              }
              return this.finishNode(node, "UnaryExpression");
            }
          }
          const expr = this.parseUpdate(node, update, refExpressionErrors);
          if (isAwait) {
            const {
              type
            } = this.state;
            const startsExpr2 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
            if (startsExpr2 && !this.isAmbiguousAwait()) {
              this.raiseOverwrite(Errors.AwaitNotInAsyncContext, {
                at: startLoc
              });
              return this.parseAwait(startLoc);
            }
          }
          return expr;
        }
        parseUpdate(node, update, refExpressionErrors) {
          if (update) {
            const updateExpressionNode = node;
            this.checkLVal(updateExpressionNode.argument, {
              in: this.finishNode(updateExpressionNode, "UpdateExpression")
            });
            return node;
          }
          const startLoc = this.state.startLoc;
          let expr = this.parseExprSubscripts(refExpressionErrors);
          if (this.checkExpressionErrors(refExpressionErrors, false))
            return expr;
          while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
            const node2 = this.startNodeAt(startLoc);
            node2.operator = this.state.value;
            node2.prefix = false;
            node2.argument = expr;
            this.next();
            this.checkLVal(expr, {
              in: expr = this.finishNode(node2, "UpdateExpression")
            });
          }
          return expr;
        }
        parseExprSubscripts(refExpressionErrors) {
          const startLoc = this.state.startLoc;
          const potentialArrowAt = this.state.potentialArrowAt;
          const expr = this.parseExprAtom(refExpressionErrors);
          if (this.shouldExitDescending(expr, potentialArrowAt)) {
            return expr;
          }
          return this.parseSubscripts(expr, startLoc);
        }
        parseSubscripts(base, startLoc, noCalls) {
          const state = {
            optionalChainMember: false,
            maybeAsyncArrow: this.atPossibleAsyncArrow(base),
            stop: false
          };
          do {
            base = this.parseSubscript(base, startLoc, noCalls, state);
            state.maybeAsyncArrow = false;
          } while (!state.stop);
          return base;
        }
        parseSubscript(base, startLoc, noCalls, state) {
          const {
            type
          } = this.state;
          if (!noCalls && type === 15) {
            return this.parseBind(base, startLoc, noCalls, state);
          } else if (tokenIsTemplate(type)) {
            return this.parseTaggedTemplateExpression(base, startLoc, state);
          }
          let optional = false;
          if (type === 18) {
            if (noCalls) {
              this.raise(Errors.OptionalChainingNoNew, {
                at: this.state.startLoc
              });
              if (this.lookaheadCharCode() === 40) {
                state.stop = true;
                return base;
              }
            }
            state.optionalChainMember = optional = true;
            this.next();
          }
          if (!noCalls && this.match(10)) {
            return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
          } else {
            const computed = this.eat(0);
            if (computed || optional || this.eat(16)) {
              return this.parseMember(base, startLoc, state, computed, optional);
            } else {
              state.stop = true;
              return base;
            }
          }
        }
        parseMember(base, startLoc, state, computed, optional) {
          const node = this.startNodeAt(startLoc);
          node.object = base;
          node.computed = computed;
          if (computed) {
            node.property = this.parseExpression();
            this.expect(3);
          } else if (this.match(136)) {
            if (base.type === "Super") {
              this.raise(Errors.SuperPrivateField, {
                at: startLoc
              });
            }
            this.classScope.usePrivateName(this.state.value, this.state.startLoc);
            node.property = this.parsePrivateName();
          } else {
            node.property = this.parseIdentifier(true);
          }
          if (state.optionalChainMember) {
            node.optional = optional;
            return this.finishNode(node, "OptionalMemberExpression");
          } else {
            return this.finishNode(node, "MemberExpression");
          }
        }
        parseBind(base, startLoc, noCalls, state) {
          const node = this.startNodeAt(startLoc);
          node.object = base;
          this.next();
          node.callee = this.parseNoCallExpr();
          state.stop = true;
          return this.parseSubscripts(this.finishNode(node, "BindExpression"), startLoc, noCalls);
        }
        parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          let refExpressionErrors = null;
          this.state.maybeInArrowParameters = true;
          this.next();
          const node = this.startNodeAt(startLoc);
          node.callee = base;
          const {
            maybeAsyncArrow,
            optionalChainMember
          } = state;
          if (maybeAsyncArrow) {
            this.expressionScope.enter(newAsyncArrowScope());
            refExpressionErrors = new ExpressionErrors();
          }
          if (optionalChainMember) {
            node.optional = optional;
          }
          if (optional) {
            node.arguments = this.parseCallExpressionArguments(11);
          } else {
            node.arguments = this.parseCallExpressionArguments(11, base.type === "Import", base.type !== "Super", node, refExpressionErrors);
          }
          let finishedNode = this.finishCallExpression(node, optionalChainMember);
          if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
            state.stop = true;
            this.checkDestructuringPrivate(refExpressionErrors);
            this.expressionScope.validateAsPattern();
            this.expressionScope.exit();
            finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);
          } else {
            if (maybeAsyncArrow) {
              this.checkExpressionErrors(refExpressionErrors, true);
              this.expressionScope.exit();
            }
            this.toReferencedArguments(finishedNode);
          }
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          return finishedNode;
        }
        toReferencedArguments(node, isParenthesizedExpr) {
          this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
        }
        parseTaggedTemplateExpression(base, startLoc, state) {
          const node = this.startNodeAt(startLoc);
          node.tag = base;
          node.quasi = this.parseTemplate(true);
          if (state.optionalChainMember) {
            this.raise(Errors.OptionalChainingNoTemplate, {
              at: startLoc
            });
          }
          return this.finishNode(node, "TaggedTemplateExpression");
        }
        atPossibleAsyncArrow(base) {
          return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
        }
        expectImportAttributesPlugin() {
          if (!this.hasPlugin("importAssertions")) {
            this.expectPlugin("importAttributes");
          }
        }
        finishCallExpression(node, optional) {
          if (node.callee.type === "Import") {
            if (node.arguments.length === 2) {
              {
                if (!this.hasPlugin("moduleAttributes")) {
                  this.expectImportAttributesPlugin();
                }
              }
            }
            if (node.arguments.length === 0 || node.arguments.length > 2) {
              this.raise(Errors.ImportCallArity, {
                at: node,
                maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
              });
            } else {
              for (const arg of node.arguments) {
                if (arg.type === "SpreadElement") {
                  this.raise(Errors.ImportCallSpreadArgument, {
                    at: arg
                  });
                }
              }
            }
          }
          return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
        }
        parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
          const elts = [];
          let first = true;
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = false;
          while (!this.eat(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
              if (this.match(close)) {
                if (dynamicImport && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
                  this.raise(Errors.ImportCallArgumentTrailingComma, {
                    at: this.state.lastTokStartLoc
                  });
                }
                if (nodeForExtra) {
                  this.addTrailingCommaExtraToNode(nodeForExtra);
                }
                this.next();
                break;
              }
            }
            elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
          }
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          return elts;
        }
        shouldParseAsyncArrow() {
          return this.match(19) && !this.canInsertSemicolon();
        }
        parseAsyncArrowFromCallExpression(node, call) {
          var _call$extra;
          this.resetPreviousNodeTrailingComments(call);
          this.expect(19);
          this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);
          if (call.innerComments) {
            setInnerComments(node, call.innerComments);
          }
          if (call.callee.trailingComments) {
            setInnerComments(node, call.callee.trailingComments);
          }
          return node;
        }
        parseNoCallExpr() {
          const startLoc = this.state.startLoc;
          return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
        }
        parseExprAtom(refExpressionErrors) {
          let node;
          let decorators = null;
          const {
            type
          } = this.state;
          switch (type) {
            case 79:
              return this.parseSuper();
            case 83:
              node = this.startNode();
              this.next();
              if (this.match(16)) {
                return this.parseImportMetaProperty(node);
              }
              if (!this.match(10)) {
                this.raise(Errors.UnsupportedImport, {
                  at: this.state.lastTokStartLoc
                });
              }
              return this.finishNode(node, "Import");
            case 78:
              node = this.startNode();
              this.next();
              return this.finishNode(node, "ThisExpression");
            case 90: {
              return this.parseDo(this.startNode(), false);
            }
            case 56:
            case 31: {
              this.readRegexp();
              return this.parseRegExpLiteral(this.state.value);
            }
            case 132:
              return this.parseNumericLiteral(this.state.value);
            case 133:
              return this.parseBigIntLiteral(this.state.value);
            case 134:
              return this.parseDecimalLiteral(this.state.value);
            case 131:
              return this.parseStringLiteral(this.state.value);
            case 84:
              return this.parseNullLiteral();
            case 85:
              return this.parseBooleanLiteral(true);
            case 86:
              return this.parseBooleanLiteral(false);
            case 10: {
              const canBeArrow = this.state.potentialArrowAt === this.state.start;
              return this.parseParenAndDistinguishExpression(canBeArrow);
            }
            case 2:
            case 1: {
              return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
            }
            case 0: {
              return this.parseArrayLike(3, true, false, refExpressionErrors);
            }
            case 6:
            case 7: {
              return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
            }
            case 5: {
              return this.parseObjectLike(8, false, false, refExpressionErrors);
            }
            case 68:
              return this.parseFunctionOrFunctionSent();
            case 26:
              decorators = this.parseDecorators();
            case 80:
              return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
            case 77:
              return this.parseNewOrNewTarget();
            case 25:
            case 24:
              return this.parseTemplate(false);
            case 15: {
              node = this.startNode();
              this.next();
              node.object = null;
              const callee = node.callee = this.parseNoCallExpr();
              if (callee.type === "MemberExpression") {
                return this.finishNode(node, "BindExpression");
              } else {
                throw this.raise(Errors.UnsupportedBind, {
                  at: callee
                });
              }
            }
            case 136: {
              this.raise(Errors.PrivateInExpectedIn, {
                at: this.state.startLoc,
                identifierName: this.state.value
              });
              return this.parsePrivateName();
            }
            case 33: {
              return this.parseTopicReferenceThenEqualsSign(54, "%");
            }
            case 32: {
              return this.parseTopicReferenceThenEqualsSign(44, "^");
            }
            case 37:
            case 38: {
              return this.parseTopicReference("hack");
            }
            case 44:
            case 54:
            case 27: {
              const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
              if (pipeProposal) {
                return this.parseTopicReference(pipeProposal);
              }
              this.unexpected();
              break;
            }
            case 47: {
              const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
              if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
                this.expectOnePlugin(["jsx", "flow", "typescript"]);
              } else {
                this.unexpected();
              }
              break;
            }
            default:
              if (tokenIsIdentifier(type)) {
                if (this.isContextual(125) && this.lookaheadInLineCharCode() === 123) {
                  return this.parseModuleExpression();
                }
                const canBeArrow = this.state.potentialArrowAt === this.state.start;
                const containsEsc = this.state.containsEsc;
                const id = this.parseIdentifier();
                if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
                  const {
                    type: type2
                  } = this.state;
                  if (type2 === 68) {
                    this.resetPreviousNodeTrailingComments(id);
                    this.next();
                    return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
                  } else if (tokenIsIdentifier(type2)) {
                    if (this.lookaheadCharCode() === 61) {
                      return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                    } else {
                      return id;
                    }
                  } else if (type2 === 90) {
                    this.resetPreviousNodeTrailingComments(id);
                    return this.parseDo(this.startNodeAtNode(id), true);
                  }
                }
                if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
                  this.next();
                  return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
                }
                return id;
              } else {
                this.unexpected();
              }
          }
        }
        parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
          const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
          if (pipeProposal) {
            this.state.type = topicTokenType;
            this.state.value = topicTokenValue;
            this.state.pos--;
            this.state.end--;
            this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
            return this.parseTopicReference(pipeProposal);
          } else {
            this.unexpected();
          }
        }
        parseTopicReference(pipeProposal) {
          const node = this.startNode();
          const startLoc = this.state.startLoc;
          const tokenType = this.state.type;
          this.next();
          return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
        }
        finishTopicReference(node, startLoc, pipeProposal, tokenType) {
          if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
            const nodeType = pipeProposal === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
            if (!this.topicReferenceIsAllowedInCurrentContext()) {
              this.raise(pipeProposal === "smart" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, {
                at: startLoc
              });
            }
            this.registerTopicReference();
            return this.finishNode(node, nodeType);
          } else {
            throw this.raise(Errors.PipeTopicUnconfiguredToken, {
              at: startLoc,
              token: tokenLabelName(tokenType)
            });
          }
        }
        testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
          switch (pipeProposal) {
            case "hack": {
              return this.hasPlugin(["pipelineOperator", {
                topicToken: tokenLabelName(tokenType)
              }]);
            }
            case "smart":
              return tokenType === 27;
            default:
              throw this.raise(Errors.PipeTopicRequiresHackPipes, {
                at: startLoc
              });
          }
        }
        parseAsyncArrowUnaryFunction(node) {
          this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
          const params = [this.parseIdentifier()];
          this.prodParam.exit();
          if (this.hasPrecedingLineBreak()) {
            this.raise(Errors.LineTerminatorBeforeArrow, {
              at: this.state.curPosition()
            });
          }
          this.expect(19);
          return this.parseArrowExpression(node, params, true);
        }
        parseDo(node, isAsync) {
          this.expectPlugin("doExpressions");
          if (isAsync) {
            this.expectPlugin("asyncDoExpressions");
          }
          node.async = isAsync;
          this.next();
          const oldLabels = this.state.labels;
          this.state.labels = [];
          if (isAsync) {
            this.prodParam.enter(PARAM_AWAIT);
            node.body = this.parseBlock();
            this.prodParam.exit();
          } else {
            node.body = this.parseBlock();
          }
          this.state.labels = oldLabels;
          return this.finishNode(node, "DoExpression");
        }
        parseSuper() {
          const node = this.startNode();
          this.next();
          if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
            this.raise(Errors.SuperNotAllowed, {
              at: node
            });
          } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
            this.raise(Errors.UnexpectedSuper, {
              at: node
            });
          }
          if (!this.match(10) && !this.match(0) && !this.match(16)) {
            this.raise(Errors.UnsupportedSuper, {
              at: node
            });
          }
          return this.finishNode(node, "Super");
        }
        parsePrivateName() {
          const node = this.startNode();
          const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
          const name = this.state.value;
          this.next();
          node.id = this.createIdentifier(id, name);
          return this.finishNode(node, "PrivateName");
        }
        parseFunctionOrFunctionSent() {
          const node = this.startNode();
          this.next();
          if (this.prodParam.hasYield && this.match(16)) {
            const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
            this.next();
            if (this.match(102)) {
              this.expectPlugin("functionSent");
            } else if (!this.hasPlugin("functionSent")) {
              this.unexpected();
            }
            return this.parseMetaProperty(node, meta, "sent");
          }
          return this.parseFunction(node);
        }
        parseMetaProperty(node, meta, propertyName) {
          node.meta = meta;
          const containsEsc = this.state.containsEsc;
          node.property = this.parseIdentifier(true);
          if (node.property.name !== propertyName || containsEsc) {
            this.raise(Errors.UnsupportedMetaProperty, {
              at: node.property,
              target: meta.name,
              onlyValidPropertyName: propertyName
            });
          }
          return this.finishNode(node, "MetaProperty");
        }
        parseImportMetaProperty(node) {
          const id = this.createIdentifier(this.startNodeAtNode(node), "import");
          this.next();
          if (this.isContextual(100)) {
            if (!this.inModule) {
              this.raise(Errors.ImportMetaOutsideModule, {
                at: id
              });
            }
            this.sawUnambiguousESM = true;
          }
          return this.parseMetaProperty(node, id, "meta");
        }
        parseLiteralAtNode(value, type, node) {
          this.addExtra(node, "rawValue", value);
          this.addExtra(node, "raw", this.input.slice(node.start, this.state.end));
          node.value = value;
          this.next();
          return this.finishNode(node, type);
        }
        parseLiteral(value, type) {
          const node = this.startNode();
          return this.parseLiteralAtNode(value, type, node);
        }
        parseStringLiteral(value) {
          return this.parseLiteral(value, "StringLiteral");
        }
        parseNumericLiteral(value) {
          return this.parseLiteral(value, "NumericLiteral");
        }
        parseBigIntLiteral(value) {
          return this.parseLiteral(value, "BigIntLiteral");
        }
        parseDecimalLiteral(value) {
          return this.parseLiteral(value, "DecimalLiteral");
        }
        parseRegExpLiteral(value) {
          const node = this.parseLiteral(value.value, "RegExpLiteral");
          node.pattern = value.pattern;
          node.flags = value.flags;
          return node;
        }
        parseBooleanLiteral(value) {
          const node = this.startNode();
          node.value = value;
          this.next();
          return this.finishNode(node, "BooleanLiteral");
        }
        parseNullLiteral() {
          const node = this.startNode();
          this.next();
          return this.finishNode(node, "NullLiteral");
        }
        parseParenAndDistinguishExpression(canBeArrow) {
          const startLoc = this.state.startLoc;
          let val;
          this.next();
          this.expressionScope.enter(newArrowHeadScope());
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.maybeInArrowParameters = true;
          this.state.inFSharpPipelineDirectBody = false;
          const innerStartLoc = this.state.startLoc;
          const exprList = [];
          const refExpressionErrors = new ExpressionErrors();
          let first = true;
          let spreadStartLoc;
          let optionalCommaStartLoc;
          while (!this.match(11)) {
            if (first) {
              first = false;
            } else {
              this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
              if (this.match(11)) {
                optionalCommaStartLoc = this.state.startLoc;
                break;
              }
            }
            if (this.match(21)) {
              const spreadNodeStartLoc = this.state.startLoc;
              spreadStartLoc = this.state.startLoc;
              exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));
              if (!this.checkCommaAfterRest(41)) {
                break;
              }
            } else {
              exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
            }
          }
          const innerEndLoc = this.state.lastTokEndLoc;
          this.expect(11);
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          let arrowNode = this.startNodeAt(startLoc);
          if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
            this.checkDestructuringPrivate(refExpressionErrors);
            this.expressionScope.validateAsPattern();
            this.expressionScope.exit();
            this.parseArrowExpression(arrowNode, exprList, false);
            return arrowNode;
          }
          this.expressionScope.exit();
          if (!exprList.length) {
            this.unexpected(this.state.lastTokStartLoc);
          }
          if (optionalCommaStartLoc)
            this.unexpected(optionalCommaStartLoc);
          if (spreadStartLoc)
            this.unexpected(spreadStartLoc);
          this.checkExpressionErrors(refExpressionErrors, true);
          this.toReferencedListDeep(exprList, true);
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartLoc);
            val.expressions = exprList;
            this.finishNode(val, "SequenceExpression");
            this.resetEndLocation(val, innerEndLoc);
          } else {
            val = exprList[0];
          }
          return this.wrapParenthesis(startLoc, val);
        }
        wrapParenthesis(startLoc, expression) {
          if (!this.options.createParenthesizedExpressions) {
            this.addExtra(expression, "parenthesized", true);
            this.addExtra(expression, "parenStart", startLoc.index);
            this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);
            return expression;
          }
          const parenExpression = this.startNodeAt(startLoc);
          parenExpression.expression = expression;
          return this.finishNode(parenExpression, "ParenthesizedExpression");
        }
        shouldParseArrow(params) {
          return !this.canInsertSemicolon();
        }
        parseArrow(node) {
          if (this.eat(19)) {
            return node;
          }
        }
        parseParenItem(node, startLoc) {
          return node;
        }
        parseNewOrNewTarget() {
          const node = this.startNode();
          this.next();
          if (this.match(16)) {
            const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
            this.next();
            const metaProp = this.parseMetaProperty(node, meta, "target");
            if (!this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction) {
              this.raise(Errors.UnexpectedNewTarget, {
                at: metaProp
              });
            }
            return metaProp;
          }
          return this.parseNew(node);
        }
        parseNew(node) {
          this.parseNewCallee(node);
          if (this.eat(10)) {
            const args = this.parseExprList(11);
            this.toReferencedList(args);
            node.arguments = args;
          } else {
            node.arguments = [];
          }
          return this.finishNode(node, "NewExpression");
        }
        parseNewCallee(node) {
          node.callee = this.parseNoCallExpr();
          if (node.callee.type === "Import") {
            this.raise(Errors.ImportCallNotNewExpression, {
              at: node.callee
            });
          }
        }
        parseTemplateElement(isTagged) {
          const {
            start,
            startLoc,
            end,
            value
          } = this.state;
          const elemStart = start + 1;
          const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
          if (value === null) {
            if (!isTagged) {
              this.raise(Errors.InvalidEscapeSequenceTemplate, {
                at: createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1)
              });
            }
          }
          const isTail = this.match(24);
          const endOffset = isTail ? -1 : -2;
          const elemEnd = end + endOffset;
          elem.value = {
            raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
            cooked: value === null ? null : value.slice(1, endOffset)
          };
          elem.tail = isTail;
          this.next();
          const finishedNode = this.finishNode(elem, "TemplateElement");
          this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
          return finishedNode;
        }
        parseTemplate(isTagged) {
          const node = this.startNode();
          node.expressions = [];
          let curElt = this.parseTemplateElement(isTagged);
          node.quasis = [curElt];
          while (!curElt.tail) {
            node.expressions.push(this.parseTemplateSubstitution());
            this.readTemplateContinuation();
            node.quasis.push(curElt = this.parseTemplateElement(isTagged));
          }
          return this.finishNode(node, "TemplateLiteral");
        }
        parseTemplateSubstitution() {
          return this.parseExpression();
        }
        parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
          if (isRecord) {
            this.expectPlugin("recordAndTuple");
          }
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = false;
          const propHash = /* @__PURE__ */ Object.create(null);
          let first = true;
          const node = this.startNode();
          node.properties = [];
          this.next();
          while (!this.match(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
              if (this.match(close)) {
                this.addTrailingCommaExtraToNode(node);
                break;
              }
            }
            let prop;
            if (isPattern) {
              prop = this.parseBindingProperty();
            } else {
              prop = this.parsePropertyDefinition(refExpressionErrors);
              this.checkProto(prop, isRecord, propHash, refExpressionErrors);
            }
            if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
              this.raise(Errors.InvalidRecordProperty, {
                at: prop
              });
            }
            if (prop.shorthand) {
              this.addExtra(prop, "shorthand", true);
            }
            node.properties.push(prop);
          }
          this.next();
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          let type = "ObjectExpression";
          if (isPattern) {
            type = "ObjectPattern";
          } else if (isRecord) {
            type = "RecordExpression";
          }
          return this.finishNode(node, type);
        }
        addTrailingCommaExtraToNode(node) {
          this.addExtra(node, "trailingComma", this.state.lastTokStart);
          this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);
        }
        maybeAsyncOrAccessorProp(prop) {
          return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
        }
        parsePropertyDefinition(refExpressionErrors) {
          let decorators = [];
          if (this.match(26)) {
            if (this.hasPlugin("decorators")) {
              this.raise(Errors.UnsupportedPropertyDecorator, {
                at: this.state.startLoc
              });
            }
            while (this.match(26)) {
              decorators.push(this.parseDecorator());
            }
          }
          const prop = this.startNode();
          let isAsync = false;
          let isAccessor = false;
          let startLoc;
          if (this.match(21)) {
            if (decorators.length)
              this.unexpected();
            return this.parseSpread();
          }
          if (decorators.length) {
            prop.decorators = decorators;
            decorators = [];
          }
          prop.method = false;
          if (refExpressionErrors) {
            startLoc = this.state.startLoc;
          }
          let isGenerator = this.eat(55);
          this.parsePropertyNamePrefixOperator(prop);
          const containsEsc = this.state.containsEsc;
          const key = this.parsePropertyName(prop, refExpressionErrors);
          if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
            const keyName = key.name;
            if (keyName === "async" && !this.hasPrecedingLineBreak()) {
              isAsync = true;
              this.resetPreviousNodeTrailingComments(key);
              isGenerator = this.eat(55);
              this.parsePropertyName(prop);
            }
            if (keyName === "get" || keyName === "set") {
              isAccessor = true;
              this.resetPreviousNodeTrailingComments(key);
              prop.kind = keyName;
              if (this.match(55)) {
                isGenerator = true;
                this.raise(Errors.AccessorIsGenerator, {
                  at: this.state.curPosition(),
                  kind: keyName
                });
                this.next();
              }
              this.parsePropertyName(prop);
            }
          }
          return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
        }
        getGetterSetterExpectedParamCount(method) {
          return method.kind === "get" ? 0 : 1;
        }
        getObjectOrClassMethodParams(method) {
          return method.params;
        }
        checkGetterSetterParams(method) {
          var _params;
          const paramCount = this.getGetterSetterExpectedParamCount(method);
          const params = this.getObjectOrClassMethodParams(method);
          if (params.length !== paramCount) {
            this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
              at: method
            });
          }
          if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
            this.raise(Errors.BadSetterRestParameter, {
              at: method
            });
          }
        }
        parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
          if (isAccessor) {
            const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
            this.checkGetterSetterParams(finishedProp);
            return finishedProp;
          }
          if (isAsync || isGenerator || this.match(10)) {
            if (isPattern)
              this.unexpected();
            prop.kind = "method";
            prop.method = true;
            return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
          }
        }
        parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
          prop.shorthand = false;
          if (this.eat(14)) {
            prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
            return this.finishNode(prop, "ObjectProperty");
          }
          if (!prop.computed && prop.key.type === "Identifier") {
            this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
            if (isPattern) {
              prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
            } else if (this.match(29)) {
              const shorthandAssignLoc = this.state.startLoc;
              if (refExpressionErrors != null) {
                if (refExpressionErrors.shorthandAssignLoc === null) {
                  refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
                }
              } else {
                this.raise(Errors.InvalidCoverInitializedName, {
                  at: shorthandAssignLoc
                });
              }
              prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
            } else {
              prop.value = cloneIdentifier(prop.key);
            }
            prop.shorthand = true;
            return this.finishNode(prop, "ObjectProperty");
          }
        }
        parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
          const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
          if (!node)
            this.unexpected();
          return node;
        }
        parsePropertyName(prop, refExpressionErrors) {
          if (this.eat(0)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssignAllowIn();
            this.expect(3);
          } else {
            const {
              type,
              value
            } = this.state;
            let key;
            if (tokenIsKeywordOrIdentifier(type)) {
              key = this.parseIdentifier(true);
            } else {
              switch (type) {
                case 132:
                  key = this.parseNumericLiteral(value);
                  break;
                case 131:
                  key = this.parseStringLiteral(value);
                  break;
                case 133:
                  key = this.parseBigIntLiteral(value);
                  break;
                case 134:
                  key = this.parseDecimalLiteral(value);
                  break;
                case 136: {
                  const privateKeyLoc = this.state.startLoc;
                  if (refExpressionErrors != null) {
                    if (refExpressionErrors.privateKeyLoc === null) {
                      refExpressionErrors.privateKeyLoc = privateKeyLoc;
                    }
                  } else {
                    this.raise(Errors.UnexpectedPrivateField, {
                      at: privateKeyLoc
                    });
                  }
                  key = this.parsePrivateName();
                  break;
                }
                default:
                  this.unexpected();
              }
            }
            prop.key = key;
            if (type !== 136) {
              prop.computed = false;
            }
          }
          return prop.key;
        }
        initFunction(node, isAsync) {
          node.id = null;
          node.generator = false;
          node.async = isAsync;
        }
        parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
          this.initFunction(node, isAsync);
          node.generator = isGenerator;
          this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
          this.prodParam.enter(functionFlags(isAsync, node.generator));
          this.parseFunctionParams(node, isConstructor);
          const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);
          this.prodParam.exit();
          this.scope.exit();
          return finishedNode;
        }
        parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
          if (isTuple) {
            this.expectPlugin("recordAndTuple");
          }
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = false;
          const node = this.startNode();
          this.next();
          node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
        }
        parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
          this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
          let flags = functionFlags(isAsync, false);
          if (!this.match(5) && this.prodParam.hasIn) {
            flags |= PARAM_IN;
          }
          this.prodParam.enter(flags);
          this.initFunction(node, isAsync);
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          if (params) {
            this.state.maybeInArrowParameters = true;
            this.setArrowFunctionParameters(node, params, trailingCommaLoc);
          }
          this.state.maybeInArrowParameters = false;
          this.parseFunctionBody(node, true);
          this.prodParam.exit();
          this.scope.exit();
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          return this.finishNode(node, "ArrowFunctionExpression");
        }
        setArrowFunctionParameters(node, params, trailingCommaLoc) {
          this.toAssignableList(params, trailingCommaLoc, false);
          node.params = params;
        }
        parseFunctionBodyAndFinish(node, type, isMethod = false) {
          this.parseFunctionBody(node, false, isMethod);
          return this.finishNode(node, type);
        }
        parseFunctionBody(node, allowExpression, isMethod = false) {
          const isExpression = allowExpression && !this.match(5);
          this.expressionScope.enter(newExpressionScope());
          if (isExpression) {
            node.body = this.parseMaybeAssign();
            this.checkParams(node, false, allowExpression, false);
          } else {
            const oldStrict = this.state.strict;
            const oldLabels = this.state.labels;
            this.state.labels = [];
            this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
            node.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
              const nonSimple = !this.isSimpleParamList(node.params);
              if (hasStrictModeDirective && nonSimple) {
                this.raise(Errors.IllegalLanguageModeDirective, {
                  at: (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.loc.end : node
                });
              }
              const strictModeChanged = !oldStrict && this.state.strict;
              this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
              if (this.state.strict && node.id) {
                this.checkIdentifier(node.id, BIND_OUTSIDE, strictModeChanged);
              }
            });
            this.prodParam.exit();
            this.state.labels = oldLabels;
          }
          this.expressionScope.exit();
        }
        isSimpleParameter(node) {
          return node.type === "Identifier";
        }
        isSimpleParamList(params) {
          for (let i = 0, len = params.length; i < len; i++) {
            if (!this.isSimpleParameter(params[i]))
              return false;
          }
          return true;
        }
        checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
          const checkClashes = !allowDuplicates && /* @__PURE__ */ new Set();
          const formalParameters = {
            type: "FormalParameters"
          };
          for (const param of node.params) {
            this.checkLVal(param, {
              in: formalParameters,
              binding: BIND_VAR,
              checkClashes,
              strictModeChanged
            });
          }
        }
        parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
          const elts = [];
          let first = true;
          while (!this.eat(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
              if (this.match(close)) {
                if (nodeForExtra) {
                  this.addTrailingCommaExtraToNode(nodeForExtra);
                }
                this.next();
                break;
              }
            }
            elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
          }
          return elts;
        }
        parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
          let elt;
          if (this.match(12)) {
            if (!allowEmpty) {
              this.raise(Errors.UnexpectedToken, {
                at: this.state.curPosition(),
                unexpected: ","
              });
            }
            elt = null;
          } else if (this.match(21)) {
            const spreadNodeStartLoc = this.state.startLoc;
            elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
          } else if (this.match(17)) {
            this.expectPlugin("partialApplication");
            if (!allowPlaceholder) {
              this.raise(Errors.UnexpectedArgumentPlaceholder, {
                at: this.state.startLoc
              });
            }
            const node = this.startNode();
            this.next();
            elt = this.finishNode(node, "ArgumentPlaceholder");
          } else {
            elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
          }
          return elt;
        }
        parseIdentifier(liberal) {
          const node = this.startNode();
          const name = this.parseIdentifierName(liberal);
          return this.createIdentifier(node, name);
        }
        createIdentifier(node, name) {
          node.name = name;
          node.loc.identifierName = name;
          return this.finishNode(node, "Identifier");
        }
        parseIdentifierName(liberal) {
          let name;
          const {
            startLoc,
            type
          } = this.state;
          if (tokenIsKeywordOrIdentifier(type)) {
            name = this.state.value;
          } else {
            this.unexpected();
          }
          const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);
          if (liberal) {
            if (tokenIsKeyword2) {
              this.replaceToken(130);
            }
          } else {
            this.checkReservedWord(name, startLoc, tokenIsKeyword2, false);
          }
          this.next();
          return name;
        }
        checkReservedWord(word, startLoc, checkKeywords, isBinding) {
          if (word.length > 10) {
            return;
          }
          if (!canBeReservedWord(word)) {
            return;
          }
          if (checkKeywords && isKeyword(word)) {
            this.raise(Errors.UnexpectedKeyword, {
              at: startLoc,
              keyword: word
            });
            return;
          }
          const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
          if (reservedTest(word, this.inModule)) {
            this.raise(Errors.UnexpectedReservedWord, {
              at: startLoc,
              reservedWord: word
            });
            return;
          } else if (word === "yield") {
            if (this.prodParam.hasYield) {
              this.raise(Errors.YieldBindingIdentifier, {
                at: startLoc
              });
              return;
            }
          } else if (word === "await") {
            if (this.prodParam.hasAwait) {
              this.raise(Errors.AwaitBindingIdentifier, {
                at: startLoc
              });
              return;
            }
            if (this.scope.inStaticBlock) {
              this.raise(Errors.AwaitBindingIdentifierInStaticBlock, {
                at: startLoc
              });
              return;
            }
            this.expressionScope.recordAsyncArrowParametersError({
              at: startLoc
            });
          } else if (word === "arguments") {
            if (this.scope.inClassAndNotInNonArrowFunction) {
              this.raise(Errors.ArgumentsInClass, {
                at: startLoc
              });
              return;
            }
          }
        }
        isAwaitAllowed() {
          if (this.prodParam.hasAwait)
            return true;
          if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
            return true;
          }
          return false;
        }
        parseAwait(startLoc) {
          const node = this.startNodeAt(startLoc);
          this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, {
            at: node
          });
          if (this.eat(55)) {
            this.raise(Errors.ObsoleteAwaitStar, {
              at: node
            });
          }
          if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
            if (this.isAmbiguousAwait()) {
              this.ambiguousScriptDifferentAst = true;
            } else {
              this.sawUnambiguousESM = true;
            }
          }
          if (!this.state.soloAwait) {
            node.argument = this.parseMaybeUnary(null, true);
          }
          return this.finishNode(node, "AwaitExpression");
        }
        isAmbiguousAwait() {
          if (this.hasPrecedingLineBreak())
            return true;
          const {
            type
          } = this.state;
          return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 101 && !this.state.containsEsc || type === 135 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
        }
        parseYield() {
          const node = this.startNode();
          this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, {
            at: node
          });
          this.next();
          let delegating = false;
          let argument = null;
          if (!this.hasPrecedingLineBreak()) {
            delegating = this.eat(55);
            switch (this.state.type) {
              case 13:
              case 137:
              case 8:
              case 11:
              case 3:
              case 9:
              case 14:
              case 12:
                if (!delegating)
                  break;
              default:
                argument = this.parseMaybeAssign();
            }
          }
          node.delegate = delegating;
          node.argument = argument;
          return this.finishNode(node, "YieldExpression");
        }
        checkPipelineAtInfixOperator(left, leftStartLoc) {
          if (this.hasPlugin(["pipelineOperator", {
            proposal: "smart"
          }])) {
            if (left.type === "SequenceExpression") {
              this.raise(Errors.PipelineHeadSequenceExpression, {
                at: leftStartLoc
              });
            }
          }
        }
        parseSmartPipelineBodyInStyle(childExpr, startLoc) {
          if (this.isSimpleReference(childExpr)) {
            const bodyNode = this.startNodeAt(startLoc);
            bodyNode.callee = childExpr;
            return this.finishNode(bodyNode, "PipelineBareFunction");
          } else {
            const bodyNode = this.startNodeAt(startLoc);
            this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
            bodyNode.expression = childExpr;
            return this.finishNode(bodyNode, "PipelineTopicExpression");
          }
        }
        isSimpleReference(expression) {
          switch (expression.type) {
            case "MemberExpression":
              return !expression.computed && this.isSimpleReference(expression.object);
            case "Identifier":
              return true;
            default:
              return false;
          }
        }
        checkSmartPipeTopicBodyEarlyErrors(startLoc) {
          if (this.match(19)) {
            throw this.raise(Errors.PipelineBodyNoArrow, {
              at: this.state.startLoc
            });
          }
          if (!this.topicReferenceWasUsedInCurrentContext()) {
            this.raise(Errors.PipelineTopicUnused, {
              at: startLoc
            });
          }
        }
        withTopicBindingContext(callback) {
          const outerContextTopicState = this.state.topicContext;
          this.state.topicContext = {
            maxNumOfResolvableTopics: 1,
            maxTopicIndex: null
          };
          try {
            return callback();
          } finally {
            this.state.topicContext = outerContextTopicState;
          }
        }
        withSmartMixTopicForbiddingContext(callback) {
          if (this.hasPlugin(["pipelineOperator", {
            proposal: "smart"
          }])) {
            const outerContextTopicState = this.state.topicContext;
            this.state.topicContext = {
              maxNumOfResolvableTopics: 0,
              maxTopicIndex: null
            };
            try {
              return callback();
            } finally {
              this.state.topicContext = outerContextTopicState;
            }
          } else {
            return callback();
          }
        }
        withSoloAwaitPermittingContext(callback) {
          const outerContextSoloAwaitState = this.state.soloAwait;
          this.state.soloAwait = true;
          try {
            return callback();
          } finally {
            this.state.soloAwait = outerContextSoloAwaitState;
          }
        }
        allowInAnd(callback) {
          const flags = this.prodParam.currentFlags();
          const prodParamToSet = PARAM_IN & ~flags;
          if (prodParamToSet) {
            this.prodParam.enter(flags | PARAM_IN);
            try {
              return callback();
            } finally {
              this.prodParam.exit();
            }
          }
          return callback();
        }
        disallowInAnd(callback) {
          const flags = this.prodParam.currentFlags();
          const prodParamToClear = PARAM_IN & flags;
          if (prodParamToClear) {
            this.prodParam.enter(flags & ~PARAM_IN);
            try {
              return callback();
            } finally {
              this.prodParam.exit();
            }
          }
          return callback();
        }
        registerTopicReference() {
          this.state.topicContext.maxTopicIndex = 0;
        }
        topicReferenceIsAllowedInCurrentContext() {
          return this.state.topicContext.maxNumOfResolvableTopics >= 1;
        }
        topicReferenceWasUsedInCurrentContext() {
          return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
        }
        parseFSharpPipelineBody(prec) {
          const startLoc = this.state.startLoc;
          this.state.potentialArrowAt = this.state.start;
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = true;
          const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          return ret;
        }
        parseModuleExpression() {
          this.expectPlugin("moduleBlocks");
          const node = this.startNode();
          this.next();
          if (!this.match(5)) {
            this.unexpected(null, 5);
          }
          const program = this.startNodeAt(this.state.endLoc);
          this.next();
          const revertScopes = this.initializeScopes(true);
          this.enterInitialScopes();
          try {
            node.body = this.parseProgram(program, 8, "module");
          } finally {
            revertScopes();
          }
          return this.finishNode(node, "ModuleExpression");
        }
        parsePropertyNamePrefixOperator(prop) {
        }
      };
      var loopLabel = {
        kind: "loop"
      };
      var switchLabel = {
        kind: "switch"
      };
      var loneSurrogate = /[\uD800-\uDFFF]/u;
      var keywordRelationalOperator = /in(?:stanceof)?/y;
      function babel7CompatTokens(tokens, input) {
        for (let i = 0; i < tokens.length; i++) {
          const token = tokens[i];
          const {
            type
          } = token;
          if (typeof type === "number") {
            {
              if (type === 136) {
                const {
                  loc,
                  start,
                  value,
                  end
                } = token;
                const hashEndPos = start + 1;
                const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
                tokens.splice(i, 1, new Token({
                  type: getExportedToken(27),
                  value: "#",
                  start,
                  end: hashEndPos,
                  startLoc: loc.start,
                  endLoc: hashEndLoc
                }), new Token({
                  type: getExportedToken(130),
                  value,
                  start: hashEndPos,
                  end,
                  startLoc: hashEndLoc,
                  endLoc: loc.end
                }));
                i++;
                continue;
              }
              if (tokenIsTemplate(type)) {
                const {
                  loc,
                  start,
                  value,
                  end
                } = token;
                const backquoteEnd = start + 1;
                const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
                let startToken;
                if (input.charCodeAt(start) === 96) {
                  startToken = new Token({
                    type: getExportedToken(22),
                    value: "`",
                    start,
                    end: backquoteEnd,
                    startLoc: loc.start,
                    endLoc: backquoteEndLoc
                  });
                } else {
                  startToken = new Token({
                    type: getExportedToken(8),
                    value: "}",
                    start,
                    end: backquoteEnd,
                    startLoc: loc.start,
                    endLoc: backquoteEndLoc
                  });
                }
                let templateValue, templateElementEnd, templateElementEndLoc, endToken;
                if (type === 24) {
                  templateElementEnd = end - 1;
                  templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);
                  templateValue = value === null ? null : value.slice(1, -1);
                  endToken = new Token({
                    type: getExportedToken(22),
                    value: "`",
                    start: templateElementEnd,
                    end,
                    startLoc: templateElementEndLoc,
                    endLoc: loc.end
                  });
                } else {
                  templateElementEnd = end - 2;
                  templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);
                  templateValue = value === null ? null : value.slice(1, -2);
                  endToken = new Token({
                    type: getExportedToken(23),
                    value: "${",
                    start: templateElementEnd,
                    end,
                    startLoc: templateElementEndLoc,
                    endLoc: loc.end
                  });
                }
                tokens.splice(i, 1, startToken, new Token({
                  type: getExportedToken(20),
                  value: templateValue,
                  start: backquoteEnd,
                  end: templateElementEnd,
                  startLoc: backquoteEndLoc,
                  endLoc: templateElementEndLoc
                }), endToken);
                i += 2;
                continue;
              }
            }
            token.type = getExportedToken(type);
          }
        }
        return tokens;
      }
      var StatementParser = class extends ExpressionParser {
        parseTopLevel(file, program) {
          file.program = this.parseProgram(program);
          file.comments = this.state.comments;
          if (this.options.tokens) {
            file.tokens = babel7CompatTokens(this.tokens, this.input);
          }
          return this.finishNode(file, "File");
        }
        parseProgram(program, end = 137, sourceType = this.options.sourceType) {
          program.sourceType = sourceType;
          program.interpreter = this.parseInterpreterDirective();
          this.parseBlockBody(program, true, true, end);
          if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
            for (const [localName, at] of Array.from(this.scope.undefinedExports)) {
              this.raise(Errors.ModuleExportUndefined, {
                at,
                localName
              });
            }
          }
          let finishedProgram;
          if (end === 137) {
            finishedProgram = this.finishNode(program, "Program");
          } else {
            finishedProgram = this.finishNodeAt(program, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));
          }
          return finishedProgram;
        }
        stmtToDirective(stmt) {
          const directive = stmt;
          directive.type = "Directive";
          directive.value = directive.expression;
          delete directive.expression;
          const directiveLiteral = directive.value;
          const expressionValue = directiveLiteral.value;
          const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);
          const val = directiveLiteral.value = raw.slice(1, -1);
          this.addExtra(directiveLiteral, "raw", raw);
          this.addExtra(directiveLiteral, "rawValue", val);
          this.addExtra(directiveLiteral, "expressionValue", expressionValue);
          directiveLiteral.type = "DirectiveLiteral";
          return directive;
        }
        parseInterpreterDirective() {
          if (!this.match(28)) {
            return null;
          }
          const node = this.startNode();
          node.value = this.state.value;
          this.next();
          return this.finishNode(node, "InterpreterDirective");
        }
        isLet() {
          if (!this.isContextual(99)) {
            return false;
          }
          return this.hasFollowingBindingAtom();
        }
        chStartsBindingIdentifier(ch, pos) {
          if (isIdentifierStart(ch)) {
            keywordRelationalOperator.lastIndex = pos;
            if (keywordRelationalOperator.test(this.input)) {
              const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
              if (!isIdentifierChar(endCh) && endCh !== 92) {
                return false;
              }
            }
            return true;
          } else if (ch === 92) {
            return true;
          } else {
            return false;
          }
        }
        chStartsBindingPattern(ch) {
          return ch === 91 || ch === 123;
        }
        hasFollowingBindingAtom() {
          const next = this.nextTokenStart();
          const nextCh = this.codePointAtPos(next);
          return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
        }
        hasInLineFollowingBindingIdentifier() {
          const next = this.nextTokenInLineStart();
          const nextCh = this.codePointAtPos(next);
          return this.chStartsBindingIdentifier(nextCh, next);
        }
        startsUsingForOf() {
          const {
            type,
            containsEsc
          } = this.lookahead();
          if (type === 101 && !containsEsc) {
            return false;
          } else if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {
            this.expectPlugin("explicitResourceManagement");
            return true;
          }
        }
        startsAwaitUsing() {
          let next = this.nextTokenInLineStart();
          if (this.isUnparsedContextual(next, "using")) {
            next = this.nextTokenInLineStartSince(next + 5);
            const nextCh = this.codePointAtPos(next);
            if (this.chStartsBindingIdentifier(nextCh, next)) {
              this.expectPlugin("explicitResourceManagement");
              return true;
            }
          }
          return false;
        }
        parseModuleItem() {
          return this.parseStatementLike(1 | 2 | 4 | 8);
        }
        parseStatementListItem() {
          return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));
        }
        parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {
          let flags = 0;
          if (this.options.annexB && !this.state.strict) {
            flags |= 4;
            if (allowLabeledFunction) {
              flags |= 8;
            }
          }
          return this.parseStatementLike(flags);
        }
        parseStatement() {
          return this.parseStatementLike(0);
        }
        parseStatementLike(flags) {
          let decorators = null;
          if (this.match(26)) {
            decorators = this.parseDecorators(true);
          }
          return this.parseStatementContent(flags, decorators);
        }
        parseStatementContent(flags, decorators) {
          const starttype = this.state.type;
          const node = this.startNode();
          const allowDeclaration = !!(flags & 2);
          const allowFunctionDeclaration = !!(flags & 4);
          const topLevel = flags & 1;
          switch (starttype) {
            case 60:
              return this.parseBreakContinueStatement(node, true);
            case 63:
              return this.parseBreakContinueStatement(node, false);
            case 64:
              return this.parseDebuggerStatement(node);
            case 90:
              return this.parseDoWhileStatement(node);
            case 91:
              return this.parseForStatement(node);
            case 68:
              if (this.lookaheadCharCode() === 46)
                break;
              if (!allowFunctionDeclaration) {
                this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, {
                  at: this.state.startLoc
                });
              }
              return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);
            case 80:
              if (!allowDeclaration)
                this.unexpected();
              return this.parseClass(this.maybeTakeDecorators(decorators, node), true);
            case 69:
              return this.parseIfStatement(node);
            case 70:
              return this.parseReturnStatement(node);
            case 71:
              return this.parseSwitchStatement(node);
            case 72:
              return this.parseThrowStatement(node);
            case 73:
              return this.parseTryStatement(node);
            case 96:
              if (!this.state.containsEsc && this.startsAwaitUsing()) {
                if (!this.isAwaitAllowed()) {
                  this.raise(Errors.AwaitUsingNotInAsyncContext, {
                    at: node
                  });
                } else if (!allowDeclaration) {
                  this.raise(Errors.UnexpectedLexicalDeclaration, {
                    at: node
                  });
                }
                this.next();
                return this.parseVarStatement(node, "await using");
              }
              break;
            case 105:
              if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier()) {
                break;
              }
              this.expectPlugin("explicitResourceManagement");
              if (!this.scope.inModule && this.scope.inTopLevel) {
                this.raise(Errors.UnexpectedUsingDeclaration, {
                  at: this.state.startLoc
                });
              } else if (!allowDeclaration) {
                this.raise(Errors.UnexpectedLexicalDeclaration, {
                  at: this.state.startLoc
                });
              }
              return this.parseVarStatement(node, "using");
            case 99: {
              if (this.state.containsEsc) {
                break;
              }
              const next = this.nextTokenStart();
              const nextCh = this.codePointAtPos(next);
              if (nextCh !== 91) {
                if (!allowDeclaration && this.hasFollowingLineBreak())
                  break;
                if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {
                  break;
                }
              }
            }
            case 75: {
              if (!allowDeclaration) {
                this.raise(Errors.UnexpectedLexicalDeclaration, {
                  at: this.state.startLoc
                });
              }
            }
            case 74: {
              const kind = this.state.value;
              return this.parseVarStatement(node, kind);
            }
            case 92:
              return this.parseWhileStatement(node);
            case 76:
              return this.parseWithStatement(node);
            case 5:
              return this.parseBlock();
            case 13:
              return this.parseEmptyStatement(node);
            case 83: {
              const nextTokenCharCode = this.lookaheadCharCode();
              if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
                break;
              }
            }
            case 82: {
              if (!this.options.allowImportExportEverywhere && !topLevel) {
                this.raise(Errors.UnexpectedImportExport, {
                  at: this.state.startLoc
                });
              }
              this.next();
              let result;
              if (starttype === 83) {
                result = this.parseImport(node);
                if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                  this.sawUnambiguousESM = true;
                }
              } else {
                result = this.parseExport(node, decorators);
                if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                  this.sawUnambiguousESM = true;
                }
              }
              this.assertModuleNodeAllowed(result);
              return result;
            }
            default: {
              if (this.isAsyncFunction()) {
                if (!allowDeclaration) {
                  this.raise(Errors.AsyncFunctionInSingleStatementContext, {
                    at: this.state.startLoc
                  });
                }
                this.next();
                return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);
              }
            }
          }
          const maybeName = this.state.value;
          const expr = this.parseExpression();
          if (tokenIsIdentifier(starttype) && expr.type === "Identifier" && this.eat(14)) {
            return this.parseLabeledStatement(node, maybeName, expr, flags);
          } else {
            return this.parseExpressionStatement(node, expr, decorators);
          }
        }
        assertModuleNodeAllowed(node) {
          if (!this.options.allowImportExportEverywhere && !this.inModule) {
            this.raise(Errors.ImportOutsideModule, {
              at: node
            });
          }
        }
        decoratorsEnabledBeforeExport() {
          if (this.hasPlugin("decorators-legacy"))
            return true;
          return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
        }
        maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
          if (maybeDecorators) {
            if (classNode.decorators && classNode.decorators.length > 0) {
              if (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") !== "boolean") {
                this.raise(Errors.DecoratorsBeforeAfterExport, {
                  at: classNode.decorators[0]
                });
              }
              classNode.decorators.unshift(...maybeDecorators);
            } else {
              classNode.decorators = maybeDecorators;
            }
            this.resetStartLocationFromNode(classNode, maybeDecorators[0]);
            if (exportNode)
              this.resetStartLocationFromNode(exportNode, classNode);
          }
          return classNode;
        }
        canHaveLeadingDecorator() {
          return this.match(80);
        }
        parseDecorators(allowExport) {
          const decorators = [];
          do {
            decorators.push(this.parseDecorator());
          } while (this.match(26));
          if (this.match(82)) {
            if (!allowExport) {
              this.unexpected();
            }
            if (!this.decoratorsEnabledBeforeExport()) {
              this.raise(Errors.DecoratorExportClass, {
                at: this.state.startLoc
              });
            }
          } else if (!this.canHaveLeadingDecorator()) {
            throw this.raise(Errors.UnexpectedLeadingDecorator, {
              at: this.state.startLoc
            });
          }
          return decorators;
        }
        parseDecorator() {
          this.expectOnePlugin(["decorators", "decorators-legacy"]);
          const node = this.startNode();
          this.next();
          if (this.hasPlugin("decorators")) {
            const startLoc = this.state.startLoc;
            let expr;
            if (this.match(10)) {
              const startLoc2 = this.state.startLoc;
              this.next();
              expr = this.parseExpression();
              this.expect(11);
              expr = this.wrapParenthesis(startLoc2, expr);
              const paramsStartLoc = this.state.startLoc;
              node.expression = this.parseMaybeDecoratorArguments(expr);
              if (this.getPluginOption("decorators", "allowCallParenthesized") === false && node.expression !== expr) {
                this.raise(Errors.DecoratorArgumentsOutsideParentheses, {
                  at: paramsStartLoc
                });
              }
            } else {
              expr = this.parseIdentifier(false);
              while (this.eat(16)) {
                const node2 = this.startNodeAt(startLoc);
                node2.object = expr;
                if (this.match(136)) {
                  this.classScope.usePrivateName(this.state.value, this.state.startLoc);
                  node2.property = this.parsePrivateName();
                } else {
                  node2.property = this.parseIdentifier(true);
                }
                node2.computed = false;
                expr = this.finishNode(node2, "MemberExpression");
              }
              node.expression = this.parseMaybeDecoratorArguments(expr);
            }
          } else {
            node.expression = this.parseExprSubscripts();
          }
          return this.finishNode(node, "Decorator");
        }
        parseMaybeDecoratorArguments(expr) {
          if (this.eat(10)) {
            const node = this.startNodeAtNode(expr);
            node.callee = expr;
            node.arguments = this.parseCallExpressionArguments(11, false);
            this.toReferencedList(node.arguments);
            return this.finishNode(node, "CallExpression");
          }
          return expr;
        }
        parseBreakContinueStatement(node, isBreak) {
          this.next();
          if (this.isLineTerminator()) {
            node.label = null;
          } else {
            node.label = this.parseIdentifier();
            this.semicolon();
          }
          this.verifyBreakContinue(node, isBreak);
          return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
        }
        verifyBreakContinue(node, isBreak) {
          let i;
          for (i = 0; i < this.state.labels.length; ++i) {
            const lab = this.state.labels[i];
            if (node.label == null || lab.name === node.label.name) {
              if (lab.kind != null && (isBreak || lab.kind === "loop"))
                break;
              if (node.label && isBreak)
                break;
            }
          }
          if (i === this.state.labels.length) {
            const type = isBreak ? "BreakStatement" : "ContinueStatement";
            this.raise(Errors.IllegalBreakContinue, {
              at: node,
              type
            });
          }
        }
        parseDebuggerStatement(node) {
          this.next();
          this.semicolon();
          return this.finishNode(node, "DebuggerStatement");
        }
        parseHeaderExpression() {
          this.expect(10);
          const val = this.parseExpression();
          this.expect(11);
          return val;
        }
        parseDoWhileStatement(node) {
          this.next();
          this.state.labels.push(loopLabel);
          node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
          this.state.labels.pop();
          this.expect(92);
          node.test = this.parseHeaderExpression();
          this.eat(13);
          return this.finishNode(node, "DoWhileStatement");
        }
        parseForStatement(node) {
          this.next();
          this.state.labels.push(loopLabel);
          let awaitAt = null;
          if (this.isAwaitAllowed() && this.eatContextual(96)) {
            awaitAt = this.state.lastTokStartLoc;
          }
          this.scope.enter(SCOPE_OTHER);
          this.expect(10);
          if (this.match(13)) {
            if (awaitAt !== null) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node, null);
          }
          const startsWithLet = this.isContextual(99);
          {
            const startsWithAwaitUsing = this.isContextual(96) && this.startsAwaitUsing();
            const starsWithUsingDeclaration = startsWithAwaitUsing || this.isContextual(105) && this.startsUsingForOf();
            const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
            if (this.match(74) || this.match(75) || isLetOrUsing) {
              const initNode = this.startNode();
              let kind;
              if (startsWithAwaitUsing) {
                kind = "await using";
                if (!this.isAwaitAllowed()) {
                  this.raise(Errors.AwaitUsingNotInAsyncContext, {
                    at: this.state.startLoc
                  });
                }
                this.next();
              } else {
                kind = this.state.value;
              }
              this.next();
              this.parseVar(initNode, true, kind);
              const init2 = this.finishNode(initNode, "VariableDeclaration");
              const isForIn = this.match(58);
              if (isForIn && starsWithUsingDeclaration) {
                this.raise(Errors.ForInUsing, {
                  at: init2
                });
              }
              if ((isForIn || this.isContextual(101)) && init2.declarations.length === 1) {
                return this.parseForIn(node, init2, awaitAt);
              }
              if (awaitAt !== null) {
                this.unexpected(awaitAt);
              }
              return this.parseFor(node, init2);
            }
          }
          const startsWithAsync = this.isContextual(95);
          const refExpressionErrors = new ExpressionErrors();
          const init = this.parseExpression(true, refExpressionErrors);
          const isForOf = this.isContextual(101);
          if (isForOf) {
            if (startsWithLet) {
              this.raise(Errors.ForOfLet, {
                at: init
              });
            }
            if (awaitAt === null && startsWithAsync && init.type === "Identifier") {
              this.raise(Errors.ForOfAsync, {
                at: init
              });
            }
          }
          if (isForOf || this.match(58)) {
            this.checkDestructuringPrivate(refExpressionErrors);
            this.toAssignable(init, true);
            const type = isForOf ? "ForOfStatement" : "ForInStatement";
            this.checkLVal(init, {
              in: {
                type
              }
            });
            return this.parseForIn(node, init, awaitAt);
          } else {
            this.checkExpressionErrors(refExpressionErrors, true);
          }
          if (awaitAt !== null) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, init);
        }
        parseFunctionStatement(node, isAsync, isHangingDeclaration) {
          this.next();
          return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));
        }
        parseIfStatement(node) {
          this.next();
          node.test = this.parseHeaderExpression();
          node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
          node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;
          return this.finishNode(node, "IfStatement");
        }
        parseReturnStatement(node) {
          if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
            this.raise(Errors.IllegalReturn, {
              at: this.state.startLoc
            });
          }
          this.next();
          if (this.isLineTerminator()) {
            node.argument = null;
          } else {
            node.argument = this.parseExpression();
            this.semicolon();
          }
          return this.finishNode(node, "ReturnStatement");
        }
        parseSwitchStatement(node) {
          this.next();
          node.discriminant = this.parseHeaderExpression();
          const cases = node.cases = [];
          this.expect(5);
          this.state.labels.push(switchLabel);
          this.scope.enter(SCOPE_OTHER);
          let cur;
          for (let sawDefault; !this.match(8); ) {
            if (this.match(61) || this.match(65)) {
              const isCase = this.match(61);
              if (cur)
                this.finishNode(cur, "SwitchCase");
              cases.push(cur = this.startNode());
              cur.consequent = [];
              this.next();
              if (isCase) {
                cur.test = this.parseExpression();
              } else {
                if (sawDefault) {
                  this.raise(Errors.MultipleDefaultsInSwitch, {
                    at: this.state.lastTokStartLoc
                  });
                }
                sawDefault = true;
                cur.test = null;
              }
              this.expect(14);
            } else {
              if (cur) {
                cur.consequent.push(this.parseStatementListItem());
              } else {
                this.unexpected();
              }
            }
          }
          this.scope.exit();
          if (cur)
            this.finishNode(cur, "SwitchCase");
          this.next();
          this.state.labels.pop();
          return this.finishNode(node, "SwitchStatement");
        }
        parseThrowStatement(node) {
          this.next();
          if (this.hasPrecedingLineBreak()) {
            this.raise(Errors.NewlineAfterThrow, {
              at: this.state.lastTokEndLoc
            });
          }
          node.argument = this.parseExpression();
          this.semicolon();
          return this.finishNode(node, "ThrowStatement");
        }
        parseCatchClauseParam() {
          const param = this.parseBindingAtom();
          this.scope.enter(this.options.annexB && param.type === "Identifier" ? SCOPE_SIMPLE_CATCH : 0);
          this.checkLVal(param, {
            in: {
              type: "CatchClause"
            },
            binding: BIND_CATCH_PARAM
          });
          return param;
        }
        parseTryStatement(node) {
          this.next();
          node.block = this.parseBlock();
          node.handler = null;
          if (this.match(62)) {
            const clause = this.startNode();
            this.next();
            if (this.match(10)) {
              this.expect(10);
              clause.param = this.parseCatchClauseParam();
              this.expect(11);
            } else {
              clause.param = null;
              this.scope.enter(SCOPE_OTHER);
            }
            clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
            this.scope.exit();
            node.handler = this.finishNode(clause, "CatchClause");
          }
          node.finalizer = this.eat(67) ? this.parseBlock() : null;
          if (!node.handler && !node.finalizer) {
            this.raise(Errors.NoCatchOrFinally, {
              at: node
            });
          }
          return this.finishNode(node, "TryStatement");
        }
        parseVarStatement(node, kind, allowMissingInitializer = false) {
          this.next();
          this.parseVar(node, false, kind, allowMissingInitializer);
          this.semicolon();
          return this.finishNode(node, "VariableDeclaration");
        }
        parseWhileStatement(node) {
          this.next();
          node.test = this.parseHeaderExpression();
          this.state.labels.push(loopLabel);
          node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
          this.state.labels.pop();
          return this.finishNode(node, "WhileStatement");
        }
        parseWithStatement(node) {
          if (this.state.strict) {
            this.raise(Errors.StrictWith, {
              at: this.state.startLoc
            });
          }
          this.next();
          node.object = this.parseHeaderExpression();
          node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
          return this.finishNode(node, "WithStatement");
        }
        parseEmptyStatement(node) {
          this.next();
          return this.finishNode(node, "EmptyStatement");
        }
        parseLabeledStatement(node, maybeName, expr, flags) {
          for (const label of this.state.labels) {
            if (label.name === maybeName) {
              this.raise(Errors.LabelRedeclaration, {
                at: expr,
                labelName: maybeName
              });
            }
          }
          const kind = tokenIsLoop(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
          for (let i = this.state.labels.length - 1; i >= 0; i--) {
            const label = this.state.labels[i];
            if (label.statementStart === node.start) {
              label.statementStart = this.state.start;
              label.kind = kind;
            } else {
              break;
            }
          }
          this.state.labels.push({
            name: maybeName,
            kind,
            statementStart: this.state.start
          });
          node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();
          this.state.labels.pop();
          node.label = expr;
          return this.finishNode(node, "LabeledStatement");
        }
        parseExpressionStatement(node, expr, decorators) {
          node.expression = expr;
          this.semicolon();
          return this.finishNode(node, "ExpressionStatement");
        }
        parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
          const node = this.startNode();
          if (allowDirectives) {
            this.state.strictErrors.clear();
          }
          this.expect(5);
          if (createNewLexicalScope) {
            this.scope.enter(SCOPE_OTHER);
          }
          this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);
          if (createNewLexicalScope) {
            this.scope.exit();
          }
          return this.finishNode(node, "BlockStatement");
        }
        isValidDirective(stmt) {
          return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
        }
        parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
          const body = node.body = [];
          const directives = node.directives = [];
          this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
        }
        parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
          const oldStrict = this.state.strict;
          let hasStrictModeDirective = false;
          let parsedNonDirective = false;
          while (!this.match(end)) {
            const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
            if (directives && !parsedNonDirective) {
              if (this.isValidDirective(stmt)) {
                const directive = this.stmtToDirective(stmt);
                directives.push(directive);
                if (!hasStrictModeDirective && directive.value.value === "use strict") {
                  hasStrictModeDirective = true;
                  this.setStrict(true);
                }
                continue;
              }
              parsedNonDirective = true;
              this.state.strictErrors.clear();
            }
            body.push(stmt);
          }
          if (afterBlockParse) {
            afterBlockParse.call(this, hasStrictModeDirective);
          }
          if (!oldStrict) {
            this.setStrict(false);
          }
          this.next();
        }
        parseFor(node, init) {
          node.init = init;
          this.semicolon(false);
          node.test = this.match(13) ? null : this.parseExpression();
          this.semicolon(false);
          node.update = this.match(11) ? null : this.parseExpression();
          this.expect(11);
          node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
          this.scope.exit();
          this.state.labels.pop();
          return this.finishNode(node, "ForStatement");
        }
        parseForIn(node, init, awaitAt) {
          const isForIn = this.match(58);
          this.next();
          if (isForIn) {
            if (awaitAt !== null)
              this.unexpected(awaitAt);
          } else {
            node.await = awaitAt !== null;
          }
          if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
            this.raise(Errors.ForInOfLoopInitializer, {
              at: init,
              type: isForIn ? "ForInStatement" : "ForOfStatement"
            });
          }
          if (init.type === "AssignmentPattern") {
            this.raise(Errors.InvalidLhs, {
              at: init,
              ancestor: {
                type: "ForStatement"
              }
            });
          }
          node.left = init;
          node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
          this.expect(11);
          node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
          this.scope.exit();
          this.state.labels.pop();
          return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
        }
        parseVar(node, isFor, kind, allowMissingInitializer = false) {
          const declarations = node.declarations = [];
          node.kind = kind;
          for (; ; ) {
            const decl = this.startNode();
            this.parseVarId(decl, kind);
            decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
            if (decl.init === null && !allowMissingInitializer) {
              if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(101)))) {
                this.raise(Errors.DeclarationMissingInitializer, {
                  at: this.state.lastTokEndLoc,
                  kind: "destructuring"
                });
              } else if (kind === "const" && !(this.match(58) || this.isContextual(101))) {
                this.raise(Errors.DeclarationMissingInitializer, {
                  at: this.state.lastTokEndLoc,
                  kind: "const"
                });
              }
            }
            declarations.push(this.finishNode(decl, "VariableDeclarator"));
            if (!this.eat(12))
              break;
          }
          return node;
        }
        parseVarId(decl, kind) {
          const id = this.parseBindingAtom();
          this.checkLVal(id, {
            in: {
              type: "VariableDeclarator"
            },
            binding: kind === "var" ? BIND_VAR : BIND_LEXICAL
          });
          decl.id = id;
        }
        parseAsyncFunctionExpression(node) {
          return this.parseFunction(node, 8);
        }
        parseFunction(node, flags = 0) {
          const hangingDeclaration = flags & 2;
          const isDeclaration = !!(flags & 1);
          const requireId = isDeclaration && !(flags & 4);
          const isAsync = !!(flags & 8);
          this.initFunction(node, isAsync);
          if (this.match(55)) {
            if (hangingDeclaration) {
              this.raise(Errors.GeneratorInSingleStatementContext, {
                at: this.state.startLoc
              });
            }
            this.next();
            node.generator = true;
          }
          if (isDeclaration) {
            node.id = this.parseFunctionId(requireId);
          }
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          this.state.maybeInArrowParameters = false;
          this.scope.enter(SCOPE_FUNCTION);
          this.prodParam.enter(functionFlags(isAsync, node.generator));
          if (!isDeclaration) {
            node.id = this.parseFunctionId();
          }
          this.parseFunctionParams(node, false);
          this.withSmartMixTopicForbiddingContext(() => {
            this.parseFunctionBodyAndFinish(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
          });
          this.prodParam.exit();
          this.scope.exit();
          if (isDeclaration && !hangingDeclaration) {
            this.registerFunctionStatementId(node);
          }
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          return node;
        }
        parseFunctionId(requireId) {
          return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
        }
        parseFunctionParams(node, isConstructor) {
          this.expect(10);
          this.expressionScope.enter(newParameterDeclarationScope());
          node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));
          this.expressionScope.exit();
        }
        registerFunctionStatementId(node) {
          if (!node.id)
            return;
          this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.loc.start);
        }
        parseClass(node, isStatement, optionalId) {
          this.next();
          const oldStrict = this.state.strict;
          this.state.strict = true;
          this.parseClassId(node, isStatement, optionalId);
          this.parseClassSuper(node);
          node.body = this.parseClassBody(!!node.superClass, oldStrict);
          return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
        }
        isClassProperty() {
          return this.match(29) || this.match(13) || this.match(8);
        }
        isClassMethod() {
          return this.match(10);
        }
        isNonstaticConstructor(method) {
          return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
        }
        parseClassBody(hadSuperClass, oldStrict) {
          this.classScope.enter();
          const state = {
            hadConstructor: false,
            hadSuperClass
          };
          let decorators = [];
          const classBody = this.startNode();
          classBody.body = [];
          this.expect(5);
          this.withSmartMixTopicForbiddingContext(() => {
            while (!this.match(8)) {
              if (this.eat(13)) {
                if (decorators.length > 0) {
                  throw this.raise(Errors.DecoratorSemicolon, {
                    at: this.state.lastTokEndLoc
                  });
                }
                continue;
              }
              if (this.match(26)) {
                decorators.push(this.parseDecorator());
                continue;
              }
              const member = this.startNode();
              if (decorators.length) {
                member.decorators = decorators;
                this.resetStartLocationFromNode(member, decorators[0]);
                decorators = [];
              }
              this.parseClassMember(classBody, member, state);
              if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
                this.raise(Errors.DecoratorConstructor, {
                  at: member
                });
              }
            }
          });
          this.state.strict = oldStrict;
          this.next();
          if (decorators.length) {
            throw this.raise(Errors.TrailingDecorator, {
              at: this.state.startLoc
            });
          }
          this.classScope.exit();
          return this.finishNode(classBody, "ClassBody");
        }
        parseClassMemberFromModifier(classBody, member) {
          const key = this.parseIdentifier(true);
          if (this.isClassMethod()) {
            const method = member;
            method.kind = "method";
            method.computed = false;
            method.key = key;
            method.static = false;
            this.pushClassMethod(classBody, method, false, false, false, false);
            return true;
          } else if (this.isClassProperty()) {
            const prop = member;
            prop.computed = false;
            prop.key = key;
            prop.static = false;
            classBody.body.push(this.parseClassProperty(prop));
            return true;
          }
          this.resetPreviousNodeTrailingComments(key);
          return false;
        }
        parseClassMember(classBody, member, state) {
          const isStatic = this.isContextual(104);
          if (isStatic) {
            if (this.parseClassMemberFromModifier(classBody, member)) {
              return;
            }
            if (this.eat(5)) {
              this.parseClassStaticBlock(classBody, member);
              return;
            }
          }
          this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
        }
        parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
          const publicMethod = member;
          const privateMethod = member;
          const publicProp = member;
          const privateProp = member;
          const accessorProp = member;
          const method = publicMethod;
          const publicMember = publicMethod;
          member.static = isStatic;
          this.parsePropertyNamePrefixOperator(member);
          if (this.eat(55)) {
            method.kind = "method";
            const isPrivateName = this.match(136);
            this.parseClassElementName(method);
            if (isPrivateName) {
              this.pushClassPrivateMethod(classBody, privateMethod, true, false);
              return;
            }
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(Errors.ConstructorIsGenerator, {
                at: publicMethod.key
              });
            }
            this.pushClassMethod(classBody, publicMethod, true, false, false, false);
            return;
          }
          const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;
          const isPrivate = this.match(136);
          const key = this.parseClassElementName(member);
          const maybeQuestionTokenStartLoc = this.state.startLoc;
          this.parsePostMemberNameModifiers(publicMember);
          if (this.isClassMethod()) {
            method.kind = "method";
            if (isPrivate) {
              this.pushClassPrivateMethod(classBody, privateMethod, false, false);
              return;
            }
            const isConstructor = this.isNonstaticConstructor(publicMethod);
            let allowsDirectSuper = false;
            if (isConstructor) {
              publicMethod.kind = "constructor";
              if (state.hadConstructor && !this.hasPlugin("typescript")) {
                this.raise(Errors.DuplicateConstructor, {
                  at: key
                });
              }
              if (isConstructor && this.hasPlugin("typescript") && member.override) {
                this.raise(Errors.OverrideOnConstructor, {
                  at: key
                });
              }
              state.hadConstructor = true;
              allowsDirectSuper = state.hadSuperClass;
            }
            this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
          } else if (this.isClassProperty()) {
            if (isPrivate) {
              this.pushClassPrivateProperty(classBody, privateProp);
            } else {
              this.pushClassProperty(classBody, publicProp);
            }
          } else if (isContextual && key.name === "async" && !this.isLineTerminator()) {
            this.resetPreviousNodeTrailingComments(key);
            const isGenerator = this.eat(55);
            if (publicMember.optional) {
              this.unexpected(maybeQuestionTokenStartLoc);
            }
            method.kind = "method";
            const isPrivate2 = this.match(136);
            this.parseClassElementName(method);
            this.parsePostMemberNameModifiers(publicMember);
            if (isPrivate2) {
              this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
            } else {
              if (this.isNonstaticConstructor(publicMethod)) {
                this.raise(Errors.ConstructorIsAsync, {
                  at: publicMethod.key
                });
              }
              this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
            }
          } else if (isContextual && (key.name === "get" || key.name === "set") && !(this.match(55) && this.isLineTerminator())) {
            this.resetPreviousNodeTrailingComments(key);
            method.kind = key.name;
            const isPrivate2 = this.match(136);
            this.parseClassElementName(publicMethod);
            if (isPrivate2) {
              this.pushClassPrivateMethod(classBody, privateMethod, false, false);
            } else {
              if (this.isNonstaticConstructor(publicMethod)) {
                this.raise(Errors.ConstructorIsAccessor, {
                  at: publicMethod.key
                });
              }
              this.pushClassMethod(classBody, publicMethod, false, false, false, false);
            }
            this.checkGetterSetterParams(publicMethod);
          } else if (isContextual && key.name === "accessor" && !this.isLineTerminator()) {
            this.expectPlugin("decoratorAutoAccessors");
            this.resetPreviousNodeTrailingComments(key);
            const isPrivate2 = this.match(136);
            this.parseClassElementName(publicProp);
            this.pushClassAccessorProperty(classBody, accessorProp, isPrivate2);
          } else if (this.isLineTerminator()) {
            if (isPrivate) {
              this.pushClassPrivateProperty(classBody, privateProp);
            } else {
              this.pushClassProperty(classBody, publicProp);
            }
          } else {
            this.unexpected();
          }
        }
        parseClassElementName(member) {
          const {
            type,
            value
          } = this.state;
          if ((type === 130 || type === 131) && member.static && value === "prototype") {
            this.raise(Errors.StaticPrototype, {
              at: this.state.startLoc
            });
          }
          if (type === 136) {
            if (value === "constructor") {
              this.raise(Errors.ConstructorClassPrivateField, {
                at: this.state.startLoc
              });
            }
            const key = this.parsePrivateName();
            member.key = key;
            return key;
          }
          return this.parsePropertyName(member);
        }
        parseClassStaticBlock(classBody, member) {
          var _member$decorators;
          this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);
          const oldLabels = this.state.labels;
          this.state.labels = [];
          this.prodParam.enter(PARAM);
          const body = member.body = [];
          this.parseBlockOrModuleBlockBody(body, void 0, false, 8);
          this.prodParam.exit();
          this.scope.exit();
          this.state.labels = oldLabels;
          classBody.body.push(this.finishNode(member, "StaticBlock"));
          if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
            this.raise(Errors.DecoratorStaticBlock, {
              at: member
            });
          }
        }
        pushClassProperty(classBody, prop) {
          if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
            this.raise(Errors.ConstructorClassField, {
              at: prop.key
            });
          }
          classBody.body.push(this.parseClassProperty(prop));
        }
        pushClassPrivateProperty(classBody, prop) {
          const node = this.parseClassPrivateProperty(prop);
          classBody.body.push(node);
          this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);
        }
        pushClassAccessorProperty(classBody, prop, isPrivate) {
          if (!isPrivate && !prop.computed) {
            const key = prop.key;
            if (key.name === "constructor" || key.value === "constructor") {
              this.raise(Errors.ConstructorClassField, {
                at: key
              });
            }
          }
          const node = this.parseClassAccessorProperty(prop);
          classBody.body.push(node);
          if (isPrivate) {
            this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);
          }
        }
        pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
        }
        pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
          const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
          classBody.body.push(node);
          const kind = node.kind === "get" ? node.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === "set" ? node.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;
          this.declareClassPrivateMethodInScope(node, kind);
        }
        declareClassPrivateMethodInScope(node, kind) {
          this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
        }
        parsePostMemberNameModifiers(methodOrProp) {
        }
        parseClassPrivateProperty(node) {
          this.parseInitializer(node);
          this.semicolon();
          return this.finishNode(node, "ClassPrivateProperty");
        }
        parseClassProperty(node) {
          this.parseInitializer(node);
          this.semicolon();
          return this.finishNode(node, "ClassProperty");
        }
        parseClassAccessorProperty(node) {
          this.parseInitializer(node);
          this.semicolon();
          return this.finishNode(node, "ClassAccessorProperty");
        }
        parseInitializer(node) {
          this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
          this.expressionScope.enter(newExpressionScope());
          this.prodParam.enter(PARAM);
          node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
          this.expressionScope.exit();
          this.prodParam.exit();
          this.scope.exit();
        }
        parseClassId(node, isStatement, optionalId, bindingType = BIND_CLASS) {
          if (tokenIsIdentifier(this.state.type)) {
            node.id = this.parseIdentifier();
            if (isStatement) {
              this.declareNameFromIdentifier(node.id, bindingType);
            }
          } else {
            if (optionalId || !isStatement) {
              node.id = null;
            } else {
              throw this.raise(Errors.MissingClassName, {
                at: this.state.startLoc
              });
            }
          }
        }
        parseClassSuper(node) {
          node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
        }
        parseExport(node, decorators) {
          const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);
          const hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
          const parseAfterDefault = !hasDefault || this.eat(12);
          const hasStar = parseAfterDefault && this.eatExportStar(node);
          const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
          const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
          const isFromRequired = hasDefault || hasStar;
          if (hasStar && !hasNamespace) {
            if (hasDefault)
              this.unexpected();
            if (decorators) {
              throw this.raise(Errors.UnsupportedDecoratorExport, {
                at: node
              });
            }
            this.parseExportFrom(node, true);
            return this.finishNode(node, "ExportAllDeclaration");
          }
          const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
          if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {
            this.unexpected(null, 5);
          }
          if (hasNamespace && parseAfterNamespace) {
            this.unexpected(null, 97);
          }
          let hasDeclaration;
          if (isFromRequired || hasSpecifiers) {
            hasDeclaration = false;
            if (decorators) {
              throw this.raise(Errors.UnsupportedDecoratorExport, {
                at: node
              });
            }
            this.parseExportFrom(node, isFromRequired);
          } else {
            hasDeclaration = this.maybeParseExportDeclaration(node);
          }
          if (isFromRequired || hasSpecifiers || hasDeclaration) {
            var _node2$declaration;
            const node2 = node;
            this.checkExport(node2, true, false, !!node2.source);
            if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === "ClassDeclaration") {
              this.maybeTakeDecorators(decorators, node2.declaration, node2);
            } else if (decorators) {
              throw this.raise(Errors.UnsupportedDecoratorExport, {
                at: node
              });
            }
            return this.finishNode(node2, "ExportNamedDeclaration");
          }
          if (this.eat(65)) {
            const node2 = node;
            const decl = this.parseExportDefaultExpression();
            node2.declaration = decl;
            if (decl.type === "ClassDeclaration") {
              this.maybeTakeDecorators(decorators, decl, node2);
            } else if (decorators) {
              throw this.raise(Errors.UnsupportedDecoratorExport, {
                at: node
              });
            }
            this.checkExport(node2, true, true);
            return this.finishNode(node2, "ExportDefaultDeclaration");
          }
          this.unexpected(null, 5);
        }
        eatExportStar(node) {
          return this.eat(55);
        }
        maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
          if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
            this.expectPlugin("exportDefaultFrom", maybeDefaultIdentifier == null ? void 0 : maybeDefaultIdentifier.loc.start);
            const id = maybeDefaultIdentifier || this.parseIdentifier(true);
            const specifier = this.startNodeAtNode(id);
            specifier.exported = id;
            node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
            return true;
          }
          return false;
        }
        maybeParseExportNamespaceSpecifier(node) {
          if (this.isContextual(93)) {
            if (!node.specifiers)
              node.specifiers = [];
            const specifier = this.startNodeAt(this.state.lastTokStartLoc);
            this.next();
            specifier.exported = this.parseModuleExportName();
            node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
            return true;
          }
          return false;
        }
        maybeParseExportNamedSpecifiers(node) {
          if (this.match(5)) {
            if (!node.specifiers)
              node.specifiers = [];
            const isTypeExport = node.exportKind === "type";
            node.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
            node.source = null;
            node.declaration = null;
            if (this.hasPlugin("importAssertions")) {
              node.assertions = [];
            }
            return true;
          }
          return false;
        }
        maybeParseExportDeclaration(node) {
          if (this.shouldParseExportDeclaration()) {
            node.specifiers = [];
            node.source = null;
            if (this.hasPlugin("importAssertions")) {
              node.assertions = [];
            }
            node.declaration = this.parseExportDeclaration(node);
            return true;
          }
          return false;
        }
        isAsyncFunction() {
          if (!this.isContextual(95))
            return false;
          const next = this.nextTokenInLineStart();
          return this.isUnparsedContextual(next, "function");
        }
        parseExportDefaultExpression() {
          const expr = this.startNode();
          if (this.match(68)) {
            this.next();
            return this.parseFunction(expr, 1 | 4);
          } else if (this.isAsyncFunction()) {
            this.next();
            this.next();
            return this.parseFunction(expr, 1 | 4 | 8);
          }
          if (this.match(80)) {
            return this.parseClass(expr, true, true);
          }
          if (this.match(26)) {
            if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
              this.raise(Errors.DecoratorBeforeExport, {
                at: this.state.startLoc
              });
            }
            return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
          }
          if (this.match(75) || this.match(74) || this.isLet()) {
            throw this.raise(Errors.UnsupportedDefaultExport, {
              at: this.state.startLoc
            });
          }
          const res = this.parseMaybeAssignAllowIn();
          this.semicolon();
          return res;
        }
        parseExportDeclaration(node) {
          if (this.match(80)) {
            const node2 = this.parseClass(this.startNode(), true, false);
            return node2;
          }
          return this.parseStatementListItem();
        }
        isExportDefaultSpecifier() {
          const {
            type
          } = this.state;
          if (tokenIsIdentifier(type)) {
            if (type === 95 && !this.state.containsEsc || type === 99) {
              return false;
            }
            if ((type === 128 || type === 127) && !this.state.containsEsc) {
              const {
                type: nextType
              } = this.lookahead();
              if (tokenIsIdentifier(nextType) && nextType !== 97 || nextType === 5) {
                this.expectOnePlugin(["flow", "typescript"]);
                return false;
              }
            }
          } else if (!this.match(65)) {
            return false;
          }
          const next = this.nextTokenStart();
          const hasFrom = this.isUnparsedContextual(next, "from");
          if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
            return true;
          }
          if (this.match(65) && hasFrom) {
            const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
            return nextAfterFrom === 34 || nextAfterFrom === 39;
          }
          return false;
        }
        parseExportFrom(node, expect) {
          if (this.eatContextual(97)) {
            node.source = this.parseImportSource();
            this.checkExport(node);
            this.maybeParseImportAttributes(node);
            this.checkJSONModuleImport(node);
          } else if (expect) {
            this.unexpected();
          }
          this.semicolon();
        }
        shouldParseExportDeclaration() {
          const {
            type
          } = this.state;
          if (type === 26) {
            this.expectOnePlugin(["decorators", "decorators-legacy"]);
            if (this.hasPlugin("decorators")) {
              if (this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
                this.raise(Errors.DecoratorBeforeExport, {
                  at: this.state.startLoc
                });
              }
              return true;
            }
          }
          return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
        }
        checkExport(node, checkNames, isDefault, isFrom) {
          if (checkNames) {
            if (isDefault) {
              this.checkDuplicateExports(node, "default");
              if (this.hasPlugin("exportDefaultFrom")) {
                var _declaration$extra;
                const declaration = node.declaration;
                if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
                  this.raise(Errors.ExportDefaultFromAsIdentifier, {
                    at: declaration
                  });
                }
              }
            } else if (node.specifiers && node.specifiers.length) {
              for (const specifier of node.specifiers) {
                const {
                  exported
                } = specifier;
                const exportName = exported.type === "Identifier" ? exported.name : exported.value;
                this.checkDuplicateExports(specifier, exportName);
                if (!isFrom && specifier.local) {
                  const {
                    local
                  } = specifier;
                  if (local.type !== "Identifier") {
                    this.raise(Errors.ExportBindingIsString, {
                      at: specifier,
                      localName: local.value,
                      exportName
                    });
                  } else {
                    this.checkReservedWord(local.name, local.loc.start, true, false);
                    this.scope.checkLocalExport(local);
                  }
                }
              }
            } else if (node.declaration) {
              if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
                const id = node.declaration.id;
                if (!id)
                  throw new Error("Assertion failure");
                this.checkDuplicateExports(node, id.name);
              } else if (node.declaration.type === "VariableDeclaration") {
                for (const declaration of node.declaration.declarations) {
                  this.checkDeclaration(declaration.id);
                }
              }
            }
          }
        }
        checkDeclaration(node) {
          if (node.type === "Identifier") {
            this.checkDuplicateExports(node, node.name);
          } else if (node.type === "ObjectPattern") {
            for (const prop of node.properties) {
              this.checkDeclaration(prop);
            }
          } else if (node.type === "ArrayPattern") {
            for (const elem of node.elements) {
              if (elem) {
                this.checkDeclaration(elem);
              }
            }
          } else if (node.type === "ObjectProperty") {
            this.checkDeclaration(node.value);
          } else if (node.type === "RestElement") {
            this.checkDeclaration(node.argument);
          } else if (node.type === "AssignmentPattern") {
            this.checkDeclaration(node.left);
          }
        }
        checkDuplicateExports(node, exportName) {
          if (this.exportedIdentifiers.has(exportName)) {
            if (exportName === "default") {
              this.raise(Errors.DuplicateDefaultExport, {
                at: node
              });
            } else {
              this.raise(Errors.DuplicateExport, {
                at: node,
                exportName
              });
            }
          }
          this.exportedIdentifiers.add(exportName);
        }
        parseExportSpecifiers(isInTypeExport) {
          const nodes = [];
          let first = true;
          this.expect(5);
          while (!this.eat(8)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
              if (this.eat(8))
                break;
            }
            const isMaybeTypeOnly = this.isContextual(128);
            const isString = this.match(131);
            const node = this.startNode();
            node.local = this.parseModuleExportName();
            nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
          }
          return nodes;
        }
        parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
          if (this.eatContextual(93)) {
            node.exported = this.parseModuleExportName();
          } else if (isString) {
            node.exported = cloneStringLiteral(node.local);
          } else if (!node.exported) {
            node.exported = cloneIdentifier(node.local);
          }
          return this.finishNode(node, "ExportSpecifier");
        }
        parseModuleExportName() {
          if (this.match(131)) {
            const result = this.parseStringLiteral(this.state.value);
            const surrogate = result.value.match(loneSurrogate);
            if (surrogate) {
              this.raise(Errors.ModuleExportNameHasLoneSurrogate, {
                at: result,
                surrogateCharCode: surrogate[0].charCodeAt(0)
              });
            }
            return result;
          }
          return this.parseIdentifier(true);
        }
        isJSONModuleImport(node) {
          if (node.assertions != null) {
            return node.assertions.some(({
              key,
              value
            }) => {
              return value.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");
            });
          }
          return false;
        }
        checkImportReflection(node) {
          if (node.module) {
            var _node$assertions;
            if (node.specifiers.length !== 1 || node.specifiers[0].type !== "ImportDefaultSpecifier") {
              this.raise(Errors.ImportReflectionNotBinding, {
                at: node.specifiers[0].loc.start
              });
            }
            if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) {
              this.raise(Errors.ImportReflectionHasAssertion, {
                at: node.specifiers[0].loc.start
              });
            }
          }
        }
        checkJSONModuleImport(node) {
          if (this.isJSONModuleImport(node) && node.type !== "ExportAllDeclaration") {
            const {
              specifiers
            } = node;
            if (specifiers != null) {
              const nonDefaultNamedSpecifier = specifiers.find((specifier) => {
                let imported;
                if (specifier.type === "ExportSpecifier") {
                  imported = specifier.local;
                } else if (specifier.type === "ImportSpecifier") {
                  imported = specifier.imported;
                }
                if (imported !== void 0) {
                  return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
                }
              });
              if (nonDefaultNamedSpecifier !== void 0) {
                this.raise(Errors.ImportJSONBindingNotDefault, {
                  at: nonDefaultNamedSpecifier.loc.start
                });
              }
            }
          }
        }
        isPotentialImportPhase(isExport) {
          return !isExport && this.isContextual(125);
        }
        applyImportPhase(node, isExport, phase, loc) {
          if (isExport) {
            return;
          }
          if (phase === "module") {
            this.expectPlugin("importReflection", loc);
            node.module = true;
          } else if (this.hasPlugin("importReflection")) {
            node.module = false;
          }
        }
        parseMaybeImportPhase(node, isExport) {
          if (!this.isPotentialImportPhase(isExport)) {
            this.applyImportPhase(node, isExport, null);
            return null;
          }
          const phaseIdentifier = this.parseIdentifier(true);
          const {
            type
          } = this.state;
          const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 97 || this.lookaheadCharCode() === 102 : type !== 12;
          if (isImportPhase) {
            this.resetPreviousIdentifierLeadingComments(phaseIdentifier);
            this.applyImportPhase(node, isExport, phaseIdentifier.name, phaseIdentifier.loc.start);
            return null;
          } else {
            this.applyImportPhase(node, isExport, null);
            return phaseIdentifier;
          }
        }
        isPrecedingIdImportPhase(phase) {
          const {
            type
          } = this.state;
          return tokenIsIdentifier(type) ? type !== 97 || this.lookaheadCharCode() === 102 : type !== 12;
        }
        parseImport(node) {
          if (this.match(131)) {
            return this.parseImportSourceAndAttributes(node);
          }
          return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));
        }
        parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {
          node.specifiers = [];
          const hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);
          const parseNext = !hasDefault || this.eat(12);
          const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
          if (parseNext && !hasStar)
            this.parseNamedImportSpecifiers(node);
          this.expectContextual(97);
          return this.parseImportSourceAndAttributes(node);
        }
        parseImportSourceAndAttributes(node) {
          var _node$specifiers;
          (_node$specifiers = node.specifiers) != null ? _node$specifiers : node.specifiers = [];
          node.source = this.parseImportSource();
          this.maybeParseImportAttributes(node);
          this.checkImportReflection(node);
          this.checkJSONModuleImport(node);
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }
        parseImportSource() {
          if (!this.match(131))
            this.unexpected();
          return this.parseExprAtom();
        }
        parseImportSpecifierLocal(node, specifier, type) {
          specifier.local = this.parseIdentifier();
          node.specifiers.push(this.finishImportSpecifier(specifier, type));
        }
        finishImportSpecifier(specifier, type, bindingType = BIND_LEXICAL) {
          this.checkLVal(specifier.local, {
            in: {
              type
            },
            binding: bindingType
          });
          return this.finishNode(specifier, type);
        }
        parseImportAttributes() {
          this.expect(5);
          const attrs = [];
          const attrNames = /* @__PURE__ */ new Set();
          do {
            if (this.match(8)) {
              break;
            }
            const node = this.startNode();
            const keyName = this.state.value;
            if (attrNames.has(keyName)) {
              this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
                at: this.state.startLoc,
                key: keyName
              });
            }
            attrNames.add(keyName);
            if (this.match(131)) {
              node.key = this.parseStringLiteral(keyName);
            } else {
              node.key = this.parseIdentifier(true);
            }
            this.expect(14);
            if (!this.match(131)) {
              throw this.raise(Errors.ModuleAttributeInvalidValue, {
                at: this.state.startLoc
              });
            }
            node.value = this.parseStringLiteral(this.state.value);
            attrs.push(this.finishNode(node, "ImportAttribute"));
          } while (this.eat(12));
          this.expect(8);
          return attrs;
        }
        parseModuleAttributes() {
          const attrs = [];
          const attributes = /* @__PURE__ */ new Set();
          do {
            const node = this.startNode();
            node.key = this.parseIdentifier(true);
            if (node.key.name !== "type") {
              this.raise(Errors.ModuleAttributeDifferentFromType, {
                at: node.key
              });
            }
            if (attributes.has(node.key.name)) {
              this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
                at: node.key,
                key: node.key.name
              });
            }
            attributes.add(node.key.name);
            this.expect(14);
            if (!this.match(131)) {
              throw this.raise(Errors.ModuleAttributeInvalidValue, {
                at: this.state.startLoc
              });
            }
            node.value = this.parseStringLiteral(this.state.value);
            attrs.push(this.finishNode(node, "ImportAttribute"));
          } while (this.eat(12));
          return attrs;
        }
        maybeParseImportAttributes(node) {
          let attributes;
          let useWith = false;
          if (this.match(76)) {
            if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {
              return;
            }
            this.next();
            {
              if (this.hasPlugin("moduleAttributes")) {
                attributes = this.parseModuleAttributes();
              } else {
                this.expectImportAttributesPlugin();
                attributes = this.parseImportAttributes();
              }
            }
            useWith = true;
          } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
            if (this.hasPlugin("importAttributes")) {
              if (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== true) {
                this.raise(Errors.ImportAttributesUseAssert, {
                  at: this.state.startLoc
                });
              }
              this.addExtra(node, "deprecatedAssertSyntax", true);
            } else {
              this.expectOnePlugin(["importAttributes", "importAssertions"]);
            }
            this.next();
            attributes = this.parseImportAttributes();
          } else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
            attributes = [];
          } else {
            if (this.hasPlugin("moduleAttributes")) {
              attributes = [];
            } else
              return;
          }
          if (!useWith && this.hasPlugin("importAssertions")) {
            node.assertions = attributes;
          } else {
            node.attributes = attributes;
          }
        }
        maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {
          if (maybeDefaultIdentifier) {
            const specifier = this.startNodeAtNode(maybeDefaultIdentifier);
            specifier.local = maybeDefaultIdentifier;
            node.specifiers.push(this.finishImportSpecifier(specifier, "ImportDefaultSpecifier"));
            return true;
          } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
            this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier");
            return true;
          }
          return false;
        }
        maybeParseStarImportSpecifier(node) {
          if (this.match(55)) {
            const specifier = this.startNode();
            this.next();
            this.expectContextual(93);
            this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier");
            return true;
          }
          return false;
        }
        parseNamedImportSpecifiers(node) {
          let first = true;
          this.expect(5);
          while (!this.eat(8)) {
            if (first) {
              first = false;
            } else {
              if (this.eat(14)) {
                throw this.raise(Errors.DestructureNamedImport, {
                  at: this.state.startLoc
                });
              }
              this.expect(12);
              if (this.eat(8))
                break;
            }
            const specifier = this.startNode();
            const importedIsString = this.match(131);
            const isMaybeTypeOnly = this.isContextual(128);
            specifier.imported = this.parseModuleExportName();
            const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly, void 0);
            node.specifiers.push(importSpecifier);
          }
        }
        parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
          if (this.eatContextual(93)) {
            specifier.local = this.parseIdentifier();
          } else {
            const {
              imported
            } = specifier;
            if (importedIsString) {
              throw this.raise(Errors.ImportBindingIsString, {
                at: specifier,
                importName: imported.value
              });
            }
            this.checkReservedWord(imported.name, specifier.loc.start, true, true);
            if (!specifier.local) {
              specifier.local = cloneIdentifier(imported);
            }
          }
          return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
        }
        isThisParam(param) {
          return param.type === "Identifier" && param.name === "this";
        }
      };
      var Parser = class extends StatementParser {
        constructor(options, input) {
          options = getOptions(options);
          super(options, input);
          this.options = options;
          this.initializeScopes();
          this.plugins = pluginsMap(this.options.plugins);
          this.filename = options.sourceFilename;
        }
        getScopeHandler() {
          return ScopeHandler;
        }
        parse() {
          this.enterInitialScopes();
          const file = this.startNode();
          const program = this.startNode();
          this.nextToken();
          file.errors = null;
          this.parseTopLevel(file, program);
          file.errors = this.state.errors;
          return file;
        }
      };
      function pluginsMap(plugins) {
        const pluginMap = /* @__PURE__ */ new Map();
        for (const plugin of plugins) {
          const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];
          if (!pluginMap.has(name))
            pluginMap.set(name, options || {});
        }
        return pluginMap;
      }
      function parse(input, options) {
        var _options;
        if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
          options = Object.assign({}, options);
          try {
            options.sourceType = "module";
            const parser = getParser(options, input);
            const ast = parser.parse();
            if (parser.sawUnambiguousESM) {
              return ast;
            }
            if (parser.ambiguousScriptDifferentAst) {
              try {
                options.sourceType = "script";
                return getParser(options, input).parse();
              } catch (_unused) {
              }
            } else {
              ast.program.sourceType = "script";
            }
            return ast;
          } catch (moduleError) {
            try {
              options.sourceType = "script";
              return getParser(options, input).parse();
            } catch (_unused2) {
            }
            throw moduleError;
          }
        } else {
          return getParser(options, input).parse();
        }
      }
      function parseExpression(input, options) {
        const parser = getParser(options, input);
        if (parser.options.strictMode) {
          parser.state.strict = true;
        }
        return parser.getExpression();
      }
      function generateExportedTokenTypes(internalTokenTypes) {
        const tokenTypes2 = {};
        for (const typeName of Object.keys(internalTokenTypes)) {
          tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);
        }
        return tokenTypes2;
      }
      var tokTypes = generateExportedTokenTypes(tt);
      function getParser(options, input) {
        let cls = Parser;
        if (options != null && options.plugins) {
          validatePlugins(options.plugins);
          cls = getParserClass(options.plugins);
        }
        return new cls(options, input);
      }
      var parserClassCache = {};
      function getParserClass(pluginsFromOptions) {
        const pluginList = mixinPluginNames.filter((name) => hasPlugin(pluginsFromOptions, name));
        const key = pluginList.join("/");
        let cls = parserClassCache[key];
        if (!cls) {
          cls = Parser;
          for (const plugin of pluginList) {
            cls = mixinPlugins[plugin](cls);
          }
          parserClassCache[key] = cls;
        }
        return cls;
      }
      exports.parse = parse;
      exports.parseExpression = parseExpression;
      exports.tokTypes = tokTypes;
    }
  });

  // node_modules/source-map-js/lib/base64.js
  var require_base64 = __commonJS({
    "node_modules/source-map-js/lib/base64.js"(exports) {
      var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
      exports.encode = function(number) {
        if (0 <= number && number < intToCharMap.length) {
          return intToCharMap[number];
        }
        throw new TypeError("Must be between 0 and 63: " + number);
      };
      exports.decode = function(charCode) {
        var bigA = 65;
        var bigZ = 90;
        var littleA = 97;
        var littleZ = 122;
        var zero = 48;
        var nine = 57;
        var plus = 43;
        var slash = 47;
        var littleOffset = 26;
        var numberOffset = 52;
        if (bigA <= charCode && charCode <= bigZ) {
          return charCode - bigA;
        }
        if (littleA <= charCode && charCode <= littleZ) {
          return charCode - littleA + littleOffset;
        }
        if (zero <= charCode && charCode <= nine) {
          return charCode - zero + numberOffset;
        }
        if (charCode == plus) {
          return 62;
        }
        if (charCode == slash) {
          return 63;
        }
        return -1;
      };
    }
  });

  // node_modules/source-map-js/lib/base64-vlq.js
  var require_base64_vlq = __commonJS({
    "node_modules/source-map-js/lib/base64-vlq.js"(exports) {
      var base64 = require_base64();
      var VLQ_BASE_SHIFT = 5;
      var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
      var VLQ_BASE_MASK = VLQ_BASE - 1;
      var VLQ_CONTINUATION_BIT = VLQ_BASE;
      function toVLQSigned(aValue) {
        return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
      }
      function fromVLQSigned(aValue) {
        var isNegative = (aValue & 1) === 1;
        var shifted = aValue >> 1;
        return isNegative ? -shifted : shifted;
      }
      exports.encode = function base64VLQ_encode(aValue) {
        var encoded = "";
        var digit;
        var vlq = toVLQSigned(aValue);
        do {
          digit = vlq & VLQ_BASE_MASK;
          vlq >>>= VLQ_BASE_SHIFT;
          if (vlq > 0) {
            digit |= VLQ_CONTINUATION_BIT;
          }
          encoded += base64.encode(digit);
        } while (vlq > 0);
        return encoded;
      };
      exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
        var strLen = aStr.length;
        var result = 0;
        var shift = 0;
        var continuation, digit;
        do {
          if (aIndex >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
          }
          digit = base64.decode(aStr.charCodeAt(aIndex++));
          if (digit === -1) {
            throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
          }
          continuation = !!(digit & VLQ_CONTINUATION_BIT);
          digit &= VLQ_BASE_MASK;
          result = result + (digit << shift);
          shift += VLQ_BASE_SHIFT;
        } while (continuation);
        aOutParam.value = fromVLQSigned(result);
        aOutParam.rest = aIndex;
      };
    }
  });

  // node_modules/source-map-js/lib/util.js
  var require_util = __commonJS({
    "node_modules/source-map-js/lib/util.js"(exports) {
      function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) {
          return aArgs[aName];
        } else if (arguments.length === 3) {
          return aDefaultValue;
        } else {
          throw new Error('"' + aName + '" is a required argument.');
        }
      }
      exports.getArg = getArg;
      var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
      var dataUrlRegexp = /^data:.+\,.+$/;
      function urlParse(aUrl) {
        var match = aUrl.match(urlRegexp);
        if (!match) {
          return null;
        }
        return {
          scheme: match[1],
          auth: match[2],
          host: match[3],
          port: match[4],
          path: match[5]
        };
      }
      exports.urlParse = urlParse;
      function urlGenerate(aParsedUrl) {
        var url = "";
        if (aParsedUrl.scheme) {
          url += aParsedUrl.scheme + ":";
        }
        url += "//";
        if (aParsedUrl.auth) {
          url += aParsedUrl.auth + "@";
        }
        if (aParsedUrl.host) {
          url += aParsedUrl.host;
        }
        if (aParsedUrl.port) {
          url += ":" + aParsedUrl.port;
        }
        if (aParsedUrl.path) {
          url += aParsedUrl.path;
        }
        return url;
      }
      exports.urlGenerate = urlGenerate;
      var MAX_CACHED_INPUTS = 32;
      function lruMemoize(f) {
        var cache = [];
        return function(input) {
          for (var i = 0; i < cache.length; i++) {
            if (cache[i].input === input) {
              var temp = cache[0];
              cache[0] = cache[i];
              cache[i] = temp;
              return cache[0].result;
            }
          }
          var result = f(input);
          cache.unshift({
            input,
            result
          });
          if (cache.length > MAX_CACHED_INPUTS) {
            cache.pop();
          }
          return result;
        };
      }
      var normalize = lruMemoize(function normalize2(aPath) {
        var path = aPath;
        var url = urlParse(aPath);
        if (url) {
          if (!url.path) {
            return aPath;
          }
          path = url.path;
        }
        var isAbsolute = exports.isAbsolute(path);
        var parts = [];
        var start = 0;
        var i = 0;
        while (true) {
          start = i;
          i = path.indexOf("/", start);
          if (i === -1) {
            parts.push(path.slice(start));
            break;
          } else {
            parts.push(path.slice(start, i));
            while (i < path.length && path[i] === "/") {
              i++;
            }
          }
        }
        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
          part = parts[i];
          if (part === ".") {
            parts.splice(i, 1);
          } else if (part === "..") {
            up++;
          } else if (up > 0) {
            if (part === "") {
              parts.splice(i + 1, up);
              up = 0;
            } else {
              parts.splice(i, 2);
              up--;
            }
          }
        }
        path = parts.join("/");
        if (path === "") {
          path = isAbsolute ? "/" : ".";
        }
        if (url) {
          url.path = path;
          return urlGenerate(url);
        }
        return path;
      });
      exports.normalize = normalize;
      function join(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        if (aPath === "") {
          aPath = ".";
        }
        var aPathUrl = urlParse(aPath);
        var aRootUrl = urlParse(aRoot);
        if (aRootUrl) {
          aRoot = aRootUrl.path || "/";
        }
        if (aPathUrl && !aPathUrl.scheme) {
          if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
          }
          return urlGenerate(aPathUrl);
        }
        if (aPathUrl || aPath.match(dataUrlRegexp)) {
          return aPath;
        }
        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
          aRootUrl.host = aPath;
          return urlGenerate(aRootUrl);
        }
        var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
        if (aRootUrl) {
          aRootUrl.path = joined;
          return urlGenerate(aRootUrl);
        }
        return joined;
      }
      exports.join = join;
      exports.isAbsolute = function(aPath) {
        return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
      };
      function relative(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        aRoot = aRoot.replace(/\/$/, "");
        var level = 0;
        while (aPath.indexOf(aRoot + "/") !== 0) {
          var index = aRoot.lastIndexOf("/");
          if (index < 0) {
            return aPath;
          }
          aRoot = aRoot.slice(0, index);
          if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
            return aPath;
          }
          ++level;
        }
        return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
      }
      exports.relative = relative;
      var supportsNullProto = function() {
        var obj = /* @__PURE__ */ Object.create(null);
        return !("__proto__" in obj);
      }();
      function identity(s) {
        return s;
      }
      function toSetString(aStr) {
        if (isProtoString(aStr)) {
          return "$" + aStr;
        }
        return aStr;
      }
      exports.toSetString = supportsNullProto ? identity : toSetString;
      function fromSetString(aStr) {
        if (isProtoString(aStr)) {
          return aStr.slice(1);
        }
        return aStr;
      }
      exports.fromSetString = supportsNullProto ? identity : fromSetString;
      function isProtoString(s) {
        if (!s) {
          return false;
        }
        var length = s.length;
        if (length < 9) {
          return false;
        }
        if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
          return false;
        }
        for (var i = length - 10; i >= 0; i--) {
          if (s.charCodeAt(i) !== 36) {
            return false;
          }
        }
        return true;
      }
      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
        var cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0 || onlyCompareOriginal) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByOriginalPositions = compareByOriginalPositions;
      function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
        var cmp;
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0 || onlyCompareOriginal) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
      function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0 || onlyCompareGenerated) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
      function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
        var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0 || onlyCompareGenerated) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
      function strcmp(aStr1, aStr2) {
        if (aStr1 === aStr2) {
          return 0;
        }
        if (aStr1 === null) {
          return 1;
        }
        if (aStr2 === null) {
          return -1;
        }
        if (aStr1 > aStr2) {
          return 1;
        }
        return -1;
      }
      function compareByGeneratedPositionsInflated(mappingA, mappingB) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
      function parseSourceMapInput(str) {
        return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
      }
      exports.parseSourceMapInput = parseSourceMapInput;
      function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
        sourceURL = sourceURL || "";
        if (sourceRoot) {
          if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
            sourceRoot += "/";
          }
          sourceURL = sourceRoot + sourceURL;
        }
        if (sourceMapURL) {
          var parsed = urlParse(sourceMapURL);
          if (!parsed) {
            throw new Error("sourceMapURL could not be parsed");
          }
          if (parsed.path) {
            var index = parsed.path.lastIndexOf("/");
            if (index >= 0) {
              parsed.path = parsed.path.substring(0, index + 1);
            }
          }
          sourceURL = join(urlGenerate(parsed), sourceURL);
        }
        return normalize(sourceURL);
      }
      exports.computeSourceURL = computeSourceURL;
    }
  });

  // node_modules/source-map-js/lib/array-set.js
  var require_array_set = __commonJS({
    "node_modules/source-map-js/lib/array-set.js"(exports) {
      var util = require_util();
      var has = Object.prototype.hasOwnProperty;
      var hasNativeMap = typeof Map !== "undefined";
      function ArraySet() {
        this._array = [];
        this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
      }
      ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
        var set = new ArraySet();
        for (var i = 0, len = aArray.length; i < len; i++) {
          set.add(aArray[i], aAllowDuplicates);
        }
        return set;
      };
      ArraySet.prototype.size = function ArraySet_size() {
        return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
      };
      ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
        var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
        var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
        var idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          if (hasNativeMap) {
            this._set.set(aStr, idx);
          } else {
            this._set[sStr] = idx;
          }
        }
      };
      ArraySet.prototype.has = function ArraySet_has(aStr) {
        if (hasNativeMap) {
          return this._set.has(aStr);
        } else {
          var sStr = util.toSetString(aStr);
          return has.call(this._set, sStr);
        }
      };
      ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
        if (hasNativeMap) {
          var idx = this._set.get(aStr);
          if (idx >= 0) {
            return idx;
          }
        } else {
          var sStr = util.toSetString(aStr);
          if (has.call(this._set, sStr)) {
            return this._set[sStr];
          }
        }
        throw new Error('"' + aStr + '" is not in the set.');
      };
      ArraySet.prototype.at = function ArraySet_at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error("No element indexed by " + aIdx);
      };
      ArraySet.prototype.toArray = function ArraySet_toArray() {
        return this._array.slice();
      };
      exports.ArraySet = ArraySet;
    }
  });

  // node_modules/source-map-js/lib/mapping-list.js
  var require_mapping_list = __commonJS({
    "node_modules/source-map-js/lib/mapping-list.js"(exports) {
      var util = require_util();
      function generatedPositionAfter(mappingA, mappingB) {
        var lineA = mappingA.generatedLine;
        var lineB = mappingB.generatedLine;
        var columnA = mappingA.generatedColumn;
        var columnB = mappingB.generatedColumn;
        return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
      }
      function MappingList() {
        this._array = [];
        this._sorted = true;
        this._last = { generatedLine: -1, generatedColumn: 0 };
      }
      MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
        this._array.forEach(aCallback, aThisArg);
      };
      MappingList.prototype.add = function MappingList_add(aMapping) {
        if (generatedPositionAfter(this._last, aMapping)) {
          this._last = aMapping;
          this._array.push(aMapping);
        } else {
          this._sorted = false;
          this._array.push(aMapping);
        }
      };
      MappingList.prototype.toArray = function MappingList_toArray() {
        if (!this._sorted) {
          this._array.sort(util.compareByGeneratedPositionsInflated);
          this._sorted = true;
        }
        return this._array;
      };
      exports.MappingList = MappingList;
    }
  });

  // node_modules/source-map-js/lib/source-map-generator.js
  var require_source_map_generator = __commonJS({
    "node_modules/source-map-js/lib/source-map-generator.js"(exports) {
      var base64VLQ = require_base64_vlq();
      var util = require_util();
      var ArraySet = require_array_set().ArraySet;
      var MappingList = require_mapping_list().MappingList;
      function SourceMapGenerator(aArgs) {
        if (!aArgs) {
          aArgs = {};
        }
        this._file = util.getArg(aArgs, "file", null);
        this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
        this._skipValidation = util.getArg(aArgs, "skipValidation", false);
        this._sources = new ArraySet();
        this._names = new ArraySet();
        this._mappings = new MappingList();
        this._sourcesContents = null;
      }
      SourceMapGenerator.prototype._version = 3;
      SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
        var sourceRoot = aSourceMapConsumer.sourceRoot;
        var generator = new SourceMapGenerator({
          file: aSourceMapConsumer.file,
          sourceRoot
        });
        aSourceMapConsumer.eachMapping(function(mapping) {
          var newMapping = {
            generated: {
              line: mapping.generatedLine,
              column: mapping.generatedColumn
            }
          };
          if (mapping.source != null) {
            newMapping.source = mapping.source;
            if (sourceRoot != null) {
              newMapping.source = util.relative(sourceRoot, newMapping.source);
            }
            newMapping.original = {
              line: mapping.originalLine,
              column: mapping.originalColumn
            };
            if (mapping.name != null) {
              newMapping.name = mapping.name;
            }
          }
          generator.addMapping(newMapping);
        });
        aSourceMapConsumer.sources.forEach(function(sourceFile) {
          var sourceRelative = sourceFile;
          if (sourceRoot !== null) {
            sourceRelative = util.relative(sourceRoot, sourceFile);
          }
          if (!generator._sources.has(sourceRelative)) {
            generator._sources.add(sourceRelative);
          }
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            generator.setSourceContent(sourceFile, content);
          }
        });
        return generator;
      };
      SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
        var generated = util.getArg(aArgs, "generated");
        var original = util.getArg(aArgs, "original", null);
        var source = util.getArg(aArgs, "source", null);
        var name = util.getArg(aArgs, "name", null);
        if (!this._skipValidation) {
          this._validateMapping(generated, original, source, name);
        }
        if (source != null) {
          source = String(source);
          if (!this._sources.has(source)) {
            this._sources.add(source);
          }
        }
        if (name != null) {
          name = String(name);
          if (!this._names.has(name)) {
            this._names.add(name);
          }
        }
        this._mappings.add({
          generatedLine: generated.line,
          generatedColumn: generated.column,
          originalLine: original != null && original.line,
          originalColumn: original != null && original.column,
          source,
          name
        });
      };
      SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
        var source = aSourceFile;
        if (this._sourceRoot != null) {
          source = util.relative(this._sourceRoot, source);
        }
        if (aSourceContent != null) {
          if (!this._sourcesContents) {
            this._sourcesContents = /* @__PURE__ */ Object.create(null);
          }
          this._sourcesContents[util.toSetString(source)] = aSourceContent;
        } else if (this._sourcesContents) {
          delete this._sourcesContents[util.toSetString(source)];
          if (Object.keys(this._sourcesContents).length === 0) {
            this._sourcesContents = null;
          }
        }
      };
      SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
        var sourceFile = aSourceFile;
        if (aSourceFile == null) {
          if (aSourceMapConsumer.file == null) {
            throw new Error(
              `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
            );
          }
          sourceFile = aSourceMapConsumer.file;
        }
        var sourceRoot = this._sourceRoot;
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        var newSources = new ArraySet();
        var newNames = new ArraySet();
        this._mappings.unsortedForEach(function(mapping) {
          if (mapping.source === sourceFile && mapping.originalLine != null) {
            var original = aSourceMapConsumer.originalPositionFor({
              line: mapping.originalLine,
              column: mapping.originalColumn
            });
            if (original.source != null) {
              mapping.source = original.source;
              if (aSourceMapPath != null) {
                mapping.source = util.join(aSourceMapPath, mapping.source);
              }
              if (sourceRoot != null) {
                mapping.source = util.relative(sourceRoot, mapping.source);
              }
              mapping.originalLine = original.line;
              mapping.originalColumn = original.column;
              if (original.name != null) {
                mapping.name = original.name;
              }
            }
          }
          var source = mapping.source;
          if (source != null && !newSources.has(source)) {
            newSources.add(source);
          }
          var name = mapping.name;
          if (name != null && !newNames.has(name)) {
            newNames.add(name);
          }
        }, this);
        this._sources = newSources;
        this._names = newNames;
        aSourceMapConsumer.sources.forEach(function(sourceFile2) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
          if (content != null) {
            if (aSourceMapPath != null) {
              sourceFile2 = util.join(aSourceMapPath, sourceFile2);
            }
            if (sourceRoot != null) {
              sourceFile2 = util.relative(sourceRoot, sourceFile2);
            }
            this.setSourceContent(sourceFile2, content);
          }
        }, this);
      };
      SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
        if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
          throw new Error(
            "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
          );
        }
        if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
          return;
        } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
          return;
        } else {
          throw new Error("Invalid mapping: " + JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName
          }));
        }
      };
      SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
        var previousGeneratedColumn = 0;
        var previousGeneratedLine = 1;
        var previousOriginalColumn = 0;
        var previousOriginalLine = 0;
        var previousName = 0;
        var previousSource = 0;
        var result = "";
        var next;
        var mapping;
        var nameIdx;
        var sourceIdx;
        var mappings = this._mappings.toArray();
        for (var i = 0, len = mappings.length; i < len; i++) {
          mapping = mappings[i];
          next = "";
          if (mapping.generatedLine !== previousGeneratedLine) {
            previousGeneratedColumn = 0;
            while (mapping.generatedLine !== previousGeneratedLine) {
              next += ";";
              previousGeneratedLine++;
            }
          } else {
            if (i > 0) {
              if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
                continue;
              }
              next += ",";
            }
          }
          next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
          previousGeneratedColumn = mapping.generatedColumn;
          if (mapping.source != null) {
            sourceIdx = this._sources.indexOf(mapping.source);
            next += base64VLQ.encode(sourceIdx - previousSource);
            previousSource = sourceIdx;
            next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
            previousOriginalLine = mapping.originalLine - 1;
            next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
            previousOriginalColumn = mapping.originalColumn;
            if (mapping.name != null) {
              nameIdx = this._names.indexOf(mapping.name);
              next += base64VLQ.encode(nameIdx - previousName);
              previousName = nameIdx;
            }
          }
          result += next;
        }
        return result;
      };
      SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
        return aSources.map(function(source) {
          if (!this._sourcesContents) {
            return null;
          }
          if (aSourceRoot != null) {
            source = util.relative(aSourceRoot, source);
          }
          var key = util.toSetString(source);
          return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
        }, this);
      };
      SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
        var map = {
          version: this._version,
          sources: this._sources.toArray(),
          names: this._names.toArray(),
          mappings: this._serializeMappings()
        };
        if (this._file != null) {
          map.file = this._file;
        }
        if (this._sourceRoot != null) {
          map.sourceRoot = this._sourceRoot;
        }
        if (this._sourcesContents) {
          map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
        }
        return map;
      };
      SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
        return JSON.stringify(this.toJSON());
      };
      exports.SourceMapGenerator = SourceMapGenerator;
    }
  });

  // node_modules/source-map-js/lib/binary-search.js
  var require_binary_search = __commonJS({
    "node_modules/source-map-js/lib/binary-search.js"(exports) {
      exports.GREATEST_LOWER_BOUND = 1;
      exports.LEAST_UPPER_BOUND = 2;
      function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
        var mid = Math.floor((aHigh - aLow) / 2) + aLow;
        var cmp = aCompare(aNeedle, aHaystack[mid], true);
        if (cmp === 0) {
          return mid;
        } else if (cmp > 0) {
          if (aHigh - mid > 1) {
            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
          }
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return aHigh < aHaystack.length ? aHigh : -1;
          } else {
            return mid;
          }
        } else {
          if (mid - aLow > 1) {
            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
          }
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return mid;
          } else {
            return aLow < 0 ? -1 : aLow;
          }
        }
      }
      exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
        if (aHaystack.length === 0) {
          return -1;
        }
        var index = recursiveSearch(
          -1,
          aHaystack.length,
          aNeedle,
          aHaystack,
          aCompare,
          aBias || exports.GREATEST_LOWER_BOUND
        );
        if (index < 0) {
          return -1;
        }
        while (index - 1 >= 0) {
          if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
            break;
          }
          --index;
        }
        return index;
      };
    }
  });

  // node_modules/source-map-js/lib/quick-sort.js
  var require_quick_sort = __commonJS({
    "node_modules/source-map-js/lib/quick-sort.js"(exports) {
      function SortTemplate(comparator) {
        function swap(ary, x, y) {
          var temp = ary[x];
          ary[x] = ary[y];
          ary[y] = temp;
        }
        function randomIntInRange(low, high) {
          return Math.round(low + Math.random() * (high - low));
        }
        function doQuickSort(ary, comparator2, p, r) {
          if (p < r) {
            var pivotIndex = randomIntInRange(p, r);
            var i = p - 1;
            swap(ary, pivotIndex, r);
            var pivot = ary[r];
            for (var j = p; j < r; j++) {
              if (comparator2(ary[j], pivot, false) <= 0) {
                i += 1;
                swap(ary, i, j);
              }
            }
            swap(ary, i + 1, j);
            var q = i + 1;
            doQuickSort(ary, comparator2, p, q - 1);
            doQuickSort(ary, comparator2, q + 1, r);
          }
        }
        return doQuickSort;
      }
      function cloneSort(comparator) {
        let template = SortTemplate.toString();
        let templateFn = new Function(`return ${template}`)();
        return templateFn(comparator);
      }
      var sortCache = /* @__PURE__ */ new WeakMap();
      exports.quickSort = function(ary, comparator, start = 0) {
        let doQuickSort = sortCache.get(comparator);
        if (doQuickSort === void 0) {
          doQuickSort = cloneSort(comparator);
          sortCache.set(comparator, doQuickSort);
        }
        doQuickSort(ary, comparator, start, ary.length - 1);
      };
    }
  });

  // node_modules/source-map-js/lib/source-map-consumer.js
  var require_source_map_consumer = __commonJS({
    "node_modules/source-map-js/lib/source-map-consumer.js"(exports) {
      var util = require_util();
      var binarySearch = require_binary_search();
      var ArraySet = require_array_set().ArraySet;
      var base64VLQ = require_base64_vlq();
      var quickSort = require_quick_sort().quickSort;
      function SourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }
        return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
      }
      SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
        return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
      };
      SourceMapConsumer.prototype._version = 3;
      SourceMapConsumer.prototype.__generatedMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
        configurable: true,
        enumerable: true,
        get: function() {
          if (!this.__generatedMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__generatedMappings;
        }
      });
      SourceMapConsumer.prototype.__originalMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
        configurable: true,
        enumerable: true,
        get: function() {
          if (!this.__originalMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__originalMappings;
        }
      });
      SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
        var c = aStr.charAt(index);
        return c === ";" || c === ",";
      };
      SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        throw new Error("Subclasses must implement _parseMappings");
      };
      SourceMapConsumer.GENERATED_ORDER = 1;
      SourceMapConsumer.ORIGINAL_ORDER = 2;
      SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
      SourceMapConsumer.LEAST_UPPER_BOUND = 2;
      SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
        var context = aContext || null;
        var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
        var mappings;
        switch (order) {
          case SourceMapConsumer.GENERATED_ORDER:
            mappings = this._generatedMappings;
            break;
          case SourceMapConsumer.ORIGINAL_ORDER:
            mappings = this._originalMappings;
            break;
          default:
            throw new Error("Unknown order of iteration.");
        }
        var sourceRoot = this.sourceRoot;
        var boundCallback = aCallback.bind(context);
        var names = this._names;
        var sources = this._sources;
        var sourceMapURL = this._sourceMapURL;
        for (var i = 0, n = mappings.length; i < n; i++) {
          var mapping = mappings[i];
          var source = mapping.source === null ? null : sources.at(mapping.source);
          source = util.computeSourceURL(sourceRoot, source, sourceMapURL);
          boundCallback({
            source,
            generatedLine: mapping.generatedLine,
            generatedColumn: mapping.generatedColumn,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: mapping.name === null ? null : names.at(mapping.name)
          });
        }
      };
      SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
        var line = util.getArg(aArgs, "line");
        var needle = {
          source: util.getArg(aArgs, "source"),
          originalLine: line,
          originalColumn: util.getArg(aArgs, "column", 0)
        };
        needle.source = this._findSourceIndex(needle.source);
        if (needle.source < 0) {
          return [];
        }
        var mappings = [];
        var index = this._findMapping(
          needle,
          this._originalMappings,
          "originalLine",
          "originalColumn",
          util.compareByOriginalPositions,
          binarySearch.LEAST_UPPER_BOUND
        );
        if (index >= 0) {
          var mapping = this._originalMappings[index];
          if (aArgs.column === void 0) {
            var originalLine = mapping.originalLine;
            while (mapping && mapping.originalLine === originalLine) {
              mappings.push({
                line: util.getArg(mapping, "generatedLine", null),
                column: util.getArg(mapping, "generatedColumn", null),
                lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
              });
              mapping = this._originalMappings[++index];
            }
          } else {
            var originalColumn = mapping.originalColumn;
            while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
              mappings.push({
                line: util.getArg(mapping, "generatedLine", null),
                column: util.getArg(mapping, "generatedColumn", null),
                lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
              });
              mapping = this._originalMappings[++index];
            }
          }
        }
        return mappings;
      };
      exports.SourceMapConsumer = SourceMapConsumer;
      function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }
        var version = util.getArg(sourceMap, "version");
        var sources = util.getArg(sourceMap, "sources");
        var names = util.getArg(sourceMap, "names", []);
        var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
        var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
        var mappings = util.getArg(sourceMap, "mappings");
        var file = util.getArg(sourceMap, "file", null);
        if (version != this._version) {
          throw new Error("Unsupported version: " + version);
        }
        if (sourceRoot) {
          sourceRoot = util.normalize(sourceRoot);
        }
        sources = sources.map(String).map(util.normalize).map(function(source) {
          return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
        });
        this._names = ArraySet.fromArray(names.map(String), true);
        this._sources = ArraySet.fromArray(sources, true);
        this._absoluteSources = this._sources.toArray().map(function(s) {
          return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
        });
        this.sourceRoot = sourceRoot;
        this.sourcesContent = sourcesContent;
        this._mappings = mappings;
        this._sourceMapURL = aSourceMapURL;
        this.file = file;
      }
      BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
      BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
      BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
        var relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util.relative(this.sourceRoot, relativeSource);
        }
        if (this._sources.has(relativeSource)) {
          return this._sources.indexOf(relativeSource);
        }
        var i;
        for (i = 0; i < this._absoluteSources.length; ++i) {
          if (this._absoluteSources[i] == aSource) {
            return i;
          }
        }
        return -1;
      };
      BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
        var smc = Object.create(BasicSourceMapConsumer.prototype);
        var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
        var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
        smc.sourceRoot = aSourceMap._sourceRoot;
        smc.sourcesContent = aSourceMap._generateSourcesContent(
          smc._sources.toArray(),
          smc.sourceRoot
        );
        smc.file = aSourceMap._file;
        smc._sourceMapURL = aSourceMapURL;
        smc._absoluteSources = smc._sources.toArray().map(function(s) {
          return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
        });
        var generatedMappings = aSourceMap._mappings.toArray().slice();
        var destGeneratedMappings = smc.__generatedMappings = [];
        var destOriginalMappings = smc.__originalMappings = [];
        for (var i = 0, length = generatedMappings.length; i < length; i++) {
          var srcMapping = generatedMappings[i];
          var destMapping = new Mapping();
          destMapping.generatedLine = srcMapping.generatedLine;
          destMapping.generatedColumn = srcMapping.generatedColumn;
          if (srcMapping.source) {
            destMapping.source = sources.indexOf(srcMapping.source);
            destMapping.originalLine = srcMapping.originalLine;
            destMapping.originalColumn = srcMapping.originalColumn;
            if (srcMapping.name) {
              destMapping.name = names.indexOf(srcMapping.name);
            }
            destOriginalMappings.push(destMapping);
          }
          destGeneratedMappings.push(destMapping);
        }
        quickSort(smc.__originalMappings, util.compareByOriginalPositions);
        return smc;
      };
      BasicSourceMapConsumer.prototype._version = 3;
      Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
        get: function() {
          return this._absoluteSources.slice();
        }
      });
      function Mapping() {
        this.generatedLine = 0;
        this.generatedColumn = 0;
        this.source = null;
        this.originalLine = null;
        this.originalColumn = null;
        this.name = null;
      }
      var compareGenerated = util.compareByGeneratedPositionsDeflatedNoLine;
      function sortGenerated(array, start) {
        let l = array.length;
        let n = array.length - start;
        if (n <= 1) {
          return;
        } else if (n == 2) {
          let a = array[start];
          let b = array[start + 1];
          if (compareGenerated(a, b) > 0) {
            array[start] = b;
            array[start + 1] = a;
          }
        } else if (n < 20) {
          for (let i = start; i < l; i++) {
            for (let j = i; j > start; j--) {
              let a = array[j - 1];
              let b = array[j];
              if (compareGenerated(a, b) <= 0) {
                break;
              }
              array[j - 1] = b;
              array[j] = a;
            }
          }
        } else {
          quickSort(array, compareGenerated, start);
        }
      }
      BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        var generatedLine = 1;
        var previousGeneratedColumn = 0;
        var previousOriginalLine = 0;
        var previousOriginalColumn = 0;
        var previousSource = 0;
        var previousName = 0;
        var length = aStr.length;
        var index = 0;
        var cachedSegments = {};
        var temp = {};
        var originalMappings = [];
        var generatedMappings = [];
        var mapping, str, segment, end, value;
        let subarrayStart = 0;
        while (index < length) {
          if (aStr.charAt(index) === ";") {
            generatedLine++;
            index++;
            previousGeneratedColumn = 0;
            sortGenerated(generatedMappings, subarrayStart);
            subarrayStart = generatedMappings.length;
          } else if (aStr.charAt(index) === ",") {
            index++;
          } else {
            mapping = new Mapping();
            mapping.generatedLine = generatedLine;
            for (end = index; end < length; end++) {
              if (this._charIsMappingSeparator(aStr, end)) {
                break;
              }
            }
            str = aStr.slice(index, end);
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            mapping.generatedColumn = previousGeneratedColumn + segment[0];
            previousGeneratedColumn = mapping.generatedColumn;
            if (segment.length > 1) {
              mapping.source = previousSource + segment[1];
              previousSource += segment[1];
              mapping.originalLine = previousOriginalLine + segment[2];
              previousOriginalLine = mapping.originalLine;
              mapping.originalLine += 1;
              mapping.originalColumn = previousOriginalColumn + segment[3];
              previousOriginalColumn = mapping.originalColumn;
              if (segment.length > 4) {
                mapping.name = previousName + segment[4];
                previousName += segment[4];
              }
            }
            generatedMappings.push(mapping);
            if (typeof mapping.originalLine === "number") {
              let currentSource = mapping.source;
              while (originalMappings.length <= currentSource) {
                originalMappings.push(null);
              }
              if (originalMappings[currentSource] === null) {
                originalMappings[currentSource] = [];
              }
              originalMappings[currentSource].push(mapping);
            }
          }
        }
        sortGenerated(generatedMappings, subarrayStart);
        this.__generatedMappings = generatedMappings;
        for (var i = 0; i < originalMappings.length; i++) {
          if (originalMappings[i] != null) {
            quickSort(originalMappings[i], util.compareByOriginalPositionsNoSource);
          }
        }
        this.__originalMappings = [].concat(...originalMappings);
      };
      BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
        if (aNeedle[aLineName] <= 0) {
          throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
        }
        if (aNeedle[aColumnName] < 0) {
          throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
        }
        return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
      };
      BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
        for (var index = 0; index < this._generatedMappings.length; ++index) {
          var mapping = this._generatedMappings[index];
          if (index + 1 < this._generatedMappings.length) {
            var nextMapping = this._generatedMappings[index + 1];
            if (mapping.generatedLine === nextMapping.generatedLine) {
              mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
              continue;
            }
          }
          mapping.lastGeneratedColumn = Infinity;
        }
      };
      BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
        var needle = {
          generatedLine: util.getArg(aArgs, "line"),
          generatedColumn: util.getArg(aArgs, "column")
        };
        var index = this._findMapping(
          needle,
          this._generatedMappings,
          "generatedLine",
          "generatedColumn",
          util.compareByGeneratedPositionsDeflated,
          util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
        );
        if (index >= 0) {
          var mapping = this._generatedMappings[index];
          if (mapping.generatedLine === needle.generatedLine) {
            var source = util.getArg(mapping, "source", null);
            if (source !== null) {
              source = this._sources.at(source);
              source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
            }
            var name = util.getArg(mapping, "name", null);
            if (name !== null) {
              name = this._names.at(name);
            }
            return {
              source,
              line: util.getArg(mapping, "originalLine", null),
              column: util.getArg(mapping, "originalColumn", null),
              name
            };
          }
        }
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      };
      BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
        if (!this.sourcesContent) {
          return false;
        }
        return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
          return sc == null;
        });
      };
      BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
        if (!this.sourcesContent) {
          return null;
        }
        var index = this._findSourceIndex(aSource);
        if (index >= 0) {
          return this.sourcesContent[index];
        }
        var relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util.relative(this.sourceRoot, relativeSource);
        }
        var url;
        if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
          var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
          if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
          }
          if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
            return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
          }
        }
        if (nullOnMissing) {
          return null;
        } else {
          throw new Error('"' + relativeSource + '" is not in the SourceMap.');
        }
      };
      BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
        var source = util.getArg(aArgs, "source");
        source = this._findSourceIndex(source);
        if (source < 0) {
          return {
            line: null,
            column: null,
            lastColumn: null
          };
        }
        var needle = {
          source,
          originalLine: util.getArg(aArgs, "line"),
          originalColumn: util.getArg(aArgs, "column")
        };
        var index = this._findMapping(
          needle,
          this._originalMappings,
          "originalLine",
          "originalColumn",
          util.compareByOriginalPositions,
          util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
        );
        if (index >= 0) {
          var mapping = this._originalMappings[index];
          if (mapping.source === needle.source) {
            return {
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            };
          }
        }
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      };
      exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
      function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }
        var version = util.getArg(sourceMap, "version");
        var sections = util.getArg(sourceMap, "sections");
        if (version != this._version) {
          throw new Error("Unsupported version: " + version);
        }
        this._sources = new ArraySet();
        this._names = new ArraySet();
        var lastOffset = {
          line: -1,
          column: 0
        };
        this._sections = sections.map(function(s) {
          if (s.url) {
            throw new Error("Support for url field in sections not implemented.");
          }
          var offset = util.getArg(s, "offset");
          var offsetLine = util.getArg(offset, "line");
          var offsetColumn = util.getArg(offset, "column");
          if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
            throw new Error("Section offsets must be ordered and non-overlapping.");
          }
          lastOffset = offset;
          return {
            generatedOffset: {
              // The offset fields are 0-based, but we use 1-based indices when
              // encoding/decoding from VLQ.
              generatedLine: offsetLine + 1,
              generatedColumn: offsetColumn + 1
            },
            consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
          };
        });
      }
      IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
      IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
      IndexedSourceMapConsumer.prototype._version = 3;
      Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
        get: function() {
          var sources = [];
          for (var i = 0; i < this._sections.length; i++) {
            for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
              sources.push(this._sections[i].consumer.sources[j]);
            }
          }
          return sources;
        }
      });
      IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
        var needle = {
          generatedLine: util.getArg(aArgs, "line"),
          generatedColumn: util.getArg(aArgs, "column")
        };
        var sectionIndex = binarySearch.search(
          needle,
          this._sections,
          function(needle2, section2) {
            var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
            if (cmp) {
              return cmp;
            }
            return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
          }
        );
        var section = this._sections[sectionIndex];
        if (!section) {
          return {
            source: null,
            line: null,
            column: null,
            name: null
          };
        }
        return section.consumer.originalPositionFor({
          line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
          column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          bias: aArgs.bias
        });
      };
      IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
        return this._sections.every(function(s) {
          return s.consumer.hasContentsOfAllSources();
        });
      };
      IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
        for (var i = 0; i < this._sections.length; i++) {
          var section = this._sections[i];
          var content = section.consumer.sourceContentFor(aSource, true);
          if (content) {
            return content;
          }
        }
        if (nullOnMissing) {
          return null;
        } else {
          throw new Error('"' + aSource + '" is not in the SourceMap.');
        }
      };
      IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
        for (var i = 0; i < this._sections.length; i++) {
          var section = this._sections[i];
          if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
            continue;
          }
          var generatedPosition = section.consumer.generatedPositionFor(aArgs);
          if (generatedPosition) {
            var ret = {
              line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
              column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
            };
            return ret;
          }
        }
        return {
          line: null,
          column: null
        };
      };
      IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        for (var i = 0; i < this._sections.length; i++) {
          var section = this._sections[i];
          var sectionMappings = section.consumer._generatedMappings;
          for (var j = 0; j < sectionMappings.length; j++) {
            var mapping = sectionMappings[j];
            var source = section.consumer._sources.at(mapping.source);
            source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
            this._sources.add(source);
            source = this._sources.indexOf(source);
            var name = null;
            if (mapping.name) {
              name = section.consumer._names.at(mapping.name);
              this._names.add(name);
              name = this._names.indexOf(name);
            }
            var adjustedMapping = {
              source,
              generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
              generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
              originalLine: mapping.originalLine,
              originalColumn: mapping.originalColumn,
              name
            };
            this.__generatedMappings.push(adjustedMapping);
            if (typeof adjustedMapping.originalLine === "number") {
              this.__originalMappings.push(adjustedMapping);
            }
          }
        }
        quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
        quickSort(this.__originalMappings, util.compareByOriginalPositions);
      };
      exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
    }
  });

  // node_modules/source-map-js/lib/source-node.js
  var require_source_node = __commonJS({
    "node_modules/source-map-js/lib/source-node.js"(exports) {
      var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
      var util = require_util();
      var REGEX_NEWLINE = /(\r?\n)/;
      var NEWLINE_CODE = 10;
      var isSourceNode = "$$$isSourceNode$$$";
      function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
        this.children = [];
        this.sourceContents = {};
        this.line = aLine == null ? null : aLine;
        this.column = aColumn == null ? null : aColumn;
        this.source = aSource == null ? null : aSource;
        this.name = aName == null ? null : aName;
        this[isSourceNode] = true;
        if (aChunks != null)
          this.add(aChunks);
      }
      SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
        var node = new SourceNode();
        var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
        var remainingLinesIndex = 0;
        var shiftNextLine = function() {
          var lineContents = getNextLine();
          var newLine = getNextLine() || "";
          return lineContents + newLine;
          function getNextLine() {
            return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
          }
        };
        var lastGeneratedLine = 1, lastGeneratedColumn = 0;
        var lastMapping = null;
        aSourceMapConsumer.eachMapping(function(mapping) {
          if (lastMapping !== null) {
            if (lastGeneratedLine < mapping.generatedLine) {
              addMappingWithCode(lastMapping, shiftNextLine());
              lastGeneratedLine++;
              lastGeneratedColumn = 0;
            } else {
              var nextLine = remainingLines[remainingLinesIndex] || "";
              var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
              remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
              addMappingWithCode(lastMapping, code);
              lastMapping = mapping;
              return;
            }
          }
          while (lastGeneratedLine < mapping.generatedLine) {
            node.add(shiftNextLine());
            lastGeneratedLine++;
          }
          if (lastGeneratedColumn < mapping.generatedColumn) {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            node.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
          }
          lastMapping = mapping;
        }, this);
        if (remainingLinesIndex < remainingLines.length) {
          if (lastMapping) {
            addMappingWithCode(lastMapping, shiftNextLine());
          }
          node.add(remainingLines.splice(remainingLinesIndex).join(""));
        }
        aSourceMapConsumer.sources.forEach(function(sourceFile) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            if (aRelativePath != null) {
              sourceFile = util.join(aRelativePath, sourceFile);
            }
            node.setSourceContent(sourceFile, content);
          }
        });
        return node;
        function addMappingWithCode(mapping, code) {
          if (mapping === null || mapping.source === void 0) {
            node.add(code);
          } else {
            var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
            node.add(new SourceNode(
              mapping.originalLine,
              mapping.originalColumn,
              source,
              code,
              mapping.name
            ));
          }
        }
      };
      SourceNode.prototype.add = function SourceNode_add(aChunk) {
        if (Array.isArray(aChunk)) {
          aChunk.forEach(function(chunk) {
            this.add(chunk);
          }, this);
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          if (aChunk) {
            this.children.push(aChunk);
          }
        } else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
      SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
        if (Array.isArray(aChunk)) {
          for (var i = aChunk.length - 1; i >= 0; i--) {
            this.prepend(aChunk[i]);
          }
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          this.children.unshift(aChunk);
        } else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
      SourceNode.prototype.walk = function SourceNode_walk(aFn) {
        var chunk;
        for (var i = 0, len = this.children.length; i < len; i++) {
          chunk = this.children[i];
          if (chunk[isSourceNode]) {
            chunk.walk(aFn);
          } else {
            if (chunk !== "") {
              aFn(chunk, {
                source: this.source,
                line: this.line,
                column: this.column,
                name: this.name
              });
            }
          }
        }
      };
      SourceNode.prototype.join = function SourceNode_join(aSep) {
        var newChildren;
        var i;
        var len = this.children.length;
        if (len > 0) {
          newChildren = [];
          for (i = 0; i < len - 1; i++) {
            newChildren.push(this.children[i]);
            newChildren.push(aSep);
          }
          newChildren.push(this.children[i]);
          this.children = newChildren;
        }
        return this;
      };
      SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
        var lastChild = this.children[this.children.length - 1];
        if (lastChild[isSourceNode]) {
          lastChild.replaceRight(aPattern, aReplacement);
        } else if (typeof lastChild === "string") {
          this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
        } else {
          this.children.push("".replace(aPattern, aReplacement));
        }
        return this;
      };
      SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
        this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
      };
      SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
        for (var i = 0, len = this.children.length; i < len; i++) {
          if (this.children[i][isSourceNode]) {
            this.children[i].walkSourceContents(aFn);
          }
        }
        var sources = Object.keys(this.sourceContents);
        for (var i = 0, len = sources.length; i < len; i++) {
          aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
        }
      };
      SourceNode.prototype.toString = function SourceNode_toString() {
        var str = "";
        this.walk(function(chunk) {
          str += chunk;
        });
        return str;
      };
      SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
        var generated = {
          code: "",
          line: 1,
          column: 0
        };
        var map = new SourceMapGenerator(aArgs);
        var sourceMappingActive = false;
        var lastOriginalSource = null;
        var lastOriginalLine = null;
        var lastOriginalColumn = null;
        var lastOriginalName = null;
        this.walk(function(chunk, original) {
          generated.code += chunk;
          if (original.source !== null && original.line !== null && original.column !== null) {
            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
          } else if (sourceMappingActive) {
            map.addMapping({
              generated: {
                line: generated.line,
                column: generated.column
              }
            });
            lastOriginalSource = null;
            sourceMappingActive = false;
          }
          for (var idx = 0, length = chunk.length; idx < length; idx++) {
            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
              generated.line++;
              generated.column = 0;
              if (idx + 1 === length) {
                lastOriginalSource = null;
                sourceMappingActive = false;
              } else if (sourceMappingActive) {
                map.addMapping({
                  source: original.source,
                  original: {
                    line: original.line,
                    column: original.column
                  },
                  generated: {
                    line: generated.line,
                    column: generated.column
                  },
                  name: original.name
                });
              }
            } else {
              generated.column++;
            }
          }
        });
        this.walkSourceContents(function(sourceFile, sourceContent) {
          map.setSourceContent(sourceFile, sourceContent);
        });
        return { code: generated.code, map };
      };
      exports.SourceNode = SourceNode;
    }
  });

  // node_modules/source-map-js/source-map.js
  var require_source_map = __commonJS({
    "node_modules/source-map-js/source-map.js"(exports) {
      exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
      exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
      exports.SourceNode = require_source_node().SourceNode;
    }
  });

  // node_modules/estree-walker/dist/umd/estree-walker.js
  var require_estree_walker = __commonJS({
    "node_modules/estree-walker/dist/umd/estree-walker.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.estreeWalker = {}));
      })(exports, function(exports2) {
        "use strict";
        class WalkerBase {
          constructor() {
            this.should_skip = false;
            this.should_remove = false;
            this.replacement = null;
            this.context = {
              skip: () => this.should_skip = true,
              remove: () => this.should_remove = true,
              replace: (node) => this.replacement = node
            };
          }
          /**
           *
           * @param {any} parent
           * @param {string} prop
           * @param {number} index
           * @param {BaseNode} node
           */
          replace(parent, prop, index, node) {
            if (parent) {
              if (index !== null) {
                parent[prop][index] = node;
              } else {
                parent[prop] = node;
              }
            }
          }
          /**
           *
           * @param {any} parent
           * @param {string} prop
           * @param {number} index
           */
          remove(parent, prop, index) {
            if (parent) {
              if (index !== null) {
                parent[prop].splice(index, 1);
              } else {
                delete parent[prop];
              }
            }
          }
        }
        class SyncWalker extends WalkerBase {
          /**
           *
           * @param {SyncHandler} enter
           * @param {SyncHandler} leave
           */
          constructor(enter, leave) {
            super();
            this.enter = enter;
            this.leave = leave;
          }
          /**
           *
           * @param {BaseNode} node
           * @param {BaseNode} parent
           * @param {string} [prop]
           * @param {number} [index]
           * @returns {BaseNode}
           */
          visit(node, parent, prop, index) {
            if (node) {
              if (this.enter) {
                const _should_skip = this.should_skip;
                const _should_remove = this.should_remove;
                const _replacement = this.replacement;
                this.should_skip = false;
                this.should_remove = false;
                this.replacement = null;
                this.enter.call(this.context, node, parent, prop, index);
                if (this.replacement) {
                  node = this.replacement;
                  this.replace(parent, prop, index, node);
                }
                if (this.should_remove) {
                  this.remove(parent, prop, index);
                }
                const skipped = this.should_skip;
                const removed = this.should_remove;
                this.should_skip = _should_skip;
                this.should_remove = _should_remove;
                this.replacement = _replacement;
                if (skipped)
                  return node;
                if (removed)
                  return null;
              }
              for (const key in node) {
                const value = node[key];
                if (typeof value !== "object") {
                  continue;
                } else if (Array.isArray(value)) {
                  for (let i = 0; i < value.length; i += 1) {
                    if (value[i] !== null && typeof value[i].type === "string") {
                      if (!this.visit(value[i], node, key, i)) {
                        i--;
                      }
                    }
                  }
                } else if (value !== null && typeof value.type === "string") {
                  this.visit(value, node, key, null);
                }
              }
              if (this.leave) {
                const _replacement = this.replacement;
                const _should_remove = this.should_remove;
                this.replacement = null;
                this.should_remove = false;
                this.leave.call(this.context, node, parent, prop, index);
                if (this.replacement) {
                  node = this.replacement;
                  this.replace(parent, prop, index, node);
                }
                if (this.should_remove) {
                  this.remove(parent, prop, index);
                }
                const removed = this.should_remove;
                this.replacement = _replacement;
                this.should_remove = _should_remove;
                if (removed)
                  return null;
              }
            }
            return node;
          }
        }
        class AsyncWalker extends WalkerBase {
          /**
           *
           * @param {AsyncHandler} enter
           * @param {AsyncHandler} leave
           */
          constructor(enter, leave) {
            super();
            this.enter = enter;
            this.leave = leave;
          }
          /**
           *
           * @param {BaseNode} node
           * @param {BaseNode} parent
           * @param {string} [prop]
           * @param {number} [index]
           * @returns {Promise<BaseNode>}
           */
          async visit(node, parent, prop, index) {
            if (node) {
              if (this.enter) {
                const _should_skip = this.should_skip;
                const _should_remove = this.should_remove;
                const _replacement = this.replacement;
                this.should_skip = false;
                this.should_remove = false;
                this.replacement = null;
                await this.enter.call(this.context, node, parent, prop, index);
                if (this.replacement) {
                  node = this.replacement;
                  this.replace(parent, prop, index, node);
                }
                if (this.should_remove) {
                  this.remove(parent, prop, index);
                }
                const skipped = this.should_skip;
                const removed = this.should_remove;
                this.should_skip = _should_skip;
                this.should_remove = _should_remove;
                this.replacement = _replacement;
                if (skipped)
                  return node;
                if (removed)
                  return null;
              }
              for (const key in node) {
                const value = node[key];
                if (typeof value !== "object") {
                  continue;
                } else if (Array.isArray(value)) {
                  for (let i = 0; i < value.length; i += 1) {
                    if (value[i] !== null && typeof value[i].type === "string") {
                      if (!await this.visit(value[i], node, key, i)) {
                        i--;
                      }
                    }
                  }
                } else if (value !== null && typeof value.type === "string") {
                  await this.visit(value, node, key, null);
                }
              }
              if (this.leave) {
                const _replacement = this.replacement;
                const _should_remove = this.should_remove;
                this.replacement = null;
                this.should_remove = false;
                await this.leave.call(this.context, node, parent, prop, index);
                if (this.replacement) {
                  node = this.replacement;
                  this.replace(parent, prop, index, node);
                }
                if (this.should_remove) {
                  this.remove(parent, prop, index);
                }
                const removed = this.should_remove;
                this.replacement = _replacement;
                this.should_remove = _should_remove;
                if (removed)
                  return null;
              }
            }
            return node;
          }
        }
        function walk(ast, { enter, leave }) {
          const instance = new SyncWalker(enter, leave);
          return instance.visit(ast, null);
        }
        async function asyncWalk(ast, { enter, leave }) {
          const instance = new AsyncWalker(enter, leave);
          return await instance.visit(ast, null);
        }
        exports2.asyncWalk = asyncWalk;
        exports2.walk = walk;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/@vue/compiler-core/dist/compiler-core.cjs.js
  var require_compiler_core_cjs = __commonJS({
    "node_modules/@vue/compiler-core/dist/compiler-core.cjs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var shared = require_shared();
      var parser = require_lib();
      var sourceMapJs = require_source_map();
      var estreeWalker = require_estree_walker();
      function defaultOnError(error) {
        throw error;
      }
      function defaultOnWarn(msg) {
        console.warn(`[Vue warn] ${msg.message}`);
      }
      function createCompilerError(code, loc, messages, additionalMessage) {
        const msg = (messages || errorMessages)[code] + (additionalMessage || ``);
        const error = new SyntaxError(String(msg));
        error.code = code;
        error.loc = loc;
        return error;
      }
      var errorMessages = {
        // parse errors
        [0]: "Illegal comment.",
        [1]: "CDATA section is allowed only in XML context.",
        [2]: "Duplicate attribute.",
        [3]: "End tag cannot have attributes.",
        [4]: "Illegal '/' in tags.",
        [5]: "Unexpected EOF in tag.",
        [6]: "Unexpected EOF in CDATA section.",
        [7]: "Unexpected EOF in comment.",
        [8]: "Unexpected EOF in script.",
        [9]: "Unexpected EOF in tag.",
        [10]: "Incorrectly closed comment.",
        [11]: "Incorrectly opened comment.",
        [12]: "Illegal tag name. Use '&lt;' to print '<'.",
        [13]: "Attribute value was expected.",
        [14]: "End tag name was expected.",
        [15]: "Whitespace was expected.",
        [16]: "Unexpected '<!--' in comment.",
        [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
        [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
        [19]: "Attribute name cannot start with '='.",
        [21]: "'<?' is allowed only in XML context.",
        [20]: `Unexpected null character.`,
        [22]: "Illegal '/' in tags.",
        // Vue-specific parse errors
        [23]: "Invalid end tag.",
        [24]: "Element is missing end tag.",
        [25]: "Interpolation end sign was not found.",
        [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
        [26]: "Legal directive name was expected.",
        // transform errors
        [28]: `v-if/v-else-if is missing expression.`,
        [29]: `v-if/else branches must use unique keys.`,
        [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
        [31]: `v-for is missing expression.`,
        [32]: `v-for has invalid expression.`,
        [33]: `<template v-for> key should be placed on the <template> tag.`,
        [34]: `v-bind is missing expression.`,
        [35]: `v-on is missing expression.`,
        [36]: `Unexpected custom directive on <slot> outlet.`,
        [37]: `Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
        [38]: `Duplicate slot names found. `,
        [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
        [40]: `v-slot can only be used on components or <template> tags.`,
        [41]: `v-model is missing expression.`,
        [42]: `v-model value must be a valid JavaScript member expression.`,
        [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
        [44]: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
        [45]: `Error parsing JavaScript expression: `,
        [46]: `<KeepAlive> expects exactly one child component.`,
        // generic errors
        [47]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
        [48]: `ES module mode is not supported in this build of compiler.`,
        [49]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
        [50]: `"scopeId" option is only supported in module mode.`,
        // deprecations
        [51]: `@vnode-* hooks in templates are deprecated. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support will be removed in 3.4.`,
        [52]: `v-is="component-name" has been deprecated. Use is="vue:component-name" instead. v-is support will be removed in 3.4.`,
        // just to fulfill types
        [53]: ``
      };
      var FRAGMENT = Symbol(`Fragment`);
      var TELEPORT = Symbol(`Teleport`);
      var SUSPENSE = Symbol(`Suspense`);
      var KEEP_ALIVE = Symbol(`KeepAlive`);
      var BASE_TRANSITION = Symbol(`BaseTransition`);
      var OPEN_BLOCK = Symbol(`openBlock`);
      var CREATE_BLOCK = Symbol(`createBlock`);
      var CREATE_ELEMENT_BLOCK = Symbol(`createElementBlock`);
      var CREATE_VNODE = Symbol(`createVNode`);
      var CREATE_ELEMENT_VNODE = Symbol(`createElementVNode`);
      var CREATE_COMMENT = Symbol(`createCommentVNode`);
      var CREATE_TEXT = Symbol(`createTextVNode`);
      var CREATE_STATIC = Symbol(`createStaticVNode`);
      var RESOLVE_COMPONENT = Symbol(`resolveComponent`);
      var RESOLVE_DYNAMIC_COMPONENT = Symbol(
        `resolveDynamicComponent`
      );
      var RESOLVE_DIRECTIVE = Symbol(`resolveDirective`);
      var RESOLVE_FILTER = Symbol(`resolveFilter`);
      var WITH_DIRECTIVES = Symbol(`withDirectives`);
      var RENDER_LIST = Symbol(`renderList`);
      var RENDER_SLOT = Symbol(`renderSlot`);
      var CREATE_SLOTS = Symbol(`createSlots`);
      var TO_DISPLAY_STRING = Symbol(`toDisplayString`);
      var MERGE_PROPS = Symbol(`mergeProps`);
      var NORMALIZE_CLASS = Symbol(`normalizeClass`);
      var NORMALIZE_STYLE = Symbol(`normalizeStyle`);
      var NORMALIZE_PROPS = Symbol(`normalizeProps`);
      var GUARD_REACTIVE_PROPS = Symbol(`guardReactiveProps`);
      var TO_HANDLERS = Symbol(`toHandlers`);
      var CAMELIZE = Symbol(`camelize`);
      var CAPITALIZE = Symbol(`capitalize`);
      var TO_HANDLER_KEY = Symbol(`toHandlerKey`);
      var SET_BLOCK_TRACKING = Symbol(`setBlockTracking`);
      var PUSH_SCOPE_ID = Symbol(`pushScopeId`);
      var POP_SCOPE_ID = Symbol(`popScopeId`);
      var WITH_CTX = Symbol(`withCtx`);
      var UNREF = Symbol(`unref`);
      var IS_REF = Symbol(`isRef`);
      var WITH_MEMO = Symbol(`withMemo`);
      var IS_MEMO_SAME = Symbol(`isMemoSame`);
      var helperNameMap = {
        [FRAGMENT]: `Fragment`,
        [TELEPORT]: `Teleport`,
        [SUSPENSE]: `Suspense`,
        [KEEP_ALIVE]: `KeepAlive`,
        [BASE_TRANSITION]: `BaseTransition`,
        [OPEN_BLOCK]: `openBlock`,
        [CREATE_BLOCK]: `createBlock`,
        [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
        [CREATE_VNODE]: `createVNode`,
        [CREATE_ELEMENT_VNODE]: `createElementVNode`,
        [CREATE_COMMENT]: `createCommentVNode`,
        [CREATE_TEXT]: `createTextVNode`,
        [CREATE_STATIC]: `createStaticVNode`,
        [RESOLVE_COMPONENT]: `resolveComponent`,
        [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
        [RESOLVE_DIRECTIVE]: `resolveDirective`,
        [RESOLVE_FILTER]: `resolveFilter`,
        [WITH_DIRECTIVES]: `withDirectives`,
        [RENDER_LIST]: `renderList`,
        [RENDER_SLOT]: `renderSlot`,
        [CREATE_SLOTS]: `createSlots`,
        [TO_DISPLAY_STRING]: `toDisplayString`,
        [MERGE_PROPS]: `mergeProps`,
        [NORMALIZE_CLASS]: `normalizeClass`,
        [NORMALIZE_STYLE]: `normalizeStyle`,
        [NORMALIZE_PROPS]: `normalizeProps`,
        [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
        [TO_HANDLERS]: `toHandlers`,
        [CAMELIZE]: `camelize`,
        [CAPITALIZE]: `capitalize`,
        [TO_HANDLER_KEY]: `toHandlerKey`,
        [SET_BLOCK_TRACKING]: `setBlockTracking`,
        [PUSH_SCOPE_ID]: `pushScopeId`,
        [POP_SCOPE_ID]: `popScopeId`,
        [WITH_CTX]: `withCtx`,
        [UNREF]: `unref`,
        [IS_REF]: `isRef`,
        [WITH_MEMO]: `withMemo`,
        [IS_MEMO_SAME]: `isMemoSame`
      };
      function registerRuntimeHelpers(helpers) {
        Object.getOwnPropertySymbols(helpers).forEach((s) => {
          helperNameMap[s] = helpers[s];
        });
      }
      var locStub = {
        source: "",
        start: { line: 1, column: 1, offset: 0 },
        end: { line: 1, column: 1, offset: 0 }
      };
      function createRoot(children, loc = locStub) {
        return {
          type: 0,
          children,
          helpers: /* @__PURE__ */ new Set(),
          components: [],
          directives: [],
          hoists: [],
          imports: [],
          cached: 0,
          temps: 0,
          codegenNode: void 0,
          loc
        };
      }
      function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
        if (context) {
          if (isBlock) {
            context.helper(OPEN_BLOCK);
            context.helper(getVNodeBlockHelper(context.inSSR, isComponent2));
          } else {
            context.helper(getVNodeHelper(context.inSSR, isComponent2));
          }
          if (directives) {
            context.helper(WITH_DIRECTIVES);
          }
        }
        return {
          type: 13,
          tag,
          props,
          children,
          patchFlag,
          dynamicProps,
          directives,
          isBlock,
          disableTracking,
          isComponent: isComponent2,
          loc
        };
      }
      function createArrayExpression(elements, loc = locStub) {
        return {
          type: 17,
          loc,
          elements
        };
      }
      function createObjectExpression(properties, loc = locStub) {
        return {
          type: 15,
          loc,
          properties
        };
      }
      function createObjectProperty(key, value) {
        return {
          type: 16,
          loc: locStub,
          key: shared.isString(key) ? createSimpleExpression(key, true) : key,
          value
        };
      }
      function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
        return {
          type: 4,
          loc,
          content,
          isStatic,
          constType: isStatic ? 3 : constType
        };
      }
      function createInterpolation(content, loc) {
        return {
          type: 5,
          loc,
          content: shared.isString(content) ? createSimpleExpression(content, false, loc) : content
        };
      }
      function createCompoundExpression(children, loc = locStub) {
        return {
          type: 8,
          loc,
          children
        };
      }
      function createCallExpression(callee, args = [], loc = locStub) {
        return {
          type: 14,
          loc,
          callee,
          arguments: args
        };
      }
      function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
        return {
          type: 18,
          params,
          returns,
          newline,
          isSlot,
          loc
        };
      }
      function createConditionalExpression(test, consequent, alternate, newline = true) {
        return {
          type: 19,
          test,
          consequent,
          alternate,
          newline,
          loc: locStub
        };
      }
      function createCacheExpression(index, value, isVNode = false) {
        return {
          type: 20,
          index,
          value,
          isVNode,
          loc: locStub
        };
      }
      function createBlockStatement(body) {
        return {
          type: 21,
          body,
          loc: locStub
        };
      }
      function createTemplateLiteral(elements) {
        return {
          type: 22,
          elements,
          loc: locStub
        };
      }
      function createIfStatement(test, consequent, alternate) {
        return {
          type: 23,
          test,
          consequent,
          alternate,
          loc: locStub
        };
      }
      function createAssignmentExpression(left, right) {
        return {
          type: 24,
          left,
          right,
          loc: locStub
        };
      }
      function createSequenceExpression(expressions) {
        return {
          type: 25,
          expressions,
          loc: locStub
        };
      }
      function createReturnStatement(returns) {
        return {
          type: 26,
          returns,
          loc: locStub
        };
      }
      function getVNodeHelper(ssr, isComponent2) {
        return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
      }
      function getVNodeBlockHelper(ssr, isComponent2) {
        return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
      }
      function convertToBlock(node, { helper, removeHelper, inSSR }) {
        if (!node.isBlock) {
          node.isBlock = true;
          removeHelper(getVNodeHelper(inSSR, node.isComponent));
          helper(OPEN_BLOCK);
          helper(getVNodeBlockHelper(inSSR, node.isComponent));
        }
      }
      var isStaticExp = (p) => p.type === 4 && p.isStatic;
      var isBuiltInType = (tag, expected) => tag === expected || tag === shared.hyphenate(expected);
      function isCoreComponent(tag) {
        if (isBuiltInType(tag, "Teleport")) {
          return TELEPORT;
        } else if (isBuiltInType(tag, "Suspense")) {
          return SUSPENSE;
        } else if (isBuiltInType(tag, "KeepAlive")) {
          return KEEP_ALIVE;
        } else if (isBuiltInType(tag, "BaseTransition")) {
          return BASE_TRANSITION;
        }
      }
      var nonIdentifierRE = /^\d|[^\$\w]/;
      var isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
      var validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
      var validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
      var whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
      var isMemberExpressionBrowser = (path) => {
        path = path.trim().replace(whitespaceRE, (s) => s.trim());
        let state = 0;
        let stateStack = [];
        let currentOpenBracketCount = 0;
        let currentOpenParensCount = 0;
        let currentStringType = null;
        for (let i = 0; i < path.length; i++) {
          const char = path.charAt(i);
          switch (state) {
            case 0:
              if (char === "[") {
                stateStack.push(state);
                state = 1;
                currentOpenBracketCount++;
              } else if (char === "(") {
                stateStack.push(state);
                state = 2;
                currentOpenParensCount++;
              } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
                return false;
              }
              break;
            case 1:
              if (char === `'` || char === `"` || char === "`") {
                stateStack.push(state);
                state = 3;
                currentStringType = char;
              } else if (char === `[`) {
                currentOpenBracketCount++;
              } else if (char === `]`) {
                if (!--currentOpenBracketCount) {
                  state = stateStack.pop();
                }
              }
              break;
            case 2:
              if (char === `'` || char === `"` || char === "`") {
                stateStack.push(state);
                state = 3;
                currentStringType = char;
              } else if (char === `(`) {
                currentOpenParensCount++;
              } else if (char === `)`) {
                if (i === path.length - 1) {
                  return false;
                }
                if (!--currentOpenParensCount) {
                  state = stateStack.pop();
                }
              }
              break;
            case 3:
              if (char === currentStringType) {
                state = stateStack.pop();
                currentStringType = null;
              }
              break;
          }
        }
        return !currentOpenBracketCount && !currentOpenParensCount;
      };
      var isMemberExpressionNode = (path, context) => {
        try {
          let ret = parser.parseExpression(path, {
            plugins: context.expressionPlugins
          });
          if (ret.type === "TSAsExpression" || ret.type === "TSTypeAssertion") {
            ret = ret.expression;
          }
          return ret.type === "MemberExpression" || ret.type === "OptionalMemberExpression" || ret.type === "Identifier";
        } catch (e) {
          return false;
        }
      };
      var isMemberExpression = isMemberExpressionNode;
      function getInnerRange(loc, offset, length) {
        const source = loc.source.slice(offset, offset + length);
        const newLoc = {
          source,
          start: advancePositionWithClone(loc.start, loc.source, offset),
          end: loc.end
        };
        if (length != null) {
          newLoc.end = advancePositionWithClone(
            loc.start,
            loc.source,
            offset + length
          );
        }
        return newLoc;
      }
      function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
        return advancePositionWithMutation(
          shared.extend({}, pos),
          source,
          numberOfCharacters
        );
      }
      function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
        let linesCount = 0;
        let lastNewLinePos = -1;
        for (let i = 0; i < numberOfCharacters; i++) {
          if (source.charCodeAt(i) === 10) {
            linesCount++;
            lastNewLinePos = i;
          }
        }
        pos.offset += numberOfCharacters;
        pos.line += linesCount;
        pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
        return pos;
      }
      function assert(condition, msg) {
        if (!condition) {
          throw new Error(msg || `unexpected compiler condition`);
        }
      }
      function findDir(node, name, allowEmpty = false) {
        for (let i = 0; i < node.props.length; i++) {
          const p = node.props[i];
          if (p.type === 7 && (allowEmpty || p.exp) && (shared.isString(name) ? p.name === name : name.test(p.name))) {
            return p;
          }
        }
      }
      function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
        for (let i = 0; i < node.props.length; i++) {
          const p = node.props[i];
          if (p.type === 6) {
            if (dynamicOnly)
              continue;
            if (p.name === name && (p.value || allowEmpty)) {
              return p;
            }
          } else if (p.name === "bind" && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) {
            return p;
          }
        }
      }
      function isStaticArgOf(arg, name) {
        return !!(arg && isStaticExp(arg) && arg.content === name);
      }
      function hasDynamicKeyVBind(node) {
        return node.props.some(
          (p) => p.type === 7 && p.name === "bind" && (!p.arg || // v-bind="obj"
          p.arg.type !== 4 || // v-bind:[_ctx.foo]
          !p.arg.isStatic)
          // v-bind:[foo]
        );
      }
      function isText$1(node) {
        return node.type === 5 || node.type === 2;
      }
      function isVSlot(p) {
        return p.type === 7 && p.name === "slot";
      }
      function isTemplateNode(node) {
        return node.type === 1 && node.tagType === 3;
      }
      function isSlotOutlet(node) {
        return node.type === 1 && node.tagType === 2;
      }
      var propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
      function getUnnormalizedProps(props, callPath = []) {
        if (props && !shared.isString(props) && props.type === 14) {
          const callee = props.callee;
          if (!shared.isString(callee) && propsHelperSet.has(callee)) {
            return getUnnormalizedProps(
              props.arguments[0],
              callPath.concat(props)
            );
          }
        }
        return [props, callPath];
      }
      function injectProp(node, prop, context) {
        let propsWithInjection;
        let props = node.type === 13 ? node.props : node.arguments[2];
        let callPath = [];
        let parentCall;
        if (props && !shared.isString(props) && props.type === 14) {
          const ret = getUnnormalizedProps(props);
          props = ret[0];
          callPath = ret[1];
          parentCall = callPath[callPath.length - 1];
        }
        if (props == null || shared.isString(props)) {
          propsWithInjection = createObjectExpression([prop]);
        } else if (props.type === 14) {
          const first = props.arguments[0];
          if (!shared.isString(first) && first.type === 15) {
            if (!hasProp(prop, first)) {
              first.properties.unshift(prop);
            }
          } else {
            if (props.callee === TO_HANDLERS) {
              propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
                createObjectExpression([prop]),
                props
              ]);
            } else {
              props.arguments.unshift(createObjectExpression([prop]));
            }
          }
          !propsWithInjection && (propsWithInjection = props);
        } else if (props.type === 15) {
          if (!hasProp(prop, props)) {
            props.properties.unshift(prop);
          }
          propsWithInjection = props;
        } else {
          propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
            createObjectExpression([prop]),
            props
          ]);
          if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
            parentCall = callPath[callPath.length - 2];
          }
        }
        if (node.type === 13) {
          if (parentCall) {
            parentCall.arguments[0] = propsWithInjection;
          } else {
            node.props = propsWithInjection;
          }
        } else {
          if (parentCall) {
            parentCall.arguments[0] = propsWithInjection;
          } else {
            node.arguments[2] = propsWithInjection;
          }
        }
      }
      function hasProp(prop, props) {
        let result = false;
        if (prop.key.type === 4) {
          const propKeyName = prop.key.content;
          result = props.properties.some(
            (p) => p.key.type === 4 && p.key.content === propKeyName
          );
        }
        return result;
      }
      function toValidAssetId(name, type) {
        return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
          return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
        })}`;
      }
      function hasScopeRef(node, ids) {
        if (!node || Object.keys(ids).length === 0) {
          return false;
        }
        switch (node.type) {
          case 1:
            for (let i = 0; i < node.props.length; i++) {
              const p = node.props[i];
              if (p.type === 7 && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
                return true;
              }
            }
            return node.children.some((c) => hasScopeRef(c, ids));
          case 11:
            if (hasScopeRef(node.source, ids)) {
              return true;
            }
            return node.children.some((c) => hasScopeRef(c, ids));
          case 9:
            return node.branches.some((b) => hasScopeRef(b, ids));
          case 10:
            if (hasScopeRef(node.condition, ids)) {
              return true;
            }
            return node.children.some((c) => hasScopeRef(c, ids));
          case 4:
            return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];
          case 8:
            return node.children.some((c) => shared.isObject(c) && hasScopeRef(c, ids));
          case 5:
          case 12:
            return hasScopeRef(node.content, ids);
          case 2:
          case 3:
            return false;
          default:
            return false;
        }
      }
      function getMemoedVNodeCall(node) {
        if (node.type === 14 && node.callee === WITH_MEMO) {
          return node.arguments[1].returns;
        } else {
          return node;
        }
      }
      var deprecationData = {
        ["COMPILER_IS_ON_ELEMENT"]: {
          message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
          link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
        },
        ["COMPILER_V_BIND_SYNC"]: {
          message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
        },
        ["COMPILER_V_BIND_PROP"]: {
          message: `.prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate.`
        },
        ["COMPILER_V_BIND_OBJECT_ORDER"]: {
          message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
        },
        ["COMPILER_V_ON_NATIVE"]: {
          message: `.native modifier for v-on has been removed as is no longer necessary.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
        },
        ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
          message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
        },
        ["COMPILER_NATIVE_TEMPLATE"]: {
          message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
        },
        ["COMPILER_INLINE_TEMPLATE"]: {
          message: `"inline-template" has been removed in Vue 3.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
        },
        ["COMPILER_FILTER"]: {
          message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
        }
      };
      function getCompatValue(key, context) {
        const config = context.options ? context.options.compatConfig : context.compatConfig;
        const value = config && config[key];
        if (key === "MODE") {
          return value || 3;
        } else {
          return value;
        }
      }
      function isCompatEnabled(key, context) {
        const mode = getCompatValue("MODE", context);
        const value = getCompatValue(key, context);
        return mode === 3 ? value === true : value !== false;
      }
      function checkCompatEnabled(key, context, loc, ...args) {
        const enabled = isCompatEnabled(key, context);
        if (enabled) {
          warnDeprecation(key, context, loc, ...args);
        }
        return enabled;
      }
      function warnDeprecation(key, context, loc, ...args) {
        const val = getCompatValue(key, context);
        if (val === "suppress-warning") {
          return;
        }
        const { message, link } = deprecationData[key];
        const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
        const err = new SyntaxError(msg);
        err.code = key;
        if (loc)
          err.loc = loc;
        context.onWarn(err);
      }
      var decodeRE = /&(gt|lt|amp|apos|quot);/g;
      var decodeMap = {
        gt: ">",
        lt: "<",
        amp: "&",
        apos: "'",
        quot: '"'
      };
      var defaultParserOptions = {
        delimiters: [`{{`, `}}`],
        getNamespace: () => 0,
        getTextMode: () => 0,
        isVoidTag: shared.NO,
        isPreTag: shared.NO,
        isCustomElement: shared.NO,
        decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
        onError: defaultOnError,
        onWarn: defaultOnWarn,
        comments: true
      };
      function baseParse(content, options = {}) {
        const context = createParserContext(content, options);
        const start = getCursor(context);
        return createRoot(
          parseChildren(context, 0, []),
          getSelection(context, start)
        );
      }
      function createParserContext(content, rawOptions) {
        const options = shared.extend({}, defaultParserOptions);
        let key;
        for (key in rawOptions) {
          options[key] = rawOptions[key] === void 0 ? defaultParserOptions[key] : rawOptions[key];
        }
        return {
          options,
          column: 1,
          line: 1,
          offset: 0,
          originalSource: content,
          source: content,
          inPre: false,
          inVPre: false,
          onWarn: options.onWarn
        };
      }
      function parseChildren(context, mode, ancestors) {
        const parent = last(ancestors);
        const ns = parent ? parent.ns : 0;
        const nodes = [];
        while (!isEnd(context, mode, ancestors)) {
          const s = context.source;
          let node = void 0;
          if (mode === 0 || mode === 1) {
            if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
              node = parseInterpolation(context, mode);
            } else if (mode === 0 && s[0] === "<") {
              if (s.length === 1) {
                emitError(context, 5, 1);
              } else if (s[1] === "!") {
                if (startsWith(s, "<!--")) {
                  node = parseComment(context);
                } else if (startsWith(s, "<!DOCTYPE")) {
                  node = parseBogusComment(context);
                } else if (startsWith(s, "<![CDATA[")) {
                  if (ns !== 0) {
                    node = parseCDATA(context, ancestors);
                  } else {
                    emitError(context, 1);
                    node = parseBogusComment(context);
                  }
                } else {
                  emitError(context, 11);
                  node = parseBogusComment(context);
                }
              } else if (s[1] === "/") {
                if (s.length === 2) {
                  emitError(context, 5, 2);
                } else if (s[2] === ">") {
                  emitError(context, 14, 2);
                  advanceBy(context, 3);
                  continue;
                } else if (/[a-z]/i.test(s[2])) {
                  emitError(context, 23);
                  parseTag(context, TagType.End, parent);
                  continue;
                } else {
                  emitError(
                    context,
                    12,
                    2
                  );
                  node = parseBogusComment(context);
                }
              } else if (/[a-z]/i.test(s[1])) {
                node = parseElement(context, ancestors);
                if (isCompatEnabled(
                  "COMPILER_NATIVE_TEMPLATE",
                  context
                ) && node && node.tag === "template" && !node.props.some(
                  (p) => p.type === 7 && isSpecialTemplateDirective(p.name)
                )) {
                  warnDeprecation(
                    "COMPILER_NATIVE_TEMPLATE",
                    context,
                    node.loc
                  );
                  node = node.children;
                }
              } else if (s[1] === "?") {
                emitError(
                  context,
                  21,
                  1
                );
                node = parseBogusComment(context);
              } else {
                emitError(context, 12, 1);
              }
            }
          }
          if (!node) {
            node = parseText(context, mode);
          }
          if (shared.isArray(node)) {
            for (let i = 0; i < node.length; i++) {
              pushNode(nodes, node[i]);
            }
          } else {
            pushNode(nodes, node);
          }
        }
        let removedWhitespace = false;
        if (mode !== 2 && mode !== 1) {
          const shouldCondense = context.options.whitespace !== "preserve";
          for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (node.type === 2) {
              if (!context.inPre) {
                if (!/[^\t\r\n\f ]/.test(node.content)) {
                  const prev = nodes[i - 1];
                  const next = nodes[i + 1];
                  if (!prev || !next || shouldCondense && (prev.type === 3 && next.type === 3 || prev.type === 3 && next.type === 1 || prev.type === 1 && next.type === 3 || prev.type === 1 && next.type === 1 && /[\r\n]/.test(node.content))) {
                    removedWhitespace = true;
                    nodes[i] = null;
                  } else {
                    node.content = " ";
                  }
                } else if (shouldCondense) {
                  node.content = node.content.replace(/[\t\r\n\f ]+/g, " ");
                }
              } else {
                node.content = node.content.replace(/\r\n/g, "\n");
              }
            } else if (node.type === 3 && !context.options.comments) {
              removedWhitespace = true;
              nodes[i] = null;
            }
          }
          if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
            const first = nodes[0];
            if (first && first.type === 2) {
              first.content = first.content.replace(/^\r?\n/, "");
            }
          }
        }
        return removedWhitespace ? nodes.filter(Boolean) : nodes;
      }
      function pushNode(nodes, node) {
        if (node.type === 2) {
          const prev = last(nodes);
          if (prev && prev.type === 2 && prev.loc.end.offset === node.loc.start.offset) {
            prev.content += node.content;
            prev.loc.end = node.loc.end;
            prev.loc.source += node.loc.source;
            return;
          }
        }
        nodes.push(node);
      }
      function parseCDATA(context, ancestors) {
        advanceBy(context, 9);
        const nodes = parseChildren(context, 3, ancestors);
        if (context.source.length === 0) {
          emitError(context, 6);
        } else {
          advanceBy(context, 3);
        }
        return nodes;
      }
      function parseComment(context) {
        const start = getCursor(context);
        let content;
        const match = /--(\!)?>/.exec(context.source);
        if (!match) {
          content = context.source.slice(4);
          advanceBy(context, context.source.length);
          emitError(context, 7);
        } else {
          if (match.index <= 3) {
            emitError(context, 0);
          }
          if (match[1]) {
            emitError(context, 10);
          }
          content = context.source.slice(4, match.index);
          const s = context.source.slice(0, match.index);
          let prevIndex = 1, nestedIndex = 0;
          while ((nestedIndex = s.indexOf("<!--", prevIndex)) !== -1) {
            advanceBy(context, nestedIndex - prevIndex + 1);
            if (nestedIndex + 4 < s.length) {
              emitError(context, 16);
            }
            prevIndex = nestedIndex + 1;
          }
          advanceBy(context, match.index + match[0].length - prevIndex + 1);
        }
        return {
          type: 3,
          content,
          loc: getSelection(context, start)
        };
      }
      function parseBogusComment(context) {
        const start = getCursor(context);
        const contentStart = context.source[1] === "?" ? 1 : 2;
        let content;
        const closeIndex = context.source.indexOf(">");
        if (closeIndex === -1) {
          content = context.source.slice(contentStart);
          advanceBy(context, context.source.length);
        } else {
          content = context.source.slice(contentStart, closeIndex);
          advanceBy(context, closeIndex + 1);
        }
        return {
          type: 3,
          content,
          loc: getSelection(context, start)
        };
      }
      function parseElement(context, ancestors) {
        const wasInPre = context.inPre;
        const wasInVPre = context.inVPre;
        const parent = last(ancestors);
        const element = parseTag(context, TagType.Start, parent);
        const isPreBoundary = context.inPre && !wasInPre;
        const isVPreBoundary = context.inVPre && !wasInVPre;
        if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
          if (isPreBoundary) {
            context.inPre = false;
          }
          if (isVPreBoundary) {
            context.inVPre = false;
          }
          return element;
        }
        ancestors.push(element);
        const mode = context.options.getTextMode(element, parent);
        const children = parseChildren(context, mode, ancestors);
        ancestors.pop();
        {
          const inlineTemplateProp = element.props.find(
            (p) => p.type === 6 && p.name === "inline-template"
          );
          if (inlineTemplateProp && checkCompatEnabled(
            "COMPILER_INLINE_TEMPLATE",
            context,
            inlineTemplateProp.loc
          )) {
            const loc = getSelection(context, element.loc.end);
            inlineTemplateProp.value = {
              type: 2,
              content: loc.source,
              loc
            };
          }
        }
        element.children = children;
        if (startsWithEndTagOpen(context.source, element.tag)) {
          parseTag(context, TagType.End, parent);
        } else {
          emitError(context, 24, 0, element.loc.start);
          if (context.source.length === 0 && element.tag.toLowerCase() === "script") {
            const first = children[0];
            if (first && startsWith(first.loc.source, "<!--")) {
              emitError(context, 8);
            }
          }
        }
        element.loc = getSelection(context, element.loc.start);
        if (isPreBoundary) {
          context.inPre = false;
        }
        if (isVPreBoundary) {
          context.inVPre = false;
        }
        return element;
      }
      var TagType = /* @__PURE__ */ ((TagType2) => {
        TagType2[TagType2["Start"] = 0] = "Start";
        TagType2[TagType2["End"] = 1] = "End";
        return TagType2;
      })(TagType || {});
      var isSpecialTemplateDirective = /* @__PURE__ */ shared.makeMap(
        `if,else,else-if,for,slot`
      );
      function parseTag(context, type, parent) {
        const start = getCursor(context);
        const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
        const tag = match[1];
        const ns = context.options.getNamespace(tag, parent);
        advanceBy(context, match[0].length);
        advanceSpaces(context);
        const cursor = getCursor(context);
        const currentSource = context.source;
        if (context.options.isPreTag(tag)) {
          context.inPre = true;
        }
        let props = parseAttributes(context, type);
        if (type === 0 && !context.inVPre && props.some((p) => p.type === 7 && p.name === "pre")) {
          context.inVPre = true;
          shared.extend(context, cursor);
          context.source = currentSource;
          props = parseAttributes(context, type).filter((p) => p.name !== "v-pre");
        }
        let isSelfClosing = false;
        if (context.source.length === 0) {
          emitError(context, 9);
        } else {
          isSelfClosing = startsWith(context.source, "/>");
          if (type === 1 && isSelfClosing) {
            emitError(context, 4);
          }
          advanceBy(context, isSelfClosing ? 2 : 1);
        }
        if (type === 1) {
          return;
        }
        if (isCompatEnabled(
          "COMPILER_V_IF_V_FOR_PRECEDENCE",
          context
        )) {
          let hasIf = false;
          let hasFor = false;
          for (let i = 0; i < props.length; i++) {
            const p = props[i];
            if (p.type === 7) {
              if (p.name === "if") {
                hasIf = true;
              } else if (p.name === "for") {
                hasFor = true;
              }
            }
            if (hasIf && hasFor) {
              warnDeprecation(
                "COMPILER_V_IF_V_FOR_PRECEDENCE",
                context,
                getSelection(context, start)
              );
              break;
            }
          }
        }
        let tagType = 0;
        if (!context.inVPre) {
          if (tag === "slot") {
            tagType = 2;
          } else if (tag === "template") {
            if (props.some(
              (p) => p.type === 7 && isSpecialTemplateDirective(p.name)
            )) {
              tagType = 3;
            }
          } else if (isComponent(tag, props, context)) {
            tagType = 1;
          }
        }
        return {
          type: 1,
          ns,
          tag,
          tagType,
          props,
          isSelfClosing,
          children: [],
          loc: getSelection(context, start),
          codegenNode: void 0
          // to be created during transform phase
        };
      }
      function isComponent(tag, props, context) {
        const options = context.options;
        if (options.isCustomElement(tag)) {
          return false;
        }
        if (tag === "component" || /^[A-Z]/.test(tag) || isCoreComponent(tag) || options.isBuiltInComponent && options.isBuiltInComponent(tag) || options.isNativeTag && !options.isNativeTag(tag)) {
          return true;
        }
        for (let i = 0; i < props.length; i++) {
          const p = props[i];
          if (p.type === 6) {
            if (p.name === "is" && p.value) {
              if (p.value.content.startsWith("vue:")) {
                return true;
              } else if (checkCompatEnabled(
                "COMPILER_IS_ON_ELEMENT",
                context,
                p.loc
              )) {
                return true;
              }
            }
          } else {
            if (p.name === "is") {
              return true;
            } else if (
              // :is on plain element - only treat as component in compat mode
              p.name === "bind" && isStaticArgOf(p.arg, "is") && true && checkCompatEnabled(
                "COMPILER_IS_ON_ELEMENT",
                context,
                p.loc
              )
            ) {
              return true;
            }
          }
        }
      }
      function parseAttributes(context, type) {
        const props = [];
        const attributeNames = /* @__PURE__ */ new Set();
        while (context.source.length > 0 && !startsWith(context.source, ">") && !startsWith(context.source, "/>")) {
          if (startsWith(context.source, "/")) {
            emitError(context, 22);
            advanceBy(context, 1);
            advanceSpaces(context);
            continue;
          }
          if (type === 1) {
            emitError(context, 3);
          }
          const attr = parseAttribute(context, attributeNames);
          if (attr.type === 6 && attr.value && attr.name === "class") {
            attr.value.content = attr.value.content.replace(/\s+/g, " ").trim();
          }
          if (type === 0) {
            props.push(attr);
          }
          if (/^[^\t\r\n\f />]/.test(context.source)) {
            emitError(context, 15);
          }
          advanceSpaces(context);
        }
        return props;
      }
      function parseAttribute(context, nameSet) {
        var _a;
        const start = getCursor(context);
        const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
        const name = match[0];
        if (nameSet.has(name)) {
          emitError(context, 2);
        }
        nameSet.add(name);
        if (name[0] === "=") {
          emitError(context, 19);
        }
        {
          const pattern = /["'<]/g;
          let m;
          while (m = pattern.exec(name)) {
            emitError(
              context,
              17,
              m.index
            );
          }
        }
        advanceBy(context, name.length);
        let value = void 0;
        if (/^[\t\r\n\f ]*=/.test(context.source)) {
          advanceSpaces(context);
          advanceBy(context, 1);
          advanceSpaces(context);
          value = parseAttributeValue(context);
          if (!value) {
            emitError(context, 13);
          }
        }
        const loc = getSelection(context, start);
        if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {
          const match2 = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(
            name
          );
          let isPropShorthand = startsWith(name, ".");
          let dirName = match2[1] || (isPropShorthand || startsWith(name, ":") ? "bind" : startsWith(name, "@") ? "on" : "slot");
          let arg;
          if (match2[2]) {
            const isSlot = dirName === "slot";
            const startOffset = name.lastIndexOf(
              match2[2],
              name.length - (((_a = match2[3]) == null ? void 0 : _a.length) || 0)
            );
            const loc2 = getSelection(
              context,
              getNewPosition(context, start, startOffset),
              getNewPosition(
                context,
                start,
                startOffset + match2[2].length + (isSlot && match2[3] || "").length
              )
            );
            let content = match2[2];
            let isStatic = true;
            if (content.startsWith("[")) {
              isStatic = false;
              if (!content.endsWith("]")) {
                emitError(
                  context,
                  27
                );
                content = content.slice(1);
              } else {
                content = content.slice(1, content.length - 1);
              }
            } else if (isSlot) {
              content += match2[3] || "";
            }
            arg = {
              type: 4,
              content,
              isStatic,
              constType: isStatic ? 3 : 0,
              loc: loc2
            };
          }
          if (value && value.isQuoted) {
            const valueLoc = value.loc;
            valueLoc.start.offset++;
            valueLoc.start.column++;
            valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
            valueLoc.source = valueLoc.source.slice(1, -1);
          }
          const modifiers = match2[3] ? match2[3].slice(1).split(".") : [];
          if (isPropShorthand)
            modifiers.push("prop");
          if (dirName === "bind" && arg) {
            if (modifiers.includes("sync") && checkCompatEnabled(
              "COMPILER_V_BIND_SYNC",
              context,
              loc,
              arg.loc.source
            )) {
              dirName = "model";
              modifiers.splice(modifiers.indexOf("sync"), 1);
            }
            if (modifiers.includes("prop")) {
              checkCompatEnabled(
                "COMPILER_V_BIND_PROP",
                context,
                loc
              );
            }
          }
          return {
            type: 7,
            name: dirName,
            exp: value && {
              type: 4,
              content: value.content,
              isStatic: false,
              // Treat as non-constant by default. This can be potentially set to
              // other values by `transformExpression` to make it eligible for hoisting.
              constType: 0,
              loc: value.loc
            },
            arg,
            modifiers,
            loc
          };
        }
        if (!context.inVPre && startsWith(name, "v-")) {
          emitError(context, 26);
        }
        return {
          type: 6,
          name,
          value: value && {
            type: 2,
            content: value.content,
            loc: value.loc
          },
          loc
        };
      }
      function parseAttributeValue(context) {
        const start = getCursor(context);
        let content;
        const quote = context.source[0];
        const isQuoted = quote === `"` || quote === `'`;
        if (isQuoted) {
          advanceBy(context, 1);
          const endIndex = context.source.indexOf(quote);
          if (endIndex === -1) {
            content = parseTextData(
              context,
              context.source.length,
              4
            );
          } else {
            content = parseTextData(context, endIndex, 4);
            advanceBy(context, 1);
          }
        } else {
          const match = /^[^\t\r\n\f >]+/.exec(context.source);
          if (!match) {
            return void 0;
          }
          const unexpectedChars = /["'<=`]/g;
          let m;
          while (m = unexpectedChars.exec(match[0])) {
            emitError(
              context,
              18,
              m.index
            );
          }
          content = parseTextData(context, match[0].length, 4);
        }
        return { content, isQuoted, loc: getSelection(context, start) };
      }
      function parseInterpolation(context, mode) {
        const [open, close] = context.options.delimiters;
        const closeIndex = context.source.indexOf(close, open.length);
        if (closeIndex === -1) {
          emitError(context, 25);
          return void 0;
        }
        const start = getCursor(context);
        advanceBy(context, open.length);
        const innerStart = getCursor(context);
        const innerEnd = getCursor(context);
        const rawContentLength = closeIndex - open.length;
        const rawContent = context.source.slice(0, rawContentLength);
        const preTrimContent = parseTextData(context, rawContentLength, mode);
        const content = preTrimContent.trim();
        const startOffset = preTrimContent.indexOf(content);
        if (startOffset > 0) {
          advancePositionWithMutation(innerStart, rawContent, startOffset);
        }
        const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
        advancePositionWithMutation(innerEnd, rawContent, endOffset);
        advanceBy(context, close.length);
        return {
          type: 5,
          content: {
            type: 4,
            isStatic: false,
            // Set `isConstant` to false by default and will decide in transformExpression
            constType: 0,
            content,
            loc: getSelection(context, innerStart, innerEnd)
          },
          loc: getSelection(context, start)
        };
      }
      function parseText(context, mode) {
        const endTokens = mode === 3 ? ["]]>"] : ["<", context.options.delimiters[0]];
        let endIndex = context.source.length;
        for (let i = 0; i < endTokens.length; i++) {
          const index = context.source.indexOf(endTokens[i], 1);
          if (index !== -1 && endIndex > index) {
            endIndex = index;
          }
        }
        const start = getCursor(context);
        const content = parseTextData(context, endIndex, mode);
        return {
          type: 2,
          content,
          loc: getSelection(context, start)
        };
      }
      function parseTextData(context, length, mode) {
        const rawText = context.source.slice(0, length);
        advanceBy(context, length);
        if (mode === 2 || mode === 3 || !rawText.includes("&")) {
          return rawText;
        } else {
          return context.options.decodeEntities(
            rawText,
            mode === 4
          );
        }
      }
      function getCursor(context) {
        const { column, line, offset } = context;
        return { column, line, offset };
      }
      function getSelection(context, start, end) {
        end = end || getCursor(context);
        return {
          start,
          end,
          source: context.originalSource.slice(start.offset, end.offset)
        };
      }
      function last(xs) {
        return xs[xs.length - 1];
      }
      function startsWith(source, searchString) {
        return source.startsWith(searchString);
      }
      function advanceBy(context, numberOfCharacters) {
        const { source } = context;
        advancePositionWithMutation(context, source, numberOfCharacters);
        context.source = source.slice(numberOfCharacters);
      }
      function advanceSpaces(context) {
        const match = /^[\t\r\n\f ]+/.exec(context.source);
        if (match) {
          advanceBy(context, match[0].length);
        }
      }
      function getNewPosition(context, start, numberOfCharacters) {
        return advancePositionWithClone(
          start,
          context.originalSource.slice(start.offset, numberOfCharacters),
          numberOfCharacters
        );
      }
      function emitError(context, code, offset, loc = getCursor(context)) {
        if (offset) {
          loc.offset += offset;
          loc.column += offset;
        }
        context.options.onError(
          createCompilerError(code, {
            start: loc,
            end: loc,
            source: ""
          })
        );
      }
      function isEnd(context, mode, ancestors) {
        const s = context.source;
        switch (mode) {
          case 0:
            if (startsWith(s, "</")) {
              for (let i = ancestors.length - 1; i >= 0; --i) {
                if (startsWithEndTagOpen(s, ancestors[i].tag)) {
                  return true;
                }
              }
            }
            break;
          case 1:
          case 2: {
            const parent = last(ancestors);
            if (parent && startsWithEndTagOpen(s, parent.tag)) {
              return true;
            }
            break;
          }
          case 3:
            if (startsWith(s, "]]>")) {
              return true;
            }
            break;
        }
        return !s;
      }
      function startsWithEndTagOpen(source, tag) {
        return startsWith(source, "</") && source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() && /[\t\r\n\f />]/.test(source[2 + tag.length] || ">");
      }
      function hoistStatic(root, context) {
        walk(
          root,
          context,
          // Root node is unfortunately non-hoistable due to potential parent
          // fallthrough attributes.
          isSingleElementRoot(root, root.children[0])
        );
      }
      function isSingleElementRoot(root, child) {
        const { children } = root;
        return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
      }
      function walk(node, context, doNotHoistNode = false) {
        const { children } = node;
        const originalCount = children.length;
        let hoistedCount = 0;
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child.type === 1 && child.tagType === 0) {
            const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
            if (constantType > 0) {
              if (constantType >= 2) {
                child.codegenNode.patchFlag = `-1 /* HOISTED */`;
                child.codegenNode = context.hoist(child.codegenNode);
                hoistedCount++;
                continue;
              }
            } else {
              const codegenNode = child.codegenNode;
              if (codegenNode.type === 13) {
                const flag = getPatchFlag(codegenNode);
                if ((!flag || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
                  const props = getNodeProps(child);
                  if (props) {
                    codegenNode.props = context.hoist(props);
                  }
                }
                if (codegenNode.dynamicProps) {
                  codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
                }
              }
            }
          }
          if (child.type === 1) {
            const isComponent2 = child.tagType === 1;
            if (isComponent2) {
              context.scopes.vSlot++;
            }
            walk(child, context);
            if (isComponent2) {
              context.scopes.vSlot--;
            }
          } else if (child.type === 11) {
            walk(child, context, child.children.length === 1);
          } else if (child.type === 9) {
            for (let i2 = 0; i2 < child.branches.length; i2++) {
              walk(
                child.branches[i2],
                context,
                child.branches[i2].children.length === 1
              );
            }
          }
        }
        if (hoistedCount && context.transformHoist) {
          context.transformHoist(children, context, node);
        }
        if (hoistedCount && hoistedCount === originalCount && node.type === 1 && node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && shared.isArray(node.codegenNode.children)) {
          node.codegenNode.children = context.hoist(
            createArrayExpression(node.codegenNode.children)
          );
        }
      }
      function getConstantType(node, context) {
        const { constantCache } = context;
        switch (node.type) {
          case 1:
            if (node.tagType !== 0) {
              return 0;
            }
            const cached = constantCache.get(node);
            if (cached !== void 0) {
              return cached;
            }
            const codegenNode = node.codegenNode;
            if (codegenNode.type !== 13) {
              return 0;
            }
            if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject") {
              return 0;
            }
            const flag = getPatchFlag(codegenNode);
            if (!flag) {
              let returnType2 = 3;
              const generatedPropsType = getGeneratedPropsConstantType(node, context);
              if (generatedPropsType === 0) {
                constantCache.set(node, 0);
                return 0;
              }
              if (generatedPropsType < returnType2) {
                returnType2 = generatedPropsType;
              }
              for (let i = 0; i < node.children.length; i++) {
                const childType = getConstantType(node.children[i], context);
                if (childType === 0) {
                  constantCache.set(node, 0);
                  return 0;
                }
                if (childType < returnType2) {
                  returnType2 = childType;
                }
              }
              if (returnType2 > 1) {
                for (let i = 0; i < node.props.length; i++) {
                  const p = node.props[i];
                  if (p.type === 7 && p.name === "bind" && p.exp) {
                    const expType = getConstantType(p.exp, context);
                    if (expType === 0) {
                      constantCache.set(node, 0);
                      return 0;
                    }
                    if (expType < returnType2) {
                      returnType2 = expType;
                    }
                  }
                }
              }
              if (codegenNode.isBlock) {
                for (let i = 0; i < node.props.length; i++) {
                  const p = node.props[i];
                  if (p.type === 7) {
                    constantCache.set(node, 0);
                    return 0;
                  }
                }
                context.removeHelper(OPEN_BLOCK);
                context.removeHelper(
                  getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)
                );
                codegenNode.isBlock = false;
                context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
              }
              constantCache.set(node, returnType2);
              return returnType2;
            } else {
              constantCache.set(node, 0);
              return 0;
            }
          case 2:
          case 3:
            return 3;
          case 9:
          case 11:
          case 10:
            return 0;
          case 5:
          case 12:
            return getConstantType(node.content, context);
          case 4:
            return node.constType;
          case 8:
            let returnType = 3;
            for (let i = 0; i < node.children.length; i++) {
              const child = node.children[i];
              if (shared.isString(child) || shared.isSymbol(child)) {
                continue;
              }
              const childType = getConstantType(child, context);
              if (childType === 0) {
                return 0;
              } else if (childType < returnType) {
                returnType = childType;
              }
            }
            return returnType;
          default:
            return 0;
        }
      }
      var allowHoistedHelperSet = /* @__PURE__ */ new Set([
        NORMALIZE_CLASS,
        NORMALIZE_STYLE,
        NORMALIZE_PROPS,
        GUARD_REACTIVE_PROPS
      ]);
      function getConstantTypeOfHelperCall(value, context) {
        if (value.type === 14 && !shared.isString(value.callee) && allowHoistedHelperSet.has(value.callee)) {
          const arg = value.arguments[0];
          if (arg.type === 4) {
            return getConstantType(arg, context);
          } else if (arg.type === 14) {
            return getConstantTypeOfHelperCall(arg, context);
          }
        }
        return 0;
      }
      function getGeneratedPropsConstantType(node, context) {
        let returnType = 3;
        const props = getNodeProps(node);
        if (props && props.type === 15) {
          const { properties } = props;
          for (let i = 0; i < properties.length; i++) {
            const { key, value } = properties[i];
            const keyType = getConstantType(key, context);
            if (keyType === 0) {
              return keyType;
            }
            if (keyType < returnType) {
              returnType = keyType;
            }
            let valueType;
            if (value.type === 4) {
              valueType = getConstantType(value, context);
            } else if (value.type === 14) {
              valueType = getConstantTypeOfHelperCall(value, context);
            } else {
              valueType = 0;
            }
            if (valueType === 0) {
              return valueType;
            }
            if (valueType < returnType) {
              returnType = valueType;
            }
          }
        }
        return returnType;
      }
      function getNodeProps(node) {
        const codegenNode = node.codegenNode;
        if (codegenNode.type === 13) {
          return codegenNode.props;
        }
      }
      function getPatchFlag(node) {
        const flag = node.patchFlag;
        return flag ? parseInt(flag, 10) : void 0;
      }
      function createTransformContext(root, {
        filename = "",
        prefixIdentifiers = false,
        hoistStatic: hoistStatic2 = false,
        cacheHandlers = false,
        nodeTransforms = [],
        directiveTransforms = {},
        transformHoist = null,
        isBuiltInComponent = shared.NOOP,
        isCustomElement = shared.NOOP,
        expressionPlugins = [],
        scopeId = null,
        slotted = true,
        ssr = false,
        inSSR = false,
        ssrCssVars = ``,
        bindingMetadata = shared.EMPTY_OBJ,
        inline = false,
        isTS = false,
        onError = defaultOnError,
        onWarn = defaultOnWarn,
        compatConfig
      }) {
        const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
        const context = {
          // options
          selfName: nameMatch && shared.capitalize(shared.camelize(nameMatch[1])),
          prefixIdentifiers,
          hoistStatic: hoistStatic2,
          cacheHandlers,
          nodeTransforms,
          directiveTransforms,
          transformHoist,
          isBuiltInComponent,
          isCustomElement,
          expressionPlugins,
          scopeId,
          slotted,
          ssr,
          inSSR,
          ssrCssVars,
          bindingMetadata,
          inline,
          isTS,
          onError,
          onWarn,
          compatConfig,
          // state
          root,
          helpers: /* @__PURE__ */ new Map(),
          components: /* @__PURE__ */ new Set(),
          directives: /* @__PURE__ */ new Set(),
          hoists: [],
          imports: [],
          constantCache: /* @__PURE__ */ new Map(),
          temps: 0,
          cached: 0,
          identifiers: /* @__PURE__ */ Object.create(null),
          scopes: {
            vFor: 0,
            vSlot: 0,
            vPre: 0,
            vOnce: 0
          },
          parent: null,
          currentNode: root,
          childIndex: 0,
          inVOnce: false,
          // methods
          helper(name) {
            const count = context.helpers.get(name) || 0;
            context.helpers.set(name, count + 1);
            return name;
          },
          removeHelper(name) {
            const count = context.helpers.get(name);
            if (count) {
              const currentCount = count - 1;
              if (!currentCount) {
                context.helpers.delete(name);
              } else {
                context.helpers.set(name, currentCount);
              }
            }
          },
          helperString(name) {
            return `_${helperNameMap[context.helper(name)]}`;
          },
          replaceNode(node) {
            {
              if (!context.currentNode) {
                throw new Error(`Node being replaced is already removed.`);
              }
              if (!context.parent) {
                throw new Error(`Cannot replace root node.`);
              }
            }
            context.parent.children[context.childIndex] = context.currentNode = node;
          },
          removeNode(node) {
            if (!context.parent) {
              throw new Error(`Cannot remove root node.`);
            }
            const list = context.parent.children;
            const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
            if (removalIndex < 0) {
              throw new Error(`node being removed is not a child of current parent`);
            }
            if (!node || node === context.currentNode) {
              context.currentNode = null;
              context.onNodeRemoved();
            } else {
              if (context.childIndex > removalIndex) {
                context.childIndex--;
                context.onNodeRemoved();
              }
            }
            context.parent.children.splice(removalIndex, 1);
          },
          onNodeRemoved: () => {
          },
          addIdentifiers(exp) {
            {
              if (shared.isString(exp)) {
                addId(exp);
              } else if (exp.identifiers) {
                exp.identifiers.forEach(addId);
              } else if (exp.type === 4) {
                addId(exp.content);
              }
            }
          },
          removeIdentifiers(exp) {
            {
              if (shared.isString(exp)) {
                removeId(exp);
              } else if (exp.identifiers) {
                exp.identifiers.forEach(removeId);
              } else if (exp.type === 4) {
                removeId(exp.content);
              }
            }
          },
          hoist(exp) {
            if (shared.isString(exp))
              exp = createSimpleExpression(exp);
            context.hoists.push(exp);
            const identifier = createSimpleExpression(
              `_hoisted_${context.hoists.length}`,
              false,
              exp.loc,
              2
            );
            identifier.hoisted = exp;
            return identifier;
          },
          cache(exp, isVNode = false) {
            return createCacheExpression(context.cached++, exp, isVNode);
          }
        };
        {
          context.filters = /* @__PURE__ */ new Set();
        }
        function addId(id) {
          const { identifiers } = context;
          if (identifiers[id] === void 0) {
            identifiers[id] = 0;
          }
          identifiers[id]++;
        }
        function removeId(id) {
          context.identifiers[id]--;
        }
        return context;
      }
      function transform(root, options) {
        const context = createTransformContext(root, options);
        traverseNode(root, context);
        if (options.hoistStatic) {
          hoistStatic(root, context);
        }
        if (!options.ssr) {
          createRootCodegen(root, context);
        }
        root.helpers = /* @__PURE__ */ new Set([...context.helpers.keys()]);
        root.components = [...context.components];
        root.directives = [...context.directives];
        root.imports = context.imports;
        root.hoists = context.hoists;
        root.temps = context.temps;
        root.cached = context.cached;
        {
          root.filters = [...context.filters];
        }
      }
      function createRootCodegen(root, context) {
        const { helper } = context;
        const { children } = root;
        if (children.length === 1) {
          const child = children[0];
          if (isSingleElementRoot(root, child) && child.codegenNode) {
            const codegenNode = child.codegenNode;
            if (codegenNode.type === 13) {
              convertToBlock(codegenNode, context);
            }
            root.codegenNode = codegenNode;
          } else {
            root.codegenNode = child;
          }
        } else if (children.length > 1) {
          let patchFlag = 64;
          let patchFlagText = shared.PatchFlagNames[64];
          if (children.filter((c) => c.type !== 3).length === 1) {
            patchFlag |= 2048;
            patchFlagText += `, ${shared.PatchFlagNames[2048]}`;
          }
          root.codegenNode = createVNodeCall(
            context,
            helper(FRAGMENT),
            void 0,
            root.children,
            patchFlag + ` /* ${patchFlagText} */`,
            void 0,
            void 0,
            true,
            void 0,
            false
            /* isComponent */
          );
        } else
          ;
      }
      function traverseChildren(parent, context) {
        let i = 0;
        const nodeRemoved = () => {
          i--;
        };
        for (; i < parent.children.length; i++) {
          const child = parent.children[i];
          if (shared.isString(child))
            continue;
          context.parent = parent;
          context.childIndex = i;
          context.onNodeRemoved = nodeRemoved;
          traverseNode(child, context);
        }
      }
      function traverseNode(node, context) {
        context.currentNode = node;
        const { nodeTransforms } = context;
        const exitFns = [];
        for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
          const onExit = nodeTransforms[i2](node, context);
          if (onExit) {
            if (shared.isArray(onExit)) {
              exitFns.push(...onExit);
            } else {
              exitFns.push(onExit);
            }
          }
          if (!context.currentNode) {
            return;
          } else {
            node = context.currentNode;
          }
        }
        switch (node.type) {
          case 3:
            if (!context.ssr) {
              context.helper(CREATE_COMMENT);
            }
            break;
          case 5:
            if (!context.ssr) {
              context.helper(TO_DISPLAY_STRING);
            }
            break;
          case 9:
            for (let i2 = 0; i2 < node.branches.length; i2++) {
              traverseNode(node.branches[i2], context);
            }
            break;
          case 10:
          case 11:
          case 1:
          case 0:
            traverseChildren(node, context);
            break;
        }
        context.currentNode = node;
        let i = exitFns.length;
        while (i--) {
          exitFns[i]();
        }
      }
      function createStructuralDirectiveTransform(name, fn) {
        const matches = shared.isString(name) ? (n) => n === name : (n) => name.test(n);
        return (node, context) => {
          if (node.type === 1) {
            const { props } = node;
            if (node.tagType === 3 && props.some(isVSlot)) {
              return;
            }
            const exitFns = [];
            for (let i = 0; i < props.length; i++) {
              const prop = props[i];
              if (prop.type === 7 && matches(prop.name)) {
                props.splice(i, 1);
                i--;
                const onExit = fn(node, prop, context);
                if (onExit)
                  exitFns.push(onExit);
              }
            }
            return exitFns;
          }
        };
      }
      var PURE_ANNOTATION = `/*#__PURE__*/`;
      var aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
      function createCodegenContext(ast, {
        mode = "function",
        prefixIdentifiers = mode === "module",
        sourceMap = false,
        filename = `template.vue.html`,
        scopeId = null,
        optimizeImports = false,
        runtimeGlobalName = `Vue`,
        runtimeModuleName = `vue`,
        ssrRuntimeModuleName = "vue/server-renderer",
        ssr = false,
        isTS = false,
        inSSR = false
      }) {
        const context = {
          mode,
          prefixIdentifiers,
          sourceMap,
          filename,
          scopeId,
          optimizeImports,
          runtimeGlobalName,
          runtimeModuleName,
          ssrRuntimeModuleName,
          ssr,
          isTS,
          inSSR,
          source: ast.loc.source,
          code: ``,
          column: 1,
          line: 1,
          offset: 0,
          indentLevel: 0,
          pure: false,
          map: void 0,
          helper(key) {
            return `_${helperNameMap[key]}`;
          },
          push(code, node) {
            context.code += code;
            if (context.map) {
              if (node) {
                let name;
                if (node.type === 4 && !node.isStatic) {
                  const content = node.content.replace(/^_ctx\./, "");
                  if (content !== node.content && isSimpleIdentifier(content)) {
                    name = content;
                  }
                }
                addMapping(node.loc.start, name);
              }
              advancePositionWithMutation(context, code);
              if (node && node.loc !== locStub) {
                addMapping(node.loc.end);
              }
            }
          },
          indent() {
            newline(++context.indentLevel);
          },
          deindent(withoutNewLine = false) {
            if (withoutNewLine) {
              --context.indentLevel;
            } else {
              newline(--context.indentLevel);
            }
          },
          newline() {
            newline(context.indentLevel);
          }
        };
        function newline(n) {
          context.push("\n" + `  `.repeat(n));
        }
        function addMapping(loc, name) {
          context.map.addMapping({
            name,
            source: context.filename,
            original: {
              line: loc.line,
              column: loc.column - 1
              // source-map column is 0 based
            },
            generated: {
              line: context.line,
              column: context.column - 1
            }
          });
        }
        if (sourceMap) {
          context.map = new sourceMapJs.SourceMapGenerator();
          context.map.setSourceContent(filename, context.source);
        }
        return context;
      }
      function generate(ast, options = {}) {
        const context = createCodegenContext(ast, options);
        if (options.onContextCreated)
          options.onContextCreated(context);
        const {
          mode,
          push,
          prefixIdentifiers,
          indent,
          deindent,
          newline,
          scopeId,
          ssr
        } = context;
        const helpers = Array.from(ast.helpers);
        const hasHelpers = helpers.length > 0;
        const useWithBlock = !prefixIdentifiers && mode !== "module";
        const genScopeId = scopeId != null && mode === "module";
        const isSetupInlined = !!options.inline;
        const preambleContext = isSetupInlined ? createCodegenContext(ast, options) : context;
        if (mode === "module") {
          genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined);
        } else {
          genFunctionPreamble(ast, preambleContext);
        }
        const functionName = ssr ? `ssrRender` : `render`;
        const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
        if (options.bindingMetadata && !options.inline) {
          args.push("$props", "$setup", "$data", "$options");
        }
        const signature = options.isTS ? args.map((arg) => `${arg}: any`).join(",") : args.join(", ");
        if (isSetupInlined) {
          push(`(${signature}) => {`);
        } else {
          push(`function ${functionName}(${signature}) {`);
        }
        indent();
        if (useWithBlock) {
          push(`with (_ctx) {`);
          indent();
          if (hasHelpers) {
            push(`const { ${helpers.map(aliasHelper).join(", ")} } = _Vue`);
            push(`
`);
            newline();
          }
        }
        if (ast.components.length) {
          genAssets(ast.components, "component", context);
          if (ast.directives.length || ast.temps > 0) {
            newline();
          }
        }
        if (ast.directives.length) {
          genAssets(ast.directives, "directive", context);
          if (ast.temps > 0) {
            newline();
          }
        }
        if (ast.filters && ast.filters.length) {
          newline();
          genAssets(ast.filters, "filter", context);
          newline();
        }
        if (ast.temps > 0) {
          push(`let `);
          for (let i = 0; i < ast.temps; i++) {
            push(`${i > 0 ? `, ` : ``}_temp${i}`);
          }
        }
        if (ast.components.length || ast.directives.length || ast.temps) {
          push(`
`);
          newline();
        }
        if (!ssr) {
          push(`return `);
        }
        if (ast.codegenNode) {
          genNode(ast.codegenNode, context);
        } else {
          push(`null`);
        }
        if (useWithBlock) {
          deindent();
          push(`}`);
        }
        deindent();
        push(`}`);
        return {
          ast,
          code: context.code,
          preamble: isSetupInlined ? preambleContext.code : ``,
          // SourceMapGenerator does have toJSON() method but it's not in the types
          map: context.map ? context.map.toJSON() : void 0
        };
      }
      function genFunctionPreamble(ast, context) {
        const {
          ssr,
          prefixIdentifiers,
          push,
          newline,
          runtimeModuleName,
          runtimeGlobalName,
          ssrRuntimeModuleName
        } = context;
        const VueBinding = ssr ? `require(${JSON.stringify(runtimeModuleName)})` : runtimeGlobalName;
        const helpers = Array.from(ast.helpers);
        if (helpers.length > 0) {
          if (prefixIdentifiers) {
            push(`const { ${helpers.map(aliasHelper).join(", ")} } = ${VueBinding}
`);
          } else {
            push(`const _Vue = ${VueBinding}
`);
            if (ast.hoists.length) {
              const staticHelpers = [
                CREATE_VNODE,
                CREATE_ELEMENT_VNODE,
                CREATE_COMMENT,
                CREATE_TEXT,
                CREATE_STATIC
              ].filter((helper) => helpers.includes(helper)).map(aliasHelper).join(", ");
              push(`const { ${staticHelpers} } = _Vue
`);
            }
          }
        }
        if (ast.ssrHelpers && ast.ssrHelpers.length) {
          push(
            `const { ${ast.ssrHelpers.map(aliasHelper).join(", ")} } = require("${ssrRuntimeModuleName}")
`
          );
        }
        genHoists(ast.hoists, context);
        newline();
        push(`return `);
      }
      function genModulePreamble(ast, context, genScopeId, inline) {
        const {
          push,
          newline,
          optimizeImports,
          runtimeModuleName,
          ssrRuntimeModuleName
        } = context;
        if (genScopeId && ast.hoists.length) {
          ast.helpers.add(PUSH_SCOPE_ID);
          ast.helpers.add(POP_SCOPE_ID);
        }
        if (ast.helpers.size) {
          const helpers = Array.from(ast.helpers);
          if (optimizeImports) {
            push(
              `import { ${helpers.map((s) => helperNameMap[s]).join(", ")} } from ${JSON.stringify(runtimeModuleName)}
`
            );
            push(
              `
// Binding optimization for webpack code-split
const ${helpers.map((s) => `_${helperNameMap[s]} = ${helperNameMap[s]}`).join(", ")}
`
            );
          } else {
            push(
              `import { ${helpers.map((s) => `${helperNameMap[s]} as _${helperNameMap[s]}`).join(", ")} } from ${JSON.stringify(runtimeModuleName)}
`
            );
          }
        }
        if (ast.ssrHelpers && ast.ssrHelpers.length) {
          push(
            `import { ${ast.ssrHelpers.map((s) => `${helperNameMap[s]} as _${helperNameMap[s]}`).join(", ")} } from "${ssrRuntimeModuleName}"
`
          );
        }
        if (ast.imports.length) {
          genImports(ast.imports, context);
          newline();
        }
        genHoists(ast.hoists, context);
        newline();
        if (!inline) {
          push(`export `);
        }
      }
      function genAssets(assets, type, { helper, push, newline, isTS }) {
        const resolver = helper(
          type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE
        );
        for (let i = 0; i < assets.length; i++) {
          let id = assets[i];
          const maybeSelfReference = id.endsWith("__self");
          if (maybeSelfReference) {
            id = id.slice(0, -6);
          }
          push(
            `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`
          );
          if (i < assets.length - 1) {
            newline();
          }
        }
      }
      function genHoists(hoists, context) {
        if (!hoists.length) {
          return;
        }
        context.pure = true;
        const { push, newline, helper, scopeId, mode } = context;
        const genScopeId = scopeId != null && mode !== "function";
        newline();
        if (genScopeId) {
          push(
            `const _withScopeId = n => (${helper(
              PUSH_SCOPE_ID
            )}("${scopeId}"),n=n(),${helper(POP_SCOPE_ID)}(),n)`
          );
          newline();
        }
        for (let i = 0; i < hoists.length; i++) {
          const exp = hoists[i];
          if (exp) {
            const needScopeIdWrapper = genScopeId && exp.type === 13;
            push(
              `const _hoisted_${i + 1} = ${needScopeIdWrapper ? `${PURE_ANNOTATION} _withScopeId(() => ` : ``}`
            );
            genNode(exp, context);
            if (needScopeIdWrapper) {
              push(`)`);
            }
            newline();
          }
        }
        context.pure = false;
      }
      function genImports(importsOptions, context) {
        if (!importsOptions.length) {
          return;
        }
        importsOptions.forEach((imports) => {
          context.push(`import `);
          genNode(imports.exp, context);
          context.push(` from '${imports.path}'`);
          context.newline();
        });
      }
      function isText(n) {
        return shared.isString(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
      }
      function genNodeListAsArray(nodes, context) {
        const multilines = nodes.length > 3 || nodes.some((n) => shared.isArray(n) || !isText(n));
        context.push(`[`);
        multilines && context.indent();
        genNodeList(nodes, context, multilines);
        multilines && context.deindent();
        context.push(`]`);
      }
      function genNodeList(nodes, context, multilines = false, comma = true) {
        const { push, newline } = context;
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (shared.isString(node)) {
            push(node);
          } else if (shared.isArray(node)) {
            genNodeListAsArray(node, context);
          } else {
            genNode(node, context);
          }
          if (i < nodes.length - 1) {
            if (multilines) {
              comma && push(",");
              newline();
            } else {
              comma && push(", ");
            }
          }
        }
      }
      function genNode(node, context) {
        if (shared.isString(node)) {
          context.push(node);
          return;
        }
        if (shared.isSymbol(node)) {
          context.push(context.helper(node));
          return;
        }
        switch (node.type) {
          case 1:
          case 9:
          case 11:
            assert(
              node.codegenNode != null,
              `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`
            );
            genNode(node.codegenNode, context);
            break;
          case 2:
            genText(node, context);
            break;
          case 4:
            genExpression(node, context);
            break;
          case 5:
            genInterpolation(node, context);
            break;
          case 12:
            genNode(node.codegenNode, context);
            break;
          case 8:
            genCompoundExpression(node, context);
            break;
          case 3:
            genComment(node, context);
            break;
          case 13:
            genVNodeCall(node, context);
            break;
          case 14:
            genCallExpression(node, context);
            break;
          case 15:
            genObjectExpression(node, context);
            break;
          case 17:
            genArrayExpression(node, context);
            break;
          case 18:
            genFunctionExpression(node, context);
            break;
          case 19:
            genConditionalExpression(node, context);
            break;
          case 20:
            genCacheExpression(node, context);
            break;
          case 21:
            genNodeList(node.body, context, true, false);
            break;
          case 22:
            genTemplateLiteral(node, context);
            break;
          case 23:
            genIfStatement(node, context);
            break;
          case 24:
            genAssignmentExpression(node, context);
            break;
          case 25:
            genSequenceExpression(node, context);
            break;
          case 26:
            genReturnStatement(node, context);
            break;
          case 10:
            break;
          default: {
            assert(false, `unhandled codegen node type: ${node.type}`);
            const exhaustiveCheck = node;
            return exhaustiveCheck;
          }
        }
      }
      function genText(node, context) {
        context.push(JSON.stringify(node.content), node);
      }
      function genExpression(node, context) {
        const { content, isStatic } = node;
        context.push(isStatic ? JSON.stringify(content) : content, node);
      }
      function genInterpolation(node, context) {
        const { push, helper, pure } = context;
        if (pure)
          push(PURE_ANNOTATION);
        push(`${helper(TO_DISPLAY_STRING)}(`);
        genNode(node.content, context);
        push(`)`);
      }
      function genCompoundExpression(node, context) {
        for (let i = 0; i < node.children.length; i++) {
          const child = node.children[i];
          if (shared.isString(child)) {
            context.push(child);
          } else {
            genNode(child, context);
          }
        }
      }
      function genExpressionAsPropertyKey(node, context) {
        const { push } = context;
        if (node.type === 8) {
          push(`[`);
          genCompoundExpression(node, context);
          push(`]`);
        } else if (node.isStatic) {
          const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
          push(text, node);
        } else {
          push(`[${node.content}]`, node);
        }
      }
      function genComment(node, context) {
        const { push, helper, pure } = context;
        if (pure) {
          push(PURE_ANNOTATION);
        }
        push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
      }
      function genVNodeCall(node, context) {
        const { push, helper, pure } = context;
        const {
          tag,
          props,
          children,
          patchFlag,
          dynamicProps,
          directives,
          isBlock,
          disableTracking,
          isComponent: isComponent2
        } = node;
        if (directives) {
          push(helper(WITH_DIRECTIVES) + `(`);
        }
        if (isBlock) {
          push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
        }
        if (pure) {
          push(PURE_ANNOTATION);
        }
        const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent2) : getVNodeHelper(context.inSSR, isComponent2);
        push(helper(callHelper) + `(`, node);
        genNodeList(
          genNullableArgs([tag, props, children, patchFlag, dynamicProps]),
          context
        );
        push(`)`);
        if (isBlock) {
          push(`)`);
        }
        if (directives) {
          push(`, `);
          genNode(directives, context);
          push(`)`);
        }
      }
      function genNullableArgs(args) {
        let i = args.length;
        while (i--) {
          if (args[i] != null)
            break;
        }
        return args.slice(0, i + 1).map((arg) => arg || `null`);
      }
      function genCallExpression(node, context) {
        const { push, helper, pure } = context;
        const callee = shared.isString(node.callee) ? node.callee : helper(node.callee);
        if (pure) {
          push(PURE_ANNOTATION);
        }
        push(callee + `(`, node);
        genNodeList(node.arguments, context);
        push(`)`);
      }
      function genObjectExpression(node, context) {
        const { push, indent, deindent, newline } = context;
        const { properties } = node;
        if (!properties.length) {
          push(`{}`, node);
          return;
        }
        const multilines = properties.length > 1 || properties.some((p) => p.value.type !== 4);
        push(multilines ? `{` : `{ `);
        multilines && indent();
        for (let i = 0; i < properties.length; i++) {
          const { key, value } = properties[i];
          genExpressionAsPropertyKey(key, context);
          push(`: `);
          genNode(value, context);
          if (i < properties.length - 1) {
            push(`,`);
            newline();
          }
        }
        multilines && deindent();
        push(multilines ? `}` : ` }`);
      }
      function genArrayExpression(node, context) {
        genNodeListAsArray(node.elements, context);
      }
      function genFunctionExpression(node, context) {
        const { push, indent, deindent } = context;
        const { params, returns, body, newline, isSlot } = node;
        if (isSlot) {
          push(`_${helperNameMap[WITH_CTX]}(`);
        }
        push(`(`, node);
        if (shared.isArray(params)) {
          genNodeList(params, context);
        } else if (params) {
          genNode(params, context);
        }
        push(`) => `);
        if (newline || body) {
          push(`{`);
          indent();
        }
        if (returns) {
          if (newline) {
            push(`return `);
          }
          if (shared.isArray(returns)) {
            genNodeListAsArray(returns, context);
          } else {
            genNode(returns, context);
          }
        } else if (body) {
          genNode(body, context);
        }
        if (newline || body) {
          deindent();
          push(`}`);
        }
        if (isSlot) {
          if (node.isNonScopedSlot) {
            push(`, undefined, true`);
          }
          push(`)`);
        }
      }
      function genConditionalExpression(node, context) {
        const { test, consequent, alternate, newline: needNewline } = node;
        const { push, indent, deindent, newline } = context;
        if (test.type === 4) {
          const needsParens = !isSimpleIdentifier(test.content);
          needsParens && push(`(`);
          genExpression(test, context);
          needsParens && push(`)`);
        } else {
          push(`(`);
          genNode(test, context);
          push(`)`);
        }
        needNewline && indent();
        context.indentLevel++;
        needNewline || push(` `);
        push(`? `);
        genNode(consequent, context);
        context.indentLevel--;
        needNewline && newline();
        needNewline || push(` `);
        push(`: `);
        const isNested = alternate.type === 19;
        if (!isNested) {
          context.indentLevel++;
        }
        genNode(alternate, context);
        if (!isNested) {
          context.indentLevel--;
        }
        needNewline && deindent(
          true
          /* without newline */
        );
      }
      function genCacheExpression(node, context) {
        const { push, helper, indent, deindent, newline } = context;
        push(`_cache[${node.index}] || (`);
        if (node.isVNode) {
          indent();
          push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
          newline();
        }
        push(`_cache[${node.index}] = `);
        genNode(node.value, context);
        if (node.isVNode) {
          push(`,`);
          newline();
          push(`${helper(SET_BLOCK_TRACKING)}(1),`);
          newline();
          push(`_cache[${node.index}]`);
          deindent();
        }
        push(`)`);
      }
      function genTemplateLiteral(node, context) {
        const { push, indent, deindent } = context;
        push("`");
        const l = node.elements.length;
        const multilines = l > 3;
        for (let i = 0; i < l; i++) {
          const e = node.elements[i];
          if (shared.isString(e)) {
            push(e.replace(/(`|\$|\\)/g, "\\$1"));
          } else {
            push("${");
            if (multilines)
              indent();
            genNode(e, context);
            if (multilines)
              deindent();
            push("}");
          }
        }
        push("`");
      }
      function genIfStatement(node, context) {
        const { push, indent, deindent } = context;
        const { test, consequent, alternate } = node;
        push(`if (`);
        genNode(test, context);
        push(`) {`);
        indent();
        genNode(consequent, context);
        deindent();
        push(`}`);
        if (alternate) {
          push(` else `);
          if (alternate.type === 23) {
            genIfStatement(alternate, context);
          } else {
            push(`{`);
            indent();
            genNode(alternate, context);
            deindent();
            push(`}`);
          }
        }
      }
      function genAssignmentExpression(node, context) {
        genNode(node.left, context);
        context.push(` = `);
        genNode(node.right, context);
      }
      function genSequenceExpression(node, context) {
        context.push(`(`);
        genNodeList(node.expressions, context);
        context.push(`)`);
      }
      function genReturnStatement({ returns }, context) {
        context.push(`return `);
        if (shared.isArray(returns)) {
          genNodeListAsArray(returns, context);
        } else {
          genNode(returns, context);
        }
      }
      function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = /* @__PURE__ */ Object.create(null)) {
        const rootExp = root.type === "Program" && root.body[0].type === "ExpressionStatement" && root.body[0].expression;
        estreeWalker.walk(root, {
          enter(node, parent) {
            parent && parentStack.push(parent);
            if (parent && parent.type.startsWith("TS") && !TS_NODE_TYPES.includes(parent.type)) {
              return this.skip();
            }
            if (node.type === "Identifier") {
              const isLocal = !!knownIds[node.name];
              const isRefed = isReferencedIdentifier(node, parent, parentStack);
              if (includeAll || isRefed && !isLocal) {
                onIdentifier(node, parent, parentStack, isRefed, isLocal);
              }
            } else if (node.type === "ObjectProperty" && parent.type === "ObjectPattern") {
              node.inPattern = true;
            } else if (isFunctionType(node)) {
              walkFunctionParams(node, (id) => markScopeIdentifier(node, id, knownIds));
            } else if (node.type === "BlockStatement") {
              walkBlockDeclarations(
                node,
                (id) => markScopeIdentifier(node, id, knownIds)
              );
            }
          },
          leave(node, parent) {
            parent && parentStack.pop();
            if (node !== rootExp && node.scopeIds) {
              for (const id of node.scopeIds) {
                knownIds[id]--;
                if (knownIds[id] === 0) {
                  delete knownIds[id];
                }
              }
            }
          }
        });
      }
      function isReferencedIdentifier(id, parent, parentStack) {
        if (!parent) {
          return true;
        }
        if (id.name === "arguments") {
          return false;
        }
        if (isReferenced(id, parent)) {
          return true;
        }
        switch (parent.type) {
          case "AssignmentExpression":
          case "AssignmentPattern":
            return true;
          case "ObjectPattern":
          case "ArrayPattern":
            return isInDestructureAssignment(parent, parentStack);
        }
        return false;
      }
      function isInDestructureAssignment(parent, parentStack) {
        if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
          let i = parentStack.length;
          while (i--) {
            const p = parentStack[i];
            if (p.type === "AssignmentExpression") {
              return true;
            } else if (p.type !== "ObjectProperty" && !p.type.endsWith("Pattern")) {
              break;
            }
          }
        }
        return false;
      }
      function walkFunctionParams(node, onIdent) {
        for (const p of node.params) {
          for (const id of extractIdentifiers(p)) {
            onIdent(id);
          }
        }
      }
      function walkBlockDeclarations(block, onIdent) {
        for (const stmt of block.body) {
          if (stmt.type === "VariableDeclaration") {
            if (stmt.declare)
              continue;
            for (const decl of stmt.declarations) {
              for (const id of extractIdentifiers(decl.id)) {
                onIdent(id);
              }
            }
          } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
            if (stmt.declare || !stmt.id)
              continue;
            onIdent(stmt.id);
          }
        }
      }
      function extractIdentifiers(param, nodes = []) {
        switch (param.type) {
          case "Identifier":
            nodes.push(param);
            break;
          case "MemberExpression":
            let object = param;
            while (object.type === "MemberExpression") {
              object = object.object;
            }
            nodes.push(object);
            break;
          case "ObjectPattern":
            for (const prop of param.properties) {
              if (prop.type === "RestElement") {
                extractIdentifiers(prop.argument, nodes);
              } else {
                extractIdentifiers(prop.value, nodes);
              }
            }
            break;
          case "ArrayPattern":
            param.elements.forEach((element) => {
              if (element)
                extractIdentifiers(element, nodes);
            });
            break;
          case "RestElement":
            extractIdentifiers(param.argument, nodes);
            break;
          case "AssignmentPattern":
            extractIdentifiers(param.left, nodes);
            break;
        }
        return nodes;
      }
      function markScopeIdentifier(node, child, knownIds) {
        const { name } = child;
        if (node.scopeIds && node.scopeIds.has(name)) {
          return;
        }
        if (name in knownIds) {
          knownIds[name]++;
        } else {
          knownIds[name] = 1;
        }
        (node.scopeIds || (node.scopeIds = /* @__PURE__ */ new Set())).add(name);
      }
      var isFunctionType = (node) => {
        return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
      };
      var isStaticProperty = (node) => node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
      var isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
      function isReferenced(node, parent, grandparent) {
        switch (parent.type) {
          case "MemberExpression":
          case "OptionalMemberExpression":
            if (parent.property === node) {
              return !!parent.computed;
            }
            return parent.object === node;
          case "JSXMemberExpression":
            return parent.object === node;
          case "VariableDeclarator":
            return parent.init === node;
          case "ArrowFunctionExpression":
            return parent.body === node;
          case "PrivateName":
            return false;
          case "ClassMethod":
          case "ClassPrivateMethod":
          case "ObjectMethod":
            if (parent.key === node) {
              return !!parent.computed;
            }
            return false;
          case "ObjectProperty":
            if (parent.key === node) {
              return !!parent.computed;
            }
            return !grandparent || grandparent.type !== "ObjectPattern";
          case "ClassProperty":
            if (parent.key === node) {
              return !!parent.computed;
            }
            return true;
          case "ClassPrivateProperty":
            return parent.key !== node;
          case "ClassDeclaration":
          case "ClassExpression":
            return parent.superClass === node;
          case "AssignmentExpression":
            return parent.right === node;
          case "AssignmentPattern":
            return parent.right === node;
          case "LabeledStatement":
            return false;
          case "CatchClause":
            return false;
          case "RestElement":
            return false;
          case "BreakStatement":
          case "ContinueStatement":
            return false;
          case "FunctionDeclaration":
          case "FunctionExpression":
            return false;
          case "ExportNamespaceSpecifier":
          case "ExportDefaultSpecifier":
            return false;
          case "ExportSpecifier":
            if (grandparent == null ? void 0 : grandparent.source) {
              return false;
            }
            return parent.local === node;
          case "ImportDefaultSpecifier":
          case "ImportNamespaceSpecifier":
          case "ImportSpecifier":
            return false;
          case "ImportAttribute":
            return false;
          case "JSXAttribute":
            return false;
          case "ObjectPattern":
          case "ArrayPattern":
            return false;
          case "MetaProperty":
            return false;
          case "ObjectTypeProperty":
            return parent.key !== node;
          case "TSEnumMember":
            return parent.id !== node;
          case "TSPropertySignature":
            if (parent.key === node) {
              return !!parent.computed;
            }
            return true;
        }
        return true;
      }
      var TS_NODE_TYPES = [
        "TSAsExpression",
        // foo as number
        "TSTypeAssertion",
        // (<number>foo)
        "TSNonNullExpression",
        // foo!
        "TSInstantiationExpression",
        // foo<string>
        "TSSatisfiesExpression"
        // foo satisfies T
      ];
      var isLiteralWhitelisted = /* @__PURE__ */ shared.makeMap("true,false,null,this");
      var constantBailRE = /\w\s*\(|\.[^\d]/;
      var transformExpression = (node, context) => {
        if (node.type === 5) {
          node.content = processExpression(
            node.content,
            context
          );
        } else if (node.type === 1) {
          for (let i = 0; i < node.props.length; i++) {
            const dir = node.props[i];
            if (dir.type === 7 && dir.name !== "for") {
              const exp = dir.exp;
              const arg = dir.arg;
              if (exp && exp.type === 4 && !(dir.name === "on" && arg)) {
                dir.exp = processExpression(
                  exp,
                  context,
                  // slot args must be processed as function params
                  dir.name === "slot"
                );
              }
              if (arg && arg.type === 4 && !arg.isStatic) {
                dir.arg = processExpression(arg, context);
              }
            }
          }
        }
      };
      function processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {
        if (!context.prefixIdentifiers || !node.content.trim()) {
          return node;
        }
        const { inline, bindingMetadata } = context;
        const rewriteIdentifier = (raw, parent, id) => {
          const type = shared.hasOwn(bindingMetadata, raw) && bindingMetadata[raw];
          if (inline) {
            const isAssignmentLVal = parent && parent.type === "AssignmentExpression" && parent.left === id;
            const isUpdateArg = parent && parent.type === "UpdateExpression" && parent.argument === id;
            const isDestructureAssignment = parent && isInDestructureAssignment(parent, parentStack);
            if (isConst(type) || type === "setup-reactive-const" || localVars[raw]) {
              return raw;
            } else if (type === "setup-ref") {
              return `${raw}.value`;
            } else if (type === "setup-maybe-ref") {
              return isAssignmentLVal || isUpdateArg || isDestructureAssignment ? `${raw}.value` : `${context.helperString(UNREF)}(${raw})`;
            } else if (type === "setup-let") {
              if (isAssignmentLVal) {
                const { right: rVal, operator } = parent;
                const rExp = rawExp.slice(rVal.start - 1, rVal.end - 1);
                const rExpString = stringifyExpression(
                  processExpression(
                    createSimpleExpression(rExp, false),
                    context,
                    false,
                    false,
                    knownIds
                  )
                );
                return `${context.helperString(IS_REF)}(${raw})${context.isTS ? ` //@ts-ignore
` : ``} ? ${raw}.value ${operator} ${rExpString} : ${raw}`;
              } else if (isUpdateArg) {
                id.start = parent.start;
                id.end = parent.end;
                const { prefix: isPrefix, operator } = parent;
                const prefix = isPrefix ? operator : ``;
                const postfix = isPrefix ? `` : operator;
                return `${context.helperString(IS_REF)}(${raw})${context.isTS ? ` //@ts-ignore
` : ``} ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`;
              } else if (isDestructureAssignment) {
                return raw;
              } else {
                return `${context.helperString(UNREF)}(${raw})`;
              }
            } else if (type === "props") {
              return shared.genPropsAccessExp(raw);
            } else if (type === "props-aliased") {
              return shared.genPropsAccessExp(bindingMetadata.__propsAliases[raw]);
            }
          } else {
            if (type && type.startsWith("setup") || type === "literal-const") {
              return `$setup.${raw}`;
            } else if (type === "props-aliased") {
              return `$props['${bindingMetadata.__propsAliases[raw]}']`;
            } else if (type) {
              return `$${type}.${raw}`;
            }
          }
          return `_ctx.${raw}`;
        };
        const rawExp = node.content;
        const bailConstant = constantBailRE.test(rawExp);
        if (isSimpleIdentifier(rawExp)) {
          const isScopeVarReference = context.identifiers[rawExp];
          const isAllowedGlobal = shared.isGloballyWhitelisted(rawExp);
          const isLiteral = isLiteralWhitelisted(rawExp);
          if (!asParams && !isScopeVarReference && !isAllowedGlobal && !isLiteral) {
            if (isConst(bindingMetadata[node.content])) {
              node.constType = 1;
            }
            node.content = rewriteIdentifier(rawExp);
          } else if (!isScopeVarReference) {
            if (isLiteral) {
              node.constType = 3;
            } else {
              node.constType = 2;
            }
          }
          return node;
        }
        let ast;
        const source = asRawStatements ? ` ${rawExp} ` : `(${rawExp})${asParams ? `=>{}` : ``}`;
        try {
          ast = parser.parse(source, {
            plugins: context.expressionPlugins
          }).program;
        } catch (e) {
          context.onError(
            createCompilerError(
              45,
              node.loc,
              void 0,
              e.message
            )
          );
          return node;
        }
        const ids = [];
        const parentStack = [];
        const knownIds = Object.create(context.identifiers);
        walkIdentifiers(
          ast,
          (node2, parent, _, isReferenced2, isLocal) => {
            if (isStaticPropertyKey(node2, parent)) {
              return;
            }
            if (node2.name.startsWith("_filter_")) {
              return;
            }
            const needPrefix = isReferenced2 && canPrefix(node2);
            if (needPrefix && !isLocal) {
              if (isStaticProperty(parent) && parent.shorthand) {
                node2.prefix = `${node2.name}: `;
              }
              node2.name = rewriteIdentifier(node2.name, parent, node2);
              ids.push(node2);
            } else {
              if (!(needPrefix && isLocal) && !bailConstant) {
                node2.isConstant = true;
              }
              ids.push(node2);
            }
          },
          true,
          // invoke on ALL identifiers
          parentStack,
          knownIds
        );
        const children = [];
        ids.sort((a, b) => a.start - b.start);
        ids.forEach((id, i) => {
          const start = id.start - 1;
          const end = id.end - 1;
          const last2 = ids[i - 1];
          const leadingText = rawExp.slice(last2 ? last2.end - 1 : 0, start);
          if (leadingText.length || id.prefix) {
            children.push(leadingText + (id.prefix || ``));
          }
          const source2 = rawExp.slice(start, end);
          children.push(
            createSimpleExpression(
              id.name,
              false,
              {
                source: source2,
                start: advancePositionWithClone(node.loc.start, source2, start),
                end: advancePositionWithClone(node.loc.start, source2, end)
              },
              id.isConstant ? 3 : 0
            )
          );
          if (i === ids.length - 1 && end < rawExp.length) {
            children.push(rawExp.slice(end));
          }
        });
        let ret;
        if (children.length) {
          ret = createCompoundExpression(children, node.loc);
        } else {
          ret = node;
          ret.constType = bailConstant ? 0 : 3;
        }
        ret.identifiers = Object.keys(knownIds);
        return ret;
      }
      function canPrefix(id) {
        if (shared.isGloballyWhitelisted(id.name)) {
          return false;
        }
        if (id.name === "require") {
          return false;
        }
        return true;
      }
      function stringifyExpression(exp) {
        if (shared.isString(exp)) {
          return exp;
        } else if (exp.type === 4) {
          return exp.content;
        } else {
          return exp.children.map(stringifyExpression).join("");
        }
      }
      function isConst(type) {
        return type === "setup-const" || type === "literal-const";
      }
      var transformIf = createStructuralDirectiveTransform(
        /^(if|else|else-if)$/,
        (node, dir, context) => {
          return processIf(node, dir, context, (ifNode, branch, isRoot) => {
            const siblings = context.parent.children;
            let i = siblings.indexOf(ifNode);
            let key = 0;
            while (i-- >= 0) {
              const sibling = siblings[i];
              if (sibling && sibling.type === 9) {
                key += sibling.branches.length;
              }
            }
            return () => {
              if (isRoot) {
                ifNode.codegenNode = createCodegenNodeForBranch(
                  branch,
                  key,
                  context
                );
              } else {
                const parentCondition = getParentCondition(ifNode.codegenNode);
                parentCondition.alternate = createCodegenNodeForBranch(
                  branch,
                  key + ifNode.branches.length - 1,
                  context
                );
              }
            };
          });
        }
      );
      function processIf(node, dir, context, processCodegen) {
        if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
          const loc = dir.exp ? dir.exp.loc : node.loc;
          context.onError(
            createCompilerError(28, dir.loc)
          );
          dir.exp = createSimpleExpression(`true`, false, loc);
        }
        if (context.prefixIdentifiers && dir.exp) {
          dir.exp = processExpression(dir.exp, context);
        }
        if (dir.name === "if") {
          const branch = createIfBranch(node, dir);
          const ifNode = {
            type: 9,
            loc: node.loc,
            branches: [branch]
          };
          context.replaceNode(ifNode);
          if (processCodegen) {
            return processCodegen(ifNode, branch, true);
          }
        } else {
          const siblings = context.parent.children;
          const comments = [];
          let i = siblings.indexOf(node);
          while (i-- >= -1) {
            const sibling = siblings[i];
            if (sibling && sibling.type === 3) {
              context.removeNode(sibling);
              comments.unshift(sibling);
              continue;
            }
            if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
              context.removeNode(sibling);
              continue;
            }
            if (sibling && sibling.type === 9) {
              if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
                context.onError(
                  createCompilerError(30, node.loc)
                );
              }
              context.removeNode();
              const branch = createIfBranch(node, dir);
              if (comments.length && // #3619 ignore comments if the v-if is direct child of <transition>
              !(context.parent && context.parent.type === 1 && isBuiltInType(context.parent.tag, "transition"))) {
                branch.children = [...comments, ...branch.children];
              }
              {
                const key = branch.userKey;
                if (key) {
                  sibling.branches.forEach(({ userKey }) => {
                    if (isSameKey(userKey, key)) {
                      context.onError(
                        createCompilerError(
                          29,
                          branch.userKey.loc
                        )
                      );
                    }
                  });
                }
              }
              sibling.branches.push(branch);
              const onExit = processCodegen && processCodegen(sibling, branch, false);
              traverseNode(branch, context);
              if (onExit)
                onExit();
              context.currentNode = null;
            } else {
              context.onError(
                createCompilerError(30, node.loc)
              );
            }
            break;
          }
        }
      }
      function createIfBranch(node, dir) {
        const isTemplateIf = node.tagType === 3;
        return {
          type: 10,
          loc: node.loc,
          condition: dir.name === "else" ? void 0 : dir.exp,
          children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
          userKey: findProp(node, `key`),
          isTemplateIf
        };
      }
      function createCodegenNodeForBranch(branch, keyIndex, context) {
        if (branch.condition) {
          return createConditionalExpression(
            branch.condition,
            createChildrenCodegenNode(branch, keyIndex, context),
            // make sure to pass in asBlock: true so that the comment node call
            // closes the current block.
            createCallExpression(context.helper(CREATE_COMMENT), [
              '"v-if"',
              "true"
            ])
          );
        } else {
          return createChildrenCodegenNode(branch, keyIndex, context);
        }
      }
      function createChildrenCodegenNode(branch, keyIndex, context) {
        const { helper } = context;
        const keyProperty = createObjectProperty(
          `key`,
          createSimpleExpression(
            `${keyIndex}`,
            false,
            locStub,
            2
          )
        );
        const { children } = branch;
        const firstChild = children[0];
        const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
        if (needFragmentWrapper) {
          if (children.length === 1 && firstChild.type === 11) {
            const vnodeCall = firstChild.codegenNode;
            injectProp(vnodeCall, keyProperty, context);
            return vnodeCall;
          } else {
            let patchFlag = 64;
            let patchFlagText = shared.PatchFlagNames[64];
            if (!branch.isTemplateIf && children.filter((c) => c.type !== 3).length === 1) {
              patchFlag |= 2048;
              patchFlagText += `, ${shared.PatchFlagNames[2048]}`;
            }
            return createVNodeCall(
              context,
              helper(FRAGMENT),
              createObjectExpression([keyProperty]),
              children,
              patchFlag + ` /* ${patchFlagText} */`,
              void 0,
              void 0,
              true,
              false,
              false,
              branch.loc
            );
          }
        } else {
          const ret = firstChild.codegenNode;
          const vnodeCall = getMemoedVNodeCall(ret);
          if (vnodeCall.type === 13) {
            convertToBlock(vnodeCall, context);
          }
          injectProp(vnodeCall, keyProperty, context);
          return ret;
        }
      }
      function isSameKey(a, b) {
        if (!a || a.type !== b.type) {
          return false;
        }
        if (a.type === 6) {
          if (a.value.content !== b.value.content) {
            return false;
          }
        } else {
          const exp = a.exp;
          const branchExp = b.exp;
          if (exp.type !== branchExp.type) {
            return false;
          }
          if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
            return false;
          }
        }
        return true;
      }
      function getParentCondition(node) {
        while (true) {
          if (node.type === 19) {
            if (node.alternate.type === 19) {
              node = node.alternate;
            } else {
              return node;
            }
          } else if (node.type === 20) {
            node = node.value;
          }
        }
      }
      var transformFor = createStructuralDirectiveTransform(
        "for",
        (node, dir, context) => {
          const { helper, removeHelper } = context;
          return processFor(node, dir, context, (forNode) => {
            const renderExp = createCallExpression(helper(RENDER_LIST), [
              forNode.source
            ]);
            const isTemplate = isTemplateNode(node);
            const memo = findDir(node, "memo");
            const keyProp = findProp(node, `key`);
            const keyExp = keyProp && (keyProp.type === 6 ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp);
            const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
            if (isTemplate) {
              if (memo) {
                memo.exp = processExpression(
                  memo.exp,
                  context
                );
              }
              if (keyProperty && keyProp.type !== 6) {
                keyProperty.value = processExpression(
                  keyProperty.value,
                  context
                );
              }
            }
            const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
            const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
            forNode.codegenNode = createVNodeCall(
              context,
              helper(FRAGMENT),
              void 0,
              renderExp,
              fragmentFlag + ` /* ${shared.PatchFlagNames[fragmentFlag]} */`,
              void 0,
              void 0,
              true,
              !isStableFragment,
              false,
              node.loc
            );
            return () => {
              let childBlock;
              const { children } = forNode;
              if (isTemplate) {
                node.children.some((c) => {
                  if (c.type === 1) {
                    const key = findProp(c, "key");
                    if (key) {
                      context.onError(
                        createCompilerError(
                          33,
                          key.loc
                        )
                      );
                      return true;
                    }
                  }
                });
              }
              const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
              const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
              if (slotOutlet) {
                childBlock = slotOutlet.codegenNode;
                if (isTemplate && keyProperty) {
                  injectProp(childBlock, keyProperty, context);
                }
              } else if (needFragmentWrapper) {
                childBlock = createVNodeCall(
                  context,
                  helper(FRAGMENT),
                  keyProperty ? createObjectExpression([keyProperty]) : void 0,
                  node.children,
                  `64 /* ${shared.PatchFlagNames[64]} */`,
                  void 0,
                  void 0,
                  true,
                  void 0,
                  false
                  /* isComponent */
                );
              } else {
                childBlock = children[0].codegenNode;
                if (isTemplate && keyProperty) {
                  injectProp(childBlock, keyProperty, context);
                }
                if (childBlock.isBlock !== !isStableFragment) {
                  if (childBlock.isBlock) {
                    removeHelper(OPEN_BLOCK);
                    removeHelper(
                      getVNodeBlockHelper(context.inSSR, childBlock.isComponent)
                    );
                  } else {
                    removeHelper(
                      getVNodeHelper(context.inSSR, childBlock.isComponent)
                    );
                  }
                }
                childBlock.isBlock = !isStableFragment;
                if (childBlock.isBlock) {
                  helper(OPEN_BLOCK);
                  helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
                } else {
                  helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
                }
              }
              if (memo) {
                const loop = createFunctionExpression(
                  createForLoopParams(forNode.parseResult, [
                    createSimpleExpression(`_cached`)
                  ])
                );
                loop.body = createBlockStatement([
                  createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
                  createCompoundExpression([
                    `if (_cached`,
                    ...keyExp ? [` && _cached.key === `, keyExp] : [],
                    ` && ${context.helperString(
                      IS_MEMO_SAME
                    )}(_cached, _memo)) return _cached`
                  ]),
                  createCompoundExpression([`const _item = `, childBlock]),
                  createSimpleExpression(`_item.memo = _memo`),
                  createSimpleExpression(`return _item`)
                ]);
                renderExp.arguments.push(
                  loop,
                  createSimpleExpression(`_cache`),
                  createSimpleExpression(String(context.cached++))
                );
              } else {
                renderExp.arguments.push(
                  createFunctionExpression(
                    createForLoopParams(forNode.parseResult),
                    childBlock,
                    true
                    /* force newline */
                  )
                );
              }
            };
          });
        }
      );
      function processFor(node, dir, context, processCodegen) {
        if (!dir.exp) {
          context.onError(
            createCompilerError(31, dir.loc)
          );
          return;
        }
        const parseResult = parseForExpression(
          // can only be simple expression because vFor transform is applied
          // before expression transform.
          dir.exp,
          context
        );
        if (!parseResult) {
          context.onError(
            createCompilerError(32, dir.loc)
          );
          return;
        }
        const { addIdentifiers, removeIdentifiers, scopes } = context;
        const { source, value, key, index } = parseResult;
        const forNode = {
          type: 11,
          loc: dir.loc,
          source,
          valueAlias: value,
          keyAlias: key,
          objectIndexAlias: index,
          parseResult,
          children: isTemplateNode(node) ? node.children : [node]
        };
        context.replaceNode(forNode);
        scopes.vFor++;
        if (context.prefixIdentifiers) {
          value && addIdentifiers(value);
          key && addIdentifiers(key);
          index && addIdentifiers(index);
        }
        const onExit = processCodegen && processCodegen(forNode);
        return () => {
          scopes.vFor--;
          if (context.prefixIdentifiers) {
            value && removeIdentifiers(value);
            key && removeIdentifiers(key);
            index && removeIdentifiers(index);
          }
          if (onExit)
            onExit();
        };
      }
      var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
      var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
      var stripParensRE = /^\(|\)$/g;
      function parseForExpression(input, context) {
        const loc = input.loc;
        const exp = input.content;
        const inMatch = exp.match(forAliasRE);
        if (!inMatch)
          return;
        const [, LHS, RHS] = inMatch;
        const result = {
          source: createAliasExpression(
            loc,
            RHS.trim(),
            exp.indexOf(RHS, LHS.length)
          ),
          value: void 0,
          key: void 0,
          index: void 0
        };
        if (context.prefixIdentifiers) {
          result.source = processExpression(
            result.source,
            context
          );
        }
        let valueContent = LHS.trim().replace(stripParensRE, "").trim();
        const trimmedOffset = LHS.indexOf(valueContent);
        const iteratorMatch = valueContent.match(forIteratorRE);
        if (iteratorMatch) {
          valueContent = valueContent.replace(forIteratorRE, "").trim();
          const keyContent = iteratorMatch[1].trim();
          let keyOffset;
          if (keyContent) {
            keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
            result.key = createAliasExpression(loc, keyContent, keyOffset);
            if (context.prefixIdentifiers) {
              result.key = processExpression(result.key, context, true);
            }
          }
          if (iteratorMatch[2]) {
            const indexContent = iteratorMatch[2].trim();
            if (indexContent) {
              result.index = createAliasExpression(
                loc,
                indexContent,
                exp.indexOf(
                  indexContent,
                  result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length
                )
              );
              if (context.prefixIdentifiers) {
                result.index = processExpression(result.index, context, true);
              }
            }
          }
        }
        if (valueContent) {
          result.value = createAliasExpression(loc, valueContent, trimmedOffset);
          if (context.prefixIdentifiers) {
            result.value = processExpression(result.value, context, true);
          }
        }
        return result;
      }
      function createAliasExpression(range, content, offset) {
        return createSimpleExpression(
          content,
          false,
          getInnerRange(range, offset, content.length)
        );
      }
      function createForLoopParams({ value, key, index }, memoArgs = []) {
        return createParamsList([value, key, index, ...memoArgs]);
      }
      function createParamsList(args) {
        let i = args.length;
        while (i--) {
          if (args[i])
            break;
        }
        return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
      }
      var defaultFallback = createSimpleExpression(`undefined`, false);
      var trackSlotScopes = (node, context) => {
        if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
          const vSlot = findDir(node, "slot");
          if (vSlot) {
            const slotProps = vSlot.exp;
            if (context.prefixIdentifiers) {
              slotProps && context.addIdentifiers(slotProps);
            }
            context.scopes.vSlot++;
            return () => {
              if (context.prefixIdentifiers) {
                slotProps && context.removeIdentifiers(slotProps);
              }
              context.scopes.vSlot--;
            };
          }
        }
      };
      var trackVForSlotScopes = (node, context) => {
        let vFor;
        if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, "for"))) {
          const result = vFor.parseResult = parseForExpression(
            vFor.exp,
            context
          );
          if (result) {
            const { value, key, index } = result;
            const { addIdentifiers, removeIdentifiers } = context;
            value && addIdentifiers(value);
            key && addIdentifiers(key);
            index && addIdentifiers(index);
            return () => {
              value && removeIdentifiers(value);
              key && removeIdentifiers(key);
              index && removeIdentifiers(index);
            };
          }
        }
      };
      var buildClientSlotFn = (props, children, loc) => createFunctionExpression(
        props,
        children,
        false,
        true,
        children.length ? children[0].loc : loc
      );
      function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
        context.helper(WITH_CTX);
        const { children, loc } = node;
        const slotsProperties = [];
        const dynamicSlots = [];
        let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
        if (!context.ssr && context.prefixIdentifiers) {
          hasDynamicSlots = hasScopeRef(node, context.identifiers);
        }
        const onComponentSlot = findDir(node, "slot", true);
        if (onComponentSlot) {
          const { arg, exp } = onComponentSlot;
          if (arg && !isStaticExp(arg)) {
            hasDynamicSlots = true;
          }
          slotsProperties.push(
            createObjectProperty(
              arg || createSimpleExpression("default", true),
              buildSlotFn(exp, children, loc)
            )
          );
        }
        let hasTemplateSlots = false;
        let hasNamedDefaultSlot = false;
        const implicitDefaultChildren = [];
        const seenSlotNames = /* @__PURE__ */ new Set();
        let conditionalBranchIndex = 0;
        for (let i = 0; i < children.length; i++) {
          const slotElement = children[i];
          let slotDir;
          if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
            if (slotElement.type !== 3) {
              implicitDefaultChildren.push(slotElement);
            }
            continue;
          }
          if (onComponentSlot) {
            context.onError(
              createCompilerError(37, slotDir.loc)
            );
            break;
          }
          hasTemplateSlots = true;
          const { children: slotChildren, loc: slotLoc } = slotElement;
          const {
            arg: slotName = createSimpleExpression(`default`, true),
            exp: slotProps,
            loc: dirLoc
          } = slotDir;
          let staticSlotName;
          if (isStaticExp(slotName)) {
            staticSlotName = slotName ? slotName.content : `default`;
          } else {
            hasDynamicSlots = true;
          }
          const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
          let vIf;
          let vElse;
          let vFor;
          if (vIf = findDir(slotElement, "if")) {
            hasDynamicSlots = true;
            dynamicSlots.push(
              createConditionalExpression(
                vIf.exp,
                buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++),
                defaultFallback
              )
            );
          } else if (vElse = findDir(
            slotElement,
            /^else(-if)?$/,
            true
            /* allowEmpty */
          )) {
            let j = i;
            let prev;
            while (j--) {
              prev = children[j];
              if (prev.type !== 3) {
                break;
              }
            }
            if (prev && isTemplateNode(prev) && findDir(prev, "if")) {
              children.splice(i, 1);
              i--;
              let conditional = dynamicSlots[dynamicSlots.length - 1];
              while (conditional.alternate.type === 19) {
                conditional = conditional.alternate;
              }
              conditional.alternate = vElse.exp ? createConditionalExpression(
                vElse.exp,
                buildDynamicSlot(
                  slotName,
                  slotFunction,
                  conditionalBranchIndex++
                ),
                defaultFallback
              ) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
            } else {
              context.onError(
                createCompilerError(30, vElse.loc)
              );
            }
          } else if (vFor = findDir(slotElement, "for")) {
            hasDynamicSlots = true;
            const parseResult = vFor.parseResult || parseForExpression(vFor.exp, context);
            if (parseResult) {
              dynamicSlots.push(
                createCallExpression(context.helper(RENDER_LIST), [
                  parseResult.source,
                  createFunctionExpression(
                    createForLoopParams(parseResult),
                    buildDynamicSlot(slotName, slotFunction),
                    true
                    /* force newline */
                  )
                ])
              );
            } else {
              context.onError(
                createCompilerError(32, vFor.loc)
              );
            }
          } else {
            if (staticSlotName) {
              if (seenSlotNames.has(staticSlotName)) {
                context.onError(
                  createCompilerError(
                    38,
                    dirLoc
                  )
                );
                continue;
              }
              seenSlotNames.add(staticSlotName);
              if (staticSlotName === "default") {
                hasNamedDefaultSlot = true;
              }
            }
            slotsProperties.push(createObjectProperty(slotName, slotFunction));
          }
        }
        if (!onComponentSlot) {
          const buildDefaultSlotProperty = (props, children2) => {
            const fn = buildSlotFn(props, children2, loc);
            if (context.compatConfig) {
              fn.isNonScopedSlot = true;
            }
            return createObjectProperty(`default`, fn);
          };
          if (!hasTemplateSlots) {
            slotsProperties.push(buildDefaultSlotProperty(void 0, children));
          } else if (implicitDefaultChildren.length && // #3766
          // with whitespace: 'preserve', whitespaces between slots will end up in
          // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
          implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
            if (hasNamedDefaultSlot) {
              context.onError(
                createCompilerError(
                  39,
                  implicitDefaultChildren[0].loc
                )
              );
            } else {
              slotsProperties.push(
                buildDefaultSlotProperty(void 0, implicitDefaultChildren)
              );
            }
          }
        }
        const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
        let slots = createObjectExpression(
          slotsProperties.concat(
            createObjectProperty(
              `_`,
              // 2 = compiled but dynamic = can skip normalization, but must run diff
              // 1 = compiled and static = can skip normalization AND diff as optimized
              createSimpleExpression(
                slotFlag + ` /* ${shared.slotFlagsText[slotFlag]} */`,
                false
              )
            )
          ),
          loc
        );
        if (dynamicSlots.length) {
          slots = createCallExpression(context.helper(CREATE_SLOTS), [
            slots,
            createArrayExpression(dynamicSlots)
          ]);
        }
        return {
          slots,
          hasDynamicSlots
        };
      }
      function buildDynamicSlot(name, fn, index) {
        const props = [
          createObjectProperty(`name`, name),
          createObjectProperty(`fn`, fn)
        ];
        if (index != null) {
          props.push(
            createObjectProperty(`key`, createSimpleExpression(String(index), true))
          );
        }
        return createObjectExpression(props);
      }
      function hasForwardedSlots(children) {
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          switch (child.type) {
            case 1:
              if (child.tagType === 2 || hasForwardedSlots(child.children)) {
                return true;
              }
              break;
            case 9:
              if (hasForwardedSlots(child.branches))
                return true;
              break;
            case 10:
            case 11:
              if (hasForwardedSlots(child.children))
                return true;
              break;
          }
        }
        return false;
      }
      function isNonWhitespaceContent(node) {
        if (node.type !== 2 && node.type !== 12)
          return true;
        return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
      }
      var directiveImportMap = /* @__PURE__ */ new WeakMap();
      var transformElement = (node, context) => {
        return function postTransformElement() {
          node = context.currentNode;
          if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
            return;
          }
          const { tag, props } = node;
          const isComponent2 = node.tagType === 1;
          let vnodeTag = isComponent2 ? resolveComponentType(node, context) : `"${tag}"`;
          const isDynamicComponent = shared.isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
          let vnodeProps;
          let vnodeChildren;
          let vnodePatchFlag;
          let patchFlag = 0;
          let vnodeDynamicProps;
          let dynamicPropNames;
          let vnodeDirectives;
          let shouldUseBlock = (
            // dynamic component may resolve to plain elements
            isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && // <svg> and <foreignObject> must be forced into blocks so that block
            // updates inside get proper isSVG flag at runtime. (#639, #643)
            // This is technically web-specific, but splitting the logic out of core
            // leads to too much unnecessary complexity.
            (tag === "svg" || tag === "foreignObject")
          );
          if (props.length > 0) {
            const propsBuildResult = buildProps(
              node,
              context,
              void 0,
              isComponent2,
              isDynamicComponent
            );
            vnodeProps = propsBuildResult.props;
            patchFlag = propsBuildResult.patchFlag;
            dynamicPropNames = propsBuildResult.dynamicPropNames;
            const directives = propsBuildResult.directives;
            vnodeDirectives = directives && directives.length ? createArrayExpression(
              directives.map((dir) => buildDirectiveArgs(dir, context))
            ) : void 0;
            if (propsBuildResult.shouldUseBlock) {
              shouldUseBlock = true;
            }
          }
          if (node.children.length > 0) {
            if (vnodeTag === KEEP_ALIVE) {
              shouldUseBlock = true;
              patchFlag |= 1024;
              if (node.children.length > 1) {
                context.onError(
                  createCompilerError(46, {
                    start: node.children[0].loc.start,
                    end: node.children[node.children.length - 1].loc.end,
                    source: ""
                  })
                );
              }
            }
            const shouldBuildAsSlots = isComponent2 && // Teleport is not a real component and has dedicated runtime handling
            vnodeTag !== TELEPORT && // explained above.
            vnodeTag !== KEEP_ALIVE;
            if (shouldBuildAsSlots) {
              const { slots, hasDynamicSlots } = buildSlots(node, context);
              vnodeChildren = slots;
              if (hasDynamicSlots) {
                patchFlag |= 1024;
              }
            } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
              const child = node.children[0];
              const type = child.type;
              const hasDynamicTextChild = type === 5 || type === 8;
              if (hasDynamicTextChild && getConstantType(child, context) === 0) {
                patchFlag |= 1;
              }
              if (hasDynamicTextChild || type === 2) {
                vnodeChildren = child;
              } else {
                vnodeChildren = node.children;
              }
            } else {
              vnodeChildren = node.children;
            }
          }
          if (patchFlag !== 0) {
            {
              if (patchFlag < 0) {
                vnodePatchFlag = patchFlag + ` /* ${shared.PatchFlagNames[patchFlag]} */`;
              } else {
                const flagNames = Object.keys(shared.PatchFlagNames).map(Number).filter((n) => n > 0 && patchFlag & n).map((n) => shared.PatchFlagNames[n]).join(`, `);
                vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
              }
            }
            if (dynamicPropNames && dynamicPropNames.length) {
              vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
            }
          }
          node.codegenNode = createVNodeCall(
            context,
            vnodeTag,
            vnodeProps,
            vnodeChildren,
            vnodePatchFlag,
            vnodeDynamicProps,
            vnodeDirectives,
            !!shouldUseBlock,
            false,
            isComponent2,
            node.loc
          );
        };
      };
      function resolveComponentType(node, context, ssr = false) {
        let { tag } = node;
        const isExplicitDynamic = isComponentTag(tag);
        const isProp = findProp(node, "is");
        if (isProp) {
          if (isExplicitDynamic || isCompatEnabled(
            "COMPILER_IS_ON_ELEMENT",
            context
          )) {
            const exp = isProp.type === 6 ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;
            if (exp) {
              return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
                exp
              ]);
            }
          } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
            tag = isProp.value.content.slice(4);
          }
        }
        const isDir = !isExplicitDynamic && findDir(node, "is");
        if (isDir && isDir.exp) {
          {
            context.onWarn(
              createCompilerError(52, isDir.loc)
            );
          }
          return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
            isDir.exp
          ]);
        }
        const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
        if (builtIn) {
          if (!ssr)
            context.helper(builtIn);
          return builtIn;
        }
        {
          const fromSetup = resolveSetupReference(tag, context);
          if (fromSetup) {
            return fromSetup;
          }
          const dotIndex = tag.indexOf(".");
          if (dotIndex > 0) {
            const ns = resolveSetupReference(tag.slice(0, dotIndex), context);
            if (ns) {
              return ns + tag.slice(dotIndex);
            }
          }
        }
        if (context.selfName && shared.capitalize(shared.camelize(tag)) === context.selfName) {
          context.helper(RESOLVE_COMPONENT);
          context.components.add(tag + `__self`);
          return toValidAssetId(tag, `component`);
        }
        context.helper(RESOLVE_COMPONENT);
        context.components.add(tag);
        return toValidAssetId(tag, `component`);
      }
      function resolveSetupReference(name, context) {
        const bindings = context.bindingMetadata;
        if (!bindings || bindings.__isScriptSetup === false) {
          return;
        }
        const camelName = shared.camelize(name);
        const PascalName = shared.capitalize(camelName);
        const checkType = (type) => {
          if (bindings[name] === type) {
            return name;
          }
          if (bindings[camelName] === type) {
            return camelName;
          }
          if (bindings[PascalName] === type) {
            return PascalName;
          }
        };
        const fromConst = checkType("setup-const") || checkType("setup-reactive-const") || checkType("literal-const");
        if (fromConst) {
          return context.inline ? (
            // in inline mode, const setup bindings (e.g. imports) can be used as-is
            fromConst
          ) : `$setup[${JSON.stringify(fromConst)}]`;
        }
        const fromMaybeRef = checkType("setup-let") || checkType("setup-ref") || checkType("setup-maybe-ref");
        if (fromMaybeRef) {
          return context.inline ? (
            // setup scope bindings that may be refs need to be unrefed
            `${context.helperString(UNREF)}(${fromMaybeRef})`
          ) : `$setup[${JSON.stringify(fromMaybeRef)}]`;
        }
      }
      function buildProps(node, context, props = node.props, isComponent2, isDynamicComponent, ssr = false) {
        const { tag, loc: elementLoc, children } = node;
        let properties = [];
        const mergeArgs = [];
        const runtimeDirectives = [];
        const hasChildren = children.length > 0;
        let shouldUseBlock = false;
        let patchFlag = 0;
        let hasRef = false;
        let hasClassBinding = false;
        let hasStyleBinding = false;
        let hasHydrationEventBinding = false;
        let hasDynamicKeys = false;
        let hasVnodeHook = false;
        const dynamicPropNames = [];
        const pushMergeArg = (arg) => {
          if (properties.length) {
            mergeArgs.push(
              createObjectExpression(dedupeProperties(properties), elementLoc)
            );
            properties = [];
          }
          if (arg)
            mergeArgs.push(arg);
        };
        const analyzePatchFlag = ({ key, value }) => {
          if (isStaticExp(key)) {
            const name = key.content;
            const isEventHandler = shared.isOn(name);
            if (isEventHandler && (!isComponent2 || isDynamicComponent) && // omit the flag for click handlers because hydration gives click
            // dedicated fast path.
            name.toLowerCase() !== "onclick" && // omit v-model handlers
            name !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
            !shared.isReservedProp(name)) {
              hasHydrationEventBinding = true;
            }
            if (isEventHandler && shared.isReservedProp(name)) {
              hasVnodeHook = true;
            }
            if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
              return;
            }
            if (name === "ref") {
              hasRef = true;
            } else if (name === "class") {
              hasClassBinding = true;
            } else if (name === "style") {
              hasStyleBinding = true;
            } else if (name !== "key" && !dynamicPropNames.includes(name)) {
              dynamicPropNames.push(name);
            }
            if (isComponent2 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
              dynamicPropNames.push(name);
            }
          } else {
            hasDynamicKeys = true;
          }
        };
        for (let i = 0; i < props.length; i++) {
          const prop = props[i];
          if (prop.type === 6) {
            const { loc, name, value } = prop;
            let isStatic = true;
            if (name === "ref") {
              hasRef = true;
              if (context.scopes.vFor > 0) {
                properties.push(
                  createObjectProperty(
                    createSimpleExpression("ref_for", true),
                    createSimpleExpression("true")
                  )
                );
              }
              if (value && context.inline) {
                const binding = context.bindingMetadata[value.content];
                if (binding === "setup-let" || binding === "setup-ref" || binding === "setup-maybe-ref") {
                  isStatic = false;
                  properties.push(
                    createObjectProperty(
                      createSimpleExpression("ref_key", true),
                      createSimpleExpression(value.content, true, value.loc)
                    )
                  );
                }
              }
            }
            if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled(
              "COMPILER_IS_ON_ELEMENT",
              context
            ))) {
              continue;
            }
            properties.push(
              createObjectProperty(
                createSimpleExpression(
                  name,
                  true,
                  getInnerRange(loc, 0, name.length)
                ),
                createSimpleExpression(
                  value ? value.content : "",
                  isStatic,
                  value ? value.loc : loc
                )
              )
            );
          } else {
            const { name, arg, exp, loc } = prop;
            const isVBind = name === "bind";
            const isVOn = name === "on";
            if (name === "slot") {
              if (!isComponent2) {
                context.onError(
                  createCompilerError(40, loc)
                );
              }
              continue;
            }
            if (name === "once" || name === "memo") {
              continue;
            }
            if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled(
              "COMPILER_IS_ON_ELEMENT",
              context
            ))) {
              continue;
            }
            if (isVOn && ssr) {
              continue;
            }
            if (
              // #938: elements with dynamic keys should be forced into blocks
              isVBind && isStaticArgOf(arg, "key") || // inline before-update hooks need to force block so that it is invoked
              // before children
              isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")
            ) {
              shouldUseBlock = true;
            }
            if (isVBind && isStaticArgOf(arg, "ref") && context.scopes.vFor > 0) {
              properties.push(
                createObjectProperty(
                  createSimpleExpression("ref_for", true),
                  createSimpleExpression("true")
                )
              );
            }
            if (!arg && (isVBind || isVOn)) {
              hasDynamicKeys = true;
              if (exp) {
                if (isVBind) {
                  pushMergeArg();
                  {
                    {
                      const hasOverridableKeys = mergeArgs.some((arg2) => {
                        if (arg2.type === 15) {
                          return arg2.properties.some(({ key }) => {
                            if (key.type !== 4 || !key.isStatic) {
                              return true;
                            }
                            return key.content !== "class" && key.content !== "style" && !shared.isOn(key.content);
                          });
                        } else {
                          return true;
                        }
                      });
                      if (hasOverridableKeys) {
                        checkCompatEnabled(
                          "COMPILER_V_BIND_OBJECT_ORDER",
                          context,
                          loc
                        );
                      }
                    }
                    if (isCompatEnabled(
                      "COMPILER_V_BIND_OBJECT_ORDER",
                      context
                    )) {
                      mergeArgs.unshift(exp);
                      continue;
                    }
                  }
                  mergeArgs.push(exp);
                } else {
                  pushMergeArg({
                    type: 14,
                    loc,
                    callee: context.helper(TO_HANDLERS),
                    arguments: isComponent2 ? [exp] : [exp, `true`]
                  });
                }
              } else {
                context.onError(
                  createCompilerError(
                    isVBind ? 34 : 35,
                    loc
                  )
                );
              }
              continue;
            }
            const directiveTransform = context.directiveTransforms[name];
            if (directiveTransform) {
              const { props: props2, needRuntime } = directiveTransform(prop, node, context);
              !ssr && props2.forEach(analyzePatchFlag);
              if (isVOn && arg && !isStaticExp(arg)) {
                pushMergeArg(createObjectExpression(props2, elementLoc));
              } else {
                properties.push(...props2);
              }
              if (needRuntime) {
                runtimeDirectives.push(prop);
                if (shared.isSymbol(needRuntime)) {
                  directiveImportMap.set(prop, needRuntime);
                }
              }
            } else if (!shared.isBuiltInDirective(name)) {
              runtimeDirectives.push(prop);
              if (hasChildren) {
                shouldUseBlock = true;
              }
            }
          }
        }
        let propsExpression = void 0;
        if (mergeArgs.length) {
          pushMergeArg();
          if (mergeArgs.length > 1) {
            propsExpression = createCallExpression(
              context.helper(MERGE_PROPS),
              mergeArgs,
              elementLoc
            );
          } else {
            propsExpression = mergeArgs[0];
          }
        } else if (properties.length) {
          propsExpression = createObjectExpression(
            dedupeProperties(properties),
            elementLoc
          );
        }
        if (hasDynamicKeys) {
          patchFlag |= 16;
        } else {
          if (hasClassBinding && !isComponent2) {
            patchFlag |= 2;
          }
          if (hasStyleBinding && !isComponent2) {
            patchFlag |= 4;
          }
          if (dynamicPropNames.length) {
            patchFlag |= 8;
          }
          if (hasHydrationEventBinding) {
            patchFlag |= 32;
          }
        }
        if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
          patchFlag |= 512;
        }
        if (!context.inSSR && propsExpression) {
          switch (propsExpression.type) {
            case 15:
              let classKeyIndex = -1;
              let styleKeyIndex = -1;
              let hasDynamicKey = false;
              for (let i = 0; i < propsExpression.properties.length; i++) {
                const key = propsExpression.properties[i].key;
                if (isStaticExp(key)) {
                  if (key.content === "class") {
                    classKeyIndex = i;
                  } else if (key.content === "style") {
                    styleKeyIndex = i;
                  }
                } else if (!key.isHandlerKey) {
                  hasDynamicKey = true;
                }
              }
              const classProp = propsExpression.properties[classKeyIndex];
              const styleProp = propsExpression.properties[styleKeyIndex];
              if (!hasDynamicKey) {
                if (classProp && !isStaticExp(classProp.value)) {
                  classProp.value = createCallExpression(
                    context.helper(NORMALIZE_CLASS),
                    [classProp.value]
                  );
                }
                if (styleProp && // the static style is compiled into an object,
                // so use `hasStyleBinding` to ensure that it is a dynamic style binding
                (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || // v-bind:style and style both exist,
                // v-bind:style with static literal object
                styleProp.value.type === 17)) {
                  styleProp.value = createCallExpression(
                    context.helper(NORMALIZE_STYLE),
                    [styleProp.value]
                  );
                }
              } else {
                propsExpression = createCallExpression(
                  context.helper(NORMALIZE_PROPS),
                  [propsExpression]
                );
              }
              break;
            case 14:
              break;
            default:
              propsExpression = createCallExpression(
                context.helper(NORMALIZE_PROPS),
                [
                  createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
                    propsExpression
                  ])
                ]
              );
              break;
          }
        }
        return {
          props: propsExpression,
          directives: runtimeDirectives,
          patchFlag,
          dynamicPropNames,
          shouldUseBlock
        };
      }
      function dedupeProperties(properties) {
        const knownProps = /* @__PURE__ */ new Map();
        const deduped = [];
        for (let i = 0; i < properties.length; i++) {
          const prop = properties[i];
          if (prop.key.type === 8 || !prop.key.isStatic) {
            deduped.push(prop);
            continue;
          }
          const name = prop.key.content;
          const existing = knownProps.get(name);
          if (existing) {
            if (name === "style" || name === "class" || shared.isOn(name)) {
              mergeAsArray(existing, prop);
            }
          } else {
            knownProps.set(name, prop);
            deduped.push(prop);
          }
        }
        return deduped;
      }
      function mergeAsArray(existing, incoming) {
        if (existing.value.type === 17) {
          existing.value.elements.push(incoming.value);
        } else {
          existing.value = createArrayExpression(
            [existing.value, incoming.value],
            existing.loc
          );
        }
      }
      function buildDirectiveArgs(dir, context) {
        const dirArgs = [];
        const runtime = directiveImportMap.get(dir);
        if (runtime) {
          dirArgs.push(context.helperString(runtime));
        } else {
          const fromSetup = resolveSetupReference("v-" + dir.name, context);
          if (fromSetup) {
            dirArgs.push(fromSetup);
          } else {
            context.helper(RESOLVE_DIRECTIVE);
            context.directives.add(dir.name);
            dirArgs.push(toValidAssetId(dir.name, `directive`));
          }
        }
        const { loc } = dir;
        if (dir.exp)
          dirArgs.push(dir.exp);
        if (dir.arg) {
          if (!dir.exp) {
            dirArgs.push(`void 0`);
          }
          dirArgs.push(dir.arg);
        }
        if (Object.keys(dir.modifiers).length) {
          if (!dir.arg) {
            if (!dir.exp) {
              dirArgs.push(`void 0`);
            }
            dirArgs.push(`void 0`);
          }
          const trueExpression = createSimpleExpression(`true`, false, loc);
          dirArgs.push(
            createObjectExpression(
              dir.modifiers.map(
                (modifier) => createObjectProperty(modifier, trueExpression)
              ),
              loc
            )
          );
        }
        return createArrayExpression(dirArgs, dir.loc);
      }
      function stringifyDynamicPropNames(props) {
        let propsNamesString = `[`;
        for (let i = 0, l = props.length; i < l; i++) {
          propsNamesString += JSON.stringify(props[i]);
          if (i < l - 1)
            propsNamesString += ", ";
        }
        return propsNamesString + `]`;
      }
      function isComponentTag(tag) {
        return tag === "component" || tag === "Component";
      }
      var transformSlotOutlet = (node, context) => {
        if (isSlotOutlet(node)) {
          const { children, loc } = node;
          const { slotName, slotProps } = processSlotOutlet(node, context);
          const slotArgs = [
            context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
            slotName,
            "{}",
            "undefined",
            "true"
          ];
          let expectedLen = 2;
          if (slotProps) {
            slotArgs[2] = slotProps;
            expectedLen = 3;
          }
          if (children.length) {
            slotArgs[3] = createFunctionExpression([], children, false, false, loc);
            expectedLen = 4;
          }
          if (context.scopeId && !context.slotted) {
            expectedLen = 5;
          }
          slotArgs.splice(expectedLen);
          node.codegenNode = createCallExpression(
            context.helper(RENDER_SLOT),
            slotArgs,
            loc
          );
        }
      };
      function processSlotOutlet(node, context) {
        let slotName = `"default"`;
        let slotProps = void 0;
        const nonNameProps = [];
        for (let i = 0; i < node.props.length; i++) {
          const p = node.props[i];
          if (p.type === 6) {
            if (p.value) {
              if (p.name === "name") {
                slotName = JSON.stringify(p.value.content);
              } else {
                p.name = shared.camelize(p.name);
                nonNameProps.push(p);
              }
            }
          } else {
            if (p.name === "bind" && isStaticArgOf(p.arg, "name")) {
              if (p.exp)
                slotName = p.exp;
            } else {
              if (p.name === "bind" && p.arg && isStaticExp(p.arg)) {
                p.arg.content = shared.camelize(p.arg.content);
              }
              nonNameProps.push(p);
            }
          }
        }
        if (nonNameProps.length > 0) {
          const { props, directives } = buildProps(
            node,
            context,
            nonNameProps,
            false,
            false
          );
          slotProps = props;
          if (directives.length) {
            context.onError(
              createCompilerError(
                36,
                directives[0].loc
              )
            );
          }
        }
        return {
          slotName,
          slotProps
        };
      }
      var fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
      var transformOn = (dir, node, context, augmentor) => {
        const { loc, modifiers, arg } = dir;
        if (!dir.exp && !modifiers.length) {
          context.onError(createCompilerError(35, loc));
        }
        let eventName;
        if (arg.type === 4) {
          if (arg.isStatic) {
            let rawName = arg.content;
            if (rawName.startsWith("vnode")) {
              context.onWarn(
                createCompilerError(51, arg.loc)
              );
            }
            if (rawName.startsWith("vue:")) {
              rawName = `vnode-${rawName.slice(4)}`;
            }
            const eventString = node.tagType !== 0 || rawName.startsWith("vnode") || !/[A-Z]/.test(rawName) ? (
              // for non-element and vnode lifecycle event listeners, auto convert
              // it to camelCase. See issue #2249
              shared.toHandlerKey(shared.camelize(rawName))
            ) : (
              // preserve case for plain element listeners that have uppercase
              // letters, as these may be custom elements' custom events
              `on:${rawName}`
            );
            eventName = createSimpleExpression(eventString, true, arg.loc);
          } else {
            eventName = createCompoundExpression([
              `${context.helperString(TO_HANDLER_KEY)}(`,
              arg,
              `)`
            ]);
          }
        } else {
          eventName = arg;
          eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
          eventName.children.push(`)`);
        }
        let exp = dir.exp;
        if (exp && !exp.content.trim()) {
          exp = void 0;
        }
        let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
        if (exp) {
          const isMemberExp = isMemberExpression(exp.content, context);
          const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
          const hasMultipleStatements = exp.content.includes(`;`);
          if (context.prefixIdentifiers) {
            isInlineStatement && context.addIdentifiers(`$event`);
            exp = dir.exp = processExpression(
              exp,
              context,
              false,
              hasMultipleStatements
            );
            isInlineStatement && context.removeIdentifiers(`$event`);
            shouldCache = context.cacheHandlers && // unnecessary to cache inside v-once
            !context.inVOnce && // runtime constants don't need to be cached
            // (this is analyzed by compileScript in SFC <script setup>)
            !(exp.type === 4 && exp.constType > 0) && // #1541 bail if this is a member exp handler passed to a component -
            // we need to use the original function to preserve arity,
            // e.g. <transition> relies on checking cb.length to determine
            // transition end handling. Inline function is ok since its arity
            // is preserved even when cached.
            !(isMemberExp && node.tagType === 1) && // bail if the function references closure variables (v-for, v-slot)
            // it must be passed fresh to avoid stale values.
            !hasScopeRef(exp, context.identifiers);
            if (shouldCache && isMemberExp) {
              if (exp.type === 4) {
                exp.content = `${exp.content} && ${exp.content}(...args)`;
              } else {
                exp.children = [...exp.children, ` && `, ...exp.children, `(...args)`];
              }
            }
          }
          if (isInlineStatement || shouldCache && isMemberExp) {
            exp = createCompoundExpression([
              `${isInlineStatement ? context.isTS ? `($event: any)` : `$event` : `${context.isTS ? `
//@ts-ignore
` : ``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
              exp,
              hasMultipleStatements ? `}` : `)`
            ]);
          }
        }
        let ret = {
          props: [
            createObjectProperty(
              eventName,
              exp || createSimpleExpression(`() => {}`, false, loc)
            )
          ]
        };
        if (augmentor) {
          ret = augmentor(ret);
        }
        if (shouldCache) {
          ret.props[0].value = context.cache(ret.props[0].value);
        }
        ret.props.forEach((p) => p.key.isHandlerKey = true);
        return ret;
      };
      var transformBind = (dir, _node, context) => {
        const { exp, modifiers, loc } = dir;
        const arg = dir.arg;
        if (arg.type !== 4) {
          arg.children.unshift(`(`);
          arg.children.push(`) || ""`);
        } else if (!arg.isStatic) {
          arg.content = `${arg.content} || ""`;
        }
        if (modifiers.includes("camel")) {
          if (arg.type === 4) {
            if (arg.isStatic) {
              arg.content = shared.camelize(arg.content);
            } else {
              arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
            }
          } else {
            arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
            arg.children.push(`)`);
          }
        }
        if (!context.inSSR) {
          if (modifiers.includes("prop")) {
            injectPrefix(arg, ".");
          }
          if (modifiers.includes("attr")) {
            injectPrefix(arg, "^");
          }
        }
        if (!exp || exp.type === 4 && !exp.content.trim()) {
          context.onError(createCompilerError(34, loc));
          return {
            props: [createObjectProperty(arg, createSimpleExpression("", true, loc))]
          };
        }
        return {
          props: [createObjectProperty(arg, exp)]
        };
      };
      var injectPrefix = (arg, prefix) => {
        if (arg.type === 4) {
          if (arg.isStatic) {
            arg.content = prefix + arg.content;
          } else {
            arg.content = `\`${prefix}\${${arg.content}}\``;
          }
        } else {
          arg.children.unshift(`'${prefix}' + (`);
          arg.children.push(`)`);
        }
      };
      var transformText = (node, context) => {
        if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
          return () => {
            const children = node.children;
            let currentContainer = void 0;
            let hasText = false;
            for (let i = 0; i < children.length; i++) {
              const child = children[i];
              if (isText$1(child)) {
                hasText = true;
                for (let j = i + 1; j < children.length; j++) {
                  const next = children[j];
                  if (isText$1(next)) {
                    if (!currentContainer) {
                      currentContainer = children[i] = createCompoundExpression(
                        [child],
                        child.loc
                      );
                    }
                    currentContainer.children.push(` + `, next);
                    children.splice(j, 1);
                    j--;
                  } else {
                    currentContainer = void 0;
                    break;
                  }
                }
              }
            }
            if (!hasText || // if this is a plain element with a single text child, leave it
            // as-is since the runtime has dedicated fast path for this by directly
            // setting textContent of the element.
            // for component root it's always normalized anyway.
            children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && // #3756
            // custom directives can potentially add DOM elements arbitrarily,
            // we need to avoid setting textContent of the element at runtime
            // to avoid accidentally overwriting the DOM elements added
            // by the user through custom directives.
            !node.props.find(
              (p) => p.type === 7 && !context.directiveTransforms[p.name]
            ) && // in compat mode, <template> tags with no special directives
            // will be rendered as a fragment so its children must be
            // converted into vnodes.
            !(node.tag === "template"))) {
              return;
            }
            for (let i = 0; i < children.length; i++) {
              const child = children[i];
              if (isText$1(child) || child.type === 8) {
                const callArgs = [];
                if (child.type !== 2 || child.content !== " ") {
                  callArgs.push(child);
                }
                if (!context.ssr && getConstantType(child, context) === 0) {
                  callArgs.push(
                    `1 /* ${shared.PatchFlagNames[1]} */`
                  );
                }
                children[i] = {
                  type: 12,
                  content: child,
                  loc: child.loc,
                  codegenNode: createCallExpression(
                    context.helper(CREATE_TEXT),
                    callArgs
                  )
                };
              }
            }
          };
        }
      };
      var seen$1 = /* @__PURE__ */ new WeakSet();
      var transformOnce = (node, context) => {
        if (node.type === 1 && findDir(node, "once", true)) {
          if (seen$1.has(node) || context.inVOnce || context.inSSR) {
            return;
          }
          seen$1.add(node);
          context.inVOnce = true;
          context.helper(SET_BLOCK_TRACKING);
          return () => {
            context.inVOnce = false;
            const cur = context.currentNode;
            if (cur.codegenNode) {
              cur.codegenNode = context.cache(
                cur.codegenNode,
                true
                /* isVNode */
              );
            }
          };
        }
      };
      var transformModel = (dir, node, context) => {
        const { exp, arg } = dir;
        if (!exp) {
          context.onError(
            createCompilerError(41, dir.loc)
          );
          return createTransformProps();
        }
        const rawExp = exp.loc.source;
        const expString = exp.type === 4 ? exp.content : rawExp;
        const bindingType = context.bindingMetadata[rawExp];
        if (bindingType === "props" || bindingType === "props-aliased") {
          context.onError(createCompilerError(44, exp.loc));
          return createTransformProps();
        }
        const maybeRef = context.inline && (bindingType === "setup-let" || bindingType === "setup-ref" || bindingType === "setup-maybe-ref");
        if (!expString.trim() || !isMemberExpression(expString, context) && !maybeRef) {
          context.onError(
            createCompilerError(42, exp.loc)
          );
          return createTransformProps();
        }
        if (context.prefixIdentifiers && isSimpleIdentifier(expString) && context.identifiers[expString]) {
          context.onError(
            createCompilerError(43, exp.loc)
          );
          return createTransformProps();
        }
        const propName = arg ? arg : createSimpleExpression("modelValue", true);
        const eventName = arg ? isStaticExp(arg) ? `onUpdate:${shared.camelize(arg.content)}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
        let assignmentExp;
        const eventArg = context.isTS ? `($event: any)` : `$event`;
        if (maybeRef) {
          if (bindingType === "setup-ref") {
            assignmentExp = createCompoundExpression([
              `${eventArg} => ((`,
              createSimpleExpression(rawExp, false, exp.loc),
              `).value = $event)`
            ]);
          } else {
            const altAssignment = bindingType === "setup-let" ? `${rawExp} = $event` : `null`;
            assignmentExp = createCompoundExpression([
              `${eventArg} => (${context.helperString(IS_REF)}(${rawExp}) ? (`,
              createSimpleExpression(rawExp, false, exp.loc),
              `).value = $event : ${altAssignment})`
            ]);
          }
        } else {
          assignmentExp = createCompoundExpression([
            `${eventArg} => ((`,
            exp,
            `) = $event)`
          ]);
        }
        const props = [
          // modelValue: foo
          createObjectProperty(propName, dir.exp),
          // "onUpdate:modelValue": $event => (foo = $event)
          createObjectProperty(eventName, assignmentExp)
        ];
        if (context.prefixIdentifiers && !context.inVOnce && context.cacheHandlers && !hasScopeRef(exp, context.identifiers)) {
          props[1].value = context.cache(props[1].value);
        }
        if (dir.modifiers.length && node.tagType === 1) {
          const modifiers = dir.modifiers.map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
          const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
          props.push(
            createObjectProperty(
              modifiersKey,
              createSimpleExpression(
                `{ ${modifiers} }`,
                false,
                dir.loc,
                2
              )
            )
          );
        }
        return createTransformProps(props);
      };
      function createTransformProps(props = []) {
        return { props };
      }
      var validDivisionCharRE = /[\w).+\-_$\]]/;
      var transformFilter = (node, context) => {
        if (!isCompatEnabled("COMPILER_FILTER", context)) {
          return;
        }
        if (node.type === 5) {
          rewriteFilter(node.content, context);
        }
        if (node.type === 1) {
          node.props.forEach((prop) => {
            if (prop.type === 7 && prop.name !== "for" && prop.exp) {
              rewriteFilter(prop.exp, context);
            }
          });
        }
      };
      function rewriteFilter(node, context) {
        if (node.type === 4) {
          parseFilter(node, context);
        } else {
          for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            if (typeof child !== "object")
              continue;
            if (child.type === 4) {
              parseFilter(child, context);
            } else if (child.type === 8) {
              rewriteFilter(node, context);
            } else if (child.type === 5) {
              rewriteFilter(child.content, context);
            }
          }
        }
      }
      function parseFilter(node, context) {
        const exp = node.content;
        let inSingle = false;
        let inDouble = false;
        let inTemplateString = false;
        let inRegex = false;
        let curly = 0;
        let square = 0;
        let paren = 0;
        let lastFilterIndex = 0;
        let c, prev, i, expression, filters = [];
        for (i = 0; i < exp.length; i++) {
          prev = c;
          c = exp.charCodeAt(i);
          if (inSingle) {
            if (c === 39 && prev !== 92)
              inSingle = false;
          } else if (inDouble) {
            if (c === 34 && prev !== 92)
              inDouble = false;
          } else if (inTemplateString) {
            if (c === 96 && prev !== 92)
              inTemplateString = false;
          } else if (inRegex) {
            if (c === 47 && prev !== 92)
              inRegex = false;
          } else if (c === 124 && // pipe
          exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
            if (expression === void 0) {
              lastFilterIndex = i + 1;
              expression = exp.slice(0, i).trim();
            } else {
              pushFilter();
            }
          } else {
            switch (c) {
              case 34:
                inDouble = true;
                break;
              case 39:
                inSingle = true;
                break;
              case 96:
                inTemplateString = true;
                break;
              case 40:
                paren++;
                break;
              case 41:
                paren--;
                break;
              case 91:
                square++;
                break;
              case 93:
                square--;
                break;
              case 123:
                curly++;
                break;
              case 125:
                curly--;
                break;
            }
            if (c === 47) {
              let j = i - 1;
              let p;
              for (; j >= 0; j--) {
                p = exp.charAt(j);
                if (p !== " ")
                  break;
              }
              if (!p || !validDivisionCharRE.test(p)) {
                inRegex = true;
              }
            }
          }
        }
        if (expression === void 0) {
          expression = exp.slice(0, i).trim();
        } else if (lastFilterIndex !== 0) {
          pushFilter();
        }
        function pushFilter() {
          filters.push(exp.slice(lastFilterIndex, i).trim());
          lastFilterIndex = i + 1;
        }
        if (filters.length) {
          warnDeprecation(
            "COMPILER_FILTER",
            context,
            node.loc
          );
          for (i = 0; i < filters.length; i++) {
            expression = wrapFilter(expression, filters[i], context);
          }
          node.content = expression;
        }
      }
      function wrapFilter(exp, filter, context) {
        context.helper(RESOLVE_FILTER);
        const i = filter.indexOf("(");
        if (i < 0) {
          context.filters.add(filter);
          return `${toValidAssetId(filter, "filter")}(${exp})`;
        } else {
          const name = filter.slice(0, i);
          const args = filter.slice(i + 1);
          context.filters.add(name);
          return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
        }
      }
      var seen = /* @__PURE__ */ new WeakSet();
      var transformMemo = (node, context) => {
        if (node.type === 1) {
          const dir = findDir(node, "memo");
          if (!dir || seen.has(node)) {
            return;
          }
          seen.add(node);
          return () => {
            const codegenNode = node.codegenNode || context.currentNode.codegenNode;
            if (codegenNode && codegenNode.type === 13) {
              if (node.tagType !== 1) {
                convertToBlock(codegenNode, context);
              }
              node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
                dir.exp,
                createFunctionExpression(void 0, codegenNode),
                `_cache`,
                String(context.cached++)
              ]);
            }
          };
        }
      };
      function getBaseTransformPreset(prefixIdentifiers) {
        return [
          [
            transformOnce,
            transformIf,
            transformMemo,
            transformFor,
            ...[transformFilter],
            ...prefixIdentifiers ? [
              // order is important
              trackVForSlotScopes,
              transformExpression
            ] : [],
            transformSlotOutlet,
            transformElement,
            trackSlotScopes,
            transformText
          ],
          {
            on: transformOn,
            bind: transformBind,
            model: transformModel
          }
        ];
      }
      function baseCompile(template, options = {}) {
        const onError = options.onError || defaultOnError;
        const isModuleMode = options.mode === "module";
        const prefixIdentifiers = options.prefixIdentifiers === true || isModuleMode;
        if (!prefixIdentifiers && options.cacheHandlers) {
          onError(createCompilerError(49));
        }
        if (options.scopeId && !isModuleMode) {
          onError(createCompilerError(50));
        }
        const ast = shared.isString(template) ? baseParse(template, options) : template;
        const [nodeTransforms, directiveTransforms] = getBaseTransformPreset(prefixIdentifiers);
        if (options.isTS) {
          const { expressionPlugins } = options;
          if (!expressionPlugins || !expressionPlugins.includes("typescript")) {
            options.expressionPlugins = [...expressionPlugins || [], "typescript"];
          }
        }
        transform(
          ast,
          shared.extend({}, options, {
            prefixIdentifiers,
            nodeTransforms: [
              ...nodeTransforms,
              ...options.nodeTransforms || []
              // user transforms
            ],
            directiveTransforms: shared.extend(
              {},
              directiveTransforms,
              options.directiveTransforms || {}
              // user transforms
            )
          })
        );
        return generate(
          ast,
          shared.extend({}, options, {
            prefixIdentifiers
          })
        );
      }
      var noopDirectiveTransform = () => ({ props: [] });
      exports.generateCodeFrame = shared.generateCodeFrame;
      exports.BASE_TRANSITION = BASE_TRANSITION;
      exports.CAMELIZE = CAMELIZE;
      exports.CAPITALIZE = CAPITALIZE;
      exports.CREATE_BLOCK = CREATE_BLOCK;
      exports.CREATE_COMMENT = CREATE_COMMENT;
      exports.CREATE_ELEMENT_BLOCK = CREATE_ELEMENT_BLOCK;
      exports.CREATE_ELEMENT_VNODE = CREATE_ELEMENT_VNODE;
      exports.CREATE_SLOTS = CREATE_SLOTS;
      exports.CREATE_STATIC = CREATE_STATIC;
      exports.CREATE_TEXT = CREATE_TEXT;
      exports.CREATE_VNODE = CREATE_VNODE;
      exports.FRAGMENT = FRAGMENT;
      exports.GUARD_REACTIVE_PROPS = GUARD_REACTIVE_PROPS;
      exports.IS_MEMO_SAME = IS_MEMO_SAME;
      exports.IS_REF = IS_REF;
      exports.KEEP_ALIVE = KEEP_ALIVE;
      exports.MERGE_PROPS = MERGE_PROPS;
      exports.NORMALIZE_CLASS = NORMALIZE_CLASS;
      exports.NORMALIZE_PROPS = NORMALIZE_PROPS;
      exports.NORMALIZE_STYLE = NORMALIZE_STYLE;
      exports.OPEN_BLOCK = OPEN_BLOCK;
      exports.POP_SCOPE_ID = POP_SCOPE_ID;
      exports.PUSH_SCOPE_ID = PUSH_SCOPE_ID;
      exports.RENDER_LIST = RENDER_LIST;
      exports.RENDER_SLOT = RENDER_SLOT;
      exports.RESOLVE_COMPONENT = RESOLVE_COMPONENT;
      exports.RESOLVE_DIRECTIVE = RESOLVE_DIRECTIVE;
      exports.RESOLVE_DYNAMIC_COMPONENT = RESOLVE_DYNAMIC_COMPONENT;
      exports.RESOLVE_FILTER = RESOLVE_FILTER;
      exports.SET_BLOCK_TRACKING = SET_BLOCK_TRACKING;
      exports.SUSPENSE = SUSPENSE;
      exports.TELEPORT = TELEPORT;
      exports.TO_DISPLAY_STRING = TO_DISPLAY_STRING;
      exports.TO_HANDLERS = TO_HANDLERS;
      exports.TO_HANDLER_KEY = TO_HANDLER_KEY;
      exports.TS_NODE_TYPES = TS_NODE_TYPES;
      exports.UNREF = UNREF;
      exports.WITH_CTX = WITH_CTX;
      exports.WITH_DIRECTIVES = WITH_DIRECTIVES;
      exports.WITH_MEMO = WITH_MEMO;
      exports.advancePositionWithClone = advancePositionWithClone;
      exports.advancePositionWithMutation = advancePositionWithMutation;
      exports.assert = assert;
      exports.baseCompile = baseCompile;
      exports.baseParse = baseParse;
      exports.buildDirectiveArgs = buildDirectiveArgs;
      exports.buildProps = buildProps;
      exports.buildSlots = buildSlots;
      exports.checkCompatEnabled = checkCompatEnabled;
      exports.convertToBlock = convertToBlock;
      exports.createArrayExpression = createArrayExpression;
      exports.createAssignmentExpression = createAssignmentExpression;
      exports.createBlockStatement = createBlockStatement;
      exports.createCacheExpression = createCacheExpression;
      exports.createCallExpression = createCallExpression;
      exports.createCompilerError = createCompilerError;
      exports.createCompoundExpression = createCompoundExpression;
      exports.createConditionalExpression = createConditionalExpression;
      exports.createForLoopParams = createForLoopParams;
      exports.createFunctionExpression = createFunctionExpression;
      exports.createIfStatement = createIfStatement;
      exports.createInterpolation = createInterpolation;
      exports.createObjectExpression = createObjectExpression;
      exports.createObjectProperty = createObjectProperty;
      exports.createReturnStatement = createReturnStatement;
      exports.createRoot = createRoot;
      exports.createSequenceExpression = createSequenceExpression;
      exports.createSimpleExpression = createSimpleExpression;
      exports.createStructuralDirectiveTransform = createStructuralDirectiveTransform;
      exports.createTemplateLiteral = createTemplateLiteral;
      exports.createTransformContext = createTransformContext;
      exports.createVNodeCall = createVNodeCall;
      exports.extractIdentifiers = extractIdentifiers;
      exports.findDir = findDir;
      exports.findProp = findProp;
      exports.generate = generate;
      exports.getBaseTransformPreset = getBaseTransformPreset;
      exports.getConstantType = getConstantType;
      exports.getInnerRange = getInnerRange;
      exports.getMemoedVNodeCall = getMemoedVNodeCall;
      exports.getVNodeBlockHelper = getVNodeBlockHelper;
      exports.getVNodeHelper = getVNodeHelper;
      exports.hasDynamicKeyVBind = hasDynamicKeyVBind;
      exports.hasScopeRef = hasScopeRef;
      exports.helperNameMap = helperNameMap;
      exports.injectProp = injectProp;
      exports.isBuiltInType = isBuiltInType;
      exports.isCoreComponent = isCoreComponent;
      exports.isFunctionType = isFunctionType;
      exports.isInDestructureAssignment = isInDestructureAssignment;
      exports.isMemberExpression = isMemberExpression;
      exports.isMemberExpressionBrowser = isMemberExpressionBrowser;
      exports.isMemberExpressionNode = isMemberExpressionNode;
      exports.isReferencedIdentifier = isReferencedIdentifier;
      exports.isSimpleIdentifier = isSimpleIdentifier;
      exports.isSlotOutlet = isSlotOutlet;
      exports.isStaticArgOf = isStaticArgOf;
      exports.isStaticExp = isStaticExp;
      exports.isStaticProperty = isStaticProperty;
      exports.isStaticPropertyKey = isStaticPropertyKey;
      exports.isTemplateNode = isTemplateNode;
      exports.isText = isText$1;
      exports.isVSlot = isVSlot;
      exports.locStub = locStub;
      exports.noopDirectiveTransform = noopDirectiveTransform;
      exports.processExpression = processExpression;
      exports.processFor = processFor;
      exports.processIf = processIf;
      exports.processSlotOutlet = processSlotOutlet;
      exports.registerRuntimeHelpers = registerRuntimeHelpers;
      exports.resolveComponentType = resolveComponentType;
      exports.stringifyExpression = stringifyExpression;
      exports.toValidAssetId = toValidAssetId;
      exports.trackSlotScopes = trackSlotScopes;
      exports.trackVForSlotScopes = trackVForSlotScopes;
      exports.transform = transform;
      exports.transformBind = transformBind;
      exports.transformElement = transformElement;
      exports.transformExpression = transformExpression;
      exports.transformModel = transformModel;
      exports.transformOn = transformOn;
      exports.traverseNode = traverseNode;
      exports.walkBlockDeclarations = walkBlockDeclarations;
      exports.walkFunctionParams = walkFunctionParams;
      exports.walkIdentifiers = walkIdentifiers;
      exports.warnDeprecation = warnDeprecation;
    }
  });

  // node_modules/@vue/compiler-core/index.js
  var require_compiler_core = __commonJS({
    "node_modules/@vue/compiler-core/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_compiler_core_cjs();
      }
    }
  });

  // node_modules/@vue/compiler-dom/dist/compiler-dom.cjs.js
  var require_compiler_dom_cjs = __commonJS({
    "node_modules/@vue/compiler-dom/dist/compiler-dom.cjs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var compilerCore = require_compiler_core();
      var shared = require_shared();
      var V_MODEL_RADIO = Symbol(`vModelRadio`);
      var V_MODEL_CHECKBOX = Symbol(`vModelCheckbox`);
      var V_MODEL_TEXT = Symbol(`vModelText`);
      var V_MODEL_SELECT = Symbol(`vModelSelect`);
      var V_MODEL_DYNAMIC = Symbol(`vModelDynamic`);
      var V_ON_WITH_MODIFIERS = Symbol(`vOnModifiersGuard`);
      var V_ON_WITH_KEYS = Symbol(`vOnKeysGuard`);
      var V_SHOW = Symbol(`vShow`);
      var TRANSITION = Symbol(`Transition`);
      var TRANSITION_GROUP = Symbol(`TransitionGroup`);
      compilerCore.registerRuntimeHelpers({
        [V_MODEL_RADIO]: `vModelRadio`,
        [V_MODEL_CHECKBOX]: `vModelCheckbox`,
        [V_MODEL_TEXT]: `vModelText`,
        [V_MODEL_SELECT]: `vModelSelect`,
        [V_MODEL_DYNAMIC]: `vModelDynamic`,
        [V_ON_WITH_MODIFIERS]: `withModifiers`,
        [V_ON_WITH_KEYS]: `withKeys`,
        [V_SHOW]: `vShow`,
        [TRANSITION]: `Transition`,
        [TRANSITION_GROUP]: `TransitionGroup`
      });
      var namedCharacterReferences = {
        GT: ">",
        gt: ">",
        LT: "<",
        lt: "<",
        "ac;": "\u223E",
        "af;": "\u2061",
        AMP: "&",
        amp: "&",
        "ap;": "\u2248",
        "DD;": "\u2145",
        "dd;": "\u2146",
        deg: "\xB0",
        "ee;": "\u2147",
        "eg;": "\u2A9A",
        "el;": "\u2A99",
        ETH: "\xD0",
        eth: "\xF0",
        "gE;": "\u2267",
        "ge;": "\u2265",
        "Gg;": "\u22D9",
        "gg;": "\u226B",
        "gl;": "\u2277",
        "GT;": ">",
        "Gt;": "\u226B",
        "gt;": ">",
        "ic;": "\u2063",
        "ii;": "\u2148",
        "Im;": "\u2111",
        "in;": "\u2208",
        "it;": "\u2062",
        "lE;": "\u2266",
        "le;": "\u2264",
        "lg;": "\u2276",
        "Ll;": "\u22D8",
        "ll;": "\u226A",
        "LT;": "<",
        "Lt;": "\u226A",
        "lt;": "<",
        "mp;": "\u2213",
        "Mu;": "\u039C",
        "mu;": "\u03BC",
        "ne;": "\u2260",
        "ni;": "\u220B",
        not: "\xAC",
        "Nu;": "\u039D",
        "nu;": "\u03BD",
        "Or;": "\u2A54",
        "or;": "\u2228",
        "oS;": "\u24C8",
        "Pi;": "\u03A0",
        "pi;": "\u03C0",
        "pm;": "\xB1",
        "Pr;": "\u2ABB",
        "pr;": "\u227A",
        "Re;": "\u211C",
        REG: "\xAE",
        reg: "\xAE",
        "rx;": "\u211E",
        "Sc;": "\u2ABC",
        "sc;": "\u227B",
        shy: "\xAD",
        uml: "\xA8",
        "wp;": "\u2118",
        "wr;": "\u2240",
        "Xi;": "\u039E",
        "xi;": "\u03BE",
        yen: "\xA5",
        "acd;": "\u223F",
        "acE;": "\u223E\u0333",
        "Acy;": "\u0410",
        "acy;": "\u0430",
        "Afr;": "\u{1D504}",
        "afr;": "\u{1D51E}",
        "AMP;": "&",
        "amp;": "&",
        "And;": "\u2A53",
        "and;": "\u2227",
        "ang;": "\u2220",
        "apE;": "\u2A70",
        "ape;": "\u224A",
        "ast;": "*",
        Auml: "\xC4",
        auml: "\xE4",
        "Bcy;": "\u0411",
        "bcy;": "\u0431",
        "Bfr;": "\u{1D505}",
        "bfr;": "\u{1D51F}",
        "bne;": "=\u20E5",
        "bot;": "\u22A5",
        "Cap;": "\u22D2",
        "cap;": "\u2229",
        cent: "\xA2",
        "Cfr;": "\u212D",
        "cfr;": "\u{1D520}",
        "Chi;": "\u03A7",
        "chi;": "\u03C7",
        "cir;": "\u25CB",
        COPY: "\xA9",
        copy: "\xA9",
        "Cup;": "\u22D3",
        "cup;": "\u222A",
        "Dcy;": "\u0414",
        "dcy;": "\u0434",
        "deg;": "\xB0",
        "Del;": "\u2207",
        "Dfr;": "\u{1D507}",
        "dfr;": "\u{1D521}",
        "die;": "\xA8",
        "div;": "\xF7",
        "Dot;": "\xA8",
        "dot;": "\u02D9",
        "Ecy;": "\u042D",
        "ecy;": "\u044D",
        "Efr;": "\u{1D508}",
        "efr;": "\u{1D522}",
        "egs;": "\u2A96",
        "ell;": "\u2113",
        "els;": "\u2A95",
        "ENG;": "\u014A",
        "eng;": "\u014B",
        "Eta;": "\u0397",
        "eta;": "\u03B7",
        "ETH;": "\xD0",
        "eth;": "\xF0",
        Euml: "\xCB",
        euml: "\xEB",
        "Fcy;": "\u0424",
        "fcy;": "\u0444",
        "Ffr;": "\u{1D509}",
        "ffr;": "\u{1D523}",
        "gap;": "\u2A86",
        "Gcy;": "\u0413",
        "gcy;": "\u0433",
        "gEl;": "\u2A8C",
        "gel;": "\u22DB",
        "geq;": "\u2265",
        "ges;": "\u2A7E",
        "Gfr;": "\u{1D50A}",
        "gfr;": "\u{1D524}",
        "ggg;": "\u22D9",
        "gla;": "\u2AA5",
        "glE;": "\u2A92",
        "glj;": "\u2AA4",
        "gnE;": "\u2269",
        "gne;": "\u2A88",
        "Hat;": "^",
        "Hfr;": "\u210C",
        "hfr;": "\u{1D525}",
        "Icy;": "\u0418",
        "icy;": "\u0438",
        "iff;": "\u21D4",
        "Ifr;": "\u2111",
        "ifr;": "\u{1D526}",
        "Int;": "\u222C",
        "int;": "\u222B",
        Iuml: "\xCF",
        iuml: "\xEF",
        "Jcy;": "\u0419",
        "jcy;": "\u0439",
        "Jfr;": "\u{1D50D}",
        "jfr;": "\u{1D527}",
        "Kcy;": "\u041A",
        "kcy;": "\u043A",
        "Kfr;": "\u{1D50E}",
        "kfr;": "\u{1D528}",
        "lap;": "\u2A85",
        "lat;": "\u2AAB",
        "Lcy;": "\u041B",
        "lcy;": "\u043B",
        "lEg;": "\u2A8B",
        "leg;": "\u22DA",
        "leq;": "\u2264",
        "les;": "\u2A7D",
        "Lfr;": "\u{1D50F}",
        "lfr;": "\u{1D529}",
        "lgE;": "\u2A91",
        "lnE;": "\u2268",
        "lne;": "\u2A87",
        "loz;": "\u25CA",
        "lrm;": "\u200E",
        "Lsh;": "\u21B0",
        "lsh;": "\u21B0",
        macr: "\xAF",
        "Map;": "\u2905",
        "map;": "\u21A6",
        "Mcy;": "\u041C",
        "mcy;": "\u043C",
        "Mfr;": "\u{1D510}",
        "mfr;": "\u{1D52A}",
        "mho;": "\u2127",
        "mid;": "\u2223",
        "nap;": "\u2249",
        nbsp: "\xA0",
        "Ncy;": "\u041D",
        "ncy;": "\u043D",
        "Nfr;": "\u{1D511}",
        "nfr;": "\u{1D52B}",
        "ngE;": "\u2267\u0338",
        "nge;": "\u2271",
        "nGg;": "\u22D9\u0338",
        "nGt;": "\u226B\u20D2",
        "ngt;": "\u226F",
        "nis;": "\u22FC",
        "niv;": "\u220B",
        "nlE;": "\u2266\u0338",
        "nle;": "\u2270",
        "nLl;": "\u22D8\u0338",
        "nLt;": "\u226A\u20D2",
        "nlt;": "\u226E",
        "Not;": "\u2AEC",
        "not;": "\xAC",
        "npr;": "\u2280",
        "nsc;": "\u2281",
        "num;": "#",
        "Ocy;": "\u041E",
        "ocy;": "\u043E",
        "Ofr;": "\u{1D512}",
        "ofr;": "\u{1D52C}",
        "ogt;": "\u29C1",
        "ohm;": "\u03A9",
        "olt;": "\u29C0",
        "ord;": "\u2A5D",
        ordf: "\xAA",
        ordm: "\xBA",
        "orv;": "\u2A5B",
        Ouml: "\xD6",
        ouml: "\xF6",
        "par;": "\u2225",
        para: "\xB6",
        "Pcy;": "\u041F",
        "pcy;": "\u043F",
        "Pfr;": "\u{1D513}",
        "pfr;": "\u{1D52D}",
        "Phi;": "\u03A6",
        "phi;": "\u03C6",
        "piv;": "\u03D6",
        "prE;": "\u2AB3",
        "pre;": "\u2AAF",
        "Psi;": "\u03A8",
        "psi;": "\u03C8",
        "Qfr;": "\u{1D514}",
        "qfr;": "\u{1D52E}",
        QUOT: '"',
        quot: '"',
        "Rcy;": "\u0420",
        "rcy;": "\u0440",
        "REG;": "\xAE",
        "reg;": "\xAE",
        "Rfr;": "\u211C",
        "rfr;": "\u{1D52F}",
        "Rho;": "\u03A1",
        "rho;": "\u03C1",
        "rlm;": "\u200F",
        "Rsh;": "\u21B1",
        "rsh;": "\u21B1",
        "scE;": "\u2AB4",
        "sce;": "\u2AB0",
        "Scy;": "\u0421",
        "scy;": "\u0441",
        sect: "\xA7",
        "Sfr;": "\u{1D516}",
        "sfr;": "\u{1D530}",
        "shy;": "\xAD",
        "sim;": "\u223C",
        "smt;": "\u2AAA",
        "sol;": "/",
        "squ;": "\u25A1",
        "Sub;": "\u22D0",
        "sub;": "\u2282",
        "Sum;": "\u2211",
        "sum;": "\u2211",
        "Sup;": "\u22D1",
        "sup;": "\u2283",
        sup1: "\xB9",
        sup2: "\xB2",
        sup3: "\xB3",
        "Tab;": "	",
        "Tau;": "\u03A4",
        "tau;": "\u03C4",
        "Tcy;": "\u0422",
        "tcy;": "\u0442",
        "Tfr;": "\u{1D517}",
        "tfr;": "\u{1D531}",
        "top;": "\u22A4",
        "Ucy;": "\u0423",
        "ucy;": "\u0443",
        "Ufr;": "\u{1D518}",
        "ufr;": "\u{1D532}",
        "uml;": "\xA8",
        Uuml: "\xDC",
        uuml: "\xFC",
        "Vcy;": "\u0412",
        "vcy;": "\u0432",
        "Vee;": "\u22C1",
        "vee;": "\u2228",
        "Vfr;": "\u{1D519}",
        "vfr;": "\u{1D533}",
        "Wfr;": "\u{1D51A}",
        "wfr;": "\u{1D534}",
        "Xfr;": "\u{1D51B}",
        "xfr;": "\u{1D535}",
        "Ycy;": "\u042B",
        "ycy;": "\u044B",
        "yen;": "\xA5",
        "Yfr;": "\u{1D51C}",
        "yfr;": "\u{1D536}",
        yuml: "\xFF",
        "Zcy;": "\u0417",
        "zcy;": "\u0437",
        "Zfr;": "\u2128",
        "zfr;": "\u{1D537}",
        "zwj;": "\u200D",
        Acirc: "\xC2",
        acirc: "\xE2",
        acute: "\xB4",
        AElig: "\xC6",
        aelig: "\xE6",
        "andd;": "\u2A5C",
        "andv;": "\u2A5A",
        "ange;": "\u29A4",
        "Aopf;": "\u{1D538}",
        "aopf;": "\u{1D552}",
        "apid;": "\u224B",
        "apos;": "'",
        Aring: "\xC5",
        aring: "\xE5",
        "Ascr;": "\u{1D49C}",
        "ascr;": "\u{1D4B6}",
        "Auml;": "\xC4",
        "auml;": "\xE4",
        "Barv;": "\u2AE7",
        "bbrk;": "\u23B5",
        "Beta;": "\u0392",
        "beta;": "\u03B2",
        "beth;": "\u2136",
        "bNot;": "\u2AED",
        "bnot;": "\u2310",
        "Bopf;": "\u{1D539}",
        "bopf;": "\u{1D553}",
        "boxH;": "\u2550",
        "boxh;": "\u2500",
        "boxV;": "\u2551",
        "boxv;": "\u2502",
        "Bscr;": "\u212C",
        "bscr;": "\u{1D4B7}",
        "bsim;": "\u223D",
        "bsol;": "\\",
        "bull;": "\u2022",
        "bump;": "\u224E",
        "caps;": "\u2229\uFE00",
        "Cdot;": "\u010A",
        "cdot;": "\u010B",
        cedil: "\xB8",
        "cent;": "\xA2",
        "CHcy;": "\u0427",
        "chcy;": "\u0447",
        "circ;": "\u02C6",
        "cirE;": "\u29C3",
        "cire;": "\u2257",
        "comp;": "\u2201",
        "cong;": "\u2245",
        "Copf;": "\u2102",
        "copf;": "\u{1D554}",
        "COPY;": "\xA9",
        "copy;": "\xA9",
        "Cscr;": "\u{1D49E}",
        "cscr;": "\u{1D4B8}",
        "csub;": "\u2ACF",
        "csup;": "\u2AD0",
        "cups;": "\u222A\uFE00",
        "Darr;": "\u21A1",
        "dArr;": "\u21D3",
        "darr;": "\u2193",
        "dash;": "\u2010",
        "dHar;": "\u2965",
        "diam;": "\u22C4",
        "DJcy;": "\u0402",
        "djcy;": "\u0452",
        "Dopf;": "\u{1D53B}",
        "dopf;": "\u{1D555}",
        "Dscr;": "\u{1D49F}",
        "dscr;": "\u{1D4B9}",
        "DScy;": "\u0405",
        "dscy;": "\u0455",
        "dsol;": "\u29F6",
        "dtri;": "\u25BF",
        "DZcy;": "\u040F",
        "dzcy;": "\u045F",
        "ecir;": "\u2256",
        Ecirc: "\xCA",
        ecirc: "\xEA",
        "Edot;": "\u0116",
        "eDot;": "\u2251",
        "edot;": "\u0117",
        "emsp;": "\u2003",
        "ensp;": "\u2002",
        "Eopf;": "\u{1D53C}",
        "eopf;": "\u{1D556}",
        "epar;": "\u22D5",
        "epsi;": "\u03B5",
        "Escr;": "\u2130",
        "escr;": "\u212F",
        "Esim;": "\u2A73",
        "esim;": "\u2242",
        "Euml;": "\xCB",
        "euml;": "\xEB",
        "euro;": "\u20AC",
        "excl;": "!",
        "flat;": "\u266D",
        "fnof;": "\u0192",
        "Fopf;": "\u{1D53D}",
        "fopf;": "\u{1D557}",
        "fork;": "\u22D4",
        "Fscr;": "\u2131",
        "fscr;": "\u{1D4BB}",
        "Gdot;": "\u0120",
        "gdot;": "\u0121",
        "geqq;": "\u2267",
        "gesl;": "\u22DB\uFE00",
        "GJcy;": "\u0403",
        "gjcy;": "\u0453",
        "gnap;": "\u2A8A",
        "gneq;": "\u2A88",
        "Gopf;": "\u{1D53E}",
        "gopf;": "\u{1D558}",
        "Gscr;": "\u{1D4A2}",
        "gscr;": "\u210A",
        "gsim;": "\u2273",
        "gtcc;": "\u2AA7",
        "gvnE;": "\u2269\uFE00",
        "half;": "\xBD",
        "hArr;": "\u21D4",
        "harr;": "\u2194",
        "hbar;": "\u210F",
        "Hopf;": "\u210D",
        "hopf;": "\u{1D559}",
        "Hscr;": "\u210B",
        "hscr;": "\u{1D4BD}",
        Icirc: "\xCE",
        icirc: "\xEE",
        "Idot;": "\u0130",
        "IEcy;": "\u0415",
        "iecy;": "\u0435",
        iexcl: "\xA1",
        "imof;": "\u22B7",
        "IOcy;": "\u0401",
        "iocy;": "\u0451",
        "Iopf;": "\u{1D540}",
        "iopf;": "\u{1D55A}",
        "Iota;": "\u0399",
        "iota;": "\u03B9",
        "Iscr;": "\u2110",
        "iscr;": "\u{1D4BE}",
        "isin;": "\u2208",
        "Iuml;": "\xCF",
        "iuml;": "\xEF",
        "Jopf;": "\u{1D541}",
        "jopf;": "\u{1D55B}",
        "Jscr;": "\u{1D4A5}",
        "jscr;": "\u{1D4BF}",
        "KHcy;": "\u0425",
        "khcy;": "\u0445",
        "KJcy;": "\u040C",
        "kjcy;": "\u045C",
        "Kopf;": "\u{1D542}",
        "kopf;": "\u{1D55C}",
        "Kscr;": "\u{1D4A6}",
        "kscr;": "\u{1D4C0}",
        "Lang;": "\u27EA",
        "lang;": "\u27E8",
        laquo: "\xAB",
        "Larr;": "\u219E",
        "lArr;": "\u21D0",
        "larr;": "\u2190",
        "late;": "\u2AAD",
        "lcub;": "{",
        "ldca;": "\u2936",
        "ldsh;": "\u21B2",
        "leqq;": "\u2266",
        "lesg;": "\u22DA\uFE00",
        "lHar;": "\u2962",
        "LJcy;": "\u0409",
        "ljcy;": "\u0459",
        "lnap;": "\u2A89",
        "lneq;": "\u2A87",
        "Lopf;": "\u{1D543}",
        "lopf;": "\u{1D55D}",
        "lozf;": "\u29EB",
        "lpar;": "(",
        "Lscr;": "\u2112",
        "lscr;": "\u{1D4C1}",
        "lsim;": "\u2272",
        "lsqb;": "[",
        "ltcc;": "\u2AA6",
        "ltri;": "\u25C3",
        "lvnE;": "\u2268\uFE00",
        "macr;": "\xAF",
        "male;": "\u2642",
        "malt;": "\u2720",
        micro: "\xB5",
        "mlcp;": "\u2ADB",
        "mldr;": "\u2026",
        "Mopf;": "\u{1D544}",
        "mopf;": "\u{1D55E}",
        "Mscr;": "\u2133",
        "mscr;": "\u{1D4C2}",
        "nang;": "\u2220\u20D2",
        "napE;": "\u2A70\u0338",
        "nbsp;": "\xA0",
        "ncap;": "\u2A43",
        "ncup;": "\u2A42",
        "ngeq;": "\u2271",
        "nges;": "\u2A7E\u0338",
        "ngtr;": "\u226F",
        "nGtv;": "\u226B\u0338",
        "nisd;": "\u22FA",
        "NJcy;": "\u040A",
        "njcy;": "\u045A",
        "nldr;": "\u2025",
        "nleq;": "\u2270",
        "nles;": "\u2A7D\u0338",
        "nLtv;": "\u226A\u0338",
        "nmid;": "\u2224",
        "Nopf;": "\u2115",
        "nopf;": "\u{1D55F}",
        "npar;": "\u2226",
        "npre;": "\u2AAF\u0338",
        "nsce;": "\u2AB0\u0338",
        "Nscr;": "\u{1D4A9}",
        "nscr;": "\u{1D4C3}",
        "nsim;": "\u2241",
        "nsub;": "\u2284",
        "nsup;": "\u2285",
        "ntgl;": "\u2279",
        "ntlg;": "\u2278",
        "nvap;": "\u224D\u20D2",
        "nvge;": "\u2265\u20D2",
        "nvgt;": ">\u20D2",
        "nvle;": "\u2264\u20D2",
        "nvlt;": "<\u20D2",
        "oast;": "\u229B",
        "ocir;": "\u229A",
        Ocirc: "\xD4",
        ocirc: "\xF4",
        "odiv;": "\u2A38",
        "odot;": "\u2299",
        "ogon;": "\u02DB",
        "oint;": "\u222E",
        "omid;": "\u29B6",
        "Oopf;": "\u{1D546}",
        "oopf;": "\u{1D560}",
        "opar;": "\u29B7",
        "ordf;": "\xAA",
        "ordm;": "\xBA",
        "oror;": "\u2A56",
        "Oscr;": "\u{1D4AA}",
        "oscr;": "\u2134",
        "osol;": "\u2298",
        "Ouml;": "\xD6",
        "ouml;": "\xF6",
        "para;": "\xB6",
        "part;": "\u2202",
        "perp;": "\u22A5",
        "phiv;": "\u03D5",
        "plus;": "+",
        "Popf;": "\u2119",
        "popf;": "\u{1D561}",
        pound: "\xA3",
        "prap;": "\u2AB7",
        "prec;": "\u227A",
        "prnE;": "\u2AB5",
        "prod;": "\u220F",
        "prop;": "\u221D",
        "Pscr;": "\u{1D4AB}",
        "pscr;": "\u{1D4C5}",
        "qint;": "\u2A0C",
        "Qopf;": "\u211A",
        "qopf;": "\u{1D562}",
        "Qscr;": "\u{1D4AC}",
        "qscr;": "\u{1D4C6}",
        "QUOT;": '"',
        "quot;": '"',
        "race;": "\u223D\u0331",
        "Rang;": "\u27EB",
        "rang;": "\u27E9",
        raquo: "\xBB",
        "Rarr;": "\u21A0",
        "rArr;": "\u21D2",
        "rarr;": "\u2192",
        "rcub;": "}",
        "rdca;": "\u2937",
        "rdsh;": "\u21B3",
        "real;": "\u211C",
        "rect;": "\u25AD",
        "rHar;": "\u2964",
        "rhov;": "\u03F1",
        "ring;": "\u02DA",
        "Ropf;": "\u211D",
        "ropf;": "\u{1D563}",
        "rpar;": ")",
        "Rscr;": "\u211B",
        "rscr;": "\u{1D4C7}",
        "rsqb;": "]",
        "rtri;": "\u25B9",
        "scap;": "\u2AB8",
        "scnE;": "\u2AB6",
        "sdot;": "\u22C5",
        "sect;": "\xA7",
        "semi;": ";",
        "sext;": "\u2736",
        "SHcy;": "\u0428",
        "shcy;": "\u0448",
        "sime;": "\u2243",
        "simg;": "\u2A9E",
        "siml;": "\u2A9D",
        "smid;": "\u2223",
        "smte;": "\u2AAC",
        "solb;": "\u29C4",
        "Sopf;": "\u{1D54A}",
        "sopf;": "\u{1D564}",
        "spar;": "\u2225",
        "Sqrt;": "\u221A",
        "squf;": "\u25AA",
        "Sscr;": "\u{1D4AE}",
        "sscr;": "\u{1D4C8}",
        "Star;": "\u22C6",
        "star;": "\u2606",
        "subE;": "\u2AC5",
        "sube;": "\u2286",
        "succ;": "\u227B",
        "sung;": "\u266A",
        "sup1;": "\xB9",
        "sup2;": "\xB2",
        "sup3;": "\xB3",
        "supE;": "\u2AC6",
        "supe;": "\u2287",
        szlig: "\xDF",
        "tbrk;": "\u23B4",
        "tdot;": "\u20DB",
        THORN: "\xDE",
        thorn: "\xFE",
        times: "\xD7",
        "tint;": "\u222D",
        "toea;": "\u2928",
        "Topf;": "\u{1D54B}",
        "topf;": "\u{1D565}",
        "tosa;": "\u2929",
        "trie;": "\u225C",
        "Tscr;": "\u{1D4AF}",
        "tscr;": "\u{1D4C9}",
        "TScy;": "\u0426",
        "tscy;": "\u0446",
        "Uarr;": "\u219F",
        "uArr;": "\u21D1",
        "uarr;": "\u2191",
        Ucirc: "\xDB",
        ucirc: "\xFB",
        "uHar;": "\u2963",
        "Uopf;": "\u{1D54C}",
        "uopf;": "\u{1D566}",
        "Upsi;": "\u03D2",
        "upsi;": "\u03C5",
        "Uscr;": "\u{1D4B0}",
        "uscr;": "\u{1D4CA}",
        "utri;": "\u25B5",
        "Uuml;": "\xDC",
        "uuml;": "\xFC",
        "vArr;": "\u21D5",
        "varr;": "\u2195",
        "Vbar;": "\u2AEB",
        "vBar;": "\u2AE8",
        "Vert;": "\u2016",
        "vert;": "|",
        "Vopf;": "\u{1D54D}",
        "vopf;": "\u{1D567}",
        "Vscr;": "\u{1D4B1}",
        "vscr;": "\u{1D4CB}",
        "Wopf;": "\u{1D54E}",
        "wopf;": "\u{1D568}",
        "Wscr;": "\u{1D4B2}",
        "wscr;": "\u{1D4CC}",
        "xcap;": "\u22C2",
        "xcup;": "\u22C3",
        "xmap;": "\u27FC",
        "xnis;": "\u22FB",
        "Xopf;": "\u{1D54F}",
        "xopf;": "\u{1D569}",
        "Xscr;": "\u{1D4B3}",
        "xscr;": "\u{1D4CD}",
        "xvee;": "\u22C1",
        "YAcy;": "\u042F",
        "yacy;": "\u044F",
        "YIcy;": "\u0407",
        "yicy;": "\u0457",
        "Yopf;": "\u{1D550}",
        "yopf;": "\u{1D56A}",
        "Yscr;": "\u{1D4B4}",
        "yscr;": "\u{1D4CE}",
        "YUcy;": "\u042E",
        "yucy;": "\u044E",
        "Yuml;": "\u0178",
        "yuml;": "\xFF",
        "Zdot;": "\u017B",
        "zdot;": "\u017C",
        "Zeta;": "\u0396",
        "zeta;": "\u03B6",
        "ZHcy;": "\u0416",
        "zhcy;": "\u0436",
        "Zopf;": "\u2124",
        "zopf;": "\u{1D56B}",
        "Zscr;": "\u{1D4B5}",
        "zscr;": "\u{1D4CF}",
        "zwnj;": "\u200C",
        Aacute: "\xC1",
        aacute: "\xE1",
        "Acirc;": "\xC2",
        "acirc;": "\xE2",
        "acute;": "\xB4",
        "AElig;": "\xC6",
        "aelig;": "\xE6",
        Agrave: "\xC0",
        agrave: "\xE0",
        "aleph;": "\u2135",
        "Alpha;": "\u0391",
        "alpha;": "\u03B1",
        "Amacr;": "\u0100",
        "amacr;": "\u0101",
        "amalg;": "\u2A3F",
        "angle;": "\u2220",
        "angrt;": "\u221F",
        "angst;": "\xC5",
        "Aogon;": "\u0104",
        "aogon;": "\u0105",
        "Aring;": "\xC5",
        "aring;": "\xE5",
        "asymp;": "\u2248",
        Atilde: "\xC3",
        atilde: "\xE3",
        "awint;": "\u2A11",
        "bcong;": "\u224C",
        "bdquo;": "\u201E",
        "bepsi;": "\u03F6",
        "blank;": "\u2423",
        "blk12;": "\u2592",
        "blk14;": "\u2591",
        "blk34;": "\u2593",
        "block;": "\u2588",
        "boxDL;": "\u2557",
        "boxDl;": "\u2556",
        "boxdL;": "\u2555",
        "boxdl;": "\u2510",
        "boxDR;": "\u2554",
        "boxDr;": "\u2553",
        "boxdR;": "\u2552",
        "boxdr;": "\u250C",
        "boxHD;": "\u2566",
        "boxHd;": "\u2564",
        "boxhD;": "\u2565",
        "boxhd;": "\u252C",
        "boxHU;": "\u2569",
        "boxHu;": "\u2567",
        "boxhU;": "\u2568",
        "boxhu;": "\u2534",
        "boxUL;": "\u255D",
        "boxUl;": "\u255C",
        "boxuL;": "\u255B",
        "boxul;": "\u2518",
        "boxUR;": "\u255A",
        "boxUr;": "\u2559",
        "boxuR;": "\u2558",
        "boxur;": "\u2514",
        "boxVH;": "\u256C",
        "boxVh;": "\u256B",
        "boxvH;": "\u256A",
        "boxvh;": "\u253C",
        "boxVL;": "\u2563",
        "boxVl;": "\u2562",
        "boxvL;": "\u2561",
        "boxvl;": "\u2524",
        "boxVR;": "\u2560",
        "boxVr;": "\u255F",
        "boxvR;": "\u255E",
        "boxvr;": "\u251C",
        "Breve;": "\u02D8",
        "breve;": "\u02D8",
        brvbar: "\xA6",
        "bsemi;": "\u204F",
        "bsime;": "\u22CD",
        "bsolb;": "\u29C5",
        "bumpE;": "\u2AAE",
        "bumpe;": "\u224F",
        "caret;": "\u2041",
        "caron;": "\u02C7",
        "ccaps;": "\u2A4D",
        Ccedil: "\xC7",
        ccedil: "\xE7",
        "Ccirc;": "\u0108",
        "ccirc;": "\u0109",
        "ccups;": "\u2A4C",
        "cedil;": "\xB8",
        "check;": "\u2713",
        "clubs;": "\u2663",
        "Colon;": "\u2237",
        "colon;": ":",
        "comma;": ",",
        "crarr;": "\u21B5",
        "Cross;": "\u2A2F",
        "cross;": "\u2717",
        "csube;": "\u2AD1",
        "csupe;": "\u2AD2",
        "ctdot;": "\u22EF",
        "cuepr;": "\u22DE",
        "cuesc;": "\u22DF",
        "cupor;": "\u2A45",
        curren: "\xA4",
        "cuvee;": "\u22CE",
        "cuwed;": "\u22CF",
        "cwint;": "\u2231",
        "Dashv;": "\u2AE4",
        "dashv;": "\u22A3",
        "dblac;": "\u02DD",
        "ddarr;": "\u21CA",
        "Delta;": "\u0394",
        "delta;": "\u03B4",
        "dharl;": "\u21C3",
        "dharr;": "\u21C2",
        "diams;": "\u2666",
        "disin;": "\u22F2",
        divide: "\xF7",
        "doteq;": "\u2250",
        "dtdot;": "\u22F1",
        "dtrif;": "\u25BE",
        "duarr;": "\u21F5",
        "duhar;": "\u296F",
        Eacute: "\xC9",
        eacute: "\xE9",
        "Ecirc;": "\xCA",
        "ecirc;": "\xEA",
        "eDDot;": "\u2A77",
        "efDot;": "\u2252",
        Egrave: "\xC8",
        egrave: "\xE8",
        "Emacr;": "\u0112",
        "emacr;": "\u0113",
        "empty;": "\u2205",
        "Eogon;": "\u0118",
        "eogon;": "\u0119",
        "eplus;": "\u2A71",
        "epsiv;": "\u03F5",
        "eqsim;": "\u2242",
        "Equal;": "\u2A75",
        "equiv;": "\u2261",
        "erarr;": "\u2971",
        "erDot;": "\u2253",
        "esdot;": "\u2250",
        "exist;": "\u2203",
        "fflig;": "\uFB00",
        "filig;": "\uFB01",
        "fjlig;": "fj",
        "fllig;": "\uFB02",
        "fltns;": "\u25B1",
        "forkv;": "\u2AD9",
        frac12: "\xBD",
        frac14: "\xBC",
        frac34: "\xBE",
        "frasl;": "\u2044",
        "frown;": "\u2322",
        "Gamma;": "\u0393",
        "gamma;": "\u03B3",
        "Gcirc;": "\u011C",
        "gcirc;": "\u011D",
        "gescc;": "\u2AA9",
        "gimel;": "\u2137",
        "gneqq;": "\u2269",
        "gnsim;": "\u22E7",
        "grave;": "`",
        "gsime;": "\u2A8E",
        "gsiml;": "\u2A90",
        "gtcir;": "\u2A7A",
        "gtdot;": "\u22D7",
        "Hacek;": "\u02C7",
        "harrw;": "\u21AD",
        "Hcirc;": "\u0124",
        "hcirc;": "\u0125",
        "hoarr;": "\u21FF",
        Iacute: "\xCD",
        iacute: "\xED",
        "Icirc;": "\xCE",
        "icirc;": "\xEE",
        "iexcl;": "\xA1",
        Igrave: "\xCC",
        igrave: "\xEC",
        "iiint;": "\u222D",
        "iiota;": "\u2129",
        "IJlig;": "\u0132",
        "ijlig;": "\u0133",
        "Imacr;": "\u012A",
        "imacr;": "\u012B",
        "image;": "\u2111",
        "imath;": "\u0131",
        "imped;": "\u01B5",
        "infin;": "\u221E",
        "Iogon;": "\u012E",
        "iogon;": "\u012F",
        "iprod;": "\u2A3C",
        iquest: "\xBF",
        "isinE;": "\u22F9",
        "isins;": "\u22F4",
        "isinv;": "\u2208",
        "Iukcy;": "\u0406",
        "iukcy;": "\u0456",
        "Jcirc;": "\u0134",
        "jcirc;": "\u0135",
        "jmath;": "\u0237",
        "Jukcy;": "\u0404",
        "jukcy;": "\u0454",
        "Kappa;": "\u039A",
        "kappa;": "\u03BA",
        "lAarr;": "\u21DA",
        "langd;": "\u2991",
        "laquo;": "\xAB",
        "larrb;": "\u21E4",
        "lates;": "\u2AAD\uFE00",
        "lBarr;": "\u290E",
        "lbarr;": "\u290C",
        "lbbrk;": "\u2772",
        "lbrke;": "\u298B",
        "lceil;": "\u2308",
        "ldquo;": "\u201C",
        "lescc;": "\u2AA8",
        "lhard;": "\u21BD",
        "lharu;": "\u21BC",
        "lhblk;": "\u2584",
        "llarr;": "\u21C7",
        "lltri;": "\u25FA",
        "lneqq;": "\u2268",
        "lnsim;": "\u22E6",
        "loang;": "\u27EC",
        "loarr;": "\u21FD",
        "lobrk;": "\u27E6",
        "lopar;": "\u2985",
        "lrarr;": "\u21C6",
        "lrhar;": "\u21CB",
        "lrtri;": "\u22BF",
        "lsime;": "\u2A8D",
        "lsimg;": "\u2A8F",
        "lsquo;": "\u2018",
        "ltcir;": "\u2A79",
        "ltdot;": "\u22D6",
        "ltrie;": "\u22B4",
        "ltrif;": "\u25C2",
        "mdash;": "\u2014",
        "mDDot;": "\u223A",
        "micro;": "\xB5",
        middot: "\xB7",
        "minus;": "\u2212",
        "mumap;": "\u22B8",
        "nabla;": "\u2207",
        "napid;": "\u224B\u0338",
        "napos;": "\u0149",
        "natur;": "\u266E",
        "nbump;": "\u224E\u0338",
        "ncong;": "\u2247",
        "ndash;": "\u2013",
        "neArr;": "\u21D7",
        "nearr;": "\u2197",
        "nedot;": "\u2250\u0338",
        "nesim;": "\u2242\u0338",
        "ngeqq;": "\u2267\u0338",
        "ngsim;": "\u2275",
        "nhArr;": "\u21CE",
        "nharr;": "\u21AE",
        "nhpar;": "\u2AF2",
        "nlArr;": "\u21CD",
        "nlarr;": "\u219A",
        "nleqq;": "\u2266\u0338",
        "nless;": "\u226E",
        "nlsim;": "\u2274",
        "nltri;": "\u22EA",
        "notin;": "\u2209",
        "notni;": "\u220C",
        "npart;": "\u2202\u0338",
        "nprec;": "\u2280",
        "nrArr;": "\u21CF",
        "nrarr;": "\u219B",
        "nrtri;": "\u22EB",
        "nsime;": "\u2244",
        "nsmid;": "\u2224",
        "nspar;": "\u2226",
        "nsubE;": "\u2AC5\u0338",
        "nsube;": "\u2288",
        "nsucc;": "\u2281",
        "nsupE;": "\u2AC6\u0338",
        "nsupe;": "\u2289",
        Ntilde: "\xD1",
        ntilde: "\xF1",
        "numsp;": "\u2007",
        "nvsim;": "\u223C\u20D2",
        "nwArr;": "\u21D6",
        "nwarr;": "\u2196",
        Oacute: "\xD3",
        oacute: "\xF3",
        "Ocirc;": "\xD4",
        "ocirc;": "\xF4",
        "odash;": "\u229D",
        "OElig;": "\u0152",
        "oelig;": "\u0153",
        "ofcir;": "\u29BF",
        Ograve: "\xD2",
        ograve: "\xF2",
        "ohbar;": "\u29B5",
        "olarr;": "\u21BA",
        "olcir;": "\u29BE",
        "oline;": "\u203E",
        "Omacr;": "\u014C",
        "omacr;": "\u014D",
        "Omega;": "\u03A9",
        "omega;": "\u03C9",
        "operp;": "\u29B9",
        "oplus;": "\u2295",
        "orarr;": "\u21BB",
        "order;": "\u2134",
        Oslash: "\xD8",
        oslash: "\xF8",
        Otilde: "\xD5",
        otilde: "\xF5",
        "ovbar;": "\u233D",
        "parsl;": "\u2AFD",
        "phone;": "\u260E",
        "plusb;": "\u229E",
        "pluse;": "\u2A72",
        plusmn: "\xB1",
        "pound;": "\xA3",
        "prcue;": "\u227C",
        "Prime;": "\u2033",
        "prime;": "\u2032",
        "prnap;": "\u2AB9",
        "prsim;": "\u227E",
        "quest;": "?",
        "rAarr;": "\u21DB",
        "radic;": "\u221A",
        "rangd;": "\u2992",
        "range;": "\u29A5",
        "raquo;": "\xBB",
        "rarrb;": "\u21E5",
        "rarrc;": "\u2933",
        "rarrw;": "\u219D",
        "ratio;": "\u2236",
        "RBarr;": "\u2910",
        "rBarr;": "\u290F",
        "rbarr;": "\u290D",
        "rbbrk;": "\u2773",
        "rbrke;": "\u298C",
        "rceil;": "\u2309",
        "rdquo;": "\u201D",
        "reals;": "\u211D",
        "rhard;": "\u21C1",
        "rharu;": "\u21C0",
        "rlarr;": "\u21C4",
        "rlhar;": "\u21CC",
        "rnmid;": "\u2AEE",
        "roang;": "\u27ED",
        "roarr;": "\u21FE",
        "robrk;": "\u27E7",
        "ropar;": "\u2986",
        "rrarr;": "\u21C9",
        "rsquo;": "\u2019",
        "rtrie;": "\u22B5",
        "rtrif;": "\u25B8",
        "sbquo;": "\u201A",
        "sccue;": "\u227D",
        "Scirc;": "\u015C",
        "scirc;": "\u015D",
        "scnap;": "\u2ABA",
        "scsim;": "\u227F",
        "sdotb;": "\u22A1",
        "sdote;": "\u2A66",
        "seArr;": "\u21D8",
        "searr;": "\u2198",
        "setmn;": "\u2216",
        "sharp;": "\u266F",
        "Sigma;": "\u03A3",
        "sigma;": "\u03C3",
        "simeq;": "\u2243",
        "simgE;": "\u2AA0",
        "simlE;": "\u2A9F",
        "simne;": "\u2246",
        "slarr;": "\u2190",
        "smile;": "\u2323",
        "smtes;": "\u2AAC\uFE00",
        "sqcap;": "\u2293",
        "sqcup;": "\u2294",
        "sqsub;": "\u228F",
        "sqsup;": "\u2290",
        "srarr;": "\u2192",
        "starf;": "\u2605",
        "strns;": "\xAF",
        "subnE;": "\u2ACB",
        "subne;": "\u228A",
        "supnE;": "\u2ACC",
        "supne;": "\u228B",
        "swArr;": "\u21D9",
        "swarr;": "\u2199",
        "szlig;": "\xDF",
        "Theta;": "\u0398",
        "theta;": "\u03B8",
        "thkap;": "\u2248",
        "THORN;": "\xDE",
        "thorn;": "\xFE",
        "Tilde;": "\u223C",
        "tilde;": "\u02DC",
        "times;": "\xD7",
        "TRADE;": "\u2122",
        "trade;": "\u2122",
        "trisb;": "\u29CD",
        "TSHcy;": "\u040B",
        "tshcy;": "\u045B",
        "twixt;": "\u226C",
        Uacute: "\xDA",
        uacute: "\xFA",
        "Ubrcy;": "\u040E",
        "ubrcy;": "\u045E",
        "Ucirc;": "\xDB",
        "ucirc;": "\xFB",
        "udarr;": "\u21C5",
        "udhar;": "\u296E",
        Ugrave: "\xD9",
        ugrave: "\xF9",
        "uharl;": "\u21BF",
        "uharr;": "\u21BE",
        "uhblk;": "\u2580",
        "ultri;": "\u25F8",
        "Umacr;": "\u016A",
        "umacr;": "\u016B",
        "Union;": "\u22C3",
        "Uogon;": "\u0172",
        "uogon;": "\u0173",
        "uplus;": "\u228E",
        "upsih;": "\u03D2",
        "UpTee;": "\u22A5",
        "Uring;": "\u016E",
        "uring;": "\u016F",
        "urtri;": "\u25F9",
        "utdot;": "\u22F0",
        "utrif;": "\u25B4",
        "uuarr;": "\u21C8",
        "varpi;": "\u03D6",
        "vBarv;": "\u2AE9",
        "VDash;": "\u22AB",
        "Vdash;": "\u22A9",
        "vDash;": "\u22A8",
        "vdash;": "\u22A2",
        "veeeq;": "\u225A",
        "vltri;": "\u22B2",
        "vnsub;": "\u2282\u20D2",
        "vnsup;": "\u2283\u20D2",
        "vprop;": "\u221D",
        "vrtri;": "\u22B3",
        "Wcirc;": "\u0174",
        "wcirc;": "\u0175",
        "Wedge;": "\u22C0",
        "wedge;": "\u2227",
        "xcirc;": "\u25EF",
        "xdtri;": "\u25BD",
        "xhArr;": "\u27FA",
        "xharr;": "\u27F7",
        "xlArr;": "\u27F8",
        "xlarr;": "\u27F5",
        "xodot;": "\u2A00",
        "xrArr;": "\u27F9",
        "xrarr;": "\u27F6",
        "xutri;": "\u25B3",
        Yacute: "\xDD",
        yacute: "\xFD",
        "Ycirc;": "\u0176",
        "ycirc;": "\u0177",
        "Aacute;": "\xC1",
        "aacute;": "\xE1",
        "Abreve;": "\u0102",
        "abreve;": "\u0103",
        "Agrave;": "\xC0",
        "agrave;": "\xE0",
        "andand;": "\u2A55",
        "angmsd;": "\u2221",
        "angsph;": "\u2222",
        "apacir;": "\u2A6F",
        "approx;": "\u2248",
        "Assign;": "\u2254",
        "Atilde;": "\xC3",
        "atilde;": "\xE3",
        "barvee;": "\u22BD",
        "Barwed;": "\u2306",
        "barwed;": "\u2305",
        "becaus;": "\u2235",
        "bernou;": "\u212C",
        "bigcap;": "\u22C2",
        "bigcup;": "\u22C3",
        "bigvee;": "\u22C1",
        "bkarow;": "\u290D",
        "bottom;": "\u22A5",
        "bowtie;": "\u22C8",
        "boxbox;": "\u29C9",
        "bprime;": "\u2035",
        "brvbar;": "\xA6",
        "bullet;": "\u2022",
        "Bumpeq;": "\u224E",
        "bumpeq;": "\u224F",
        "Cacute;": "\u0106",
        "cacute;": "\u0107",
        "capand;": "\u2A44",
        "capcap;": "\u2A4B",
        "capcup;": "\u2A47",
        "capdot;": "\u2A40",
        "Ccaron;": "\u010C",
        "ccaron;": "\u010D",
        "Ccedil;": "\xC7",
        "ccedil;": "\xE7",
        "circeq;": "\u2257",
        "cirmid;": "\u2AEF",
        "Colone;": "\u2A74",
        "colone;": "\u2254",
        "commat;": "@",
        "compfn;": "\u2218",
        "Conint;": "\u222F",
        "conint;": "\u222E",
        "coprod;": "\u2210",
        "copysr;": "\u2117",
        "cularr;": "\u21B6",
        "CupCap;": "\u224D",
        "cupcap;": "\u2A46",
        "cupcup;": "\u2A4A",
        "cupdot;": "\u228D",
        "curarr;": "\u21B7",
        "curren;": "\xA4",
        "cylcty;": "\u232D",
        "Dagger;": "\u2021",
        "dagger;": "\u2020",
        "daleth;": "\u2138",
        "Dcaron;": "\u010E",
        "dcaron;": "\u010F",
        "dfisht;": "\u297F",
        "divide;": "\xF7",
        "divonx;": "\u22C7",
        "dlcorn;": "\u231E",
        "dlcrop;": "\u230D",
        "dollar;": "$",
        "DotDot;": "\u20DC",
        "drcorn;": "\u231F",
        "drcrop;": "\u230C",
        "Dstrok;": "\u0110",
        "dstrok;": "\u0111",
        "Eacute;": "\xC9",
        "eacute;": "\xE9",
        "easter;": "\u2A6E",
        "Ecaron;": "\u011A",
        "ecaron;": "\u011B",
        "ecolon;": "\u2255",
        "Egrave;": "\xC8",
        "egrave;": "\xE8",
        "egsdot;": "\u2A98",
        "elsdot;": "\u2A97",
        "emptyv;": "\u2205",
        "emsp13;": "\u2004",
        "emsp14;": "\u2005",
        "eparsl;": "\u29E3",
        "eqcirc;": "\u2256",
        "equals;": "=",
        "equest;": "\u225F",
        "Exists;": "\u2203",
        "female;": "\u2640",
        "ffilig;": "\uFB03",
        "ffllig;": "\uFB04",
        "ForAll;": "\u2200",
        "forall;": "\u2200",
        "frac12;": "\xBD",
        "frac13;": "\u2153",
        "frac14;": "\xBC",
        "frac15;": "\u2155",
        "frac16;": "\u2159",
        "frac18;": "\u215B",
        "frac23;": "\u2154",
        "frac25;": "\u2156",
        "frac34;": "\xBE",
        "frac35;": "\u2157",
        "frac38;": "\u215C",
        "frac45;": "\u2158",
        "frac56;": "\u215A",
        "frac58;": "\u215D",
        "frac78;": "\u215E",
        "gacute;": "\u01F5",
        "Gammad;": "\u03DC",
        "gammad;": "\u03DD",
        "Gbreve;": "\u011E",
        "gbreve;": "\u011F",
        "Gcedil;": "\u0122",
        "gesdot;": "\u2A80",
        "gesles;": "\u2A94",
        "gtlPar;": "\u2995",
        "gtrarr;": "\u2978",
        "gtrdot;": "\u22D7",
        "gtrsim;": "\u2273",
        "hairsp;": "\u200A",
        "hamilt;": "\u210B",
        "HARDcy;": "\u042A",
        "hardcy;": "\u044A",
        "hearts;": "\u2665",
        "hellip;": "\u2026",
        "hercon;": "\u22B9",
        "homtht;": "\u223B",
        "horbar;": "\u2015",
        "hslash;": "\u210F",
        "Hstrok;": "\u0126",
        "hstrok;": "\u0127",
        "hybull;": "\u2043",
        "hyphen;": "\u2010",
        "Iacute;": "\xCD",
        "iacute;": "\xED",
        "Igrave;": "\xCC",
        "igrave;": "\xEC",
        "iiiint;": "\u2A0C",
        "iinfin;": "\u29DC",
        "incare;": "\u2105",
        "inodot;": "\u0131",
        "intcal;": "\u22BA",
        "iquest;": "\xBF",
        "isinsv;": "\u22F3",
        "Itilde;": "\u0128",
        "itilde;": "\u0129",
        "Jsercy;": "\u0408",
        "jsercy;": "\u0458",
        "kappav;": "\u03F0",
        "Kcedil;": "\u0136",
        "kcedil;": "\u0137",
        "kgreen;": "\u0138",
        "Lacute;": "\u0139",
        "lacute;": "\u013A",
        "lagran;": "\u2112",
        "Lambda;": "\u039B",
        "lambda;": "\u03BB",
        "langle;": "\u27E8",
        "larrfs;": "\u291D",
        "larrhk;": "\u21A9",
        "larrlp;": "\u21AB",
        "larrpl;": "\u2939",
        "larrtl;": "\u21A2",
        "lAtail;": "\u291B",
        "latail;": "\u2919",
        "lbrace;": "{",
        "lbrack;": "[",
        "Lcaron;": "\u013D",
        "lcaron;": "\u013E",
        "Lcedil;": "\u013B",
        "lcedil;": "\u013C",
        "ldquor;": "\u201E",
        "lesdot;": "\u2A7F",
        "lesges;": "\u2A93",
        "lfisht;": "\u297C",
        "lfloor;": "\u230A",
        "lharul;": "\u296A",
        "llhard;": "\u296B",
        "Lmidot;": "\u013F",
        "lmidot;": "\u0140",
        "lmoust;": "\u23B0",
        "loplus;": "\u2A2D",
        "lowast;": "\u2217",
        "lowbar;": "_",
        "lparlt;": "\u2993",
        "lrhard;": "\u296D",
        "lsaquo;": "\u2039",
        "lsquor;": "\u201A",
        "Lstrok;": "\u0141",
        "lstrok;": "\u0142",
        "lthree;": "\u22CB",
        "ltimes;": "\u22C9",
        "ltlarr;": "\u2976",
        "ltrPar;": "\u2996",
        "mapsto;": "\u21A6",
        "marker;": "\u25AE",
        "mcomma;": "\u2A29",
        "midast;": "*",
        "midcir;": "\u2AF0",
        "middot;": "\xB7",
        "minusb;": "\u229F",
        "minusd;": "\u2238",
        "mnplus;": "\u2213",
        "models;": "\u22A7",
        "mstpos;": "\u223E",
        "Nacute;": "\u0143",
        "nacute;": "\u0144",
        "nbumpe;": "\u224F\u0338",
        "Ncaron;": "\u0147",
        "ncaron;": "\u0148",
        "Ncedil;": "\u0145",
        "ncedil;": "\u0146",
        "nearhk;": "\u2924",
        "nequiv;": "\u2262",
        "nesear;": "\u2928",
        "nexist;": "\u2204",
        "nltrie;": "\u22EC",
        "notinE;": "\u22F9\u0338",
        "nparsl;": "\u2AFD\u20E5",
        "nprcue;": "\u22E0",
        "nrarrc;": "\u2933\u0338",
        "nrarrw;": "\u219D\u0338",
        "nrtrie;": "\u22ED",
        "nsccue;": "\u22E1",
        "nsimeq;": "\u2244",
        "Ntilde;": "\xD1",
        "ntilde;": "\xF1",
        "numero;": "\u2116",
        "nVDash;": "\u22AF",
        "nVdash;": "\u22AE",
        "nvDash;": "\u22AD",
        "nvdash;": "\u22AC",
        "nvHarr;": "\u2904",
        "nvlArr;": "\u2902",
        "nvrArr;": "\u2903",
        "nwarhk;": "\u2923",
        "nwnear;": "\u2927",
        "Oacute;": "\xD3",
        "oacute;": "\xF3",
        "Odblac;": "\u0150",
        "odblac;": "\u0151",
        "odsold;": "\u29BC",
        "Ograve;": "\xD2",
        "ograve;": "\xF2",
        "ominus;": "\u2296",
        "origof;": "\u22B6",
        "Oslash;": "\xD8",
        "oslash;": "\xF8",
        "Otilde;": "\xD5",
        "otilde;": "\xF5",
        "Otimes;": "\u2A37",
        "otimes;": "\u2297",
        "parsim;": "\u2AF3",
        "percnt;": "%",
        "period;": ".",
        "permil;": "\u2030",
        "phmmat;": "\u2133",
        "planck;": "\u210F",
        "plankv;": "\u210F",
        "plusdo;": "\u2214",
        "plusdu;": "\u2A25",
        "plusmn;": "\xB1",
        "preceq;": "\u2AAF",
        "primes;": "\u2119",
        "prnsim;": "\u22E8",
        "propto;": "\u221D",
        "prurel;": "\u22B0",
        "puncsp;": "\u2008",
        "qprime;": "\u2057",
        "Racute;": "\u0154",
        "racute;": "\u0155",
        "rangle;": "\u27E9",
        "rarrap;": "\u2975",
        "rarrfs;": "\u291E",
        "rarrhk;": "\u21AA",
        "rarrlp;": "\u21AC",
        "rarrpl;": "\u2945",
        "Rarrtl;": "\u2916",
        "rarrtl;": "\u21A3",
        "rAtail;": "\u291C",
        "ratail;": "\u291A",
        "rbrace;": "}",
        "rbrack;": "]",
        "Rcaron;": "\u0158",
        "rcaron;": "\u0159",
        "Rcedil;": "\u0156",
        "rcedil;": "\u0157",
        "rdquor;": "\u201D",
        "rfisht;": "\u297D",
        "rfloor;": "\u230B",
        "rharul;": "\u296C",
        "rmoust;": "\u23B1",
        "roplus;": "\u2A2E",
        "rpargt;": "\u2994",
        "rsaquo;": "\u203A",
        "rsquor;": "\u2019",
        "rthree;": "\u22CC",
        "rtimes;": "\u22CA",
        "Sacute;": "\u015A",
        "sacute;": "\u015B",
        "Scaron;": "\u0160",
        "scaron;": "\u0161",
        "Scedil;": "\u015E",
        "scedil;": "\u015F",
        "scnsim;": "\u22E9",
        "searhk;": "\u2925",
        "seswar;": "\u2929",
        "sfrown;": "\u2322",
        "SHCHcy;": "\u0429",
        "shchcy;": "\u0449",
        "sigmaf;": "\u03C2",
        "sigmav;": "\u03C2",
        "simdot;": "\u2A6A",
        "smashp;": "\u2A33",
        "SOFTcy;": "\u042C",
        "softcy;": "\u044C",
        "solbar;": "\u233F",
        "spades;": "\u2660",
        "sqcaps;": "\u2293\uFE00",
        "sqcups;": "\u2294\uFE00",
        "sqsube;": "\u2291",
        "sqsupe;": "\u2292",
        "Square;": "\u25A1",
        "square;": "\u25A1",
        "squarf;": "\u25AA",
        "ssetmn;": "\u2216",
        "ssmile;": "\u2323",
        "sstarf;": "\u22C6",
        "subdot;": "\u2ABD",
        "Subset;": "\u22D0",
        "subset;": "\u2282",
        "subsim;": "\u2AC7",
        "subsub;": "\u2AD5",
        "subsup;": "\u2AD3",
        "succeq;": "\u2AB0",
        "supdot;": "\u2ABE",
        "Supset;": "\u22D1",
        "supset;": "\u2283",
        "supsim;": "\u2AC8",
        "supsub;": "\u2AD4",
        "supsup;": "\u2AD6",
        "swarhk;": "\u2926",
        "swnwar;": "\u292A",
        "target;": "\u2316",
        "Tcaron;": "\u0164",
        "tcaron;": "\u0165",
        "Tcedil;": "\u0162",
        "tcedil;": "\u0163",
        "telrec;": "\u2315",
        "there4;": "\u2234",
        "thetav;": "\u03D1",
        "thinsp;": "\u2009",
        "thksim;": "\u223C",
        "timesb;": "\u22A0",
        "timesd;": "\u2A30",
        "topbot;": "\u2336",
        "topcir;": "\u2AF1",
        "tprime;": "\u2034",
        "tridot;": "\u25EC",
        "Tstrok;": "\u0166",
        "tstrok;": "\u0167",
        "Uacute;": "\xDA",
        "uacute;": "\xFA",
        "Ubreve;": "\u016C",
        "ubreve;": "\u016D",
        "Udblac;": "\u0170",
        "udblac;": "\u0171",
        "ufisht;": "\u297E",
        "Ugrave;": "\xD9",
        "ugrave;": "\xF9",
        "ulcorn;": "\u231C",
        "ulcrop;": "\u230F",
        "urcorn;": "\u231D",
        "urcrop;": "\u230E",
        "Utilde;": "\u0168",
        "utilde;": "\u0169",
        "vangrt;": "\u299C",
        "varphi;": "\u03D5",
        "varrho;": "\u03F1",
        "Vdashl;": "\u2AE6",
        "veebar;": "\u22BB",
        "vellip;": "\u22EE",
        "Verbar;": "\u2016",
        "verbar;": "|",
        "vsubnE;": "\u2ACB\uFE00",
        "vsubne;": "\u228A\uFE00",
        "vsupnE;": "\u2ACC\uFE00",
        "vsupne;": "\u228B\uFE00",
        "Vvdash;": "\u22AA",
        "wedbar;": "\u2A5F",
        "wedgeq;": "\u2259",
        "weierp;": "\u2118",
        "wreath;": "\u2240",
        "xoplus;": "\u2A01",
        "xotime;": "\u2A02",
        "xsqcup;": "\u2A06",
        "xuplus;": "\u2A04",
        "xwedge;": "\u22C0",
        "Yacute;": "\xDD",
        "yacute;": "\xFD",
        "Zacute;": "\u0179",
        "zacute;": "\u017A",
        "Zcaron;": "\u017D",
        "zcaron;": "\u017E",
        "zeetrf;": "\u2128",
        "alefsym;": "\u2135",
        "angrtvb;": "\u22BE",
        "angzarr;": "\u237C",
        "asympeq;": "\u224D",
        "backsim;": "\u223D",
        "Because;": "\u2235",
        "because;": "\u2235",
        "bemptyv;": "\u29B0",
        "between;": "\u226C",
        "bigcirc;": "\u25EF",
        "bigodot;": "\u2A00",
        "bigstar;": "\u2605",
        "bnequiv;": "\u2261\u20E5",
        "boxplus;": "\u229E",
        "Cayleys;": "\u212D",
        "Cconint;": "\u2230",
        "ccupssm;": "\u2A50",
        "Cedilla;": "\xB8",
        "cemptyv;": "\u29B2",
        "cirscir;": "\u29C2",
        "coloneq;": "\u2254",
        "congdot;": "\u2A6D",
        "cudarrl;": "\u2938",
        "cudarrr;": "\u2935",
        "cularrp;": "\u293D",
        "curarrm;": "\u293C",
        "dbkarow;": "\u290F",
        "ddagger;": "\u2021",
        "ddotseq;": "\u2A77",
        "demptyv;": "\u29B1",
        "Diamond;": "\u22C4",
        "diamond;": "\u22C4",
        "digamma;": "\u03DD",
        "dotplus;": "\u2214",
        "DownTee;": "\u22A4",
        "dwangle;": "\u29A6",
        "Element;": "\u2208",
        "Epsilon;": "\u0395",
        "epsilon;": "\u03B5",
        "eqcolon;": "\u2255",
        "equivDD;": "\u2A78",
        "gesdoto;": "\u2A82",
        "gtquest;": "\u2A7C",
        "gtrless;": "\u2277",
        "harrcir;": "\u2948",
        "Implies;": "\u21D2",
        "intprod;": "\u2A3C",
        "isindot;": "\u22F5",
        "larrbfs;": "\u291F",
        "larrsim;": "\u2973",
        "lbrksld;": "\u298F",
        "lbrkslu;": "\u298D",
        "ldrdhar;": "\u2967",
        "LeftTee;": "\u22A3",
        "lesdoto;": "\u2A81",
        "lessdot;": "\u22D6",
        "lessgtr;": "\u2276",
        "lesssim;": "\u2272",
        "lotimes;": "\u2A34",
        "lozenge;": "\u25CA",
        "ltquest;": "\u2A7B",
        "luruhar;": "\u2966",
        "maltese;": "\u2720",
        "minusdu;": "\u2A2A",
        "napprox;": "\u2249",
        "natural;": "\u266E",
        "nearrow;": "\u2197",
        "NewLine;": "\n",
        "nexists;": "\u2204",
        "NoBreak;": "\u2060",
        "notinva;": "\u2209",
        "notinvb;": "\u22F7",
        "notinvc;": "\u22F6",
        "NotLess;": "\u226E",
        "notniva;": "\u220C",
        "notnivb;": "\u22FE",
        "notnivc;": "\u22FD",
        "npolint;": "\u2A14",
        "npreceq;": "\u2AAF\u0338",
        "nsqsube;": "\u22E2",
        "nsqsupe;": "\u22E3",
        "nsubset;": "\u2282\u20D2",
        "nsucceq;": "\u2AB0\u0338",
        "nsupset;": "\u2283\u20D2",
        "nvinfin;": "\u29DE",
        "nvltrie;": "\u22B4\u20D2",
        "nvrtrie;": "\u22B5\u20D2",
        "nwarrow;": "\u2196",
        "olcross;": "\u29BB",
        "Omicron;": "\u039F",
        "omicron;": "\u03BF",
        "orderof;": "\u2134",
        "orslope;": "\u2A57",
        "OverBar;": "\u203E",
        "pertenk;": "\u2031",
        "planckh;": "\u210E",
        "pluscir;": "\u2A22",
        "plussim;": "\u2A26",
        "plustwo;": "\u2A27",
        "precsim;": "\u227E",
        "Product;": "\u220F",
        "quatint;": "\u2A16",
        "questeq;": "\u225F",
        "rarrbfs;": "\u2920",
        "rarrsim;": "\u2974",
        "rbrksld;": "\u298E",
        "rbrkslu;": "\u2990",
        "rdldhar;": "\u2969",
        "realine;": "\u211B",
        "rotimes;": "\u2A35",
        "ruluhar;": "\u2968",
        "searrow;": "\u2198",
        "simplus;": "\u2A24",
        "simrarr;": "\u2972",
        "subedot;": "\u2AC3",
        "submult;": "\u2AC1",
        "subplus;": "\u2ABF",
        "subrarr;": "\u2979",
        "succsim;": "\u227F",
        "supdsub;": "\u2AD8",
        "supedot;": "\u2AC4",
        "suphsol;": "\u27C9",
        "suphsub;": "\u2AD7",
        "suplarr;": "\u297B",
        "supmult;": "\u2AC2",
        "supplus;": "\u2AC0",
        "swarrow;": "\u2199",
        "topfork;": "\u2ADA",
        "triplus;": "\u2A39",
        "tritime;": "\u2A3B",
        "UpArrow;": "\u2191",
        "Uparrow;": "\u21D1",
        "uparrow;": "\u2191",
        "Upsilon;": "\u03A5",
        "upsilon;": "\u03C5",
        "uwangle;": "\u29A7",
        "vzigzag;": "\u299A",
        "zigrarr;": "\u21DD",
        "andslope;": "\u2A58",
        "angmsdaa;": "\u29A8",
        "angmsdab;": "\u29A9",
        "angmsdac;": "\u29AA",
        "angmsdad;": "\u29AB",
        "angmsdae;": "\u29AC",
        "angmsdaf;": "\u29AD",
        "angmsdag;": "\u29AE",
        "angmsdah;": "\u29AF",
        "angrtvbd;": "\u299D",
        "approxeq;": "\u224A",
        "awconint;": "\u2233",
        "backcong;": "\u224C",
        "barwedge;": "\u2305",
        "bbrktbrk;": "\u23B6",
        "bigoplus;": "\u2A01",
        "bigsqcup;": "\u2A06",
        "biguplus;": "\u2A04",
        "bigwedge;": "\u22C0",
        "boxminus;": "\u229F",
        "boxtimes;": "\u22A0",
        "bsolhsub;": "\u27C8",
        "capbrcup;": "\u2A49",
        "circledR;": "\xAE",
        "circledS;": "\u24C8",
        "cirfnint;": "\u2A10",
        "clubsuit;": "\u2663",
        "cupbrcap;": "\u2A48",
        "curlyvee;": "\u22CE",
        "cwconint;": "\u2232",
        "DDotrahd;": "\u2911",
        "doteqdot;": "\u2251",
        "DotEqual;": "\u2250",
        "dotminus;": "\u2238",
        "drbkarow;": "\u2910",
        "dzigrarr;": "\u27FF",
        "elinters;": "\u23E7",
        "emptyset;": "\u2205",
        "eqvparsl;": "\u29E5",
        "fpartint;": "\u2A0D",
        "geqslant;": "\u2A7E",
        "gesdotol;": "\u2A84",
        "gnapprox;": "\u2A8A",
        "hksearow;": "\u2925",
        "hkswarow;": "\u2926",
        "imagline;": "\u2110",
        "imagpart;": "\u2111",
        "infintie;": "\u29DD",
        "integers;": "\u2124",
        "Integral;": "\u222B",
        "intercal;": "\u22BA",
        "intlarhk;": "\u2A17",
        "laemptyv;": "\u29B4",
        "ldrushar;": "\u294B",
        "leqslant;": "\u2A7D",
        "lesdotor;": "\u2A83",
        "LessLess;": "\u2AA1",
        "llcorner;": "\u231E",
        "lnapprox;": "\u2A89",
        "lrcorner;": "\u231F",
        "lurdshar;": "\u294A",
        "mapstoup;": "\u21A5",
        "multimap;": "\u22B8",
        "naturals;": "\u2115",
        "ncongdot;": "\u2A6D\u0338",
        "NotEqual;": "\u2260",
        "notindot;": "\u22F5\u0338",
        "NotTilde;": "\u2241",
        "otimesas;": "\u2A36",
        "parallel;": "\u2225",
        "PartialD;": "\u2202",
        "plusacir;": "\u2A23",
        "pointint;": "\u2A15",
        "Precedes;": "\u227A",
        "precneqq;": "\u2AB5",
        "precnsim;": "\u22E8",
        "profalar;": "\u232E",
        "profline;": "\u2312",
        "profsurf;": "\u2313",
        "raemptyv;": "\u29B3",
        "realpart;": "\u211C",
        "RightTee;": "\u22A2",
        "rppolint;": "\u2A12",
        "rtriltri;": "\u29CE",
        "scpolint;": "\u2A13",
        "setminus;": "\u2216",
        "shortmid;": "\u2223",
        "smeparsl;": "\u29E4",
        "sqsubset;": "\u228F",
        "sqsupset;": "\u2290",
        "subseteq;": "\u2286",
        "Succeeds;": "\u227B",
        "succneqq;": "\u2AB6",
        "succnsim;": "\u22E9",
        "SuchThat;": "\u220B",
        "Superset;": "\u2283",
        "supseteq;": "\u2287",
        "thetasym;": "\u03D1",
        "thicksim;": "\u223C",
        "timesbar;": "\u2A31",
        "triangle;": "\u25B5",
        "triminus;": "\u2A3A",
        "trpezium;": "\u23E2",
        "Uarrocir;": "\u2949",
        "ulcorner;": "\u231C",
        "UnderBar;": "_",
        "urcorner;": "\u231D",
        "varkappa;": "\u03F0",
        "varsigma;": "\u03C2",
        "vartheta;": "\u03D1",
        "backprime;": "\u2035",
        "backsimeq;": "\u22CD",
        "Backslash;": "\u2216",
        "bigotimes;": "\u2A02",
        "CenterDot;": "\xB7",
        "centerdot;": "\xB7",
        "checkmark;": "\u2713",
        "CircleDot;": "\u2299",
        "complexes;": "\u2102",
        "Congruent;": "\u2261",
        "Coproduct;": "\u2210",
        "dotsquare;": "\u22A1",
        "DoubleDot;": "\xA8",
        "DownArrow;": "\u2193",
        "Downarrow;": "\u21D3",
        "downarrow;": "\u2193",
        "DownBreve;": "\u0311",
        "gtrapprox;": "\u2A86",
        "gtreqless;": "\u22DB",
        "gvertneqq;": "\u2269\uFE00",
        "heartsuit;": "\u2665",
        "HumpEqual;": "\u224F",
        "LeftArrow;": "\u2190",
        "Leftarrow;": "\u21D0",
        "leftarrow;": "\u2190",
        "LeftFloor;": "\u230A",
        "lesseqgtr;": "\u22DA",
        "LessTilde;": "\u2272",
        "lvertneqq;": "\u2268\uFE00",
        "Mellintrf;": "\u2133",
        "MinusPlus;": "\u2213",
        "ngeqslant;": "\u2A7E\u0338",
        "nleqslant;": "\u2A7D\u0338",
        "NotCupCap;": "\u226D",
        "NotExists;": "\u2204",
        "NotSubset;": "\u2282\u20D2",
        "nparallel;": "\u2226",
        "nshortmid;": "\u2224",
        "nsubseteq;": "\u2288",
        "nsupseteq;": "\u2289",
        "OverBrace;": "\u23DE",
        "pitchfork;": "\u22D4",
        "PlusMinus;": "\xB1",
        "rationals;": "\u211A",
        "spadesuit;": "\u2660",
        "subseteqq;": "\u2AC5",
        "subsetneq;": "\u228A",
        "supseteqq;": "\u2AC6",
        "supsetneq;": "\u228B",
        "Therefore;": "\u2234",
        "therefore;": "\u2234",
        "ThinSpace;": "\u2009",
        "triangleq;": "\u225C",
        "TripleDot;": "\u20DB",
        "UnionPlus;": "\u228E",
        "varpropto;": "\u221D",
        "Bernoullis;": "\u212C",
        "circledast;": "\u229B",
        "CirclePlus;": "\u2295",
        "complement;": "\u2201",
        "curlywedge;": "\u22CF",
        "eqslantgtr;": "\u2A96",
        "EqualTilde;": "\u2242",
        "Fouriertrf;": "\u2131",
        "gtreqqless;": "\u2A8C",
        "ImaginaryI;": "\u2148",
        "Laplacetrf;": "\u2112",
        "LeftVector;": "\u21BC",
        "lessapprox;": "\u2A85",
        "lesseqqgtr;": "\u2A8B",
        "Lleftarrow;": "\u21DA",
        "lmoustache;": "\u23B0",
        "longmapsto;": "\u27FC",
        "mapstodown;": "\u21A7",
        "mapstoleft;": "\u21A4",
        "nLeftarrow;": "\u21CD",
        "nleftarrow;": "\u219A",
        "NotElement;": "\u2209",
        "NotGreater;": "\u226F",
        "nsubseteqq;": "\u2AC5\u0338",
        "nsupseteqq;": "\u2AC6\u0338",
        "precapprox;": "\u2AB7",
        "Proportion;": "\u2237",
        "RightArrow;": "\u2192",
        "Rightarrow;": "\u21D2",
        "rightarrow;": "\u2192",
        "RightFloor;": "\u230B",
        "rmoustache;": "\u23B1",
        "sqsubseteq;": "\u2291",
        "sqsupseteq;": "\u2292",
        "subsetneqq;": "\u2ACB",
        "succapprox;": "\u2AB8",
        "supsetneqq;": "\u2ACC",
        "ThickSpace;": "\u205F\u200A",
        "TildeEqual;": "\u2243",
        "TildeTilde;": "\u2248",
        "UnderBrace;": "\u23DF",
        "UpArrowBar;": "\u2912",
        "UpTeeArrow;": "\u21A5",
        "upuparrows;": "\u21C8",
        "varepsilon;": "\u03F5",
        "varnothing;": "\u2205",
        "backepsilon;": "\u03F6",
        "blacksquare;": "\u25AA",
        "circledcirc;": "\u229A",
        "circleddash;": "\u229D",
        "CircleMinus;": "\u2296",
        "CircleTimes;": "\u2297",
        "curlyeqprec;": "\u22DE",
        "curlyeqsucc;": "\u22DF",
        "diamondsuit;": "\u2666",
        "eqslantless;": "\u2A95",
        "Equilibrium;": "\u21CC",
        "expectation;": "\u2130",
        "GreaterLess;": "\u2277",
        "LeftCeiling;": "\u2308",
        "LessGreater;": "\u2276",
        "MediumSpace;": "\u205F",
        "NotLessLess;": "\u226A\u0338",
        "NotPrecedes;": "\u2280",
        "NotSucceeds;": "\u2281",
        "NotSuperset;": "\u2283\u20D2",
        "nRightarrow;": "\u21CF",
        "nrightarrow;": "\u219B",
        "OverBracket;": "\u23B4",
        "preccurlyeq;": "\u227C",
        "precnapprox;": "\u2AB9",
        "quaternions;": "\u210D",
        "RightVector;": "\u21C0",
        "Rrightarrow;": "\u21DB",
        "RuleDelayed;": "\u29F4",
        "SmallCircle;": "\u2218",
        "SquareUnion;": "\u2294",
        "straightphi;": "\u03D5",
        "SubsetEqual;": "\u2286",
        "succcurlyeq;": "\u227D",
        "succnapprox;": "\u2ABA",
        "thickapprox;": "\u2248",
        "UpDownArrow;": "\u2195",
        "Updownarrow;": "\u21D5",
        "updownarrow;": "\u2195",
        "VerticalBar;": "\u2223",
        "blacklozenge;": "\u29EB",
        "DownArrowBar;": "\u2913",
        "DownTeeArrow;": "\u21A7",
        "ExponentialE;": "\u2147",
        "exponentiale;": "\u2147",
        "GreaterEqual;": "\u2265",
        "GreaterTilde;": "\u2273",
        "HilbertSpace;": "\u210B",
        "HumpDownHump;": "\u224E",
        "Intersection;": "\u22C2",
        "LeftArrowBar;": "\u21E4",
        "LeftTeeArrow;": "\u21A4",
        "LeftTriangle;": "\u22B2",
        "LeftUpVector;": "\u21BF",
        "NotCongruent;": "\u2262",
        "NotHumpEqual;": "\u224F\u0338",
        "NotLessEqual;": "\u2270",
        "NotLessTilde;": "\u2274",
        "Proportional;": "\u221D",
        "RightCeiling;": "\u2309",
        "risingdotseq;": "\u2253",
        "RoundImplies;": "\u2970",
        "ShortUpArrow;": "\u2191",
        "SquareSubset;": "\u228F",
        "triangledown;": "\u25BF",
        "triangleleft;": "\u25C3",
        "UnderBracket;": "\u23B5",
        "varsubsetneq;": "\u228A\uFE00",
        "varsupsetneq;": "\u228B\uFE00",
        "VerticalLine;": "|",
        "ApplyFunction;": "\u2061",
        "bigtriangleup;": "\u25B3",
        "blacktriangle;": "\u25B4",
        "DifferentialD;": "\u2146",
        "divideontimes;": "\u22C7",
        "DoubleLeftTee;": "\u2AE4",
        "DoubleUpArrow;": "\u21D1",
        "fallingdotseq;": "\u2252",
        "hookleftarrow;": "\u21A9",
        "leftarrowtail;": "\u21A2",
        "leftharpoonup;": "\u21BC",
        "LeftTeeVector;": "\u295A",
        "LeftVectorBar;": "\u2952",
        "LessFullEqual;": "\u2266",
        "LongLeftArrow;": "\u27F5",
        "Longleftarrow;": "\u27F8",
        "longleftarrow;": "\u27F5",
        "looparrowleft;": "\u21AB",
        "measuredangle;": "\u2221",
        "NotEqualTilde;": "\u2242\u0338",
        "NotTildeEqual;": "\u2244",
        "NotTildeTilde;": "\u2249",
        "ntriangleleft;": "\u22EA",
        "Poincareplane;": "\u210C",
        "PrecedesEqual;": "\u2AAF",
        "PrecedesTilde;": "\u227E",
        "RightArrowBar;": "\u21E5",
        "RightTeeArrow;": "\u21A6",
        "RightTriangle;": "\u22B3",
        "RightUpVector;": "\u21BE",
        "shortparallel;": "\u2225",
        "smallsetminus;": "\u2216",
        "SucceedsEqual;": "\u2AB0",
        "SucceedsTilde;": "\u227F",
        "SupersetEqual;": "\u2287",
        "triangleright;": "\u25B9",
        "UpEquilibrium;": "\u296E",
        "upharpoonleft;": "\u21BF",
        "varsubsetneqq;": "\u2ACB\uFE00",
        "varsupsetneqq;": "\u2ACC\uFE00",
        "VerticalTilde;": "\u2240",
        "VeryThinSpace;": "\u200A",
        "curvearrowleft;": "\u21B6",
        "DiacriticalDot;": "\u02D9",
        "doublebarwedge;": "\u2306",
        "DoubleRightTee;": "\u22A8",
        "downdownarrows;": "\u21CA",
        "DownLeftVector;": "\u21BD",
        "GreaterGreater;": "\u2AA2",
        "hookrightarrow;": "\u21AA",
        "HorizontalLine;": "\u2500",
        "InvisibleComma;": "\u2063",
        "InvisibleTimes;": "\u2062",
        "LeftDownVector;": "\u21C3",
        "leftleftarrows;": "\u21C7",
        "LeftRightArrow;": "\u2194",
        "Leftrightarrow;": "\u21D4",
        "leftrightarrow;": "\u2194",
        "leftthreetimes;": "\u22CB",
        "LessSlantEqual;": "\u2A7D",
        "LongRightArrow;": "\u27F6",
        "Longrightarrow;": "\u27F9",
        "longrightarrow;": "\u27F6",
        "looparrowright;": "\u21AC",
        "LowerLeftArrow;": "\u2199",
        "NestedLessLess;": "\u226A",
        "NotGreaterLess;": "\u2279",
        "NotLessGreater;": "\u2278",
        "NotSubsetEqual;": "\u2288",
        "NotVerticalBar;": "\u2224",
        "nshortparallel;": "\u2226",
        "ntriangleright;": "\u22EB",
        "OpenCurlyQuote;": "\u2018",
        "ReverseElement;": "\u220B",
        "rightarrowtail;": "\u21A3",
        "rightharpoonup;": "\u21C0",
        "RightTeeVector;": "\u295B",
        "RightVectorBar;": "\u2953",
        "ShortDownArrow;": "\u2193",
        "ShortLeftArrow;": "\u2190",
        "SquareSuperset;": "\u2290",
        "TildeFullEqual;": "\u2245",
        "trianglelefteq;": "\u22B4",
        "upharpoonright;": "\u21BE",
        "UpperLeftArrow;": "\u2196",
        "ZeroWidthSpace;": "\u200B",
        "bigtriangledown;": "\u25BD",
        "circlearrowleft;": "\u21BA",
        "CloseCurlyQuote;": "\u2019",
        "ContourIntegral;": "\u222E",
        "curvearrowright;": "\u21B7",
        "DoubleDownArrow;": "\u21D3",
        "DoubleLeftArrow;": "\u21D0",
        "downharpoonleft;": "\u21C3",
        "DownRightVector;": "\u21C1",
        "leftharpoondown;": "\u21BD",
        "leftrightarrows;": "\u21C6",
        "LeftRightVector;": "\u294E",
        "LeftTriangleBar;": "\u29CF",
        "LeftUpTeeVector;": "\u2960",
        "LeftUpVectorBar;": "\u2958",
        "LowerRightArrow;": "\u2198",
        "nLeftrightarrow;": "\u21CE",
        "nleftrightarrow;": "\u21AE",
        "NotGreaterEqual;": "\u2271",
        "NotGreaterTilde;": "\u2275",
        "NotHumpDownHump;": "\u224E\u0338",
        "NotLeftTriangle;": "\u22EA",
        "NotSquareSubset;": "\u228F\u0338",
        "ntrianglelefteq;": "\u22EC",
        "OverParenthesis;": "\u23DC",
        "RightDownVector;": "\u21C2",
        "rightleftarrows;": "\u21C4",
        "rightsquigarrow;": "\u219D",
        "rightthreetimes;": "\u22CC",
        "ShortRightArrow;": "\u2192",
        "straightepsilon;": "\u03F5",
        "trianglerighteq;": "\u22B5",
        "UpperRightArrow;": "\u2197",
        "vartriangleleft;": "\u22B2",
        "circlearrowright;": "\u21BB",
        "DiacriticalAcute;": "\xB4",
        "DiacriticalGrave;": "`",
        "DiacriticalTilde;": "\u02DC",
        "DoubleRightArrow;": "\u21D2",
        "DownArrowUpArrow;": "\u21F5",
        "downharpoonright;": "\u21C2",
        "EmptySmallSquare;": "\u25FB",
        "GreaterEqualLess;": "\u22DB",
        "GreaterFullEqual;": "\u2267",
        "LeftAngleBracket;": "\u27E8",
        "LeftUpDownVector;": "\u2951",
        "LessEqualGreater;": "\u22DA",
        "NonBreakingSpace;": "\xA0",
        "NotPrecedesEqual;": "\u2AAF\u0338",
        "NotRightTriangle;": "\u22EB",
        "NotSucceedsEqual;": "\u2AB0\u0338",
        "NotSucceedsTilde;": "\u227F\u0338",
        "NotSupersetEqual;": "\u2289",
        "ntrianglerighteq;": "\u22ED",
        "rightharpoondown;": "\u21C1",
        "rightrightarrows;": "\u21C9",
        "RightTriangleBar;": "\u29D0",
        "RightUpTeeVector;": "\u295C",
        "RightUpVectorBar;": "\u2954",
        "twoheadleftarrow;": "\u219E",
        "UnderParenthesis;": "\u23DD",
        "UpArrowDownArrow;": "\u21C5",
        "vartriangleright;": "\u22B3",
        "blacktriangledown;": "\u25BE",
        "blacktriangleleft;": "\u25C2",
        "DoubleUpDownArrow;": "\u21D5",
        "DoubleVerticalBar;": "\u2225",
        "DownLeftTeeVector;": "\u295E",
        "DownLeftVectorBar;": "\u2956",
        "FilledSmallSquare;": "\u25FC",
        "GreaterSlantEqual;": "\u2A7E",
        "LeftDoubleBracket;": "\u27E6",
        "LeftDownTeeVector;": "\u2961",
        "LeftDownVectorBar;": "\u2959",
        "leftrightharpoons;": "\u21CB",
        "LeftTriangleEqual;": "\u22B4",
        "NegativeThinSpace;": "\u200B",
        "NotGreaterGreater;": "\u226B\u0338",
        "NotLessSlantEqual;": "\u2A7D\u0338",
        "NotNestedLessLess;": "\u2AA1\u0338",
        "NotReverseElement;": "\u220C",
        "NotSquareSuperset;": "\u2290\u0338",
        "NotTildeFullEqual;": "\u2247",
        "RightAngleBracket;": "\u27E9",
        "rightleftharpoons;": "\u21CC",
        "RightUpDownVector;": "\u294F",
        "SquareSubsetEqual;": "\u2291",
        "twoheadrightarrow;": "\u21A0",
        "VerticalSeparator;": "\u2758",
        "blacktriangleright;": "\u25B8",
        "DownRightTeeVector;": "\u295F",
        "DownRightVectorBar;": "\u2957",
        "LongLeftRightArrow;": "\u27F7",
        "Longleftrightarrow;": "\u27FA",
        "longleftrightarrow;": "\u27F7",
        "NegativeThickSpace;": "\u200B",
        "NotLeftTriangleBar;": "\u29CF\u0338",
        "PrecedesSlantEqual;": "\u227C",
        "ReverseEquilibrium;": "\u21CB",
        "RightDoubleBracket;": "\u27E7",
        "RightDownTeeVector;": "\u295D",
        "RightDownVectorBar;": "\u2955",
        "RightTriangleEqual;": "\u22B5",
        "SquareIntersection;": "\u2293",
        "SucceedsSlantEqual;": "\u227D",
        "DoubleLongLeftArrow;": "\u27F8",
        "DownLeftRightVector;": "\u2950",
        "LeftArrowRightArrow;": "\u21C6",
        "leftrightsquigarrow;": "\u21AD",
        "NegativeMediumSpace;": "\u200B",
        "NotGreaterFullEqual;": "\u2267\u0338",
        "NotRightTriangleBar;": "\u29D0\u0338",
        "RightArrowLeftArrow;": "\u21C4",
        "SquareSupersetEqual;": "\u2292",
        "CapitalDifferentialD;": "\u2145",
        "DoubleLeftRightArrow;": "\u21D4",
        "DoubleLongRightArrow;": "\u27F9",
        "EmptyVerySmallSquare;": "\u25AB",
        "NestedGreaterGreater;": "\u226B",
        "NotDoubleVerticalBar;": "\u2226",
        "NotGreaterSlantEqual;": "\u2A7E\u0338",
        "NotLeftTriangleEqual;": "\u22EC",
        "NotSquareSubsetEqual;": "\u22E2",
        "OpenCurlyDoubleQuote;": "\u201C",
        "ReverseUpEquilibrium;": "\u296F",
        "CloseCurlyDoubleQuote;": "\u201D",
        "DoubleContourIntegral;": "\u222F",
        "FilledVerySmallSquare;": "\u25AA",
        "NegativeVeryThinSpace;": "\u200B",
        "NotPrecedesSlantEqual;": "\u22E0",
        "NotRightTriangleEqual;": "\u22ED",
        "NotSucceedsSlantEqual;": "\u22E1",
        "DiacriticalDoubleAcute;": "\u02DD",
        "NotSquareSupersetEqual;": "\u22E3",
        "NotNestedGreaterGreater;": "\u2AA2\u0338",
        "ClockwiseContourIntegral;": "\u2232",
        "DoubleLongLeftRightArrow;": "\u27FA",
        "CounterClockwiseContourIntegral;": "\u2233"
      };
      var maxCRNameLength;
      var decodeHtml = (rawText, asAttr) => {
        let offset = 0;
        const end = rawText.length;
        let decodedText = "";
        function advance(length) {
          offset += length;
          rawText = rawText.slice(length);
        }
        while (offset < end) {
          const head = /&(?:#x?)?/i.exec(rawText);
          if (!head || offset + head.index >= end) {
            const remaining = end - offset;
            decodedText += rawText.slice(0, remaining);
            advance(remaining);
            break;
          }
          decodedText += rawText.slice(0, head.index);
          advance(head.index);
          if (head[0] === "&") {
            let name = "";
            let value = void 0;
            if (/[0-9a-z]/i.test(rawText[1])) {
              if (!maxCRNameLength) {
                maxCRNameLength = Object.keys(namedCharacterReferences).reduce(
                  (max, name2) => Math.max(max, name2.length),
                  0
                );
              }
              for (let length = maxCRNameLength; !value && length > 0; --length) {
                name = rawText.slice(1, 1 + length);
                value = namedCharacterReferences[name];
              }
              if (value) {
                const semi = name.endsWith(";");
                if (asAttr && !semi && /[=a-z0-9]/i.test(rawText[name.length + 1] || "")) {
                  decodedText += "&" + name;
                  advance(1 + name.length);
                } else {
                  decodedText += value;
                  advance(1 + name.length);
                }
              } else {
                decodedText += "&" + name;
                advance(1 + name.length);
              }
            } else {
              decodedText += "&";
              advance(1);
            }
          } else {
            const hex = head[0] === "&#x";
            const pattern = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/;
            const body = pattern.exec(rawText);
            if (!body) {
              decodedText += head[0];
              advance(head[0].length);
            } else {
              let cp = Number.parseInt(body[1], hex ? 16 : 10);
              if (cp === 0) {
                cp = 65533;
              } else if (cp > 1114111) {
                cp = 65533;
              } else if (cp >= 55296 && cp <= 57343) {
                cp = 65533;
              } else if (cp >= 64976 && cp <= 65007 || (cp & 65534) === 65534)
                ;
              else if (cp >= 1 && cp <= 8 || cp === 11 || cp >= 13 && cp <= 31 || cp >= 127 && cp <= 159) {
                cp = CCR_REPLACEMENTS[cp] || cp;
              }
              decodedText += String.fromCodePoint(cp);
              advance(body[0].length);
            }
          }
        }
        return decodedText;
      };
      var CCR_REPLACEMENTS = {
        128: 8364,
        130: 8218,
        131: 402,
        132: 8222,
        133: 8230,
        134: 8224,
        135: 8225,
        136: 710,
        137: 8240,
        138: 352,
        139: 8249,
        140: 338,
        142: 381,
        145: 8216,
        146: 8217,
        147: 8220,
        148: 8221,
        149: 8226,
        150: 8211,
        151: 8212,
        152: 732,
        153: 8482,
        154: 353,
        155: 8250,
        156: 339,
        158: 382,
        159: 376
      };
      var isRawTextContainer = /* @__PURE__ */ shared.makeMap(
        "style,iframe,script,noscript",
        true
      );
      var parserOptions = {
        isVoidTag: shared.isVoidTag,
        isNativeTag: (tag) => shared.isHTMLTag(tag) || shared.isSVGTag(tag),
        isPreTag: (tag) => tag === "pre",
        decodeEntities: decodeHtml,
        isBuiltInComponent: (tag) => {
          if (compilerCore.isBuiltInType(tag, `Transition`)) {
            return TRANSITION;
          } else if (compilerCore.isBuiltInType(tag, `TransitionGroup`)) {
            return TRANSITION_GROUP;
          }
        },
        // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
        getNamespace(tag, parent) {
          let ns = parent ? parent.ns : 0;
          if (parent && ns === 2) {
            if (parent.tag === "annotation-xml") {
              if (tag === "svg") {
                return 1;
              }
              if (parent.props.some(
                (a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml")
              )) {
                ns = 0;
              }
            } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
              ns = 0;
            }
          } else if (parent && ns === 1) {
            if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
              ns = 0;
            }
          }
          if (ns === 0) {
            if (tag === "svg") {
              return 1;
            }
            if (tag === "math") {
              return 2;
            }
          }
          return ns;
        },
        // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
        getTextMode({ tag, ns }) {
          if (ns === 0) {
            if (tag === "textarea" || tag === "title") {
              return 1;
            }
            if (isRawTextContainer(tag)) {
              return 2;
            }
          }
          return 0;
        }
      };
      var transformStyle = (node) => {
        if (node.type === 1) {
          node.props.forEach((p, i) => {
            if (p.type === 6 && p.name === "style" && p.value) {
              node.props[i] = {
                type: 7,
                name: `bind`,
                arg: compilerCore.createSimpleExpression(`style`, true, p.loc),
                exp: parseInlineCSS(p.value.content, p.loc),
                modifiers: [],
                loc: p.loc
              };
            }
          });
        }
      };
      var parseInlineCSS = (cssText, loc) => {
        const normalized = shared.parseStringStyle(cssText);
        return compilerCore.createSimpleExpression(
          JSON.stringify(normalized),
          false,
          loc,
          3
        );
      };
      function createDOMCompilerError(code, loc) {
        return compilerCore.createCompilerError(
          code,
          loc,
          DOMErrorMessages
        );
      }
      var DOMErrorMessages = {
        [53]: `v-html is missing expression.`,
        [54]: `v-html will override element children.`,
        [55]: `v-text is missing expression.`,
        [56]: `v-text will override element children.`,
        [57]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
        [58]: `v-model argument is not supported on plain elements.`,
        [59]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
        [60]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
        [61]: `v-show is missing expression.`,
        [62]: `<Transition> expects exactly one child element or component.`,
        [63]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
      };
      var transformVHtml = (dir, node, context) => {
        const { exp, loc } = dir;
        if (!exp) {
          context.onError(
            createDOMCompilerError(53, loc)
          );
        }
        if (node.children.length) {
          context.onError(
            createDOMCompilerError(54, loc)
          );
          node.children.length = 0;
        }
        return {
          props: [
            compilerCore.createObjectProperty(
              compilerCore.createSimpleExpression(`innerHTML`, true, loc),
              exp || compilerCore.createSimpleExpression("", true)
            )
          ]
        };
      };
      var transformVText = (dir, node, context) => {
        const { exp, loc } = dir;
        if (!exp) {
          context.onError(
            createDOMCompilerError(55, loc)
          );
        }
        if (node.children.length) {
          context.onError(
            createDOMCompilerError(56, loc)
          );
          node.children.length = 0;
        }
        return {
          props: [
            compilerCore.createObjectProperty(
              compilerCore.createSimpleExpression(`textContent`, true),
              exp ? compilerCore.getConstantType(exp, context) > 0 ? exp : compilerCore.createCallExpression(
                context.helperString(compilerCore.TO_DISPLAY_STRING),
                [exp],
                loc
              ) : compilerCore.createSimpleExpression("", true)
            )
          ]
        };
      };
      var transformModel = (dir, node, context) => {
        const baseResult = compilerCore.transformModel(dir, node, context);
        if (!baseResult.props.length || node.tagType === 1) {
          return baseResult;
        }
        if (dir.arg) {
          context.onError(
            createDOMCompilerError(
              58,
              dir.arg.loc
            )
          );
        }
        function checkDuplicatedValue() {
          const value = compilerCore.findProp(node, "value");
          if (value) {
            context.onError(
              createDOMCompilerError(
                60,
                value.loc
              )
            );
          }
        }
        const { tag } = node;
        const isCustomElement = context.isCustomElement(tag);
        if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
          let directiveToUse = V_MODEL_TEXT;
          let isInvalidType = false;
          if (tag === "input" || isCustomElement) {
            const type = compilerCore.findProp(node, `type`);
            if (type) {
              if (type.type === 7) {
                directiveToUse = V_MODEL_DYNAMIC;
              } else if (type.value) {
                switch (type.value.content) {
                  case "radio":
                    directiveToUse = V_MODEL_RADIO;
                    break;
                  case "checkbox":
                    directiveToUse = V_MODEL_CHECKBOX;
                    break;
                  case "file":
                    isInvalidType = true;
                    context.onError(
                      createDOMCompilerError(
                        59,
                        dir.loc
                      )
                    );
                    break;
                  default:
                    checkDuplicatedValue();
                    break;
                }
              }
            } else if (compilerCore.hasDynamicKeyVBind(node)) {
              directiveToUse = V_MODEL_DYNAMIC;
            } else {
              checkDuplicatedValue();
            }
          } else if (tag === "select") {
            directiveToUse = V_MODEL_SELECT;
          } else {
            checkDuplicatedValue();
          }
          if (!isInvalidType) {
            baseResult.needRuntime = context.helper(directiveToUse);
          }
        } else {
          context.onError(
            createDOMCompilerError(
              57,
              dir.loc
            )
          );
        }
        baseResult.props = baseResult.props.filter(
          (p) => !(p.key.type === 4 && p.key.content === "modelValue")
        );
        return baseResult;
      };
      var isEventOptionModifier = /* @__PURE__ */ shared.makeMap(`passive,once,capture`);
      var isNonKeyModifier = /* @__PURE__ */ shared.makeMap(
        // event propagation management
        `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`
      );
      var maybeKeyModifier = /* @__PURE__ */ shared.makeMap("left,right");
      var isKeyboardEvent = /* @__PURE__ */ shared.makeMap(
        `onkeyup,onkeydown,onkeypress`,
        true
      );
      var resolveModifiers = (key, modifiers, context, loc) => {
        const keyModifiers = [];
        const nonKeyModifiers = [];
        const eventOptionModifiers = [];
        for (let i = 0; i < modifiers.length; i++) {
          const modifier = modifiers[i];
          if (modifier === "native" && compilerCore.checkCompatEnabled(
            "COMPILER_V_ON_NATIVE",
            context,
            loc
          )) {
            eventOptionModifiers.push(modifier);
          } else if (isEventOptionModifier(modifier)) {
            eventOptionModifiers.push(modifier);
          } else {
            if (maybeKeyModifier(modifier)) {
              if (compilerCore.isStaticExp(key)) {
                if (isKeyboardEvent(key.content)) {
                  keyModifiers.push(modifier);
                } else {
                  nonKeyModifiers.push(modifier);
                }
              } else {
                keyModifiers.push(modifier);
                nonKeyModifiers.push(modifier);
              }
            } else {
              if (isNonKeyModifier(modifier)) {
                nonKeyModifiers.push(modifier);
              } else {
                keyModifiers.push(modifier);
              }
            }
          }
        }
        return {
          keyModifiers,
          nonKeyModifiers,
          eventOptionModifiers
        };
      };
      var transformClick = (key, event) => {
        const isStaticClick = compilerCore.isStaticExp(key) && key.content.toLowerCase() === "onclick";
        return isStaticClick ? compilerCore.createSimpleExpression(event, true) : key.type !== 4 ? compilerCore.createCompoundExpression([
          `(`,
          key,
          `) === "onClick" ? "${event}" : (`,
          key,
          `)`
        ]) : key;
      };
      var transformOn = (dir, node, context) => {
        return compilerCore.transformOn(dir, node, context, (baseResult) => {
          const { modifiers } = dir;
          if (!modifiers.length)
            return baseResult;
          let { key, value: handlerExp } = baseResult.props[0];
          const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
          if (nonKeyModifiers.includes("right")) {
            key = transformClick(key, `onContextmenu`);
          }
          if (nonKeyModifiers.includes("middle")) {
            key = transformClick(key, `onMouseup`);
          }
          if (nonKeyModifiers.length) {
            handlerExp = compilerCore.createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
              handlerExp,
              JSON.stringify(nonKeyModifiers)
            ]);
          }
          if (keyModifiers.length && // if event name is dynamic, always wrap with keys guard
          (!compilerCore.isStaticExp(key) || isKeyboardEvent(key.content))) {
            handlerExp = compilerCore.createCallExpression(context.helper(V_ON_WITH_KEYS), [
              handlerExp,
              JSON.stringify(keyModifiers)
            ]);
          }
          if (eventOptionModifiers.length) {
            const modifierPostfix = eventOptionModifiers.map(shared.capitalize).join("");
            key = compilerCore.isStaticExp(key) ? compilerCore.createSimpleExpression(`${key.content}${modifierPostfix}`, true) : compilerCore.createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
          }
          return {
            props: [compilerCore.createObjectProperty(key, handlerExp)]
          };
        });
      };
      var transformShow = (dir, node, context) => {
        const { exp, loc } = dir;
        if (!exp) {
          context.onError(
            createDOMCompilerError(61, loc)
          );
        }
        return {
          props: [],
          needRuntime: context.helper(V_SHOW)
        };
      };
      var transformTransition = (node, context) => {
        if (node.type === 1 && node.tagType === 1) {
          const component = context.isBuiltInComponent(node.tag);
          if (component === TRANSITION) {
            return () => {
              if (!node.children.length) {
                return;
              }
              if (hasMultipleChildren(node)) {
                context.onError(
                  createDOMCompilerError(
                    62,
                    {
                      start: node.children[0].loc.start,
                      end: node.children[node.children.length - 1].loc.end,
                      source: ""
                    }
                  )
                );
              }
              const child = node.children[0];
              if (child.type === 1) {
                for (const p of child.props) {
                  if (p.type === 7 && p.name === "show") {
                    node.props.push({
                      type: 6,
                      name: "persisted",
                      value: void 0,
                      loc: node.loc
                    });
                  }
                }
              }
            };
          }
        }
      };
      function hasMultipleChildren(node) {
        const children = node.children = node.children.filter(
          (c) => c.type !== 3 && !(c.type === 2 && !c.content.trim())
        );
        const child = children[0];
        return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
      }
      var expReplaceRE = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g;
      var stringifyStatic = (children, context, parent) => {
        if (context.scopes.vSlot > 0) {
          return;
        }
        let nc = 0;
        let ec = 0;
        const currentChunk = [];
        const stringifyCurrentChunk = (currentIndex) => {
          if (nc >= 20 || ec >= 5) {
            const staticCall = compilerCore.createCallExpression(context.helper(compilerCore.CREATE_STATIC), [
              JSON.stringify(
                currentChunk.map((node) => stringifyNode(node, context)).join("")
              ).replace(expReplaceRE, `" + $1 + "`),
              // the 2nd argument indicates the number of DOM nodes this static vnode
              // will insert / hydrate
              String(currentChunk.length)
            ]);
            replaceHoist(currentChunk[0], staticCall, context);
            if (currentChunk.length > 1) {
              for (let i2 = 1; i2 < currentChunk.length; i2++) {
                replaceHoist(currentChunk[i2], null, context);
              }
              const deleteCount = currentChunk.length - 1;
              children.splice(currentIndex - currentChunk.length + 1, deleteCount);
              return deleteCount;
            }
          }
          return 0;
        };
        let i = 0;
        for (; i < children.length; i++) {
          const child = children[i];
          const hoisted = getHoistedNode(child);
          if (hoisted) {
            const node = child;
            const result = analyzeNode(node);
            if (result) {
              nc += result[0];
              ec += result[1];
              currentChunk.push(node);
              continue;
            }
          }
          i -= stringifyCurrentChunk(i);
          nc = 0;
          ec = 0;
          currentChunk.length = 0;
        }
        stringifyCurrentChunk(i);
      };
      var getHoistedNode = (node) => (node.type === 1 && node.tagType === 0 || node.type == 12) && node.codegenNode && node.codegenNode.type === 4 && node.codegenNode.hoisted;
      var dataAriaRE = /^(data|aria)-/;
      var isStringifiableAttr = (name, ns) => {
        return (ns === 0 ? shared.isKnownHtmlAttr(name) : ns === 1 ? shared.isKnownSvgAttr(name) : false) || dataAriaRE.test(name);
      };
      var replaceHoist = (node, replacement, context) => {
        const hoistToReplace = node.codegenNode.hoisted;
        context.hoists[context.hoists.indexOf(hoistToReplace)] = replacement;
      };
      var isNonStringifiable = /* @__PURE__ */ shared.makeMap(
        `caption,thead,tr,th,tbody,td,tfoot,colgroup,col`
      );
      function analyzeNode(node) {
        if (node.type === 1 && isNonStringifiable(node.tag)) {
          return false;
        }
        if (node.type === 12) {
          return [1, 0];
        }
        let nc = 1;
        let ec = node.props.length > 0 ? 1 : 0;
        let bailed = false;
        const bail = () => {
          bailed = true;
          return false;
        };
        function walk(node2) {
          for (let i = 0; i < node2.props.length; i++) {
            const p = node2.props[i];
            if (p.type === 6 && !isStringifiableAttr(p.name, node2.ns)) {
              return bail();
            }
            if (p.type === 7 && p.name === "bind") {
              if (p.arg && (p.arg.type === 8 || p.arg.isStatic && !isStringifiableAttr(p.arg.content, node2.ns))) {
                return bail();
              }
              if (p.exp && (p.exp.type === 8 || p.exp.constType < 3)) {
                return bail();
              }
            }
          }
          for (let i = 0; i < node2.children.length; i++) {
            nc++;
            const child = node2.children[i];
            if (child.type === 1) {
              if (child.props.length > 0) {
                ec++;
              }
              walk(child);
              if (bailed) {
                return false;
              }
            }
          }
          return true;
        }
        return walk(node) ? [nc, ec] : false;
      }
      function stringifyNode(node, context) {
        if (shared.isString(node)) {
          return node;
        }
        if (shared.isSymbol(node)) {
          return ``;
        }
        switch (node.type) {
          case 1:
            return stringifyElement(node, context);
          case 2:
            return shared.escapeHtml(node.content);
          case 3:
            return `<!--${shared.escapeHtml(node.content)}-->`;
          case 5:
            return shared.escapeHtml(shared.toDisplayString(evaluateConstant(node.content)));
          case 8:
            return shared.escapeHtml(evaluateConstant(node));
          case 12:
            return stringifyNode(node.content, context);
          default:
            return "";
        }
      }
      function stringifyElement(node, context) {
        let res = `<${node.tag}`;
        let innerHTML = "";
        for (let i = 0; i < node.props.length; i++) {
          const p = node.props[i];
          if (p.type === 6) {
            res += ` ${p.name}`;
            if (p.value) {
              res += `="${shared.escapeHtml(p.value.content)}"`;
            }
          } else if (p.type === 7) {
            if (p.name === "bind") {
              const exp = p.exp;
              if (exp.content[0] === "_") {
                res += ` ${p.arg.content}="__VUE_EXP_START__${exp.content}__VUE_EXP_END__"`;
                continue;
              }
              if (shared.isBooleanAttr(p.arg.content) && exp.content === "false") {
                continue;
              }
              let evaluated = evaluateConstant(exp);
              if (evaluated != null) {
                const arg = p.arg && p.arg.content;
                if (arg === "class") {
                  evaluated = shared.normalizeClass(evaluated);
                } else if (arg === "style") {
                  evaluated = shared.stringifyStyle(shared.normalizeStyle(evaluated));
                }
                res += ` ${p.arg.content}="${shared.escapeHtml(
                  evaluated
                )}"`;
              }
            } else if (p.name === "html") {
              innerHTML = evaluateConstant(p.exp);
            } else if (p.name === "text") {
              innerHTML = shared.escapeHtml(
                shared.toDisplayString(evaluateConstant(p.exp))
              );
            }
          }
        }
        if (context.scopeId) {
          res += ` ${context.scopeId}`;
        }
        res += `>`;
        if (innerHTML) {
          res += innerHTML;
        } else {
          for (let i = 0; i < node.children.length; i++) {
            res += stringifyNode(node.children[i], context);
          }
        }
        if (!shared.isVoidTag(node.tag)) {
          res += `</${node.tag}>`;
        }
        return res;
      }
      function evaluateConstant(exp) {
        if (exp.type === 4) {
          return new Function(`return (${exp.content})`)();
        } else {
          let res = ``;
          exp.children.forEach((c) => {
            if (shared.isString(c) || shared.isSymbol(c)) {
              return;
            }
            if (c.type === 2) {
              res += c.content;
            } else if (c.type === 5) {
              res += shared.toDisplayString(evaluateConstant(c.content));
            } else {
              res += evaluateConstant(c);
            }
          });
          return res;
        }
      }
      var ignoreSideEffectTags = (node, context) => {
        if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
          context.onError(
            createDOMCompilerError(
              63,
              node.loc
            )
          );
          context.removeNode();
        }
      };
      var DOMNodeTransforms = [
        transformStyle,
        ...[transformTransition]
      ];
      var DOMDirectiveTransforms = {
        cloak: compilerCore.noopDirectiveTransform,
        html: transformVHtml,
        text: transformVText,
        model: transformModel,
        // override compiler-core
        on: transformOn,
        // override compiler-core
        show: transformShow
      };
      function compile(template, options = {}) {
        return compilerCore.baseCompile(
          template,
          shared.extend({}, parserOptions, options, {
            nodeTransforms: [
              // ignore <script> and <tag>
              // this is not put inside DOMNodeTransforms because that list is used
              // by compiler-ssr to generate vnode fallback branches
              ignoreSideEffectTags,
              ...DOMNodeTransforms,
              ...options.nodeTransforms || []
            ],
            directiveTransforms: shared.extend(
              {},
              DOMDirectiveTransforms,
              options.directiveTransforms || {}
            ),
            transformHoist: stringifyStatic
          })
        );
      }
      function parse(template, options = {}) {
        return compilerCore.baseParse(template, shared.extend({}, parserOptions, options));
      }
      exports.DOMDirectiveTransforms = DOMDirectiveTransforms;
      exports.DOMNodeTransforms = DOMNodeTransforms;
      exports.TRANSITION = TRANSITION;
      exports.TRANSITION_GROUP = TRANSITION_GROUP;
      exports.V_MODEL_CHECKBOX = V_MODEL_CHECKBOX;
      exports.V_MODEL_DYNAMIC = V_MODEL_DYNAMIC;
      exports.V_MODEL_RADIO = V_MODEL_RADIO;
      exports.V_MODEL_SELECT = V_MODEL_SELECT;
      exports.V_MODEL_TEXT = V_MODEL_TEXT;
      exports.V_ON_WITH_KEYS = V_ON_WITH_KEYS;
      exports.V_ON_WITH_MODIFIERS = V_ON_WITH_MODIFIERS;
      exports.V_SHOW = V_SHOW;
      exports.compile = compile;
      exports.createDOMCompilerError = createDOMCompilerError;
      exports.parse = parse;
      exports.parserOptions = parserOptions;
      exports.transformStyle = transformStyle;
      Object.keys(compilerCore).forEach(function(k) {
        if (k !== "default" && !exports.hasOwnProperty(k))
          exports[k] = compilerCore[k];
      });
    }
  });

  // node_modules/@vue/compiler-dom/index.js
  var require_compiler_dom = __commonJS({
    "node_modules/@vue/compiler-dom/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_compiler_dom_cjs();
      }
    }
  });

  // node_modules/@vue/reactivity/dist/reactivity.cjs.js
  var require_reactivity_cjs = __commonJS({
    "node_modules/@vue/reactivity/dist/reactivity.cjs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var shared = require_shared();
      function warn(msg, ...args) {
        console.warn(`[Vue warn] ${msg}`, ...args);
      }
      var activeEffectScope;
      var EffectScope = class {
        constructor(detached = false) {
          this.detached = detached;
          this._active = true;
          this.effects = [];
          this.cleanups = [];
          this.parent = activeEffectScope;
          if (!detached && activeEffectScope) {
            this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
              this
            ) - 1;
          }
        }
        get active() {
          return this._active;
        }
        run(fn) {
          if (this._active) {
            const currentEffectScope = activeEffectScope;
            try {
              activeEffectScope = this;
              return fn();
            } finally {
              activeEffectScope = currentEffectScope;
            }
          } else {
            warn(`cannot run an inactive effect scope.`);
          }
        }
        /**
         * This should only be called on non-detached scopes
         * @internal
         */
        on() {
          activeEffectScope = this;
        }
        /**
         * This should only be called on non-detached scopes
         * @internal
         */
        off() {
          activeEffectScope = this.parent;
        }
        stop(fromParent) {
          if (this._active) {
            let i, l;
            for (i = 0, l = this.effects.length; i < l; i++) {
              this.effects[i].stop();
            }
            for (i = 0, l = this.cleanups.length; i < l; i++) {
              this.cleanups[i]();
            }
            if (this.scopes) {
              for (i = 0, l = this.scopes.length; i < l; i++) {
                this.scopes[i].stop(true);
              }
            }
            if (!this.detached && this.parent && !fromParent) {
              const last = this.parent.scopes.pop();
              if (last && last !== this) {
                this.parent.scopes[this.index] = last;
                last.index = this.index;
              }
            }
            this.parent = void 0;
            this._active = false;
          }
        }
      };
      function effectScope(detached) {
        return new EffectScope(detached);
      }
      function recordEffectScope(effect2, scope = activeEffectScope) {
        if (scope && scope.active) {
          scope.effects.push(effect2);
        }
      }
      function getCurrentScope() {
        return activeEffectScope;
      }
      function onScopeDispose(fn) {
        if (activeEffectScope) {
          activeEffectScope.cleanups.push(fn);
        } else {
          warn(
            `onScopeDispose() is called when there is no active effect scope to be associated with.`
          );
        }
      }
      var createDep = (effects) => {
        const dep = new Set(effects);
        dep.w = 0;
        dep.n = 0;
        return dep;
      };
      var wasTracked = (dep) => (dep.w & trackOpBit) > 0;
      var newTracked = (dep) => (dep.n & trackOpBit) > 0;
      var initDepMarkers = ({ deps }) => {
        if (deps.length) {
          for (let i = 0; i < deps.length; i++) {
            deps[i].w |= trackOpBit;
          }
        }
      };
      var finalizeDepMarkers = (effect2) => {
        const { deps } = effect2;
        if (deps.length) {
          let ptr = 0;
          for (let i = 0; i < deps.length; i++) {
            const dep = deps[i];
            if (wasTracked(dep) && !newTracked(dep)) {
              dep.delete(effect2);
            } else {
              deps[ptr++] = dep;
            }
            dep.w &= ~trackOpBit;
            dep.n &= ~trackOpBit;
          }
          deps.length = ptr;
        }
      };
      var targetMap = /* @__PURE__ */ new WeakMap();
      var effectTrackDepth = 0;
      var trackOpBit = 1;
      var maxMarkerBits = 30;
      var activeEffect;
      var ITERATE_KEY = Symbol("iterate");
      var MAP_KEY_ITERATE_KEY = Symbol("Map key iterate");
      var ReactiveEffect = class {
        constructor(fn, scheduler2 = null, scope) {
          this.fn = fn;
          this.scheduler = scheduler2;
          this.active = true;
          this.deps = [];
          this.parent = void 0;
          recordEffectScope(this, scope);
        }
        run() {
          if (!this.active) {
            return this.fn();
          }
          let parent = activeEffect;
          let lastShouldTrack = shouldTrack;
          while (parent) {
            if (parent === this) {
              return;
            }
            parent = parent.parent;
          }
          try {
            this.parent = activeEffect;
            activeEffect = this;
            shouldTrack = true;
            trackOpBit = 1 << ++effectTrackDepth;
            if (effectTrackDepth <= maxMarkerBits) {
              initDepMarkers(this);
            } else {
              cleanupEffect(this);
            }
            return this.fn();
          } finally {
            if (effectTrackDepth <= maxMarkerBits) {
              finalizeDepMarkers(this);
            }
            trackOpBit = 1 << --effectTrackDepth;
            activeEffect = this.parent;
            shouldTrack = lastShouldTrack;
            this.parent = void 0;
            if (this.deferStop) {
              this.stop();
            }
          }
        }
        stop() {
          if (activeEffect === this) {
            this.deferStop = true;
          } else if (this.active) {
            cleanupEffect(this);
            if (this.onStop) {
              this.onStop();
            }
            this.active = false;
          }
        }
      };
      function cleanupEffect(effect2) {
        const { deps } = effect2;
        if (deps.length) {
          for (let i = 0; i < deps.length; i++) {
            deps[i].delete(effect2);
          }
          deps.length = 0;
        }
      }
      function effect(fn, options) {
        if (fn.effect) {
          fn = fn.effect.fn;
        }
        const _effect = new ReactiveEffect(fn);
        if (options) {
          shared.extend(_effect, options);
          if (options.scope)
            recordEffectScope(_effect, options.scope);
        }
        if (!options || !options.lazy) {
          _effect.run();
        }
        const runner = _effect.run.bind(_effect);
        runner.effect = _effect;
        return runner;
      }
      function stop(runner) {
        runner.effect.stop();
      }
      var shouldTrack = true;
      var trackStack = [];
      function pauseTracking() {
        trackStack.push(shouldTrack);
        shouldTrack = false;
      }
      function enableTracking() {
        trackStack.push(shouldTrack);
        shouldTrack = true;
      }
      function resetTracking() {
        const last = trackStack.pop();
        shouldTrack = last === void 0 ? true : last;
      }
      function track(target, type, key) {
        if (shouldTrack && activeEffect) {
          let depsMap = targetMap.get(target);
          if (!depsMap) {
            targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
          }
          let dep = depsMap.get(key);
          if (!dep) {
            depsMap.set(key, dep = createDep());
          }
          const eventInfo = { effect: activeEffect, target, type, key };
          trackEffects(dep, eventInfo);
        }
      }
      function trackEffects(dep, debuggerEventExtraInfo) {
        let shouldTrack2 = false;
        if (effectTrackDepth <= maxMarkerBits) {
          if (!newTracked(dep)) {
            dep.n |= trackOpBit;
            shouldTrack2 = !wasTracked(dep);
          }
        } else {
          shouldTrack2 = !dep.has(activeEffect);
        }
        if (shouldTrack2) {
          dep.add(activeEffect);
          activeEffect.deps.push(dep);
          if (activeEffect.onTrack) {
            activeEffect.onTrack(
              shared.extend(
                {
                  effect: activeEffect
                },
                debuggerEventExtraInfo
              )
            );
          }
        }
      }
      function trigger(target, type, key, newValue, oldValue, oldTarget) {
        const depsMap = targetMap.get(target);
        if (!depsMap) {
          return;
        }
        let deps = [];
        if (type === "clear") {
          deps = [...depsMap.values()];
        } else if (key === "length" && shared.isArray(target)) {
          const newLength = Number(newValue);
          depsMap.forEach((dep, key2) => {
            if (key2 === "length" || key2 >= newLength) {
              deps.push(dep);
            }
          });
        } else {
          if (key !== void 0) {
            deps.push(depsMap.get(key));
          }
          switch (type) {
            case "add":
              if (!shared.isArray(target)) {
                deps.push(depsMap.get(ITERATE_KEY));
                if (shared.isMap(target)) {
                  deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
              } else if (shared.isIntegerKey(key)) {
                deps.push(depsMap.get("length"));
              }
              break;
            case "delete":
              if (!shared.isArray(target)) {
                deps.push(depsMap.get(ITERATE_KEY));
                if (shared.isMap(target)) {
                  deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
              }
              break;
            case "set":
              if (shared.isMap(target)) {
                deps.push(depsMap.get(ITERATE_KEY));
              }
              break;
          }
        }
        const eventInfo = { target, type, key, newValue, oldValue, oldTarget };
        if (deps.length === 1) {
          if (deps[0]) {
            {
              triggerEffects(deps[0], eventInfo);
            }
          }
        } else {
          const effects = [];
          for (const dep of deps) {
            if (dep) {
              effects.push(...dep);
            }
          }
          {
            triggerEffects(createDep(effects), eventInfo);
          }
        }
      }
      function triggerEffects(dep, debuggerEventExtraInfo) {
        const effects = shared.isArray(dep) ? dep : [...dep];
        for (const effect2 of effects) {
          if (effect2.computed) {
            triggerEffect(effect2, debuggerEventExtraInfo);
          }
        }
        for (const effect2 of effects) {
          if (!effect2.computed) {
            triggerEffect(effect2, debuggerEventExtraInfo);
          }
        }
      }
      function triggerEffect(effect2, debuggerEventExtraInfo) {
        if (effect2 !== activeEffect || effect2.allowRecurse) {
          if (effect2.onTrigger) {
            effect2.onTrigger(shared.extend({ effect: effect2 }, debuggerEventExtraInfo));
          }
          if (effect2.scheduler) {
            effect2.scheduler();
          } else {
            effect2.run();
          }
        }
      }
      function getDepFromReactive(object, key) {
        var _a;
        return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);
      }
      var isNonTrackableKeys = /* @__PURE__ */ shared.makeMap(`__proto__,__v_isRef,__isVue`);
      var builtInSymbols = new Set(
        /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(shared.isSymbol)
      );
      var get$1 = /* @__PURE__ */ createGetter();
      var shallowGet = /* @__PURE__ */ createGetter(false, true);
      var readonlyGet = /* @__PURE__ */ createGetter(true);
      var shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
      var arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
      function createArrayInstrumentations() {
        const instrumentations = {};
        ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
          instrumentations[key] = function(...args) {
            const arr = toRaw(this);
            for (let i = 0, l = this.length; i < l; i++) {
              track(arr, "get", i + "");
            }
            const res = arr[key](...args);
            if (res === -1 || res === false) {
              return arr[key](...args.map(toRaw));
            } else {
              return res;
            }
          };
        });
        ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
          instrumentations[key] = function(...args) {
            pauseTracking();
            const res = toRaw(this)[key].apply(this, args);
            resetTracking();
            return res;
          };
        });
        return instrumentations;
      }
      function hasOwnProperty(key) {
        const obj = toRaw(this);
        track(obj, "has", key);
        return obj.hasOwnProperty(key);
      }
      function createGetter(isReadonly2 = false, shallow = false) {
        return function get2(target, key, receiver) {
          if (key === "__v_isReactive") {
            return !isReadonly2;
          } else if (key === "__v_isReadonly") {
            return isReadonly2;
          } else if (key === "__v_isShallow") {
            return shallow;
          } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
            return target;
          }
          const targetIsArray = shared.isArray(target);
          if (!isReadonly2) {
            if (targetIsArray && shared.hasOwn(arrayInstrumentations, key)) {
              return Reflect.get(arrayInstrumentations, key, receiver);
            }
            if (key === "hasOwnProperty") {
              return hasOwnProperty;
            }
          }
          const res = Reflect.get(target, key, receiver);
          if (shared.isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
            return res;
          }
          if (!isReadonly2) {
            track(target, "get", key);
          }
          if (shallow) {
            return res;
          }
          if (isRef(res)) {
            return targetIsArray && shared.isIntegerKey(key) ? res : res.value;
          }
          if (shared.isObject(res)) {
            return isReadonly2 ? readonly(res) : reactive(res);
          }
          return res;
        };
      }
      var set$1 = /* @__PURE__ */ createSetter();
      var shallowSet = /* @__PURE__ */ createSetter(true);
      function createSetter(shallow = false) {
        return function set2(target, key, value, receiver) {
          let oldValue = target[key];
          if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
            return false;
          }
          if (!shallow) {
            if (!isShallow(value) && !isReadonly(value)) {
              oldValue = toRaw(oldValue);
              value = toRaw(value);
            }
            if (!shared.isArray(target) && isRef(oldValue) && !isRef(value)) {
              oldValue.value = value;
              return true;
            }
          }
          const hadKey = shared.isArray(target) && shared.isIntegerKey(key) ? Number(key) < target.length : shared.hasOwn(target, key);
          const result = Reflect.set(target, key, value, receiver);
          if (target === toRaw(receiver)) {
            if (!hadKey) {
              trigger(target, "add", key, value);
            } else if (shared.hasChanged(value, oldValue)) {
              trigger(target, "set", key, value, oldValue);
            }
          }
          return result;
        };
      }
      function deleteProperty(target, key) {
        const hadKey = shared.hasOwn(target, key);
        const oldValue = target[key];
        const result = Reflect.deleteProperty(target, key);
        if (result && hadKey) {
          trigger(target, "delete", key, void 0, oldValue);
        }
        return result;
      }
      function has$1(target, key) {
        const result = Reflect.has(target, key);
        if (!shared.isSymbol(key) || !builtInSymbols.has(key)) {
          track(target, "has", key);
        }
        return result;
      }
      function ownKeys(target) {
        track(target, "iterate", shared.isArray(target) ? "length" : ITERATE_KEY);
        return Reflect.ownKeys(target);
      }
      var mutableHandlers = {
        get: get$1,
        set: set$1,
        deleteProperty,
        has: has$1,
        ownKeys
      };
      var readonlyHandlers = {
        get: readonlyGet,
        set(target, key) {
          {
            warn(
              `Set operation on key "${String(key)}" failed: target is readonly.`,
              target
            );
          }
          return true;
        },
        deleteProperty(target, key) {
          {
            warn(
              `Delete operation on key "${String(key)}" failed: target is readonly.`,
              target
            );
          }
          return true;
        }
      };
      var shallowReactiveHandlers = /* @__PURE__ */ shared.extend(
        {},
        mutableHandlers,
        {
          get: shallowGet,
          set: shallowSet
        }
      );
      var shallowReadonlyHandlers = /* @__PURE__ */ shared.extend(
        {},
        readonlyHandlers,
        {
          get: shallowReadonlyGet
        }
      );
      var toShallow = (value) => value;
      var getProto = (v) => Reflect.getPrototypeOf(v);
      function get(target, key, isReadonly2 = false, isShallow2 = false) {
        target = target["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!isReadonly2) {
          if (key !== rawKey) {
            track(rawTarget, "get", key);
          }
          track(rawTarget, "get", rawKey);
        }
        const { has: has2 } = getProto(rawTarget);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        if (has2.call(rawTarget, key)) {
          return wrap(target.get(key));
        } else if (has2.call(rawTarget, rawKey)) {
          return wrap(target.get(rawKey));
        } else if (target !== rawTarget) {
          target.get(key);
        }
      }
      function has(key, isReadonly2 = false) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!isReadonly2) {
          if (key !== rawKey) {
            track(rawTarget, "has", key);
          }
          track(rawTarget, "has", rawKey);
        }
        return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
      }
      function size(target, isReadonly2 = false) {
        target = target["__v_raw"];
        !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
        return Reflect.get(target, "size", target);
      }
      function add(value) {
        value = toRaw(value);
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger(target, "add", value, value);
        }
        return this;
      }
      function set(key, value) {
        value = toRaw(value);
        const target = toRaw(this);
        const { has: has2, get: get2 } = getProto(target);
        let hadKey = has2.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has2.call(target, key);
        } else {
          checkIdentityKeys(target, has2, key);
        }
        const oldValue = get2.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (shared.hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
        return this;
      }
      function deleteEntry(key) {
        const target = toRaw(this);
        const { has: has2, get: get2 } = getProto(target);
        let hadKey = has2.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has2.call(target, key);
        } else {
          checkIdentityKeys(target, has2, key);
        }
        const oldValue = get2 ? get2.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0, oldValue);
        }
        return result;
      }
      function clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const oldTarget = shared.isMap(target) ? new Map(target) : new Set(target);
        const result = target.clear();
        if (hadItems) {
          trigger(target, "clear", void 0, void 0, oldTarget);
        }
        return result;
      }
      function createForEach(isReadonly2, isShallow2) {
        return function forEach(callback, thisArg) {
          const observed = this;
          const target = observed["__v_raw"];
          const rawTarget = toRaw(target);
          const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
          !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
          return target.forEach((value, key) => {
            return callback.call(thisArg, wrap(value), wrap(key), observed);
          });
        };
      }
      function createIterableMethod(method, isReadonly2, isShallow2) {
        return function(...args) {
          const target = this["__v_raw"];
          const rawTarget = toRaw(target);
          const targetIsMap = shared.isMap(rawTarget);
          const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
          const isKeyOnly = method === "keys" && targetIsMap;
          const innerIterator = target[method](...args);
          const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
          !isReadonly2 && track(
            rawTarget,
            "iterate",
            isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
          );
          return {
            // iterator protocol
            next() {
              const { value, done } = innerIterator.next();
              return done ? { value, done } : {
                value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
                done
              };
            },
            // iterable protocol
            [Symbol.iterator]() {
              return this;
            }
          };
        };
      }
      function createReadonlyMethod(type) {
        return function(...args) {
          {
            const key = args[0] ? `on key "${args[0]}" ` : ``;
            console.warn(
              `${shared.capitalize(type)} operation ${key}failed: target is readonly.`,
              toRaw(this)
            );
          }
          return type === "delete" ? false : this;
        };
      }
      function createInstrumentations() {
        const mutableInstrumentations2 = {
          get(key) {
            return get(this, key);
          },
          get size() {
            return size(this);
          },
          has,
          add,
          set,
          delete: deleteEntry,
          clear,
          forEach: createForEach(false, false)
        };
        const shallowInstrumentations2 = {
          get(key) {
            return get(this, key, false, true);
          },
          get size() {
            return size(this);
          },
          has,
          add,
          set,
          delete: deleteEntry,
          clear,
          forEach: createForEach(false, true)
        };
        const readonlyInstrumentations2 = {
          get(key) {
            return get(this, key, true);
          },
          get size() {
            return size(this, true);
          },
          has(key) {
            return has.call(this, key, true);
          },
          add: createReadonlyMethod("add"),
          set: createReadonlyMethod("set"),
          delete: createReadonlyMethod("delete"),
          clear: createReadonlyMethod("clear"),
          forEach: createForEach(true, false)
        };
        const shallowReadonlyInstrumentations2 = {
          get(key) {
            return get(this, key, true, true);
          },
          get size() {
            return size(this, true);
          },
          has(key) {
            return has.call(this, key, true);
          },
          add: createReadonlyMethod("add"),
          set: createReadonlyMethod("set"),
          delete: createReadonlyMethod("delete"),
          clear: createReadonlyMethod("clear"),
          forEach: createForEach(true, true)
        };
        const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
        iteratorMethods.forEach((method) => {
          mutableInstrumentations2[method] = createIterableMethod(
            method,
            false,
            false
          );
          readonlyInstrumentations2[method] = createIterableMethod(
            method,
            true,
            false
          );
          shallowInstrumentations2[method] = createIterableMethod(
            method,
            false,
            true
          );
          shallowReadonlyInstrumentations2[method] = createIterableMethod(
            method,
            true,
            true
          );
        });
        return [
          mutableInstrumentations2,
          readonlyInstrumentations2,
          shallowInstrumentations2,
          shallowReadonlyInstrumentations2
        ];
      }
      var [
        mutableInstrumentations,
        readonlyInstrumentations,
        shallowInstrumentations,
        shallowReadonlyInstrumentations
      ] = /* @__PURE__ */ createInstrumentations();
      function createInstrumentationGetter(isReadonly2, shallow) {
        const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
        return (target, key, receiver) => {
          if (key === "__v_isReactive") {
            return !isReadonly2;
          } else if (key === "__v_isReadonly") {
            return isReadonly2;
          } else if (key === "__v_raw") {
            return target;
          }
          return Reflect.get(
            shared.hasOwn(instrumentations, key) && key in target ? instrumentations : target,
            key,
            receiver
          );
        };
      }
      var mutableCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(false, false)
      };
      var shallowCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(false, true)
      };
      var readonlyCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(true, false)
      };
      var shallowReadonlyCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(true, true)
      };
      function checkIdentityKeys(target, has2, key) {
        const rawKey = toRaw(key);
        if (rawKey !== key && has2.call(target, rawKey)) {
          const type = shared.toRawType(target);
          console.warn(
            `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
          );
        }
      }
      var reactiveMap = /* @__PURE__ */ new WeakMap();
      var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
      var readonlyMap = /* @__PURE__ */ new WeakMap();
      var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
      function targetTypeMap(rawType) {
        switch (rawType) {
          case "Object":
          case "Array":
            return 1;
          case "Map":
          case "Set":
          case "WeakMap":
          case "WeakSet":
            return 2;
          default:
            return 0;
        }
      }
      function getTargetType(value) {
        return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(shared.toRawType(value));
      }
      function reactive(target) {
        if (isReadonly(target)) {
          return target;
        }
        return createReactiveObject(
          target,
          false,
          mutableHandlers,
          mutableCollectionHandlers,
          reactiveMap
        );
      }
      function shallowReactive(target) {
        return createReactiveObject(
          target,
          false,
          shallowReactiveHandlers,
          shallowCollectionHandlers,
          shallowReactiveMap
        );
      }
      function readonly(target) {
        return createReactiveObject(
          target,
          true,
          readonlyHandlers,
          readonlyCollectionHandlers,
          readonlyMap
        );
      }
      function shallowReadonly(target) {
        return createReactiveObject(
          target,
          true,
          shallowReadonlyHandlers,
          shallowReadonlyCollectionHandlers,
          shallowReadonlyMap
        );
      }
      function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
        if (!shared.isObject(target)) {
          {
            console.warn(`value cannot be made reactive: ${String(target)}`);
          }
          return target;
        }
        if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
          return target;
        }
        const existingProxy = proxyMap.get(target);
        if (existingProxy) {
          return existingProxy;
        }
        const targetType = getTargetType(target);
        if (targetType === 0) {
          return target;
        }
        const proxy = new Proxy(
          target,
          targetType === 2 ? collectionHandlers : baseHandlers
        );
        proxyMap.set(target, proxy);
        return proxy;
      }
      function isReactive(value) {
        if (isReadonly(value)) {
          return isReactive(value["__v_raw"]);
        }
        return !!(value && value["__v_isReactive"]);
      }
      function isReadonly(value) {
        return !!(value && value["__v_isReadonly"]);
      }
      function isShallow(value) {
        return !!(value && value["__v_isShallow"]);
      }
      function isProxy(value) {
        return isReactive(value) || isReadonly(value);
      }
      function toRaw(observed) {
        const raw = observed && observed["__v_raw"];
        return raw ? toRaw(raw) : observed;
      }
      function markRaw(value) {
        shared.def(value, "__v_skip", true);
        return value;
      }
      var toReactive = (value) => shared.isObject(value) ? reactive(value) : value;
      var toReadonly = (value) => shared.isObject(value) ? readonly(value) : value;
      function trackRefValue(ref2) {
        if (shouldTrack && activeEffect) {
          ref2 = toRaw(ref2);
          {
            trackEffects(ref2.dep || (ref2.dep = createDep()), {
              target: ref2,
              type: "get",
              key: "value"
            });
          }
        }
      }
      function triggerRefValue(ref2, newVal) {
        ref2 = toRaw(ref2);
        const dep = ref2.dep;
        if (dep) {
          {
            triggerEffects(dep, {
              target: ref2,
              type: "set",
              key: "value",
              newValue: newVal
            });
          }
        }
      }
      function isRef(r) {
        return !!(r && r.__v_isRef === true);
      }
      function ref(value) {
        return createRef(value, false);
      }
      function shallowRef(value) {
        return createRef(value, true);
      }
      function createRef(rawValue, shallow) {
        if (isRef(rawValue)) {
          return rawValue;
        }
        return new RefImpl(rawValue, shallow);
      }
      var RefImpl = class {
        constructor(value, __v_isShallow) {
          this.__v_isShallow = __v_isShallow;
          this.dep = void 0;
          this.__v_isRef = true;
          this._rawValue = __v_isShallow ? value : toRaw(value);
          this._value = __v_isShallow ? value : toReactive(value);
        }
        get value() {
          trackRefValue(this);
          return this._value;
        }
        set value(newVal) {
          const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
          newVal = useDirectValue ? newVal : toRaw(newVal);
          if (shared.hasChanged(newVal, this._rawValue)) {
            this._rawValue = newVal;
            this._value = useDirectValue ? newVal : toReactive(newVal);
            triggerRefValue(this, newVal);
          }
        }
      };
      function triggerRef(ref2) {
        triggerRefValue(ref2, ref2.value);
      }
      function unref(ref2) {
        return isRef(ref2) ? ref2.value : ref2;
      }
      function toValue(source) {
        return shared.isFunction(source) ? source() : unref(source);
      }
      var shallowUnwrapHandlers = {
        get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
        set: (target, key, value, receiver) => {
          const oldValue = target[key];
          if (isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
          } else {
            return Reflect.set(target, key, value, receiver);
          }
        }
      };
      function proxyRefs(objectWithRefs) {
        return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
      }
      var CustomRefImpl = class {
        constructor(factory) {
          this.dep = void 0;
          this.__v_isRef = true;
          const { get: get2, set: set2 } = factory(
            () => trackRefValue(this),
            () => triggerRefValue(this)
          );
          this._get = get2;
          this._set = set2;
        }
        get value() {
          return this._get();
        }
        set value(newVal) {
          this._set(newVal);
        }
      };
      function customRef(factory) {
        return new CustomRefImpl(factory);
      }
      function toRefs(object) {
        if (!isProxy(object)) {
          console.warn(`toRefs() expects a reactive object but received a plain one.`);
        }
        const ret = shared.isArray(object) ? new Array(object.length) : {};
        for (const key in object) {
          ret[key] = propertyToRef(object, key);
        }
        return ret;
      }
      var ObjectRefImpl = class {
        constructor(_object, _key, _defaultValue) {
          this._object = _object;
          this._key = _key;
          this._defaultValue = _defaultValue;
          this.__v_isRef = true;
        }
        get value() {
          const val = this._object[this._key];
          return val === void 0 ? this._defaultValue : val;
        }
        set value(newVal) {
          this._object[this._key] = newVal;
        }
        get dep() {
          return getDepFromReactive(toRaw(this._object), this._key);
        }
      };
      var GetterRefImpl = class {
        constructor(_getter) {
          this._getter = _getter;
          this.__v_isRef = true;
          this.__v_isReadonly = true;
        }
        get value() {
          return this._getter();
        }
      };
      function toRef(source, key, defaultValue) {
        if (isRef(source)) {
          return source;
        } else if (shared.isFunction(source)) {
          return new GetterRefImpl(source);
        } else if (shared.isObject(source) && arguments.length > 1) {
          return propertyToRef(source, key, defaultValue);
        } else {
          return ref(source);
        }
      }
      function propertyToRef(source, key, defaultValue) {
        const val = source[key];
        return isRef(val) ? val : new ObjectRefImpl(
          source,
          key,
          defaultValue
        );
      }
      var ComputedRefImpl = class {
        constructor(getter, _setter, isReadonly2, isSSR) {
          this._setter = _setter;
          this.dep = void 0;
          this.__v_isRef = true;
          this["__v_isReadonly"] = false;
          this._dirty = true;
          this.effect = new ReactiveEffect(getter, () => {
            if (!this._dirty) {
              this._dirty = true;
              triggerRefValue(this);
            }
          });
          this.effect.computed = this;
          this.effect.active = this._cacheable = !isSSR;
          this["__v_isReadonly"] = isReadonly2;
        }
        get value() {
          const self2 = toRaw(this);
          trackRefValue(self2);
          if (self2._dirty || !self2._cacheable) {
            self2._dirty = false;
            self2._value = self2.effect.run();
          }
          return self2._value;
        }
        set value(newValue) {
          this._setter(newValue);
        }
      };
      function computed(getterOrOptions, debugOptions, isSSR = false) {
        let getter;
        let setter;
        const onlyGetter = shared.isFunction(getterOrOptions);
        if (onlyGetter) {
          getter = getterOrOptions;
          setter = () => {
            console.warn("Write operation failed: computed value is readonly");
          };
        } else {
          getter = getterOrOptions.get;
          setter = getterOrOptions.set;
        }
        const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
        if (debugOptions && !isSSR) {
          cRef.effect.onTrack = debugOptions.onTrack;
          cRef.effect.onTrigger = debugOptions.onTrigger;
        }
        return cRef;
      }
      var tick = /* @__PURE__ */ Promise.resolve();
      var queue = [];
      var queued = false;
      var scheduler = (fn) => {
        queue.push(fn);
        if (!queued) {
          queued = true;
          tick.then(flush);
        }
      };
      var flush = () => {
        for (let i = 0; i < queue.length; i++) {
          queue[i]();
        }
        queue.length = 0;
        queued = false;
      };
      var DeferredComputedRefImpl = class {
        constructor(getter) {
          this.dep = void 0;
          this._dirty = true;
          this.__v_isRef = true;
          this["__v_isReadonly"] = true;
          let compareTarget;
          let hasCompareTarget = false;
          let scheduled = false;
          this.effect = new ReactiveEffect(getter, (computedTrigger) => {
            if (this.dep) {
              if (computedTrigger) {
                compareTarget = this._value;
                hasCompareTarget = true;
              } else if (!scheduled) {
                const valueToCompare = hasCompareTarget ? compareTarget : this._value;
                scheduled = true;
                hasCompareTarget = false;
                scheduler(() => {
                  if (this.effect.active && this._get() !== valueToCompare) {
                    triggerRefValue(this);
                  }
                  scheduled = false;
                });
              }
              for (const e of this.dep) {
                if (e.computed instanceof DeferredComputedRefImpl) {
                  e.scheduler(
                    true
                    /* computedTrigger */
                  );
                }
              }
            }
            this._dirty = true;
          });
          this.effect.computed = this;
        }
        _get() {
          if (this._dirty) {
            this._dirty = false;
            return this._value = this.effect.run();
          }
          return this._value;
        }
        get value() {
          trackRefValue(this);
          return toRaw(this)._get();
        }
      };
      function deferredComputed(getter) {
        return new DeferredComputedRefImpl(getter);
      }
      exports.EffectScope = EffectScope;
      exports.ITERATE_KEY = ITERATE_KEY;
      exports.ReactiveEffect = ReactiveEffect;
      exports.computed = computed;
      exports.customRef = customRef;
      exports.deferredComputed = deferredComputed;
      exports.effect = effect;
      exports.effectScope = effectScope;
      exports.enableTracking = enableTracking;
      exports.getCurrentScope = getCurrentScope;
      exports.isProxy = isProxy;
      exports.isReactive = isReactive;
      exports.isReadonly = isReadonly;
      exports.isRef = isRef;
      exports.isShallow = isShallow;
      exports.markRaw = markRaw;
      exports.onScopeDispose = onScopeDispose;
      exports.pauseTracking = pauseTracking;
      exports.proxyRefs = proxyRefs;
      exports.reactive = reactive;
      exports.readonly = readonly;
      exports.ref = ref;
      exports.resetTracking = resetTracking;
      exports.shallowReactive = shallowReactive;
      exports.shallowReadonly = shallowReadonly;
      exports.shallowRef = shallowRef;
      exports.stop = stop;
      exports.toRaw = toRaw;
      exports.toRef = toRef;
      exports.toRefs = toRefs;
      exports.toValue = toValue;
      exports.track = track;
      exports.trigger = trigger;
      exports.triggerRef = triggerRef;
      exports.unref = unref;
    }
  });

  // node_modules/@vue/reactivity/index.js
  var require_reactivity = __commonJS({
    "node_modules/@vue/reactivity/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_reactivity_cjs();
      }
    }
  });

  // node_modules/@vue/runtime-core/dist/runtime-core.cjs.js
  var require_runtime_core_cjs = __commonJS({
    "node_modules/@vue/runtime-core/dist/runtime-core.cjs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var reactivity = require_reactivity();
      var shared = require_shared();
      var stack = [];
      function pushWarningContext(vnode) {
        stack.push(vnode);
      }
      function popWarningContext() {
        stack.pop();
      }
      function warn(msg, ...args) {
        reactivity.pauseTracking();
        const instance = stack.length ? stack[stack.length - 1].component : null;
        const appWarnHandler = instance && instance.appContext.config.warnHandler;
        const trace = getComponentTrace();
        if (appWarnHandler) {
          callWithErrorHandling(
            appWarnHandler,
            instance,
            11,
            [
              msg + args.join(""),
              instance && instance.proxy,
              trace.map(
                ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
              ).join("\n"),
              trace
            ]
          );
        } else {
          const warnArgs = [`[Vue warn]: ${msg}`, ...args];
          if (trace.length && // avoid spamming console during tests
          true) {
            warnArgs.push(`
`, ...formatTrace(trace));
          }
          console.warn(...warnArgs);
        }
        reactivity.resetTracking();
      }
      function getComponentTrace() {
        let currentVNode = stack[stack.length - 1];
        if (!currentVNode) {
          return [];
        }
        const normalizedStack = [];
        while (currentVNode) {
          const last = normalizedStack[0];
          if (last && last.vnode === currentVNode) {
            last.recurseCount++;
          } else {
            normalizedStack.push({
              vnode: currentVNode,
              recurseCount: 0
            });
          }
          const parentInstance = currentVNode.component && currentVNode.component.parent;
          currentVNode = parentInstance && parentInstance.vnode;
        }
        return normalizedStack;
      }
      function formatTrace(trace) {
        const logs = [];
        trace.forEach((entry, i) => {
          logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
        });
        return logs;
      }
      function formatTraceEntry({ vnode, recurseCount }) {
        const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
        const isRoot = vnode.component ? vnode.component.parent == null : false;
        const open = ` at <${formatComponentName(
          vnode.component,
          vnode.type,
          isRoot
        )}`;
        const close = `>` + postfix;
        return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
      }
      function formatProps(props) {
        const res = [];
        const keys = Object.keys(props);
        keys.slice(0, 3).forEach((key) => {
          res.push(...formatProp(key, props[key]));
        });
        if (keys.length > 3) {
          res.push(` ...`);
        }
        return res;
      }
      function formatProp(key, value, raw) {
        if (shared.isString(value)) {
          value = JSON.stringify(value);
          return raw ? value : [`${key}=${value}`];
        } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
          return raw ? value : [`${key}=${value}`];
        } else if (reactivity.isRef(value)) {
          value = formatProp(key, reactivity.toRaw(value.value), true);
          return raw ? value : [`${key}=Ref<`, value, `>`];
        } else if (shared.isFunction(value)) {
          return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
        } else {
          value = reactivity.toRaw(value);
          return raw ? value : [`${key}=`, value];
        }
      }
      function assertNumber(val, type) {
        if (val === void 0) {
          return;
        } else if (typeof val !== "number") {
          warn(`${type} is not a valid number - got ${JSON.stringify(val)}.`);
        } else if (isNaN(val)) {
          warn(`${type} is NaN - the duration expression might be incorrect.`);
        }
      }
      var ErrorTypeStrings = {
        ["sp"]: "serverPrefetch hook",
        ["bc"]: "beforeCreate hook",
        ["c"]: "created hook",
        ["bm"]: "beforeMount hook",
        ["m"]: "mounted hook",
        ["bu"]: "beforeUpdate hook",
        ["u"]: "updated",
        ["bum"]: "beforeUnmount hook",
        ["um"]: "unmounted hook",
        ["a"]: "activated hook",
        ["da"]: "deactivated hook",
        ["ec"]: "errorCaptured hook",
        ["rtc"]: "renderTracked hook",
        ["rtg"]: "renderTriggered hook",
        [0]: "setup function",
        [1]: "render function",
        [2]: "watcher getter",
        [3]: "watcher callback",
        [4]: "watcher cleanup function",
        [5]: "native event handler",
        [6]: "component event handler",
        [7]: "vnode hook",
        [8]: "directive hook",
        [9]: "transition hook",
        [10]: "app errorHandler",
        [11]: "app warnHandler",
        [12]: "ref function",
        [13]: "async component loader",
        [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
      };
      function callWithErrorHandling(fn, instance, type, args) {
        let res;
        try {
          res = args ? fn(...args) : fn();
        } catch (err) {
          handleError(err, instance, type);
        }
        return res;
      }
      function callWithAsyncErrorHandling(fn, instance, type, args) {
        if (shared.isFunction(fn)) {
          const res = callWithErrorHandling(fn, instance, type, args);
          if (res && shared.isPromise(res)) {
            res.catch((err) => {
              handleError(err, instance, type);
            });
          }
          return res;
        }
        const values = [];
        for (let i = 0; i < fn.length; i++) {
          values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
        }
        return values;
      }
      function handleError(err, instance, type, throwInDev = true) {
        const contextVNode = instance ? instance.vnode : null;
        if (instance) {
          let cur = instance.parent;
          const exposedInstance = instance.proxy;
          const errorInfo = ErrorTypeStrings[type];
          while (cur) {
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) {
              for (let i = 0; i < errorCapturedHooks.length; i++) {
                if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                  return;
                }
              }
            }
            cur = cur.parent;
          }
          const appErrorHandler = instance.appContext.config.errorHandler;
          if (appErrorHandler) {
            callWithErrorHandling(
              appErrorHandler,
              null,
              10,
              [err, exposedInstance, errorInfo]
            );
            return;
          }
        }
        logError(err, type, contextVNode, throwInDev);
      }
      function logError(err, type, contextVNode, throwInDev = true) {
        {
          const info = ErrorTypeStrings[type];
          if (contextVNode) {
            pushWarningContext(contextVNode);
          }
          warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
          if (contextVNode) {
            popWarningContext();
          }
          if (throwInDev) {
            throw err;
          } else {
            console.error(err);
          }
        }
      }
      var isFlushing = false;
      var isFlushPending = false;
      var queue = [];
      var flushIndex = 0;
      var pendingPostFlushCbs = [];
      var activePostFlushCbs = null;
      var postFlushIndex = 0;
      var resolvedPromise = /* @__PURE__ */ Promise.resolve();
      var currentFlushPromise = null;
      var RECURSION_LIMIT = 100;
      function nextTick(fn) {
        const p = currentFlushPromise || resolvedPromise;
        return fn ? p.then(this ? fn.bind(this) : fn) : p;
      }
      function findInsertionIndex(id) {
        let start = flushIndex + 1;
        let end = queue.length;
        while (start < end) {
          const middle = start + end >>> 1;
          const middleJobId = getId(queue[middle]);
          middleJobId < id ? start = middle + 1 : end = middle;
        }
        return start;
      }
      function queueJob(job) {
        if (!queue.length || !queue.includes(
          job,
          isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
        )) {
          if (job.id == null) {
            queue.push(job);
          } else {
            queue.splice(findInsertionIndex(job.id), 0, job);
          }
          queueFlush();
        }
      }
      function queueFlush() {
        if (!isFlushing && !isFlushPending) {
          isFlushPending = true;
          currentFlushPromise = resolvedPromise.then(flushJobs);
        }
      }
      function invalidateJob(job) {
        const i = queue.indexOf(job);
        if (i > flushIndex) {
          queue.splice(i, 1);
        }
      }
      function queuePostFlushCb(cb) {
        if (!shared.isArray(cb)) {
          if (!activePostFlushCbs || !activePostFlushCbs.includes(
            cb,
            cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
          )) {
            pendingPostFlushCbs.push(cb);
          }
        } else {
          pendingPostFlushCbs.push(...cb);
        }
        queueFlush();
      }
      function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {
        {
          seen = seen || /* @__PURE__ */ new Map();
        }
        for (; i < queue.length; i++) {
          const cb = queue[i];
          if (cb && cb.pre) {
            if (checkRecursiveUpdates(seen, cb)) {
              continue;
            }
            queue.splice(i, 1);
            i--;
            cb();
          }
        }
      }
      function flushPostFlushCbs(seen) {
        if (pendingPostFlushCbs.length) {
          const deduped = [...new Set(pendingPostFlushCbs)];
          pendingPostFlushCbs.length = 0;
          if (activePostFlushCbs) {
            activePostFlushCbs.push(...deduped);
            return;
          }
          activePostFlushCbs = deduped;
          {
            seen = seen || /* @__PURE__ */ new Map();
          }
          activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
          for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
            if (checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
              continue;
            }
            activePostFlushCbs[postFlushIndex]();
          }
          activePostFlushCbs = null;
          postFlushIndex = 0;
        }
      }
      var getId = (job) => job.id == null ? Infinity : job.id;
      var comparator = (a, b) => {
        const diff = getId(a) - getId(b);
        if (diff === 0) {
          if (a.pre && !b.pre)
            return -1;
          if (b.pre && !a.pre)
            return 1;
        }
        return diff;
      };
      function flushJobs(seen) {
        isFlushPending = false;
        isFlushing = true;
        {
          seen = seen || /* @__PURE__ */ new Map();
        }
        queue.sort(comparator);
        const check = (job) => checkRecursiveUpdates(seen, job);
        try {
          for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
            const job = queue[flushIndex];
            if (job && job.active !== false) {
              if (check(job)) {
                continue;
              }
              callWithErrorHandling(job, null, 14);
            }
          }
        } finally {
          flushIndex = 0;
          queue.length = 0;
          flushPostFlushCbs(seen);
          isFlushing = false;
          currentFlushPromise = null;
          if (queue.length || pendingPostFlushCbs.length) {
            flushJobs(seen);
          }
        }
      }
      function checkRecursiveUpdates(seen, fn) {
        if (!seen.has(fn)) {
          seen.set(fn, 1);
        } else {
          const count = seen.get(fn);
          if (count > RECURSION_LIMIT) {
            const instance = fn.ownerInstance;
            const componentName = instance && getComponentName(instance.type);
            warn(
              `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`
            );
            return true;
          } else {
            seen.set(fn, count + 1);
          }
        }
      }
      var isHmrUpdating = false;
      var hmrDirtyComponents = /* @__PURE__ */ new Set();
      {
        shared.getGlobalThis().__VUE_HMR_RUNTIME__ = {
          createRecord: tryWrap(createRecord),
          rerender: tryWrap(rerender),
          reload: tryWrap(reload)
        };
      }
      var map = /* @__PURE__ */ new Map();
      function registerHMR(instance) {
        const id = instance.type.__hmrId;
        let record = map.get(id);
        if (!record) {
          createRecord(id, instance.type);
          record = map.get(id);
        }
        record.instances.add(instance);
      }
      function unregisterHMR(instance) {
        map.get(instance.type.__hmrId).instances.delete(instance);
      }
      function createRecord(id, initialDef) {
        if (map.has(id)) {
          return false;
        }
        map.set(id, {
          initialDef: normalizeClassComponent(initialDef),
          instances: /* @__PURE__ */ new Set()
        });
        return true;
      }
      function normalizeClassComponent(component) {
        return isClassComponent(component) ? component.__vccOpts : component;
      }
      function rerender(id, newRender) {
        const record = map.get(id);
        if (!record) {
          return;
        }
        record.initialDef.render = newRender;
        [...record.instances].forEach((instance) => {
          if (newRender) {
            instance.render = newRender;
            normalizeClassComponent(instance.type).render = newRender;
          }
          instance.renderCache = [];
          isHmrUpdating = true;
          instance.update();
          isHmrUpdating = false;
        });
      }
      function reload(id, newComp) {
        const record = map.get(id);
        if (!record)
          return;
        newComp = normalizeClassComponent(newComp);
        updateComponentDef(record.initialDef, newComp);
        const instances = [...record.instances];
        for (const instance of instances) {
          const oldComp = normalizeClassComponent(instance.type);
          if (!hmrDirtyComponents.has(oldComp)) {
            if (oldComp !== record.initialDef) {
              updateComponentDef(oldComp, newComp);
            }
            hmrDirtyComponents.add(oldComp);
          }
          instance.appContext.propsCache.delete(instance.type);
          instance.appContext.emitsCache.delete(instance.type);
          instance.appContext.optionsCache.delete(instance.type);
          if (instance.ceReload) {
            hmrDirtyComponents.add(oldComp);
            instance.ceReload(newComp.styles);
            hmrDirtyComponents.delete(oldComp);
          } else if (instance.parent) {
            queueJob(instance.parent.update);
          } else if (instance.appContext.reload) {
            instance.appContext.reload();
          } else if (typeof window !== "undefined") {
            window.location.reload();
          } else {
            console.warn(
              "[HMR] Root or manually mounted instance modified. Full reload required."
            );
          }
        }
        queuePostFlushCb(() => {
          for (const instance of instances) {
            hmrDirtyComponents.delete(
              normalizeClassComponent(instance.type)
            );
          }
        });
      }
      function updateComponentDef(oldComp, newComp) {
        shared.extend(oldComp, newComp);
        for (const key in oldComp) {
          if (key !== "__file" && !(key in newComp)) {
            delete oldComp[key];
          }
        }
      }
      function tryWrap(fn) {
        return (id, arg) => {
          try {
            return fn(id, arg);
          } catch (e) {
            console.error(e);
            console.warn(
              `[HMR] Something went wrong during Vue component hot-reload. Full reload required.`
            );
          }
        };
      }
      exports.devtools = void 0;
      var buffer = [];
      var devtoolsNotInstalled = false;
      function emit$1(event, ...args) {
        if (exports.devtools) {
          exports.devtools.emit(event, ...args);
        } else if (!devtoolsNotInstalled) {
          buffer.push({ event, args });
        }
      }
      function setDevtoolsHook(hook, target) {
        var _a, _b;
        exports.devtools = hook;
        if (exports.devtools) {
          exports.devtools.enabled = true;
          buffer.forEach(({ event, args }) => exports.devtools.emit(event, ...args));
          buffer = [];
        } else if (
          // handle late devtools injection - only do this if we are in an actual
          // browser environment to avoid the timer handle stalling test runner exit
          // (#4815)
          typeof window !== "undefined" && // some envs mock window but not fully
          window.HTMLElement && // also exclude jsdom
          !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))
        ) {
          const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
          replay.push((newHook) => {
            setDevtoolsHook(newHook, target);
          });
          setTimeout(() => {
            if (!exports.devtools) {
              target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
              devtoolsNotInstalled = true;
              buffer = [];
            }
          }, 3e3);
        } else {
          devtoolsNotInstalled = true;
          buffer = [];
        }
      }
      function devtoolsInitApp(app2, version2) {
        emit$1("app:init", app2, version2, {
          Fragment,
          Text,
          Comment,
          Static
        });
      }
      function devtoolsUnmountApp(app2) {
        emit$1("app:unmount", app2);
      }
      var devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook(
        "component:added"
        /* COMPONENT_ADDED */
      );
      var devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook(
        "component:updated"
        /* COMPONENT_UPDATED */
      );
      var _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(
        "component:removed"
        /* COMPONENT_REMOVED */
      );
      var devtoolsComponentRemoved = (component) => {
        if (exports.devtools && typeof exports.devtools.cleanupBuffer === "function" && // remove the component if it wasn't buffered
        !exports.devtools.cleanupBuffer(component)) {
          _devtoolsComponentRemoved(component);
        }
      };
      function createDevtoolsComponentHook(hook) {
        return (component) => {
          emit$1(
            hook,
            component.appContext.app,
            component.uid,
            component.parent ? component.parent.uid : void 0,
            component
          );
        };
      }
      var devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook(
        "perf:start"
        /* PERFORMANCE_START */
      );
      var devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook(
        "perf:end"
        /* PERFORMANCE_END */
      );
      function createDevtoolsPerformanceHook(hook) {
        return (component, type, time) => {
          emit$1(hook, component.appContext.app, component.uid, component, type, time);
        };
      }
      function devtoolsComponentEmit(component, event, params) {
        emit$1(
          "component:emit",
          component.appContext.app,
          component,
          event,
          params
        );
      }
      function emit(instance, event, ...rawArgs) {
        if (instance.isUnmounted)
          return;
        const props = instance.vnode.props || shared.EMPTY_OBJ;
        {
          const {
            emitsOptions,
            propsOptions: [propsOptions]
          } = instance;
          if (emitsOptions) {
            if (!(event in emitsOptions) && true) {
              if (!propsOptions || !(shared.toHandlerKey(event) in propsOptions)) {
                warn(
                  `Component emitted event "${event}" but it is neither declared in the emits option nor as an "${shared.toHandlerKey(event)}" prop.`
                );
              }
            } else {
              const validator = emitsOptions[event];
              if (shared.isFunction(validator)) {
                const isValid = validator(...rawArgs);
                if (!isValid) {
                  warn(
                    `Invalid event arguments: event validation failed for event "${event}".`
                  );
                }
              }
            }
          }
        }
        let args = rawArgs;
        const isModelListener = event.startsWith("update:");
        const modelArg = isModelListener && event.slice(7);
        if (modelArg && modelArg in props) {
          const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
          const { number, trim } = props[modifiersKey] || shared.EMPTY_OBJ;
          if (trim) {
            args = rawArgs.map((a) => shared.isString(a) ? a.trim() : a);
          }
          if (number) {
            args = rawArgs.map(shared.looseToNumber);
          }
        }
        {
          devtoolsComponentEmit(instance, event, args);
        }
        {
          const lowerCaseEvent = event.toLowerCase();
          if (lowerCaseEvent !== event && props[shared.toHandlerKey(lowerCaseEvent)]) {
            warn(
              `Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(
                instance,
                instance.type
              )} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${shared.hyphenate(event)}" instead of "${event}".`
            );
          }
        }
        let handlerName;
        let handler = props[handlerName = shared.toHandlerKey(event)] || // also try camelCase event handler (#2249)
        props[handlerName = shared.toHandlerKey(shared.camelize(event))];
        if (!handler && isModelListener) {
          handler = props[handlerName = shared.toHandlerKey(shared.hyphenate(event))];
        }
        if (handler) {
          callWithAsyncErrorHandling(
            handler,
            instance,
            6,
            args
          );
        }
        const onceHandler = props[handlerName + `Once`];
        if (onceHandler) {
          if (!instance.emitted) {
            instance.emitted = {};
          } else if (instance.emitted[handlerName]) {
            return;
          }
          instance.emitted[handlerName] = true;
          callWithAsyncErrorHandling(
            onceHandler,
            instance,
            6,
            args
          );
        }
      }
      function normalizeEmitsOptions(comp, appContext, asMixin = false) {
        const cache = appContext.emitsCache;
        const cached = cache.get(comp);
        if (cached !== void 0) {
          return cached;
        }
        const raw = comp.emits;
        let normalized = {};
        let hasExtends = false;
        if (!shared.isFunction(comp)) {
          const extendEmits = (raw2) => {
            const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
            if (normalizedFromExtend) {
              hasExtends = true;
              shared.extend(normalized, normalizedFromExtend);
            }
          };
          if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendEmits);
          }
          if (comp.extends) {
            extendEmits(comp.extends);
          }
          if (comp.mixins) {
            comp.mixins.forEach(extendEmits);
          }
        }
        if (!raw && !hasExtends) {
          if (shared.isObject(comp)) {
            cache.set(comp, null);
          }
          return null;
        }
        if (shared.isArray(raw)) {
          raw.forEach((key) => normalized[key] = null);
        } else {
          shared.extend(normalized, raw);
        }
        if (shared.isObject(comp)) {
          cache.set(comp, normalized);
        }
        return normalized;
      }
      function isEmitListener(options, key) {
        if (!options || !shared.isOn(key)) {
          return false;
        }
        key = key.slice(2).replace(/Once$/, "");
        return shared.hasOwn(options, key[0].toLowerCase() + key.slice(1)) || shared.hasOwn(options, shared.hyphenate(key)) || shared.hasOwn(options, key);
      }
      var currentRenderingInstance = null;
      var currentScopeId = null;
      function setCurrentRenderingInstance(instance) {
        const prev = currentRenderingInstance;
        currentRenderingInstance = instance;
        currentScopeId = instance && instance.type.__scopeId || null;
        return prev;
      }
      function pushScopeId(id) {
        currentScopeId = id;
      }
      function popScopeId() {
        currentScopeId = null;
      }
      var withScopeId = (_id) => withCtx;
      function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
        if (!ctx)
          return fn;
        if (fn._n) {
          return fn;
        }
        const renderFnWithContext = (...args) => {
          if (renderFnWithContext._d) {
            setBlockTracking(-1);
          }
          const prevInstance = setCurrentRenderingInstance(ctx);
          let res;
          try {
            res = fn(...args);
          } finally {
            setCurrentRenderingInstance(prevInstance);
            if (renderFnWithContext._d) {
              setBlockTracking(1);
            }
          }
          {
            devtoolsComponentUpdated(ctx);
          }
          return res;
        };
        renderFnWithContext._n = true;
        renderFnWithContext._c = true;
        renderFnWithContext._d = true;
        return renderFnWithContext;
      }
      var accessedAttrs = false;
      function markAttrsAccessed() {
        accessedAttrs = true;
      }
      function renderComponentRoot(instance) {
        const {
          type: Component,
          vnode,
          proxy,
          withProxy,
          props,
          propsOptions: [propsOptions],
          slots,
          attrs,
          emit: emit2,
          render,
          renderCache,
          data,
          setupState,
          ctx,
          inheritAttrs
        } = instance;
        let result;
        let fallthroughAttrs;
        const prev = setCurrentRenderingInstance(instance);
        {
          accessedAttrs = false;
        }
        try {
          if (vnode.shapeFlag & 4) {
            const proxyToUse = withProxy || proxy;
            result = normalizeVNode(
              render.call(
                proxyToUse,
                proxyToUse,
                renderCache,
                props,
                setupState,
                data,
                ctx
              )
            );
            fallthroughAttrs = attrs;
          } else {
            const render2 = Component;
            if (attrs === props) {
              markAttrsAccessed();
            }
            result = normalizeVNode(
              render2.length > 1 ? render2(
                props,
                true ? {
                  get attrs() {
                    markAttrsAccessed();
                    return attrs;
                  },
                  slots,
                  emit: emit2
                } : { attrs, slots, emit: emit2 }
              ) : render2(
                props,
                null
                /* we know it doesn't need it */
              )
            );
            fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
          }
        } catch (err) {
          blockStack.length = 0;
          handleError(err, instance, 1);
          result = createVNode(Comment);
        }
        let root = result;
        let setRoot = void 0;
        if (result.patchFlag > 0 && result.patchFlag & 2048) {
          [root, setRoot] = getChildRoot(result);
        }
        if (fallthroughAttrs && inheritAttrs !== false) {
          const keys = Object.keys(fallthroughAttrs);
          const { shapeFlag } = root;
          if (keys.length) {
            if (shapeFlag & (1 | 6)) {
              if (propsOptions && keys.some(shared.isModelListener)) {
                fallthroughAttrs = filterModelListeners(
                  fallthroughAttrs,
                  propsOptions
                );
              }
              root = cloneVNode(root, fallthroughAttrs);
            } else if (!accessedAttrs && root.type !== Comment) {
              const allAttrs = Object.keys(attrs);
              const eventAttrs = [];
              const extraAttrs = [];
              for (let i = 0, l = allAttrs.length; i < l; i++) {
                const key = allAttrs[i];
                if (shared.isOn(key)) {
                  if (!shared.isModelListener(key)) {
                    eventAttrs.push(key[2].toLowerCase() + key.slice(3));
                  }
                } else {
                  extraAttrs.push(key);
                }
              }
              if (extraAttrs.length) {
                warn(
                  `Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`
                );
              }
              if (eventAttrs.length) {
                warn(
                  `Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
                );
              }
            }
          }
        }
        if (vnode.dirs) {
          if (!isElementRoot(root)) {
            warn(
              `Runtime directive used on component with non-element root node. The directives will not function as intended.`
            );
          }
          root = cloneVNode(root);
          root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
        }
        if (vnode.transition) {
          if (!isElementRoot(root)) {
            warn(
              `Component inside <Transition> renders non-element root node that cannot be animated.`
            );
          }
          root.transition = vnode.transition;
        }
        if (setRoot) {
          setRoot(root);
        } else {
          result = root;
        }
        setCurrentRenderingInstance(prev);
        return result;
      }
      var getChildRoot = (vnode) => {
        const rawChildren = vnode.children;
        const dynamicChildren = vnode.dynamicChildren;
        const childRoot = filterSingleRoot(rawChildren);
        if (!childRoot) {
          return [vnode, void 0];
        }
        const index = rawChildren.indexOf(childRoot);
        const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
        const setRoot = (updatedRoot) => {
          rawChildren[index] = updatedRoot;
          if (dynamicChildren) {
            if (dynamicIndex > -1) {
              dynamicChildren[dynamicIndex] = updatedRoot;
            } else if (updatedRoot.patchFlag > 0) {
              vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
            }
          }
        };
        return [normalizeVNode(childRoot), setRoot];
      };
      function filterSingleRoot(children) {
        let singleRoot;
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (isVNode(child)) {
            if (child.type !== Comment || child.children === "v-if") {
              if (singleRoot) {
                return;
              } else {
                singleRoot = child;
              }
            }
          } else {
            return;
          }
        }
        return singleRoot;
      }
      var getFunctionalFallthrough = (attrs) => {
        let res;
        for (const key in attrs) {
          if (key === "class" || key === "style" || shared.isOn(key)) {
            (res || (res = {}))[key] = attrs[key];
          }
        }
        return res;
      };
      var filterModelListeners = (attrs, props) => {
        const res = {};
        for (const key in attrs) {
          if (!shared.isModelListener(key) || !(key.slice(9) in props)) {
            res[key] = attrs[key];
          }
        }
        return res;
      };
      var isElementRoot = (vnode) => {
        return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
      };
      function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
        const { props: prevProps, children: prevChildren, component } = prevVNode;
        const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
        const emits = component.emitsOptions;
        if ((prevChildren || nextChildren) && isHmrUpdating) {
          return true;
        }
        if (nextVNode.dirs || nextVNode.transition) {
          return true;
        }
        if (optimized && patchFlag >= 0) {
          if (patchFlag & 1024) {
            return true;
          }
          if (patchFlag & 16) {
            if (!prevProps) {
              return !!nextProps;
            }
            return hasPropsChanged(prevProps, nextProps, emits);
          } else if (patchFlag & 8) {
            const dynamicProps = nextVNode.dynamicProps;
            for (let i = 0; i < dynamicProps.length; i++) {
              const key = dynamicProps[i];
              if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
                return true;
              }
            }
          }
        } else {
          if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) {
              return true;
            }
          }
          if (prevProps === nextProps) {
            return false;
          }
          if (!prevProps) {
            return !!nextProps;
          }
          if (!nextProps) {
            return true;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        }
        return false;
      }
      function hasPropsChanged(prevProps, nextProps, emitsOptions) {
        const nextKeys = Object.keys(nextProps);
        if (nextKeys.length !== Object.keys(prevProps).length) {
          return true;
        }
        for (let i = 0; i < nextKeys.length; i++) {
          const key = nextKeys[i];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
            return true;
          }
        }
        return false;
      }
      function updateHOCHostEl({ vnode, parent }, el) {
        while (parent && parent.subTree === vnode) {
          (vnode = parent.vnode).el = el;
          parent = parent.parent;
        }
      }
      var isSuspense = (type) => type.__isSuspense;
      var SuspenseImpl = {
        name: "Suspense",
        // In order to make Suspense tree-shakable, we need to avoid importing it
        // directly in the renderer. The renderer checks for the __isSuspense flag
        // on a vnode's type and calls the `process` method, passing in renderer
        // internals.
        __isSuspense: true,
        process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
          if (n1 == null) {
            mountSuspense(
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized,
              rendererInternals
            );
          } else {
            patchSuspense(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              isSVG,
              slotScopeIds,
              optimized,
              rendererInternals
            );
          }
        },
        hydrate: hydrateSuspense,
        create: createSuspenseBoundary,
        normalize: normalizeSuspenseChildren
      };
      var Suspense = SuspenseImpl;
      function triggerEvent(vnode, name) {
        const eventListener = vnode.props && vnode.props[name];
        if (shared.isFunction(eventListener)) {
          eventListener();
        }
      }
      function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
        const {
          p: patch,
          o: { createElement }
        } = rendererInternals;
        const hiddenContainer = createElement("div");
        const suspense = vnode.suspense = createSuspenseBoundary(
          vnode,
          parentSuspense,
          parentComponent,
          container,
          hiddenContainer,
          anchor,
          isSVG,
          slotScopeIds,
          optimized,
          rendererInternals
        );
        patch(
          null,
          suspense.pendingBranch = vnode.ssContent,
          hiddenContainer,
          null,
          parentComponent,
          suspense,
          isSVG,
          slotScopeIds
        );
        if (suspense.deps > 0) {
          triggerEvent(vnode, "onPending");
          triggerEvent(vnode, "onFallback");
          patch(
            null,
            vnode.ssFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            isSVG,
            slotScopeIds
          );
          setActiveBranch(suspense, vnode.ssFallback);
        } else {
          suspense.resolve(false, true);
        }
      }
      function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
        const suspense = n2.suspense = n1.suspense;
        suspense.vnode = n2;
        n2.el = n1.el;
        const newBranch = n2.ssContent;
        const newFallback = n2.ssFallback;
        const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
        if (pendingBranch) {
          suspense.pendingBranch = newBranch;
          if (isSameVNodeType(newBranch, pendingBranch)) {
            patch(
              pendingBranch,
              newBranch,
              suspense.hiddenContainer,
              null,
              parentComponent,
              suspense,
              isSVG,
              slotScopeIds,
              optimized
            );
            if (suspense.deps <= 0) {
              suspense.resolve();
            } else if (isInFallback) {
              patch(
                activeBranch,
                newFallback,
                container,
                anchor,
                parentComponent,
                null,
                // fallback tree will not have suspense context
                isSVG,
                slotScopeIds,
                optimized
              );
              setActiveBranch(suspense, newFallback);
            }
          } else {
            suspense.pendingId++;
            if (isHydrating) {
              suspense.isHydrating = false;
              suspense.activeBranch = pendingBranch;
            } else {
              unmount(pendingBranch, parentComponent, suspense);
            }
            suspense.deps = 0;
            suspense.effects.length = 0;
            suspense.hiddenContainer = createElement("div");
            if (isInFallback) {
              patch(
                null,
                newBranch,
                suspense.hiddenContainer,
                null,
                parentComponent,
                suspense,
                isSVG,
                slotScopeIds,
                optimized
              );
              if (suspense.deps <= 0) {
                suspense.resolve();
              } else {
                patch(
                  activeBranch,
                  newFallback,
                  container,
                  anchor,
                  parentComponent,
                  null,
                  // fallback tree will not have suspense context
                  isSVG,
                  slotScopeIds,
                  optimized
                );
                setActiveBranch(suspense, newFallback);
              }
            } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
              patch(
                activeBranch,
                newBranch,
                container,
                anchor,
                parentComponent,
                suspense,
                isSVG,
                slotScopeIds,
                optimized
              );
              suspense.resolve(true);
            } else {
              patch(
                null,
                newBranch,
                suspense.hiddenContainer,
                null,
                parentComponent,
                suspense,
                isSVG,
                slotScopeIds,
                optimized
              );
              if (suspense.deps <= 0) {
                suspense.resolve();
              }
            }
          }
        } else {
          if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
            patch(
              activeBranch,
              newBranch,
              container,
              anchor,
              parentComponent,
              suspense,
              isSVG,
              slotScopeIds,
              optimized
            );
            setActiveBranch(suspense, newBranch);
          } else {
            triggerEvent(n2, "onPending");
            suspense.pendingBranch = newBranch;
            suspense.pendingId++;
            patch(
              null,
              newBranch,
              suspense.hiddenContainer,
              null,
              parentComponent,
              suspense,
              isSVG,
              slotScopeIds,
              optimized
            );
            if (suspense.deps <= 0) {
              suspense.resolve();
            } else {
              const { timeout, pendingId } = suspense;
              if (timeout > 0) {
                setTimeout(() => {
                  if (suspense.pendingId === pendingId) {
                    suspense.fallback(newFallback);
                  }
                }, timeout);
              } else if (timeout === 0) {
                suspense.fallback(newFallback);
              }
            }
          }
        }
      }
      var hasWarned = false;
      function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
        if (!hasWarned) {
          hasWarned = true;
          console[console.info ? "info" : "log"](
            `<Suspense> is an experimental feature and its API will likely change.`
          );
        }
        const {
          p: patch,
          m: move,
          um: unmount,
          n: next,
          o: { parentNode, remove }
        } = rendererInternals;
        let parentSuspenseId;
        const isSuspensible = isVNodeSuspensible(vnode);
        if (isSuspensible) {
          if (parentSuspense == null ? void 0 : parentSuspense.pendingBranch) {
            parentSuspenseId = parentSuspense.pendingId;
            parentSuspense.deps++;
          }
        }
        const timeout = vnode.props ? shared.toNumber(vnode.props.timeout) : void 0;
        {
          assertNumber(timeout, `Suspense timeout`);
        }
        const suspense = {
          vnode,
          parent: parentSuspense,
          parentComponent,
          isSVG,
          container,
          hiddenContainer,
          anchor,
          deps: 0,
          pendingId: 0,
          timeout: typeof timeout === "number" ? timeout : -1,
          activeBranch: null,
          pendingBranch: null,
          isInFallback: true,
          isHydrating,
          isUnmounted: false,
          effects: [],
          resolve(resume = false, sync = false) {
            {
              if (!resume && !suspense.pendingBranch) {
                throw new Error(
                  `suspense.resolve() is called without a pending branch.`
                );
              }
              if (suspense.isUnmounted) {
                throw new Error(
                  `suspense.resolve() is called on an already unmounted suspense boundary.`
                );
              }
            }
            const {
              vnode: vnode2,
              activeBranch,
              pendingBranch,
              pendingId,
              effects,
              parentComponent: parentComponent2,
              container: container2
            } = suspense;
            if (suspense.isHydrating) {
              suspense.isHydrating = false;
            } else if (!resume) {
              const delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
              if (delayEnter) {
                activeBranch.transition.afterLeave = () => {
                  if (pendingId === suspense.pendingId) {
                    move(pendingBranch, container2, anchor2, 0);
                  }
                };
              }
              let { anchor: anchor2 } = suspense;
              if (activeBranch) {
                anchor2 = next(activeBranch);
                unmount(activeBranch, parentComponent2, suspense, true);
              }
              if (!delayEnter) {
                move(pendingBranch, container2, anchor2, 0);
              }
            }
            setActiveBranch(suspense, pendingBranch);
            suspense.pendingBranch = null;
            suspense.isInFallback = false;
            let parent = suspense.parent;
            let hasUnresolvedAncestor = false;
            while (parent) {
              if (parent.pendingBranch) {
                parent.effects.push(...effects);
                hasUnresolvedAncestor = true;
                break;
              }
              parent = parent.parent;
            }
            if (!hasUnresolvedAncestor) {
              queuePostFlushCb(effects);
            }
            suspense.effects = [];
            if (isSuspensible) {
              if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
                parentSuspense.deps--;
                if (parentSuspense.deps === 0 && !sync) {
                  parentSuspense.resolve();
                }
              }
            }
            triggerEvent(vnode2, "onResolve");
          },
          fallback(fallbackVNode) {
            if (!suspense.pendingBranch) {
              return;
            }
            const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, isSVG: isSVG2 } = suspense;
            triggerEvent(vnode2, "onFallback");
            const anchor2 = next(activeBranch);
            const mountFallback = () => {
              if (!suspense.isInFallback) {
                return;
              }
              patch(
                null,
                fallbackVNode,
                container2,
                anchor2,
                parentComponent2,
                null,
                // fallback tree will not have suspense context
                isSVG2,
                slotScopeIds,
                optimized
              );
              setActiveBranch(suspense, fallbackVNode);
            };
            const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
            if (delayEnter) {
              activeBranch.transition.afterLeave = mountFallback;
            }
            suspense.isInFallback = true;
            unmount(
              activeBranch,
              parentComponent2,
              null,
              // no suspense so unmount hooks fire now
              true
              // shouldRemove
            );
            if (!delayEnter) {
              mountFallback();
            }
          },
          move(container2, anchor2, type) {
            suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
            suspense.container = container2;
          },
          next() {
            return suspense.activeBranch && next(suspense.activeBranch);
          },
          registerDep(instance, setupRenderEffect) {
            const isInPendingSuspense = !!suspense.pendingBranch;
            if (isInPendingSuspense) {
              suspense.deps++;
            }
            const hydratedEl = instance.vnode.el;
            instance.asyncDep.catch((err) => {
              handleError(err, instance, 0);
            }).then((asyncSetupResult) => {
              if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
                return;
              }
              instance.asyncResolved = true;
              const { vnode: vnode2 } = instance;
              {
                pushWarningContext(vnode2);
              }
              handleSetupResult(instance, asyncSetupResult, false);
              if (hydratedEl) {
                vnode2.el = hydratedEl;
              }
              const placeholder = !hydratedEl && instance.subTree.el;
              setupRenderEffect(
                instance,
                vnode2,
                // component may have been moved before resolve.
                // if this is not a hydration, instance.subTree will be the comment
                // placeholder.
                parentNode(hydratedEl || instance.subTree.el),
                // anchor will not be used if this is hydration, so only need to
                // consider the comment placeholder case.
                hydratedEl ? null : next(instance.subTree),
                suspense,
                isSVG,
                optimized
              );
              if (placeholder) {
                remove(placeholder);
              }
              updateHOCHostEl(instance, vnode2.el);
              {
                popWarningContext();
              }
              if (isInPendingSuspense && --suspense.deps === 0) {
                suspense.resolve();
              }
            });
          },
          unmount(parentSuspense2, doRemove) {
            suspense.isUnmounted = true;
            if (suspense.activeBranch) {
              unmount(
                suspense.activeBranch,
                parentComponent,
                parentSuspense2,
                doRemove
              );
            }
            if (suspense.pendingBranch) {
              unmount(
                suspense.pendingBranch,
                parentComponent,
                parentSuspense2,
                doRemove
              );
            }
          }
        };
        return suspense;
      }
      function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
        const suspense = vnode.suspense = createSuspenseBoundary(
          vnode,
          parentSuspense,
          parentComponent,
          node.parentNode,
          document.createElement("div"),
          null,
          isSVG,
          slotScopeIds,
          optimized,
          rendererInternals,
          true
          /* hydrating */
        );
        const result = hydrateNode(
          node,
          suspense.pendingBranch = vnode.ssContent,
          parentComponent,
          suspense,
          slotScopeIds,
          optimized
        );
        if (suspense.deps === 0) {
          suspense.resolve(false, true);
        }
        return result;
      }
      function normalizeSuspenseChildren(vnode) {
        const { shapeFlag, children } = vnode;
        const isSlotChildren = shapeFlag & 32;
        vnode.ssContent = normalizeSuspenseSlot(
          isSlotChildren ? children.default : children
        );
        vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
      }
      function normalizeSuspenseSlot(s) {
        let block;
        if (shared.isFunction(s)) {
          const trackBlock = isBlockTreeEnabled && s._c;
          if (trackBlock) {
            s._d = false;
            openBlock();
          }
          s = s();
          if (trackBlock) {
            s._d = true;
            block = currentBlock;
            closeBlock();
          }
        }
        if (shared.isArray(s)) {
          const singleChild = filterSingleRoot(s);
          if (!singleChild) {
            warn(`<Suspense> slots expect a single root node.`);
          }
          s = singleChild;
        }
        s = normalizeVNode(s);
        if (block && !s.dynamicChildren) {
          s.dynamicChildren = block.filter((c) => c !== s);
        }
        return s;
      }
      function queueEffectWithSuspense(fn, suspense) {
        if (suspense && suspense.pendingBranch) {
          if (shared.isArray(fn)) {
            suspense.effects.push(...fn);
          } else {
            suspense.effects.push(fn);
          }
        } else {
          queuePostFlushCb(fn);
        }
      }
      function setActiveBranch(suspense, branch) {
        suspense.activeBranch = branch;
        const { vnode, parentComponent } = suspense;
        const el = vnode.el = branch.el;
        if (parentComponent && parentComponent.subTree === vnode) {
          parentComponent.vnode.el = el;
          updateHOCHostEl(parentComponent, el);
        }
      }
      function isVNodeSuspensible(vnode) {
        var _a;
        return ((_a = vnode.props) == null ? void 0 : _a.suspensible) != null && vnode.props.suspensible !== false;
      }
      function watchEffect(effect, options) {
        return doWatch(effect, null, options);
      }
      function watchPostEffect(effect, options) {
        return doWatch(
          effect,
          null,
          shared.extend({}, options, { flush: "post" })
        );
      }
      function watchSyncEffect(effect, options) {
        return doWatch(
          effect,
          null,
          shared.extend({}, options, { flush: "sync" })
        );
      }
      var INITIAL_WATCHER_VALUE = {};
      function watch(source, cb, options) {
        if (!shared.isFunction(cb)) {
          warn(
            `\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`
          );
        }
        return doWatch(source, cb, options);
      }
      function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = shared.EMPTY_OBJ) {
        var _a;
        if (!cb) {
          if (immediate !== void 0) {
            warn(
              `watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`
            );
          }
          if (deep !== void 0) {
            warn(
              `watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`
            );
          }
        }
        const warnInvalidSource = (s) => {
          warn(
            `Invalid watch source: `,
            s,
            `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`
          );
        };
        const instance = reactivity.getCurrentScope() === ((_a = currentInstance) == null ? void 0 : _a.scope) ? currentInstance : null;
        let getter;
        let forceTrigger = false;
        let isMultiSource = false;
        if (reactivity.isRef(source)) {
          getter = () => source.value;
          forceTrigger = reactivity.isShallow(source);
        } else if (reactivity.isReactive(source)) {
          getter = () => source;
          deep = true;
        } else if (shared.isArray(source)) {
          isMultiSource = true;
          forceTrigger = source.some((s) => reactivity.isReactive(s) || reactivity.isShallow(s));
          getter = () => source.map((s) => {
            if (reactivity.isRef(s)) {
              return s.value;
            } else if (reactivity.isReactive(s)) {
              return traverse(s);
            } else if (shared.isFunction(s)) {
              return callWithErrorHandling(s, instance, 2);
            } else {
              warnInvalidSource(s);
            }
          });
        } else if (shared.isFunction(source)) {
          if (cb) {
            getter = () => callWithErrorHandling(source, instance, 2);
          } else {
            getter = () => {
              if (instance && instance.isUnmounted) {
                return;
              }
              if (cleanup) {
                cleanup();
              }
              return callWithAsyncErrorHandling(
                source,
                instance,
                3,
                [onCleanup]
              );
            };
          }
        } else {
          getter = shared.NOOP;
          warnInvalidSource(source);
        }
        if (cb && deep) {
          const baseGetter = getter;
          getter = () => traverse(baseGetter());
        }
        let cleanup;
        let onCleanup = (fn) => {
          cleanup = effect.onStop = () => {
            callWithErrorHandling(fn, instance, 4);
          };
        };
        let ssrCleanup;
        if (isInSSRComponentSetup) {
          onCleanup = shared.NOOP;
          if (!cb) {
            getter();
          } else if (immediate) {
            callWithAsyncErrorHandling(cb, instance, 3, [
              getter(),
              isMultiSource ? [] : void 0,
              onCleanup
            ]);
          }
          if (flush === "sync") {
            const ctx = useSSRContext();
            ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
          } else {
            return shared.NOOP;
          }
        }
        let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
        const job = () => {
          if (!effect.active) {
            return;
          }
          if (cb) {
            const newValue = effect.run();
            if (deep || forceTrigger || (isMultiSource ? newValue.some(
              (v, i) => shared.hasChanged(v, oldValue[i])
            ) : shared.hasChanged(newValue, oldValue)) || false) {
              if (cleanup) {
                cleanup();
              }
              callWithAsyncErrorHandling(cb, instance, 3, [
                newValue,
                // pass undefined as the old value when it's changed for the first time
                oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
                onCleanup
              ]);
              oldValue = newValue;
            }
          } else {
            effect.run();
          }
        };
        job.allowRecurse = !!cb;
        let scheduler;
        if (flush === "sync") {
          scheduler = job;
        } else if (flush === "post") {
          scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
        } else {
          job.pre = true;
          if (instance)
            job.id = instance.uid;
          scheduler = () => queueJob(job);
        }
        const effect = new reactivity.ReactiveEffect(getter, scheduler);
        {
          effect.onTrack = onTrack;
          effect.onTrigger = onTrigger;
        }
        if (cb) {
          if (immediate) {
            job();
          } else {
            oldValue = effect.run();
          }
        } else if (flush === "post") {
          queuePostRenderEffect(
            effect.run.bind(effect),
            instance && instance.suspense
          );
        } else {
          effect.run();
        }
        const unwatch = () => {
          effect.stop();
          if (instance && instance.scope) {
            shared.remove(instance.scope.effects, effect);
          }
        };
        if (ssrCleanup)
          ssrCleanup.push(unwatch);
        return unwatch;
      }
      function instanceWatch(source, value, options) {
        const publicThis = this.proxy;
        const getter = shared.isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
        let cb;
        if (shared.isFunction(value)) {
          cb = value;
        } else {
          cb = value.handler;
          options = value;
        }
        const cur = currentInstance;
        setCurrentInstance(this);
        const res = doWatch(getter, cb.bind(publicThis), options);
        if (cur) {
          setCurrentInstance(cur);
        } else {
          unsetCurrentInstance();
        }
        return res;
      }
      function createPathGetter(ctx, path) {
        const segments = path.split(".");
        return () => {
          let cur = ctx;
          for (let i = 0; i < segments.length && cur; i++) {
            cur = cur[segments[i]];
          }
          return cur;
        };
      }
      function traverse(value, seen) {
        if (!shared.isObject(value) || value["__v_skip"]) {
          return value;
        }
        seen = seen || /* @__PURE__ */ new Set();
        if (seen.has(value)) {
          return value;
        }
        seen.add(value);
        if (reactivity.isRef(value)) {
          traverse(value.value, seen);
        } else if (shared.isArray(value)) {
          for (let i = 0; i < value.length; i++) {
            traverse(value[i], seen);
          }
        } else if (shared.isSet(value) || shared.isMap(value)) {
          value.forEach((v) => {
            traverse(v, seen);
          });
        } else if (shared.isPlainObject(value)) {
          for (const key in value) {
            traverse(value[key], seen);
          }
        }
        return value;
      }
      function validateDirectiveName(name) {
        if (shared.isBuiltInDirective(name)) {
          warn("Do not use built-in directive ids as custom directive id: " + name);
        }
      }
      function withDirectives(vnode, directives) {
        const internalInstance = currentRenderingInstance;
        if (internalInstance === null) {
          warn(`withDirectives can only be used inside render functions.`);
          return vnode;
        }
        const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
        const bindings = vnode.dirs || (vnode.dirs = []);
        for (let i = 0; i < directives.length; i++) {
          let [dir, value, arg, modifiers = shared.EMPTY_OBJ] = directives[i];
          if (dir) {
            if (shared.isFunction(dir)) {
              dir = {
                mounted: dir,
                updated: dir
              };
            }
            if (dir.deep) {
              traverse(value);
            }
            bindings.push({
              dir,
              instance,
              value,
              oldValue: void 0,
              arg,
              modifiers
            });
          }
        }
        return vnode;
      }
      function invokeDirectiveHook(vnode, prevVNode, instance, name) {
        const bindings = vnode.dirs;
        const oldBindings = prevVNode && prevVNode.dirs;
        for (let i = 0; i < bindings.length; i++) {
          const binding = bindings[i];
          if (oldBindings) {
            binding.oldValue = oldBindings[i].value;
          }
          let hook = binding.dir[name];
          if (hook) {
            reactivity.pauseTracking();
            callWithAsyncErrorHandling(hook, instance, 8, [
              vnode.el,
              binding,
              vnode,
              prevVNode
            ]);
            reactivity.resetTracking();
          }
        }
      }
      function useTransitionState() {
        const state = {
          isMounted: false,
          isLeaving: false,
          isUnmounting: false,
          leavingVNodes: /* @__PURE__ */ new Map()
        };
        onMounted(() => {
          state.isMounted = true;
        });
        onBeforeUnmount(() => {
          state.isUnmounting = true;
        });
        return state;
      }
      var TransitionHookValidator = [Function, Array];
      var BaseTransitionPropsValidators = {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        // enter
        onBeforeEnter: TransitionHookValidator,
        onEnter: TransitionHookValidator,
        onAfterEnter: TransitionHookValidator,
        onEnterCancelled: TransitionHookValidator,
        // leave
        onBeforeLeave: TransitionHookValidator,
        onLeave: TransitionHookValidator,
        onAfterLeave: TransitionHookValidator,
        onLeaveCancelled: TransitionHookValidator,
        // appear
        onBeforeAppear: TransitionHookValidator,
        onAppear: TransitionHookValidator,
        onAfterAppear: TransitionHookValidator,
        onAppearCancelled: TransitionHookValidator
      };
      var BaseTransitionImpl = {
        name: `BaseTransition`,
        props: BaseTransitionPropsValidators,
        setup(props, { slots }) {
          const instance = getCurrentInstance();
          const state = useTransitionState();
          let prevTransitionKey;
          return () => {
            const children = slots.default && getTransitionRawChildren(slots.default(), true);
            if (!children || !children.length) {
              return;
            }
            let child = children[0];
            if (children.length > 1) {
              let hasFound = false;
              for (const c of children) {
                if (c.type !== Comment) {
                  if (hasFound) {
                    warn(
                      "<transition> can only be used on a single element or component. Use <transition-group> for lists."
                    );
                    break;
                  }
                  child = c;
                  hasFound = true;
                }
              }
            }
            const rawProps = reactivity.toRaw(props);
            const { mode } = rawProps;
            if (mode && mode !== "in-out" && mode !== "out-in" && mode !== "default") {
              warn(`invalid <transition> mode: ${mode}`);
            }
            if (state.isLeaving) {
              return emptyPlaceholder(child);
            }
            const innerChild = getKeepAliveChild(child);
            if (!innerChild) {
              return emptyPlaceholder(child);
            }
            const enterHooks = resolveTransitionHooks(
              innerChild,
              rawProps,
              state,
              instance
            );
            setTransitionHooks(innerChild, enterHooks);
            const oldChild = instance.subTree;
            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
            let transitionKeyChanged = false;
            const { getTransitionKey } = innerChild.type;
            if (getTransitionKey) {
              const key = getTransitionKey();
              if (prevTransitionKey === void 0) {
                prevTransitionKey = key;
              } else if (key !== prevTransitionKey) {
                prevTransitionKey = key;
                transitionKeyChanged = true;
              }
            }
            if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
              const leavingHooks = resolveTransitionHooks(
                oldInnerChild,
                rawProps,
                state,
                instance
              );
              setTransitionHooks(oldInnerChild, leavingHooks);
              if (mode === "out-in") {
                state.isLeaving = true;
                leavingHooks.afterLeave = () => {
                  state.isLeaving = false;
                  if (instance.update.active !== false) {
                    instance.update();
                  }
                };
                return emptyPlaceholder(child);
              } else if (mode === "in-out" && innerChild.type !== Comment) {
                leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                  const leavingVNodesCache = getLeavingNodesForType(
                    state,
                    oldInnerChild
                  );
                  leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                  el._leaveCb = () => {
                    earlyRemove();
                    el._leaveCb = void 0;
                    delete enterHooks.delayedLeave;
                  };
                  enterHooks.delayedLeave = delayedLeave;
                };
              }
            }
            return child;
          };
        }
      };
      var BaseTransition = BaseTransitionImpl;
      function getLeavingNodesForType(state, vnode) {
        const { leavingVNodes } = state;
        let leavingVNodesCache = leavingVNodes.get(vnode.type);
        if (!leavingVNodesCache) {
          leavingVNodesCache = /* @__PURE__ */ Object.create(null);
          leavingVNodes.set(vnode.type, leavingVNodesCache);
        }
        return leavingVNodesCache;
      }
      function resolveTransitionHooks(vnode, props, state, instance) {
        const {
          appear,
          mode,
          persisted = false,
          onBeforeEnter,
          onEnter,
          onAfterEnter,
          onEnterCancelled,
          onBeforeLeave,
          onLeave,
          onAfterLeave,
          onLeaveCancelled,
          onBeforeAppear,
          onAppear,
          onAfterAppear,
          onAppearCancelled
        } = props;
        const key = String(vnode.key);
        const leavingVNodesCache = getLeavingNodesForType(state, vnode);
        const callHook2 = (hook, args) => {
          hook && callWithAsyncErrorHandling(
            hook,
            instance,
            9,
            args
          );
        };
        const callAsyncHook = (hook, args) => {
          const done = args[1];
          callHook2(hook, args);
          if (shared.isArray(hook)) {
            if (hook.every((hook2) => hook2.length <= 1))
              done();
          } else if (hook.length <= 1) {
            done();
          }
        };
        const hooks = {
          mode,
          persisted,
          beforeEnter(el) {
            let hook = onBeforeEnter;
            if (!state.isMounted) {
              if (appear) {
                hook = onBeforeAppear || onBeforeEnter;
              } else {
                return;
              }
            }
            if (el._leaveCb) {
              el._leaveCb(
                true
                /* cancelled */
              );
            }
            const leavingVNode = leavingVNodesCache[key];
            if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
              leavingVNode.el._leaveCb();
            }
            callHook2(hook, [el]);
          },
          enter(el) {
            let hook = onEnter;
            let afterHook = onAfterEnter;
            let cancelHook = onEnterCancelled;
            if (!state.isMounted) {
              if (appear) {
                hook = onAppear || onEnter;
                afterHook = onAfterAppear || onAfterEnter;
                cancelHook = onAppearCancelled || onEnterCancelled;
              } else {
                return;
              }
            }
            let called = false;
            const done = el._enterCb = (cancelled) => {
              if (called)
                return;
              called = true;
              if (cancelled) {
                callHook2(cancelHook, [el]);
              } else {
                callHook2(afterHook, [el]);
              }
              if (hooks.delayedLeave) {
                hooks.delayedLeave();
              }
              el._enterCb = void 0;
            };
            if (hook) {
              callAsyncHook(hook, [el, done]);
            } else {
              done();
            }
          },
          leave(el, remove) {
            const key2 = String(vnode.key);
            if (el._enterCb) {
              el._enterCb(
                true
                /* cancelled */
              );
            }
            if (state.isUnmounting) {
              return remove();
            }
            callHook2(onBeforeLeave, [el]);
            let called = false;
            const done = el._leaveCb = (cancelled) => {
              if (called)
                return;
              called = true;
              remove();
              if (cancelled) {
                callHook2(onLeaveCancelled, [el]);
              } else {
                callHook2(onAfterLeave, [el]);
              }
              el._leaveCb = void 0;
              if (leavingVNodesCache[key2] === vnode) {
                delete leavingVNodesCache[key2];
              }
            };
            leavingVNodesCache[key2] = vnode;
            if (onLeave) {
              callAsyncHook(onLeave, [el, done]);
            } else {
              done();
            }
          },
          clone(vnode2) {
            return resolveTransitionHooks(vnode2, props, state, instance);
          }
        };
        return hooks;
      }
      function emptyPlaceholder(vnode) {
        if (isKeepAlive(vnode)) {
          vnode = cloneVNode(vnode);
          vnode.children = null;
          return vnode;
        }
      }
      function getKeepAliveChild(vnode) {
        return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
      }
      function setTransitionHooks(vnode, hooks) {
        if (vnode.shapeFlag & 6 && vnode.component) {
          setTransitionHooks(vnode.component.subTree, hooks);
        } else if (vnode.shapeFlag & 128) {
          vnode.ssContent.transition = hooks.clone(vnode.ssContent);
          vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
        } else {
          vnode.transition = hooks;
        }
      }
      function getTransitionRawChildren(children, keepComment = false, parentKey) {
        let ret = [];
        let keyedFragmentCount = 0;
        for (let i = 0; i < children.length; i++) {
          let child = children[i];
          const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
          if (child.type === Fragment) {
            if (child.patchFlag & 128)
              keyedFragmentCount++;
            ret = ret.concat(
              getTransitionRawChildren(child.children, keepComment, key)
            );
          } else if (keepComment || child.type !== Comment) {
            ret.push(key != null ? cloneVNode(child, { key }) : child);
          }
        }
        if (keyedFragmentCount > 1) {
          for (let i = 0; i < ret.length; i++) {
            ret[i].patchFlag = -2;
          }
        }
        return ret;
      }
      function defineComponent(options, extraOptions) {
        return shared.isFunction(options) ? (
          // #8326: extend call and options.name access are considered side-effects
          // by Rollup, so we have to wrap it in a pure-annotated IIFE.
          /* @__PURE__ */ (() => shared.extend({ name: options.name }, extraOptions, { setup: options }))()
        ) : options;
      }
      var isAsyncWrapper = (i) => !!i.type.__asyncLoader;
      function defineAsyncComponent(source) {
        if (shared.isFunction(source)) {
          source = { loader: source };
        }
        const {
          loader,
          loadingComponent,
          errorComponent,
          delay = 200,
          timeout,
          // undefined = never times out
          suspensible = true,
          onError: userOnError
        } = source;
        let pendingRequest = null;
        let resolvedComp;
        let retries = 0;
        const retry = () => {
          retries++;
          pendingRequest = null;
          return load();
        };
        const load = () => {
          let thisRequest;
          return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
            err = err instanceof Error ? err : new Error(String(err));
            if (userOnError) {
              return new Promise((resolve2, reject) => {
                const userRetry = () => resolve2(retry());
                const userFail = () => reject(err);
                userOnError(err, userRetry, userFail, retries + 1);
              });
            } else {
              throw err;
            }
          }).then((comp) => {
            if (thisRequest !== pendingRequest && pendingRequest) {
              return pendingRequest;
            }
            if (!comp) {
              warn(
                `Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`
              );
            }
            if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
              comp = comp.default;
            }
            if (comp && !shared.isObject(comp) && !shared.isFunction(comp)) {
              throw new Error(`Invalid async component load result: ${comp}`);
            }
            resolvedComp = comp;
            return comp;
          }));
        };
        return defineComponent({
          name: "AsyncComponentWrapper",
          __asyncLoader: load,
          get __asyncResolved() {
            return resolvedComp;
          },
          setup() {
            const instance = currentInstance;
            if (resolvedComp) {
              return () => createInnerComp(resolvedComp, instance);
            }
            const onError = (err) => {
              pendingRequest = null;
              handleError(
                err,
                instance,
                13,
                !errorComponent
                /* do not throw in dev if user provided error component */
              );
            };
            if (suspensible && instance.suspense || isInSSRComponentSetup) {
              return load().then((comp) => {
                return () => createInnerComp(comp, instance);
              }).catch((err) => {
                onError(err);
                return () => errorComponent ? createVNode(errorComponent, {
                  error: err
                }) : null;
              });
            }
            const loaded = reactivity.ref(false);
            const error = reactivity.ref();
            const delayed = reactivity.ref(!!delay);
            if (delay) {
              setTimeout(() => {
                delayed.value = false;
              }, delay);
            }
            if (timeout != null) {
              setTimeout(() => {
                if (!loaded.value && !error.value) {
                  const err = new Error(
                    `Async component timed out after ${timeout}ms.`
                  );
                  onError(err);
                  error.value = err;
                }
              }, timeout);
            }
            load().then(() => {
              loaded.value = true;
              if (instance.parent && isKeepAlive(instance.parent.vnode)) {
                queueJob(instance.parent.update);
              }
            }).catch((err) => {
              onError(err);
              error.value = err;
            });
            return () => {
              if (loaded.value && resolvedComp) {
                return createInnerComp(resolvedComp, instance);
              } else if (error.value && errorComponent) {
                return createVNode(errorComponent, {
                  error: error.value
                });
              } else if (loadingComponent && !delayed.value) {
                return createVNode(loadingComponent);
              }
            };
          }
        });
      }
      function createInnerComp(comp, parent) {
        const { ref: ref2, props, children, ce } = parent.vnode;
        const vnode = createVNode(comp, props, children);
        vnode.ref = ref2;
        vnode.ce = ce;
        delete parent.vnode.ce;
        return vnode;
      }
      var isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
      var KeepAliveImpl = {
        name: `KeepAlive`,
        // Marker for special handling inside the renderer. We are not using a ===
        // check directly on KeepAlive in the renderer, because importing it directly
        // would prevent it from being tree-shaken.
        __isKeepAlive: true,
        props: {
          include: [String, RegExp, Array],
          exclude: [String, RegExp, Array],
          max: [String, Number]
        },
        setup(props, { slots }) {
          const instance = getCurrentInstance();
          const sharedContext = instance.ctx;
          if (!sharedContext.renderer) {
            return () => {
              const children = slots.default && slots.default();
              return children && children.length === 1 ? children[0] : children;
            };
          }
          const cache = /* @__PURE__ */ new Map();
          const keys = /* @__PURE__ */ new Set();
          let current = null;
          {
            instance.__v_cache = cache;
          }
          const parentSuspense = instance.suspense;
          const {
            renderer: {
              p: patch,
              m: move,
              um: _unmount,
              o: { createElement }
            }
          } = sharedContext;
          const storageContainer = createElement("div");
          sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
            const instance2 = vnode.component;
            move(vnode, container, anchor, 0, parentSuspense);
            patch(
              instance2.vnode,
              vnode,
              container,
              anchor,
              instance2,
              parentSuspense,
              isSVG,
              vnode.slotScopeIds,
              optimized
            );
            queuePostRenderEffect(() => {
              instance2.isDeactivated = false;
              if (instance2.a) {
                shared.invokeArrayFns(instance2.a);
              }
              const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
              if (vnodeHook) {
                invokeVNodeHook(vnodeHook, instance2.parent, vnode);
              }
            }, parentSuspense);
            {
              devtoolsComponentAdded(instance2);
            }
          };
          sharedContext.deactivate = (vnode) => {
            const instance2 = vnode.component;
            move(vnode, storageContainer, null, 1, parentSuspense);
            queuePostRenderEffect(() => {
              if (instance2.da) {
                shared.invokeArrayFns(instance2.da);
              }
              const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
              if (vnodeHook) {
                invokeVNodeHook(vnodeHook, instance2.parent, vnode);
              }
              instance2.isDeactivated = true;
            }, parentSuspense);
            {
              devtoolsComponentAdded(instance2);
            }
          };
          function unmount(vnode) {
            resetShapeFlag(vnode);
            _unmount(vnode, instance, parentSuspense, true);
          }
          function pruneCache(filter) {
            cache.forEach((vnode, key) => {
              const name = getComponentName(vnode.type);
              if (name && (!filter || !filter(name))) {
                pruneCacheEntry(key);
              }
            });
          }
          function pruneCacheEntry(key) {
            const cached = cache.get(key);
            if (!current || !isSameVNodeType(cached, current)) {
              unmount(cached);
            } else if (current) {
              resetShapeFlag(current);
            }
            cache.delete(key);
            keys.delete(key);
          }
          watch(
            () => [props.include, props.exclude],
            ([include, exclude]) => {
              include && pruneCache((name) => matches(include, name));
              exclude && pruneCache((name) => !matches(exclude, name));
            },
            // prune post-render after `current` has been updated
            { flush: "post", deep: true }
          );
          let pendingCacheKey = null;
          const cacheSubtree = () => {
            if (pendingCacheKey != null) {
              cache.set(pendingCacheKey, getInnerChild(instance.subTree));
            }
          };
          onMounted(cacheSubtree);
          onUpdated(cacheSubtree);
          onBeforeUnmount(() => {
            cache.forEach((cached) => {
              const { subTree, suspense } = instance;
              const vnode = getInnerChild(subTree);
              if (cached.type === vnode.type && cached.key === vnode.key) {
                resetShapeFlag(vnode);
                const da = vnode.component.da;
                da && queuePostRenderEffect(da, suspense);
                return;
              }
              unmount(cached);
            });
          });
          return () => {
            pendingCacheKey = null;
            if (!slots.default) {
              return null;
            }
            const children = slots.default();
            const rawVNode = children[0];
            if (children.length > 1) {
              {
                warn(`KeepAlive should contain exactly one component child.`);
              }
              current = null;
              return children;
            } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
              current = null;
              return rawVNode;
            }
            let vnode = getInnerChild(rawVNode);
            const comp = vnode.type;
            const name = getComponentName(
              isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
            );
            const { include, exclude, max } = props;
            if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
              current = vnode;
              return rawVNode;
            }
            const key = vnode.key == null ? comp : vnode.key;
            const cachedVNode = cache.get(key);
            if (vnode.el) {
              vnode = cloneVNode(vnode);
              if (rawVNode.shapeFlag & 128) {
                rawVNode.ssContent = vnode;
              }
            }
            pendingCacheKey = key;
            if (cachedVNode) {
              vnode.el = cachedVNode.el;
              vnode.component = cachedVNode.component;
              if (vnode.transition) {
                setTransitionHooks(vnode, vnode.transition);
              }
              vnode.shapeFlag |= 512;
              keys.delete(key);
              keys.add(key);
            } else {
              keys.add(key);
              if (max && keys.size > parseInt(max, 10)) {
                pruneCacheEntry(keys.values().next().value);
              }
            }
            vnode.shapeFlag |= 256;
            current = vnode;
            return isSuspense(rawVNode.type) ? rawVNode : vnode;
          };
        }
      };
      var KeepAlive = KeepAliveImpl;
      function matches(pattern, name) {
        if (shared.isArray(pattern)) {
          return pattern.some((p) => matches(p, name));
        } else if (shared.isString(pattern)) {
          return pattern.split(",").includes(name);
        } else if (shared.isRegExp(pattern)) {
          return pattern.test(name);
        }
        return false;
      }
      function onActivated(hook, target) {
        registerKeepAliveHook(hook, "a", target);
      }
      function onDeactivated(hook, target) {
        registerKeepAliveHook(hook, "da", target);
      }
      function registerKeepAliveHook(hook, type, target = currentInstance) {
        const wrappedHook = hook.__wdc || (hook.__wdc = () => {
          let current = target;
          while (current) {
            if (current.isDeactivated) {
              return;
            }
            current = current.parent;
          }
          return hook();
        });
        injectHook(type, wrappedHook, target);
        if (target) {
          let current = target.parent;
          while (current && current.parent) {
            if (isKeepAlive(current.parent.vnode)) {
              injectToKeepAliveRoot(wrappedHook, type, target, current);
            }
            current = current.parent;
          }
        }
      }
      function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
        const injected = injectHook(
          type,
          hook,
          keepAliveRoot,
          true
          /* prepend */
        );
        onUnmounted(() => {
          shared.remove(keepAliveRoot[type], injected);
        }, target);
      }
      function resetShapeFlag(vnode) {
        vnode.shapeFlag &= ~256;
        vnode.shapeFlag &= ~512;
      }
      function getInnerChild(vnode) {
        return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
      }
      function injectHook(type, hook, target = currentInstance, prepend = false) {
        if (target) {
          const hooks = target[type] || (target[type] = []);
          const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
            if (target.isUnmounted) {
              return;
            }
            reactivity.pauseTracking();
            setCurrentInstance(target);
            const res = callWithAsyncErrorHandling(hook, target, type, args);
            unsetCurrentInstance();
            reactivity.resetTracking();
            return res;
          });
          if (prepend) {
            hooks.unshift(wrappedHook);
          } else {
            hooks.push(wrappedHook);
          }
          return wrappedHook;
        } else {
          const apiName = shared.toHandlerKey(ErrorTypeStrings[type].replace(/ hook$/, ""));
          warn(
            `${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
          );
        }
      }
      var createHook = (lifecycle) => (hook, target = currentInstance) => (
        // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
        (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
      );
      var onBeforeMount = createHook("bm");
      var onMounted = createHook("m");
      var onBeforeUpdate = createHook("bu");
      var onUpdated = createHook("u");
      var onBeforeUnmount = createHook("bum");
      var onUnmounted = createHook("um");
      var onServerPrefetch = createHook("sp");
      var onRenderTriggered = createHook(
        "rtg"
      );
      var onRenderTracked = createHook(
        "rtc"
      );
      function onErrorCaptured(hook, target = currentInstance) {
        injectHook("ec", hook, target);
      }
      var COMPONENTS = "components";
      var DIRECTIVES = "directives";
      function resolveComponent(name, maybeSelfReference) {
        return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
      }
      var NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
      function resolveDynamicComponent(component) {
        if (shared.isString(component)) {
          return resolveAsset(COMPONENTS, component, false) || component;
        } else {
          return component || NULL_DYNAMIC_COMPONENT;
        }
      }
      function resolveDirective(name) {
        return resolveAsset(DIRECTIVES, name);
      }
      function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
        const instance = currentRenderingInstance || currentInstance;
        if (instance) {
          const Component = instance.type;
          if (type === COMPONENTS) {
            const selfName = getComponentName(
              Component,
              false
              /* do not include inferred name to avoid breaking existing code */
            );
            if (selfName && (selfName === name || selfName === shared.camelize(name) || selfName === shared.capitalize(shared.camelize(name)))) {
              return Component;
            }
          }
          const res = (
            // local registration
            // check instance[type] first which is resolved for options API
            resolve(instance[type] || Component[type], name) || // global registration
            resolve(instance.appContext[type], name)
          );
          if (!res && maybeSelfReference) {
            return Component;
          }
          if (warnMissing && !res) {
            const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
            warn(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
          }
          return res;
        } else {
          warn(
            `resolve${shared.capitalize(type.slice(0, -1))} can only be used in render() or setup().`
          );
        }
      }
      function resolve(registry, name) {
        return registry && (registry[name] || registry[shared.camelize(name)] || registry[shared.capitalize(shared.camelize(name))]);
      }
      function renderList(source, renderItem, cache, index) {
        let ret;
        const cached = cache && cache[index];
        if (shared.isArray(source) || shared.isString(source)) {
          ret = new Array(source.length);
          for (let i = 0, l = source.length; i < l; i++) {
            ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
          }
        } else if (typeof source === "number") {
          if (!Number.isInteger(source)) {
            warn(`The v-for range expect an integer value but got ${source}.`);
          }
          ret = new Array(source);
          for (let i = 0; i < source; i++) {
            ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
          }
        } else if (shared.isObject(source)) {
          if (source[Symbol.iterator]) {
            ret = Array.from(
              source,
              (item, i) => renderItem(item, i, void 0, cached && cached[i])
            );
          } else {
            const keys = Object.keys(source);
            ret = new Array(keys.length);
            for (let i = 0, l = keys.length; i < l; i++) {
              const key = keys[i];
              ret[i] = renderItem(source[key], key, i, cached && cached[i]);
            }
          }
        } else {
          ret = [];
        }
        if (cache) {
          cache[index] = ret;
        }
        return ret;
      }
      function createSlots(slots, dynamicSlots) {
        for (let i = 0; i < dynamicSlots.length; i++) {
          const slot = dynamicSlots[i];
          if (shared.isArray(slot)) {
            for (let j = 0; j < slot.length; j++) {
              slots[slot[j].name] = slot[j].fn;
            }
          } else if (slot) {
            slots[slot.name] = slot.key ? (...args) => {
              const res = slot.fn(...args);
              if (res)
                res.key = slot.key;
              return res;
            } : slot.fn;
          }
        }
        return slots;
      }
      function renderSlot(slots, name, props = {}, fallback, noSlotted) {
        if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
          if (name !== "default")
            props.name = name;
          return createVNode("slot", props, fallback && fallback());
        }
        let slot = slots[name];
        if (slot && slot.length > 1) {
          warn(
            `SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`
          );
          slot = () => [];
        }
        if (slot && slot._c) {
          slot._d = false;
        }
        openBlock();
        const validSlotContent = slot && ensureValidVNode(slot(props));
        const rendered = createBlock(
          Fragment,
          {
            key: props.key || // slot content array of a dynamic conditional slot may have a branch
            // key attached in the `createSlots` helper, respect that
            validSlotContent && validSlotContent.key || `_${name}`
          },
          validSlotContent || (fallback ? fallback() : []),
          validSlotContent && slots._ === 1 ? 64 : -2
        );
        if (!noSlotted && rendered.scopeId) {
          rendered.slotScopeIds = [rendered.scopeId + "-s"];
        }
        if (slot && slot._c) {
          slot._d = true;
        }
        return rendered;
      }
      function ensureValidVNode(vnodes) {
        return vnodes.some((child) => {
          if (!isVNode(child))
            return true;
          if (child.type === Comment)
            return false;
          if (child.type === Fragment && !ensureValidVNode(child.children))
            return false;
          return true;
        }) ? vnodes : null;
      }
      function toHandlers(obj, preserveCaseIfNecessary) {
        const ret = {};
        if (!shared.isObject(obj)) {
          warn(`v-on with no argument expects an object value.`);
          return ret;
        }
        for (const key in obj) {
          ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : shared.toHandlerKey(key)] = obj[key];
        }
        return ret;
      }
      var getPublicInstance = (i) => {
        if (!i)
          return null;
        if (isStatefulComponent(i))
          return getExposeProxy(i) || i.proxy;
        return getPublicInstance(i.parent);
      };
      var publicPropertiesMap = (
        // Move PURE marker to new line to workaround compiler discarding it
        // due to type annotation
        /* @__PURE__ */ shared.extend(/* @__PURE__ */ Object.create(null), {
          $: (i) => i,
          $el: (i) => i.vnode.el,
          $data: (i) => i.data,
          $props: (i) => reactivity.shallowReadonly(i.props),
          $attrs: (i) => reactivity.shallowReadonly(i.attrs),
          $slots: (i) => reactivity.shallowReadonly(i.slots),
          $refs: (i) => reactivity.shallowReadonly(i.refs),
          $parent: (i) => getPublicInstance(i.parent),
          $root: (i) => getPublicInstance(i.root),
          $emit: (i) => i.emit,
          $options: (i) => resolveMergedOptions(i),
          $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
          $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
          $watch: (i) => instanceWatch.bind(i)
        })
      );
      var isReservedPrefix = (key) => key === "_" || key === "$";
      var hasSetupBinding = (state, key) => state !== shared.EMPTY_OBJ && !state.__isScriptSetup && shared.hasOwn(state, key);
      var PublicInstanceProxyHandlers = {
        get({ _: instance }, key) {
          const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
          if (key === "__isVue") {
            return true;
          }
          let normalizedProps;
          if (key[0] !== "$") {
            const n = accessCache[key];
            if (n !== void 0) {
              switch (n) {
                case 1:
                  return setupState[key];
                case 2:
                  return data[key];
                case 4:
                  return ctx[key];
                case 3:
                  return props[key];
              }
            } else if (hasSetupBinding(setupState, key)) {
              accessCache[key] = 1;
              return setupState[key];
            } else if (data !== shared.EMPTY_OBJ && shared.hasOwn(data, key)) {
              accessCache[key] = 2;
              return data[key];
            } else if (
              // only cache other properties when instance has declared (thus stable)
              // props
              (normalizedProps = instance.propsOptions[0]) && shared.hasOwn(normalizedProps, key)
            ) {
              accessCache[key] = 3;
              return props[key];
            } else if (ctx !== shared.EMPTY_OBJ && shared.hasOwn(ctx, key)) {
              accessCache[key] = 4;
              return ctx[key];
            } else if (shouldCacheAccess) {
              accessCache[key] = 0;
            }
          }
          const publicGetter = publicPropertiesMap[key];
          let cssModule, globalProperties;
          if (publicGetter) {
            if (key === "$attrs") {
              reactivity.track(instance, "get", key);
              markAttrsAccessed();
            } else if (key === "$slots") {
              reactivity.track(instance, "get", key);
            }
            return publicGetter(instance);
          } else if (
            // css module (injected by vue-loader)
            (cssModule = type.__cssModules) && (cssModule = cssModule[key])
          ) {
            return cssModule;
          } else if (ctx !== shared.EMPTY_OBJ && shared.hasOwn(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
          } else if (
            // global properties
            globalProperties = appContext.config.globalProperties, shared.hasOwn(globalProperties, key)
          ) {
            {
              return globalProperties[key];
            }
          } else if (currentRenderingInstance && (!shared.isString(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
          // to infinite warning loop
          key.indexOf("__v") !== 0)) {
            if (data !== shared.EMPTY_OBJ && isReservedPrefix(key[0]) && shared.hasOwn(data, key)) {
              warn(
                `Property ${JSON.stringify(
                  key
                )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
              );
            } else if (instance === currentRenderingInstance) {
              warn(
                `Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`
              );
            }
          }
        },
        set({ _: instance }, key, value) {
          const { data, setupState, ctx } = instance;
          if (hasSetupBinding(setupState, key)) {
            setupState[key] = value;
            return true;
          } else if (setupState.__isScriptSetup && shared.hasOwn(setupState, key)) {
            warn(`Cannot mutate <script setup> binding "${key}" from Options API.`);
            return false;
          } else if (data !== shared.EMPTY_OBJ && shared.hasOwn(data, key)) {
            data[key] = value;
            return true;
          } else if (shared.hasOwn(instance.props, key)) {
            warn(`Attempting to mutate prop "${key}". Props are readonly.`);
            return false;
          }
          if (key[0] === "$" && key.slice(1) in instance) {
            warn(
              `Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`
            );
            return false;
          } else {
            if (key in instance.appContext.config.globalProperties) {
              Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                value
              });
            } else {
              ctx[key] = value;
            }
          }
          return true;
        },
        has({
          _: { data, setupState, accessCache, ctx, appContext, propsOptions }
        }, key) {
          let normalizedProps;
          return !!accessCache[key] || data !== shared.EMPTY_OBJ && shared.hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && shared.hasOwn(normalizedProps, key) || shared.hasOwn(ctx, key) || shared.hasOwn(publicPropertiesMap, key) || shared.hasOwn(appContext.config.globalProperties, key);
        },
        defineProperty(target, key, descriptor) {
          if (descriptor.get != null) {
            target._.accessCache[key] = 0;
          } else if (shared.hasOwn(descriptor, "value")) {
            this.set(target, key, descriptor.value, null);
          }
          return Reflect.defineProperty(target, key, descriptor);
        }
      };
      {
        PublicInstanceProxyHandlers.ownKeys = (target) => {
          warn(
            `Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`
          );
          return Reflect.ownKeys(target);
        };
      }
      var RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ shared.extend(
        {},
        PublicInstanceProxyHandlers,
        {
          get(target, key) {
            if (key === Symbol.unscopables) {
              return;
            }
            return PublicInstanceProxyHandlers.get(target, key, target);
          },
          has(_, key) {
            const has = key[0] !== "_" && !shared.isGloballyWhitelisted(key);
            if (!has && PublicInstanceProxyHandlers.has(_, key)) {
              warn(
                `Property ${JSON.stringify(
                  key
                )} should not start with _ which is a reserved prefix for Vue internals.`
              );
            }
            return has;
          }
        }
      );
      function createDevRenderContext(instance) {
        const target = {};
        Object.defineProperty(target, `_`, {
          configurable: true,
          enumerable: false,
          get: () => instance
        });
        Object.keys(publicPropertiesMap).forEach((key) => {
          Object.defineProperty(target, key, {
            configurable: true,
            enumerable: false,
            get: () => publicPropertiesMap[key](instance),
            // intercepted by the proxy so no need for implementation,
            // but needed to prevent set errors
            set: shared.NOOP
          });
        });
        return target;
      }
      function exposePropsOnRenderContext(instance) {
        const {
          ctx,
          propsOptions: [propsOptions]
        } = instance;
        if (propsOptions) {
          Object.keys(propsOptions).forEach((key) => {
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              get: () => instance.props[key],
              set: shared.NOOP
            });
          });
        }
      }
      function exposeSetupStateOnRenderContext(instance) {
        const { ctx, setupState } = instance;
        Object.keys(reactivity.toRaw(setupState)).forEach((key) => {
          if (!setupState.__isScriptSetup) {
            if (isReservedPrefix(key[0])) {
              warn(
                `setup() return property ${JSON.stringify(
                  key
                )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
              );
              return;
            }
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              get: () => setupState[key],
              set: shared.NOOP
            });
          }
        });
      }
      var warnRuntimeUsage = (method) => warn(
        `${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`
      );
      function defineProps() {
        {
          warnRuntimeUsage(`defineProps`);
        }
        return null;
      }
      function defineEmits() {
        {
          warnRuntimeUsage(`defineEmits`);
        }
        return null;
      }
      function defineExpose(exposed) {
        {
          warnRuntimeUsage(`defineExpose`);
        }
      }
      function defineOptions(options) {
        {
          warnRuntimeUsage(`defineOptions`);
        }
      }
      function defineSlots() {
        {
          warnRuntimeUsage(`defineSlots`);
        }
        return null;
      }
      function defineModel() {
        {
          warnRuntimeUsage("defineModel");
        }
      }
      function withDefaults(props, defaults) {
        {
          warnRuntimeUsage(`withDefaults`);
        }
        return null;
      }
      function useSlots() {
        return getContext().slots;
      }
      function useAttrs() {
        return getContext().attrs;
      }
      function useModel(props, name, options) {
        const i = getCurrentInstance();
        if (!i) {
          warn(`useModel() called without active instance.`);
          return reactivity.ref();
        }
        if (!i.propsOptions[0][name]) {
          warn(`useModel() called with prop "${name}" which is not declared.`);
          return reactivity.ref();
        }
        if (options && options.local) {
          const proxy = reactivity.ref(props[name]);
          watch(
            () => props[name],
            (v) => proxy.value = v
          );
          watch(proxy, (value) => {
            if (value !== props[name]) {
              i.emit(`update:${name}`, value);
            }
          });
          return proxy;
        } else {
          return {
            __v_isRef: true,
            get value() {
              return props[name];
            },
            set value(value) {
              i.emit(`update:${name}`, value);
            }
          };
        }
      }
      function getContext() {
        const i = getCurrentInstance();
        if (!i) {
          warn(`useContext() called without active instance.`);
        }
        return i.setupContext || (i.setupContext = createSetupContext(i));
      }
      function normalizePropsOrEmits(props) {
        return shared.isArray(props) ? props.reduce(
          (normalized, p) => (normalized[p] = null, normalized),
          {}
        ) : props;
      }
      function mergeDefaults(raw, defaults) {
        const props = normalizePropsOrEmits(raw);
        for (const key in defaults) {
          if (key.startsWith("__skip"))
            continue;
          let opt = props[key];
          if (opt) {
            if (shared.isArray(opt) || shared.isFunction(opt)) {
              opt = props[key] = { type: opt, default: defaults[key] };
            } else {
              opt.default = defaults[key];
            }
          } else if (opt === null) {
            opt = props[key] = { default: defaults[key] };
          } else {
            warn(`props default key "${key}" has no corresponding declaration.`);
          }
          if (opt && defaults[`__skip_${key}`]) {
            opt.skipFactory = true;
          }
        }
        return props;
      }
      function mergeModels(a, b) {
        if (!a || !b)
          return a || b;
        if (shared.isArray(a) && shared.isArray(b))
          return a.concat(b);
        return shared.extend({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
      }
      function createPropsRestProxy(props, excludedKeys) {
        const ret = {};
        for (const key in props) {
          if (!excludedKeys.includes(key)) {
            Object.defineProperty(ret, key, {
              enumerable: true,
              get: () => props[key]
            });
          }
        }
        return ret;
      }
      function withAsyncContext(getAwaitable) {
        const ctx = getCurrentInstance();
        if (!ctx) {
          warn(
            `withAsyncContext called without active current instance. This is likely a bug.`
          );
        }
        let awaitable = getAwaitable();
        unsetCurrentInstance();
        if (shared.isPromise(awaitable)) {
          awaitable = awaitable.catch((e) => {
            setCurrentInstance(ctx);
            throw e;
          });
        }
        return [awaitable, () => setCurrentInstance(ctx)];
      }
      function createDuplicateChecker() {
        const cache = /* @__PURE__ */ Object.create(null);
        return (type, key) => {
          if (cache[key]) {
            warn(`${type} property "${key}" is already defined in ${cache[key]}.`);
          } else {
            cache[key] = type;
          }
        };
      }
      var shouldCacheAccess = true;
      function applyOptions(instance) {
        const options = resolveMergedOptions(instance);
        const publicThis = instance.proxy;
        const ctx = instance.ctx;
        shouldCacheAccess = false;
        if (options.beforeCreate) {
          callHook(options.beforeCreate, instance, "bc");
        }
        const {
          // state
          data: dataOptions,
          computed: computedOptions,
          methods,
          watch: watchOptions,
          provide: provideOptions,
          inject: injectOptions,
          // lifecycle
          created,
          beforeMount,
          mounted,
          beforeUpdate,
          updated,
          activated,
          deactivated,
          beforeDestroy,
          beforeUnmount,
          destroyed,
          unmounted,
          render,
          renderTracked,
          renderTriggered,
          errorCaptured,
          serverPrefetch,
          // public API
          expose,
          inheritAttrs,
          // assets
          components,
          directives,
          filters
        } = options;
        const checkDuplicateProperties = createDuplicateChecker();
        {
          const [propsOptions] = instance.propsOptions;
          if (propsOptions) {
            for (const key in propsOptions) {
              checkDuplicateProperties("Props", key);
            }
          }
        }
        if (injectOptions) {
          resolveInjections(injectOptions, ctx, checkDuplicateProperties);
        }
        if (methods) {
          for (const key in methods) {
            const methodHandler = methods[key];
            if (shared.isFunction(methodHandler)) {
              {
                Object.defineProperty(ctx, key, {
                  value: methodHandler.bind(publicThis),
                  configurable: true,
                  enumerable: true,
                  writable: true
                });
              }
              {
                checkDuplicateProperties("Methods", key);
              }
            } else {
              warn(
                `Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`
              );
            }
          }
        }
        if (dataOptions) {
          if (!shared.isFunction(dataOptions)) {
            warn(
              `The data option must be a function. Plain object usage is no longer supported.`
            );
          }
          const data = dataOptions.call(publicThis, publicThis);
          if (shared.isPromise(data)) {
            warn(
              `data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`
            );
          }
          if (!shared.isObject(data)) {
            warn(`data() should return an object.`);
          } else {
            instance.data = reactivity.reactive(data);
            {
              for (const key in data) {
                checkDuplicateProperties("Data", key);
                if (!isReservedPrefix(key[0])) {
                  Object.defineProperty(ctx, key, {
                    configurable: true,
                    enumerable: true,
                    get: () => data[key],
                    set: shared.NOOP
                  });
                }
              }
            }
          }
        }
        shouldCacheAccess = true;
        if (computedOptions) {
          for (const key in computedOptions) {
            const opt = computedOptions[key];
            const get = shared.isFunction(opt) ? opt.bind(publicThis, publicThis) : shared.isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : shared.NOOP;
            if (get === shared.NOOP) {
              warn(`Computed property "${key}" has no getter.`);
            }
            const set = !shared.isFunction(opt) && shared.isFunction(opt.set) ? opt.set.bind(publicThis) : () => {
              warn(
                `Write operation failed: computed property "${key}" is readonly.`
              );
            };
            const c = computed({
              get,
              set
            });
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              get: () => c.value,
              set: (v) => c.value = v
            });
            {
              checkDuplicateProperties("Computed", key);
            }
          }
        }
        if (watchOptions) {
          for (const key in watchOptions) {
            createWatcher(watchOptions[key], ctx, publicThis, key);
          }
        }
        if (provideOptions) {
          const provides = shared.isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
          Reflect.ownKeys(provides).forEach((key) => {
            provide(key, provides[key]);
          });
        }
        if (created) {
          callHook(created, instance, "c");
        }
        function registerLifecycleHook(register, hook) {
          if (shared.isArray(hook)) {
            hook.forEach((_hook) => register(_hook.bind(publicThis)));
          } else if (hook) {
            register(hook.bind(publicThis));
          }
        }
        registerLifecycleHook(onBeforeMount, beforeMount);
        registerLifecycleHook(onMounted, mounted);
        registerLifecycleHook(onBeforeUpdate, beforeUpdate);
        registerLifecycleHook(onUpdated, updated);
        registerLifecycleHook(onActivated, activated);
        registerLifecycleHook(onDeactivated, deactivated);
        registerLifecycleHook(onErrorCaptured, errorCaptured);
        registerLifecycleHook(onRenderTracked, renderTracked);
        registerLifecycleHook(onRenderTriggered, renderTriggered);
        registerLifecycleHook(onBeforeUnmount, beforeUnmount);
        registerLifecycleHook(onUnmounted, unmounted);
        registerLifecycleHook(onServerPrefetch, serverPrefetch);
        if (shared.isArray(expose)) {
          if (expose.length) {
            const exposed = instance.exposed || (instance.exposed = {});
            expose.forEach((key) => {
              Object.defineProperty(exposed, key, {
                get: () => publicThis[key],
                set: (val) => publicThis[key] = val
              });
            });
          } else if (!instance.exposed) {
            instance.exposed = {};
          }
        }
        if (render && instance.render === shared.NOOP) {
          instance.render = render;
        }
        if (inheritAttrs != null) {
          instance.inheritAttrs = inheritAttrs;
        }
        if (components)
          instance.components = components;
        if (directives)
          instance.directives = directives;
      }
      function resolveInjections(injectOptions, ctx, checkDuplicateProperties = shared.NOOP) {
        if (shared.isArray(injectOptions)) {
          injectOptions = normalizeInject(injectOptions);
        }
        for (const key in injectOptions) {
          const opt = injectOptions[key];
          let injected;
          if (shared.isObject(opt)) {
            if ("default" in opt) {
              injected = inject(
                opt.from || key,
                opt.default,
                true
                /* treat default function as factory */
              );
            } else {
              injected = inject(opt.from || key);
            }
          } else {
            injected = inject(opt);
          }
          if (reactivity.isRef(injected)) {
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              get: () => injected.value,
              set: (v) => injected.value = v
            });
          } else {
            ctx[key] = injected;
          }
          {
            checkDuplicateProperties("Inject", key);
          }
        }
      }
      function callHook(hook, instance, type) {
        callWithAsyncErrorHandling(
          shared.isArray(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
          instance,
          type
        );
      }
      function createWatcher(raw, ctx, publicThis, key) {
        const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
        if (shared.isString(raw)) {
          const handler = ctx[raw];
          if (shared.isFunction(handler)) {
            watch(getter, handler);
          } else {
            warn(`Invalid watch handler specified by key "${raw}"`, handler);
          }
        } else if (shared.isFunction(raw)) {
          watch(getter, raw.bind(publicThis));
        } else if (shared.isObject(raw)) {
          if (shared.isArray(raw)) {
            raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
          } else {
            const handler = shared.isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
            if (shared.isFunction(handler)) {
              watch(getter, handler, raw);
            } else {
              warn(`Invalid watch handler specified by key "${raw.handler}"`, handler);
            }
          }
        } else {
          warn(`Invalid watch option: "${key}"`, raw);
        }
      }
      function resolveMergedOptions(instance) {
        const base = instance.type;
        const { mixins, extends: extendsOptions } = base;
        const {
          mixins: globalMixins,
          optionsCache: cache,
          config: { optionMergeStrategies }
        } = instance.appContext;
        const cached = cache.get(base);
        let resolved;
        if (cached) {
          resolved = cached;
        } else if (!globalMixins.length && !mixins && !extendsOptions) {
          {
            resolved = base;
          }
        } else {
          resolved = {};
          if (globalMixins.length) {
            globalMixins.forEach(
              (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
            );
          }
          mergeOptions(resolved, base, optionMergeStrategies);
        }
        if (shared.isObject(base)) {
          cache.set(base, resolved);
        }
        return resolved;
      }
      function mergeOptions(to, from, strats, asMixin = false) {
        const { mixins, extends: extendsOptions } = from;
        if (extendsOptions) {
          mergeOptions(to, extendsOptions, strats, true);
        }
        if (mixins) {
          mixins.forEach(
            (m) => mergeOptions(to, m, strats, true)
          );
        }
        for (const key in from) {
          if (asMixin && key === "expose") {
            warn(
              `"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`
            );
          } else {
            const strat = internalOptionMergeStrats[key] || strats && strats[key];
            to[key] = strat ? strat(to[key], from[key]) : from[key];
          }
        }
        return to;
      }
      var internalOptionMergeStrats = {
        data: mergeDataFn,
        props: mergeEmitsOrPropsOptions,
        emits: mergeEmitsOrPropsOptions,
        // objects
        methods: mergeObjectOptions,
        computed: mergeObjectOptions,
        // lifecycle
        beforeCreate: mergeAsArray,
        created: mergeAsArray,
        beforeMount: mergeAsArray,
        mounted: mergeAsArray,
        beforeUpdate: mergeAsArray,
        updated: mergeAsArray,
        beforeDestroy: mergeAsArray,
        beforeUnmount: mergeAsArray,
        destroyed: mergeAsArray,
        unmounted: mergeAsArray,
        activated: mergeAsArray,
        deactivated: mergeAsArray,
        errorCaptured: mergeAsArray,
        serverPrefetch: mergeAsArray,
        // assets
        components: mergeObjectOptions,
        directives: mergeObjectOptions,
        // watch
        watch: mergeWatchOptions,
        // provide / inject
        provide: mergeDataFn,
        inject: mergeInject
      };
      function mergeDataFn(to, from) {
        if (!from) {
          return to;
        }
        if (!to) {
          return from;
        }
        return function mergedDataFn() {
          return shared.extend(
            shared.isFunction(to) ? to.call(this, this) : to,
            shared.isFunction(from) ? from.call(this, this) : from
          );
        };
      }
      function mergeInject(to, from) {
        return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
      }
      function normalizeInject(raw) {
        if (shared.isArray(raw)) {
          const res = {};
          for (let i = 0; i < raw.length; i++) {
            res[raw[i]] = raw[i];
          }
          return res;
        }
        return raw;
      }
      function mergeAsArray(to, from) {
        return to ? [...new Set([].concat(to, from))] : from;
      }
      function mergeObjectOptions(to, from) {
        return to ? shared.extend(/* @__PURE__ */ Object.create(null), to, from) : from;
      }
      function mergeEmitsOrPropsOptions(to, from) {
        if (to) {
          if (shared.isArray(to) && shared.isArray(from)) {
            return [.../* @__PURE__ */ new Set([...to, ...from])];
          }
          return shared.extend(
            /* @__PURE__ */ Object.create(null),
            normalizePropsOrEmits(to),
            normalizePropsOrEmits(from != null ? from : {})
          );
        } else {
          return from;
        }
      }
      function mergeWatchOptions(to, from) {
        if (!to)
          return from;
        if (!from)
          return to;
        const merged = shared.extend(/* @__PURE__ */ Object.create(null), to);
        for (const key in from) {
          merged[key] = mergeAsArray(to[key], from[key]);
        }
        return merged;
      }
      function createAppContext() {
        return {
          app: null,
          config: {
            isNativeTag: shared.NO,
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
          },
          mixins: [],
          components: {},
          directives: {},
          provides: /* @__PURE__ */ Object.create(null),
          optionsCache: /* @__PURE__ */ new WeakMap(),
          propsCache: /* @__PURE__ */ new WeakMap(),
          emitsCache: /* @__PURE__ */ new WeakMap()
        };
      }
      var uid$1 = 0;
      function createAppAPI(render, hydrate) {
        return function createApp2(rootComponent, rootProps = null) {
          if (!shared.isFunction(rootComponent)) {
            rootComponent = shared.extend({}, rootComponent);
          }
          if (rootProps != null && !shared.isObject(rootProps)) {
            warn(`root props passed to app.mount() must be an object.`);
            rootProps = null;
          }
          const context = createAppContext();
          {
            Object.defineProperty(context.config, "unwrapInjectedRef", {
              get() {
                return true;
              },
              set() {
                warn(
                  `app.config.unwrapInjectedRef has been deprecated. 3.3 now alawys unwraps injected refs in Options API.`
                );
              }
            });
          }
          const installedPlugins = /* @__PURE__ */ new Set();
          let isMounted = false;
          const app2 = context.app = {
            _uid: uid$1++,
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context,
            _instance: null,
            version,
            get config() {
              return context.config;
            },
            set config(v) {
              {
                warn(
                  `app.config cannot be replaced. Modify individual options instead.`
                );
              }
            },
            use(plugin, ...options) {
              if (installedPlugins.has(plugin)) {
                warn(`Plugin has already been applied to target app.`);
              } else if (plugin && shared.isFunction(plugin.install)) {
                installedPlugins.add(plugin);
                plugin.install(app2, ...options);
              } else if (shared.isFunction(plugin)) {
                installedPlugins.add(plugin);
                plugin(app2, ...options);
              } else {
                warn(
                  `A plugin must either be a function or an object with an "install" function.`
                );
              }
              return app2;
            },
            mixin(mixin) {
              {
                if (!context.mixins.includes(mixin)) {
                  context.mixins.push(mixin);
                } else {
                  warn(
                    "Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : "")
                  );
                }
              }
              return app2;
            },
            component(name, component) {
              {
                validateComponentName(name, context.config);
              }
              if (!component) {
                return context.components[name];
              }
              if (context.components[name]) {
                warn(`Component "${name}" has already been registered in target app.`);
              }
              context.components[name] = component;
              return app2;
            },
            directive(name, directive) {
              {
                validateDirectiveName(name);
              }
              if (!directive) {
                return context.directives[name];
              }
              if (context.directives[name]) {
                warn(`Directive "${name}" has already been registered in target app.`);
              }
              context.directives[name] = directive;
              return app2;
            },
            mount(rootContainer, isHydrate, isSVG) {
              if (!isMounted) {
                if (rootContainer.__vue_app__) {
                  warn(
                    `There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`
                  );
                }
                const vnode = createVNode(
                  rootComponent,
                  rootProps
                );
                vnode.appContext = context;
                {
                  context.reload = () => {
                    render(cloneVNode(vnode), rootContainer, isSVG);
                  };
                }
                if (isHydrate && hydrate) {
                  hydrate(vnode, rootContainer);
                } else {
                  render(vnode, rootContainer, isSVG);
                }
                isMounted = true;
                app2._container = rootContainer;
                rootContainer.__vue_app__ = app2;
                {
                  app2._instance = vnode.component;
                  devtoolsInitApp(app2, version);
                }
                return getExposeProxy(vnode.component) || vnode.component.proxy;
              } else {
                warn(
                  `App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``
                );
              }
            },
            unmount() {
              if (isMounted) {
                render(null, app2._container);
                {
                  app2._instance = null;
                  devtoolsUnmountApp(app2);
                }
                delete app2._container.__vue_app__;
              } else {
                warn(`Cannot unmount an app that is not mounted.`);
              }
            },
            provide(key, value) {
              if (key in context.provides) {
                warn(
                  `App already provides property with key "${String(key)}". It will be overwritten with the new value.`
                );
              }
              context.provides[key] = value;
              return app2;
            },
            runWithContext(fn) {
              currentApp = app2;
              try {
                return fn();
              } finally {
                currentApp = null;
              }
            }
          };
          return app2;
        };
      }
      var currentApp = null;
      function provide(key, value) {
        if (!currentInstance) {
          {
            warn(`provide() can only be used inside setup().`);
          }
        } else {
          let provides = currentInstance.provides;
          const parentProvides = currentInstance.parent && currentInstance.parent.provides;
          if (parentProvides === provides) {
            provides = currentInstance.provides = Object.create(parentProvides);
          }
          provides[key] = value;
        }
      }
      function inject(key, defaultValue, treatDefaultAsFactory = false) {
        const instance = currentInstance || currentRenderingInstance;
        if (instance || currentApp) {
          const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
          if (provides && key in provides) {
            return provides[key];
          } else if (arguments.length > 1) {
            return treatDefaultAsFactory && shared.isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
          } else {
            warn(`injection "${String(key)}" not found.`);
          }
        } else {
          warn(`inject() can only be used inside setup() or functional components.`);
        }
      }
      function hasInjectionContext() {
        return !!(currentInstance || currentRenderingInstance || currentApp);
      }
      function initProps(instance, rawProps, isStateful, isSSR = false) {
        const props = {};
        const attrs = {};
        shared.def(attrs, InternalObjectKey, 1);
        instance.propsDefaults = /* @__PURE__ */ Object.create(null);
        setFullProps(instance, rawProps, props, attrs);
        for (const key in instance.propsOptions[0]) {
          if (!(key in props)) {
            props[key] = void 0;
          }
        }
        {
          validateProps(rawProps || {}, props, instance);
        }
        if (isStateful) {
          instance.props = isSSR ? props : reactivity.shallowReactive(props);
        } else {
          if (!instance.type.props) {
            instance.props = attrs;
          } else {
            instance.props = props;
          }
        }
        instance.attrs = attrs;
      }
      function isInHmrContext(instance) {
        while (instance) {
          if (instance.type.__hmrId)
            return true;
          instance = instance.parent;
        }
      }
      function updateProps(instance, rawProps, rawPrevProps, optimized) {
        const {
          props,
          attrs,
          vnode: { patchFlag }
        } = instance;
        const rawCurrentProps = reactivity.toRaw(props);
        const [options] = instance.propsOptions;
        let hasAttrsChanged = false;
        if (
          // always force full diff in dev
          // - #1942 if hmr is enabled with sfc component
          // - vite#872 non-sfc component used by sfc component
          !isInHmrContext(instance) && (optimized || patchFlag > 0) && !(patchFlag & 16)
        ) {
          if (patchFlag & 8) {
            const propsToUpdate = instance.vnode.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
              let key = propsToUpdate[i];
              if (isEmitListener(instance.emitsOptions, key)) {
                continue;
              }
              const value = rawProps[key];
              if (options) {
                if (shared.hasOwn(attrs, key)) {
                  if (value !== attrs[key]) {
                    attrs[key] = value;
                    hasAttrsChanged = true;
                  }
                } else {
                  const camelizedKey = shared.camelize(key);
                  props[camelizedKey] = resolvePropValue(
                    options,
                    rawCurrentProps,
                    camelizedKey,
                    value,
                    instance,
                    false
                    /* isAbsent */
                  );
                }
              } else {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              }
            }
          }
        } else {
          if (setFullProps(instance, rawProps, props, attrs)) {
            hasAttrsChanged = true;
          }
          let kebabKey;
          for (const key in rawCurrentProps) {
            if (!rawProps || // for camelCase
            !shared.hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
            // and converted to camelCase (#955)
            ((kebabKey = shared.hyphenate(key)) === key || !shared.hasOwn(rawProps, kebabKey))) {
              if (options) {
                if (rawPrevProps && // for camelCase
                (rawPrevProps[key] !== void 0 || // for kebab-case
                rawPrevProps[kebabKey] !== void 0)) {
                  props[key] = resolvePropValue(
                    options,
                    rawCurrentProps,
                    key,
                    void 0,
                    instance,
                    true
                    /* isAbsent */
                  );
                }
              } else {
                delete props[key];
              }
            }
          }
          if (attrs !== rawCurrentProps) {
            for (const key in attrs) {
              if (!rawProps || !shared.hasOwn(rawProps, key) && true) {
                delete attrs[key];
                hasAttrsChanged = true;
              }
            }
          }
        }
        if (hasAttrsChanged) {
          reactivity.trigger(instance, "set", "$attrs");
        }
        {
          validateProps(rawProps || {}, props, instance);
        }
      }
      function setFullProps(instance, rawProps, props, attrs) {
        const [options, needCastKeys] = instance.propsOptions;
        let hasAttrsChanged = false;
        let rawCastValues;
        if (rawProps) {
          for (let key in rawProps) {
            if (shared.isReservedProp(key)) {
              continue;
            }
            const value = rawProps[key];
            let camelKey;
            if (options && shared.hasOwn(options, camelKey = shared.camelize(key))) {
              if (!needCastKeys || !needCastKeys.includes(camelKey)) {
                props[camelKey] = value;
              } else {
                (rawCastValues || (rawCastValues = {}))[camelKey] = value;
              }
            } else if (!isEmitListener(instance.emitsOptions, key)) {
              if (!(key in attrs) || value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
        if (needCastKeys) {
          const rawCurrentProps = reactivity.toRaw(props);
          const castValues = rawCastValues || shared.EMPTY_OBJ;
          for (let i = 0; i < needCastKeys.length; i++) {
            const key = needCastKeys[i];
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              castValues[key],
              instance,
              !shared.hasOwn(castValues, key)
            );
          }
        }
        return hasAttrsChanged;
      }
      function resolvePropValue(options, props, key, value, instance, isAbsent) {
        const opt = options[key];
        if (opt != null) {
          const hasDefault = shared.hasOwn(opt, "default");
          if (hasDefault && value === void 0) {
            const defaultValue = opt.default;
            if (opt.type !== Function && !opt.skipFactory && shared.isFunction(defaultValue)) {
              const { propsDefaults } = instance;
              if (key in propsDefaults) {
                value = propsDefaults[key];
              } else {
                setCurrentInstance(instance);
                value = propsDefaults[key] = defaultValue.call(
                  null,
                  props
                );
                unsetCurrentInstance();
              }
            } else {
              value = defaultValue;
            }
          }
          if (opt[
            0
            /* shouldCast */
          ]) {
            if (isAbsent && !hasDefault) {
              value = false;
            } else if (opt[
              1
              /* shouldCastTrue */
            ] && (value === "" || value === shared.hyphenate(key))) {
              value = true;
            }
          }
        }
        return value;
      }
      function normalizePropsOptions(comp, appContext, asMixin = false) {
        const cache = appContext.propsCache;
        const cached = cache.get(comp);
        if (cached) {
          return cached;
        }
        const raw = comp.props;
        const normalized = {};
        const needCastKeys = [];
        let hasExtends = false;
        if (!shared.isFunction(comp)) {
          const extendProps = (raw2) => {
            hasExtends = true;
            const [props, keys] = normalizePropsOptions(raw2, appContext, true);
            shared.extend(normalized, props);
            if (keys)
              needCastKeys.push(...keys);
          };
          if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendProps);
          }
          if (comp.extends) {
            extendProps(comp.extends);
          }
          if (comp.mixins) {
            comp.mixins.forEach(extendProps);
          }
        }
        if (!raw && !hasExtends) {
          if (shared.isObject(comp)) {
            cache.set(comp, shared.EMPTY_ARR);
          }
          return shared.EMPTY_ARR;
        }
        if (shared.isArray(raw)) {
          for (let i = 0; i < raw.length; i++) {
            if (!shared.isString(raw[i])) {
              warn(`props must be strings when using array syntax.`, raw[i]);
            }
            const normalizedKey = shared.camelize(raw[i]);
            if (validatePropName(normalizedKey)) {
              normalized[normalizedKey] = shared.EMPTY_OBJ;
            }
          }
        } else if (raw) {
          if (!shared.isObject(raw)) {
            warn(`invalid props options`, raw);
          }
          for (const key in raw) {
            const normalizedKey = shared.camelize(key);
            if (validatePropName(normalizedKey)) {
              const opt = raw[key];
              const prop = normalized[normalizedKey] = shared.isArray(opt) || shared.isFunction(opt) ? { type: opt } : shared.extend({}, opt);
              if (prop) {
                const booleanIndex = getTypeIndex(Boolean, prop.type);
                const stringIndex = getTypeIndex(String, prop.type);
                prop[
                  0
                  /* shouldCast */
                ] = booleanIndex > -1;
                prop[
                  1
                  /* shouldCastTrue */
                ] = stringIndex < 0 || booleanIndex < stringIndex;
                if (booleanIndex > -1 || shared.hasOwn(prop, "default")) {
                  needCastKeys.push(normalizedKey);
                }
              }
            }
          }
        }
        const res = [normalized, needCastKeys];
        if (shared.isObject(comp)) {
          cache.set(comp, res);
        }
        return res;
      }
      function validatePropName(key) {
        if (key[0] !== "$") {
          return true;
        } else {
          warn(`Invalid prop name: "${key}" is a reserved property.`);
        }
        return false;
      }
      function getType(ctor) {
        const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
        return match ? match[2] : ctor === null ? "null" : "";
      }
      function isSameType(a, b) {
        return getType(a) === getType(b);
      }
      function getTypeIndex(type, expectedTypes) {
        if (shared.isArray(expectedTypes)) {
          return expectedTypes.findIndex((t) => isSameType(t, type));
        } else if (shared.isFunction(expectedTypes)) {
          return isSameType(expectedTypes, type) ? 0 : -1;
        }
        return -1;
      }
      function validateProps(rawProps, props, instance) {
        const resolvedValues = reactivity.toRaw(props);
        const options = instance.propsOptions[0];
        for (const key in options) {
          let opt = options[key];
          if (opt == null)
            continue;
          validateProp(
            key,
            resolvedValues[key],
            opt,
            !shared.hasOwn(rawProps, key) && !shared.hasOwn(rawProps, shared.hyphenate(key))
          );
        }
      }
      function validateProp(name, value, prop, isAbsent) {
        const { type, required, validator, skipCheck } = prop;
        if (required && isAbsent) {
          warn('Missing required prop: "' + name + '"');
          return;
        }
        if (value == null && !required) {
          return;
        }
        if (type != null && type !== true && !skipCheck) {
          let isValid = false;
          const types = shared.isArray(type) ? type : [type];
          const expectedTypes = [];
          for (let i = 0; i < types.length && !isValid; i++) {
            const { valid, expectedType } = assertType(value, types[i]);
            expectedTypes.push(expectedType || "");
            isValid = valid;
          }
          if (!isValid) {
            warn(getInvalidTypeMessage(name, value, expectedTypes));
            return;
          }
        }
        if (validator && !validator(value)) {
          warn('Invalid prop: custom validator check failed for prop "' + name + '".');
        }
      }
      var isSimpleType = /* @__PURE__ */ shared.makeMap(
        "String,Number,Boolean,Function,Symbol,BigInt"
      );
      function assertType(value, type) {
        let valid;
        const expectedType = getType(type);
        if (isSimpleType(expectedType)) {
          const t = typeof value;
          valid = t === expectedType.toLowerCase();
          if (!valid && t === "object") {
            valid = value instanceof type;
          }
        } else if (expectedType === "Object") {
          valid = shared.isObject(value);
        } else if (expectedType === "Array") {
          valid = shared.isArray(value);
        } else if (expectedType === "null") {
          valid = value === null;
        } else {
          valid = value instanceof type;
        }
        return {
          valid,
          expectedType
        };
      }
      function getInvalidTypeMessage(name, value, expectedTypes) {
        let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(shared.capitalize).join(" | ")}`;
        const expectedType = expectedTypes[0];
        const receivedType = shared.toRawType(value);
        const expectedValue = styleValue(value, expectedType);
        const receivedValue = styleValue(value, receivedType);
        if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
          message += ` with value ${expectedValue}`;
        }
        message += `, got ${receivedType} `;
        if (isExplicable(receivedType)) {
          message += `with value ${receivedValue}.`;
        }
        return message;
      }
      function styleValue(value, type) {
        if (type === "String") {
          return `"${value}"`;
        } else if (type === "Number") {
          return `${Number(value)}`;
        } else {
          return `${value}`;
        }
      }
      function isExplicable(type) {
        const explicitTypes = ["string", "number", "boolean"];
        return explicitTypes.some((elem) => type.toLowerCase() === elem);
      }
      function isBoolean(...args) {
        return args.some((elem) => elem.toLowerCase() === "boolean");
      }
      var isInternalKey = (key) => key[0] === "_" || key === "$stable";
      var normalizeSlotValue = (value) => shared.isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
      var normalizeSlot = (key, rawSlot, ctx) => {
        if (rawSlot._n) {
          return rawSlot;
        }
        const normalized = withCtx((...args) => {
          if (currentInstance) {
            warn(
              `Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
            );
          }
          return normalizeSlotValue(rawSlot(...args));
        }, ctx);
        normalized._c = false;
        return normalized;
      };
      var normalizeObjectSlots = (rawSlots, slots, instance) => {
        const ctx = rawSlots._ctx;
        for (const key in rawSlots) {
          if (isInternalKey(key))
            continue;
          const value = rawSlots[key];
          if (shared.isFunction(value)) {
            slots[key] = normalizeSlot(key, value, ctx);
          } else if (value != null) {
            {
              warn(
                `Non-function value encountered for slot "${key}". Prefer function slots for better performance.`
              );
            }
            const normalized = normalizeSlotValue(value);
            slots[key] = () => normalized;
          }
        }
      };
      var normalizeVNodeSlots = (instance, children) => {
        if (!isKeepAlive(instance.vnode) && true) {
          warn(
            `Non-function value encountered for default slot. Prefer function slots for better performance.`
          );
        }
        const normalized = normalizeSlotValue(children);
        instance.slots.default = () => normalized;
      };
      var initSlots = (instance, children) => {
        if (instance.vnode.shapeFlag & 32) {
          const type = children._;
          if (type) {
            instance.slots = reactivity.toRaw(children);
            shared.def(children, "_", type);
          } else {
            normalizeObjectSlots(
              children,
              instance.slots = {}
            );
          }
        } else {
          instance.slots = {};
          if (children) {
            normalizeVNodeSlots(instance, children);
          }
        }
        shared.def(instance.slots, InternalObjectKey, 1);
      };
      var updateSlots = (instance, children, optimized) => {
        const { vnode, slots } = instance;
        let needDeletionCheck = true;
        let deletionComparisonTarget = shared.EMPTY_OBJ;
        if (vnode.shapeFlag & 32) {
          const type = children._;
          if (type) {
            if (isHmrUpdating) {
              shared.extend(slots, children);
              reactivity.trigger(instance, "set", "$slots");
            } else if (optimized && type === 1) {
              needDeletionCheck = false;
            } else {
              shared.extend(slots, children);
              if (!optimized && type === 1) {
                delete slots._;
              }
            }
          } else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
          }
          deletionComparisonTarget = children;
        } else if (children) {
          normalizeVNodeSlots(instance, children);
          deletionComparisonTarget = { default: 1 };
        }
        if (needDeletionCheck) {
          for (const key in slots) {
            if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
              delete slots[key];
            }
          }
        }
      };
      function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
        if (shared.isArray(rawRef)) {
          rawRef.forEach(
            (r, i) => setRef(
              r,
              oldRawRef && (shared.isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
              parentSuspense,
              vnode,
              isUnmount
            )
          );
          return;
        }
        if (isAsyncWrapper(vnode) && !isUnmount) {
          return;
        }
        const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
        const value = isUnmount ? null : refValue;
        const { i: owner, r: ref } = rawRef;
        if (!owner) {
          warn(
            `Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`
          );
          return;
        }
        const oldRef = oldRawRef && oldRawRef.r;
        const refs = owner.refs === shared.EMPTY_OBJ ? owner.refs = {} : owner.refs;
        const setupState = owner.setupState;
        if (oldRef != null && oldRef !== ref) {
          if (shared.isString(oldRef)) {
            refs[oldRef] = null;
            if (shared.hasOwn(setupState, oldRef)) {
              setupState[oldRef] = null;
            }
          } else if (reactivity.isRef(oldRef)) {
            oldRef.value = null;
          }
        }
        if (shared.isFunction(ref)) {
          callWithErrorHandling(ref, owner, 12, [value, refs]);
        } else {
          const _isString = shared.isString(ref);
          const _isRef = reactivity.isRef(ref);
          if (_isString || _isRef) {
            const doSet = () => {
              if (rawRef.f) {
                const existing = _isString ? shared.hasOwn(setupState, ref) ? setupState[ref] : refs[ref] : ref.value;
                if (isUnmount) {
                  shared.isArray(existing) && shared.remove(existing, refValue);
                } else {
                  if (!shared.isArray(existing)) {
                    if (_isString) {
                      refs[ref] = [refValue];
                      if (shared.hasOwn(setupState, ref)) {
                        setupState[ref] = refs[ref];
                      }
                    } else {
                      ref.value = [refValue];
                      if (rawRef.k)
                        refs[rawRef.k] = ref.value;
                    }
                  } else if (!existing.includes(refValue)) {
                    existing.push(refValue);
                  }
                }
              } else if (_isString) {
                refs[ref] = value;
                if (shared.hasOwn(setupState, ref)) {
                  setupState[ref] = value;
                }
              } else if (_isRef) {
                ref.value = value;
                if (rawRef.k)
                  refs[rawRef.k] = value;
              } else {
                warn("Invalid template ref type:", ref, `(${typeof ref})`);
              }
            };
            if (value) {
              doSet.id = -1;
              queuePostRenderEffect(doSet, parentSuspense);
            } else {
              doSet();
            }
          } else {
            warn("Invalid template ref type:", ref, `(${typeof ref})`);
          }
        }
      }
      var hasMismatch = false;
      var isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== "foreignObject";
      var isComment = (node) => node.nodeType === 8;
      function createHydrationFunctions(rendererInternals) {
        const {
          mt: mountComponent,
          p: patch,
          o: {
            patchProp,
            createText,
            nextSibling,
            parentNode,
            remove,
            insert,
            createComment
          }
        } = rendererInternals;
        const hydrate = (vnode, container) => {
          if (!container.hasChildNodes()) {
            warn(
              `Attempting to hydrate existing markup but container is empty. Performing full mount instead.`
            );
            patch(null, vnode, container);
            flushPostFlushCbs();
            container._vnode = vnode;
            return;
          }
          hasMismatch = false;
          hydrateNode(container.firstChild, vnode, null, null, null);
          flushPostFlushCbs();
          container._vnode = vnode;
          if (hasMismatch && true) {
            console.error(`Hydration completed but contains mismatches.`);
          }
        };
        const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
          const isFragmentStart = isComment(node) && node.data === "[";
          const onMismatch = () => handleMismatch(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            isFragmentStart
          );
          const { type, ref, shapeFlag, patchFlag } = vnode;
          let domType = node.nodeType;
          vnode.el = node;
          if (patchFlag === -2) {
            optimized = false;
            vnode.dynamicChildren = null;
          }
          let nextNode = null;
          switch (type) {
            case Text:
              if (domType !== 3) {
                if (vnode.children === "") {
                  insert(vnode.el = createText(""), parentNode(node), node);
                  nextNode = node;
                } else {
                  nextNode = onMismatch();
                }
              } else {
                if (node.data !== vnode.children) {
                  hasMismatch = true;
                  warn(
                    `Hydration text mismatch:
- Client: ${JSON.stringify(node.data)}
- Server: ${JSON.stringify(vnode.children)}`
                  );
                  node.data = vnode.children;
                }
                nextNode = nextSibling(node);
              }
              break;
            case Comment:
              if (domType !== 8 || isFragmentStart) {
                nextNode = onMismatch();
              } else {
                nextNode = nextSibling(node);
              }
              break;
            case Static:
              if (isFragmentStart) {
                node = nextSibling(node);
                domType = node.nodeType;
              }
              if (domType === 1 || domType === 3) {
                nextNode = node;
                const needToAdoptContent = !vnode.children.length;
                for (let i = 0; i < vnode.staticCount; i++) {
                  if (needToAdoptContent)
                    vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
                  if (i === vnode.staticCount - 1) {
                    vnode.anchor = nextNode;
                  }
                  nextNode = nextSibling(nextNode);
                }
                return isFragmentStart ? nextSibling(nextNode) : nextNode;
              } else {
                onMismatch();
              }
              break;
            case Fragment:
              if (!isFragmentStart) {
                nextNode = onMismatch();
              } else {
                nextNode = hydrateFragment(
                  node,
                  vnode,
                  parentComponent,
                  parentSuspense,
                  slotScopeIds,
                  optimized
                );
              }
              break;
            default:
              if (shapeFlag & 1) {
                if (domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) {
                  nextNode = onMismatch();
                } else {
                  nextNode = hydrateElement(
                    node,
                    vnode,
                    parentComponent,
                    parentSuspense,
                    slotScopeIds,
                    optimized
                  );
                }
              } else if (shapeFlag & 6) {
                vnode.slotScopeIds = slotScopeIds;
                const container = parentNode(node);
                mountComponent(
                  vnode,
                  container,
                  null,
                  parentComponent,
                  parentSuspense,
                  isSVGContainer(container),
                  optimized
                );
                nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node);
                if (nextNode && isComment(nextNode) && nextNode.data === "teleport end") {
                  nextNode = nextSibling(nextNode);
                }
                if (isAsyncWrapper(vnode)) {
                  let subTree;
                  if (isFragmentStart) {
                    subTree = createVNode(Fragment);
                    subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
                  } else {
                    subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
                  }
                  subTree.el = node;
                  vnode.component.subTree = subTree;
                }
              } else if (shapeFlag & 64) {
                if (domType !== 8) {
                  nextNode = onMismatch();
                } else {
                  nextNode = vnode.type.hydrate(
                    node,
                    vnode,
                    parentComponent,
                    parentSuspense,
                    slotScopeIds,
                    optimized,
                    rendererInternals,
                    hydrateChildren
                  );
                }
              } else if (shapeFlag & 128) {
                nextNode = vnode.type.hydrate(
                  node,
                  vnode,
                  parentComponent,
                  parentSuspense,
                  isSVGContainer(parentNode(node)),
                  slotScopeIds,
                  optimized,
                  rendererInternals,
                  hydrateNode
                );
              } else {
                warn("Invalid HostVNode type:", type, `(${typeof type})`);
              }
          }
          if (ref != null) {
            setRef(ref, null, parentSuspense, vnode);
          }
          return nextNode;
        };
        const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
          optimized = optimized || !!vnode.dynamicChildren;
          const { type, props, patchFlag, shapeFlag, dirs } = vnode;
          const forcePatchValue = type === "input" && dirs || type === "option";
          {
            if (dirs) {
              invokeDirectiveHook(vnode, null, parentComponent, "created");
            }
            if (props) {
              if (forcePatchValue || !optimized || patchFlag & (16 | 32)) {
                for (const key in props) {
                  if (forcePatchValue && key.endsWith("value") || shared.isOn(key) && !shared.isReservedProp(key)) {
                    patchProp(
                      el,
                      key,
                      null,
                      props[key],
                      false,
                      void 0,
                      parentComponent
                    );
                  }
                }
              } else if (props.onClick) {
                patchProp(
                  el,
                  "onClick",
                  null,
                  props.onClick,
                  false,
                  void 0,
                  parentComponent
                );
              }
            }
            let vnodeHooks;
            if (vnodeHooks = props && props.onVnodeBeforeMount) {
              invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            }
            if (dirs) {
              invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
            }
            if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
              queueEffectWithSuspense(() => {
                vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
                dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
              }, parentSuspense);
            }
            if (shapeFlag & 16 && // skip if element has innerHTML / textContent
            !(props && (props.innerHTML || props.textContent))) {
              let next = hydrateChildren(
                el.firstChild,
                vnode,
                el,
                parentComponent,
                parentSuspense,
                slotScopeIds,
                optimized
              );
              let hasWarned2 = false;
              while (next) {
                hasMismatch = true;
                if (!hasWarned2) {
                  warn(
                    `Hydration children mismatch in <${vnode.type}>: server rendered element contains more child nodes than client vdom.`
                  );
                  hasWarned2 = true;
                }
                const cur = next;
                next = next.nextSibling;
                remove(cur);
              }
            } else if (shapeFlag & 8) {
              if (el.textContent !== vnode.children) {
                hasMismatch = true;
                warn(
                  `Hydration text content mismatch in <${vnode.type}>:
- Client: ${el.textContent}
- Server: ${vnode.children}`
                );
                el.textContent = vnode.children;
              }
            }
          }
          return el.nextSibling;
        };
        const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
          optimized = optimized || !!parentVNode.dynamicChildren;
          const children = parentVNode.children;
          const l = children.length;
          let hasWarned2 = false;
          for (let i = 0; i < l; i++) {
            const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
            if (node) {
              node = hydrateNode(
                node,
                vnode,
                parentComponent,
                parentSuspense,
                slotScopeIds,
                optimized
              );
            } else if (vnode.type === Text && !vnode.children) {
              continue;
            } else {
              hasMismatch = true;
              if (!hasWarned2) {
                warn(
                  `Hydration children mismatch in <${container.tagName.toLowerCase()}>: server rendered element contains fewer child nodes than client vdom.`
                );
                hasWarned2 = true;
              }
              patch(
                null,
                vnode,
                container,
                null,
                parentComponent,
                parentSuspense,
                isSVGContainer(container),
                slotScopeIds
              );
            }
          }
          return node;
        };
        const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
          const { slotScopeIds: fragmentSlotScopeIds } = vnode;
          if (fragmentSlotScopeIds) {
            slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
          }
          const container = parentNode(node);
          const next = hydrateChildren(
            nextSibling(node),
            vnode,
            container,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
          if (next && isComment(next) && next.data === "]") {
            return nextSibling(vnode.anchor = next);
          } else {
            hasMismatch = true;
            insert(vnode.anchor = createComment(`]`), container, next);
            return next;
          }
        };
        const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
          hasMismatch = true;
          warn(
            `Hydration node mismatch:
- Client vnode:`,
            vnode.type,
            `
- Server rendered DOM:`,
            node,
            node.nodeType === 3 ? `(text)` : isComment(node) && node.data === "[" ? `(start of fragment)` : ``
          );
          vnode.el = null;
          if (isFragment) {
            const end = locateClosingAsyncAnchor(node);
            while (true) {
              const next2 = nextSibling(node);
              if (next2 && next2 !== end) {
                remove(next2);
              } else {
                break;
              }
            }
          }
          const next = nextSibling(node);
          const container = parentNode(node);
          remove(node);
          patch(
            null,
            vnode,
            container,
            next,
            parentComponent,
            parentSuspense,
            isSVGContainer(container),
            slotScopeIds
          );
          return next;
        };
        const locateClosingAsyncAnchor = (node) => {
          let match = 0;
          while (node) {
            node = nextSibling(node);
            if (node && isComment(node)) {
              if (node.data === "[")
                match++;
              if (node.data === "]") {
                if (match === 0) {
                  return nextSibling(node);
                } else {
                  match--;
                }
              }
            }
          }
          return node;
        };
        return [hydrate, hydrateNode];
      }
      var supported;
      var perf;
      function startMeasure(instance, type) {
        if (instance.appContext.config.performance && isSupported()) {
          perf.mark(`vue-${type}-${instance.uid}`);
        }
        {
          devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
        }
      }
      function endMeasure(instance, type) {
        if (instance.appContext.config.performance && isSupported()) {
          const startTag = `vue-${type}-${instance.uid}`;
          const endTag = startTag + `:end`;
          perf.mark(endTag);
          perf.measure(
            `<${formatComponentName(instance, instance.type)}> ${type}`,
            startTag,
            endTag
          );
          perf.clearMarks(startTag);
          perf.clearMarks(endTag);
        }
        {
          devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
        }
      }
      function isSupported() {
        if (supported !== void 0) {
          return supported;
        }
        if (typeof window !== "undefined" && window.performance) {
          supported = true;
          perf = window.performance;
        } else {
          supported = false;
        }
        return supported;
      }
      var queuePostRenderEffect = queueEffectWithSuspense;
      function createRenderer(options) {
        return baseCreateRenderer(options);
      }
      function createHydrationRenderer(options) {
        return baseCreateRenderer(options, createHydrationFunctions);
      }
      function baseCreateRenderer(options, createHydrationFns) {
        const target = shared.getGlobalThis();
        target.__VUE__ = true;
        {
          setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
        }
        const {
          insert: hostInsert,
          remove: hostRemove,
          patchProp: hostPatchProp,
          createElement: hostCreateElement,
          createText: hostCreateText,
          createComment: hostCreateComment,
          setText: hostSetText,
          setElementText: hostSetElementText,
          parentNode: hostParentNode,
          nextSibling: hostNextSibling,
          setScopeId: hostSetScopeId = shared.NOOP,
          insertStaticContent: hostInsertStaticContent
        } = options;
        const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren) => {
          if (n1 === n2) {
            return;
          }
          if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
          }
          if (n2.patchFlag === -2) {
            optimized = false;
            n2.dynamicChildren = null;
          }
          const { type, ref, shapeFlag } = n2;
          switch (type) {
            case Text:
              processText(n1, n2, container, anchor);
              break;
            case Comment:
              processCommentNode(n1, n2, container, anchor);
              break;
            case Static:
              if (n1 == null) {
                mountStaticNode(n2, container, anchor, isSVG);
              } else {
                patchStaticNode(n1, n2, container, isSVG);
              }
              break;
            case Fragment:
              processFragment(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
              break;
            default:
              if (shapeFlag & 1) {
                processElement(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              } else if (shapeFlag & 6) {
                processComponent(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              } else if (shapeFlag & 64) {
                type.process(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized,
                  internals
                );
              } else if (shapeFlag & 128) {
                type.process(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized,
                  internals
                );
              } else {
                warn("Invalid VNode type:", type, `(${typeof type})`);
              }
          }
          if (ref != null && parentComponent) {
            setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
          }
        };
        const processText = (n1, n2, container, anchor) => {
          if (n1 == null) {
            hostInsert(
              n2.el = hostCreateText(n2.children),
              container,
              anchor
            );
          } else {
            const el = n2.el = n1.el;
            if (n2.children !== n1.children) {
              hostSetText(el, n2.children);
            }
          }
        };
        const processCommentNode = (n1, n2, container, anchor) => {
          if (n1 == null) {
            hostInsert(
              n2.el = hostCreateComment(n2.children || ""),
              container,
              anchor
            );
          } else {
            n2.el = n1.el;
          }
        };
        const mountStaticNode = (n2, container, anchor, isSVG) => {
          [n2.el, n2.anchor] = hostInsertStaticContent(
            n2.children,
            container,
            anchor,
            isSVG,
            n2.el,
            n2.anchor
          );
        };
        const patchStaticNode = (n1, n2, container, isSVG) => {
          if (n2.children !== n1.children) {
            const anchor = hostNextSibling(n1.anchor);
            removeStaticNode(n1);
            [n2.el, n2.anchor] = hostInsertStaticContent(
              n2.children,
              container,
              anchor,
              isSVG
            );
          } else {
            n2.el = n1.el;
            n2.anchor = n1.anchor;
          }
        };
        const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
          let next;
          while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostInsert(el, container, nextSibling);
            el = next;
          }
          hostInsert(anchor, container, nextSibling);
        };
        const removeStaticNode = ({ el, anchor }) => {
          let next;
          while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostRemove(el);
            el = next;
          }
          hostRemove(anchor);
        };
        const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          isSVG = isSVG || n2.type === "svg";
          if (n1 == null) {
            mountElement(
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          } else {
            patchElement(
              n1,
              n2,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          }
        };
        const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          let el;
          let vnodeHook;
          const { type, props, shapeFlag, transition, dirs } = vnode;
          el = vnode.el = hostCreateElement(
            vnode.type,
            isSVG,
            props && props.is,
            props
          );
          if (shapeFlag & 8) {
            hostSetElementText(el, vnode.children);
          } else if (shapeFlag & 16) {
            mountChildren(
              vnode.children,
              el,
              null,
              parentComponent,
              parentSuspense,
              isSVG && type !== "foreignObject",
              slotScopeIds,
              optimized
            );
          }
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "created");
          }
          setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
          if (props) {
            for (const key in props) {
              if (key !== "value" && !shared.isReservedProp(key)) {
                hostPatchProp(
                  el,
                  key,
                  null,
                  props[key],
                  isSVG,
                  vnode.children,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                );
              }
            }
            if ("value" in props) {
              hostPatchProp(el, "value", null, props.value);
            }
            if (vnodeHook = props.onVnodeBeforeMount) {
              invokeVNodeHook(vnodeHook, parentComponent, vnode);
            }
          }
          {
            Object.defineProperty(el, "__vnode", {
              value: vnode,
              enumerable: false
            });
            Object.defineProperty(el, "__vueParentComponent", {
              value: parentComponent,
              enumerable: false
            });
          }
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
          }
          const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
          if (needCallTransitionHooks) {
            transition.beforeEnter(el);
          }
          hostInsert(el, container, anchor);
          if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
              needCallTransitionHooks && transition.enter(el);
              dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
            }, parentSuspense);
          }
        };
        const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
          if (scopeId) {
            hostSetScopeId(el, scopeId);
          }
          if (slotScopeIds) {
            for (let i = 0; i < slotScopeIds.length; i++) {
              hostSetScopeId(el, slotScopeIds[i]);
            }
          }
          if (parentComponent) {
            let subTree = parentComponent.subTree;
            if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
              subTree = filterSingleRoot(subTree.children) || subTree;
            }
            if (vnode === subTree) {
              const parentVNode = parentComponent.vnode;
              setScopeId(
                el,
                parentVNode,
                parentVNode.scopeId,
                parentVNode.slotScopeIds,
                parentComponent.parent
              );
            }
          }
        };
        const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
          for (let i = start; i < children.length; i++) {
            const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
            patch(
              null,
              child,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          }
        };
        const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          const el = n2.el = n1.el;
          let { patchFlag, dynamicChildren, dirs } = n2;
          patchFlag |= n1.patchFlag & 16;
          const oldProps = n1.props || shared.EMPTY_OBJ;
          const newProps = n2.props || shared.EMPTY_OBJ;
          let vnodeHook;
          parentComponent && toggleRecurse(parentComponent, false);
          if (vnodeHook = newProps.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          }
          if (dirs) {
            invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
          }
          parentComponent && toggleRecurse(parentComponent, true);
          if (isHmrUpdating) {
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
          }
          const areChildrenSVG = isSVG && n2.type !== "foreignObject";
          if (dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              el,
              parentComponent,
              parentSuspense,
              areChildrenSVG,
              slotScopeIds
            );
            {
              traverseStaticChildren(n1, n2);
            }
          } else if (!optimized) {
            patchChildren(
              n1,
              n2,
              el,
              null,
              parentComponent,
              parentSuspense,
              areChildrenSVG,
              slotScopeIds,
              false
            );
          }
          if (patchFlag > 0) {
            if (patchFlag & 16) {
              patchProps(
                el,
                n2,
                oldProps,
                newProps,
                parentComponent,
                parentSuspense,
                isSVG
              );
            } else {
              if (patchFlag & 2) {
                if (oldProps.class !== newProps.class) {
                  hostPatchProp(el, "class", null, newProps.class, isSVG);
                }
              }
              if (patchFlag & 4) {
                hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
              }
              if (patchFlag & 8) {
                const propsToUpdate = n2.dynamicProps;
                for (let i = 0; i < propsToUpdate.length; i++) {
                  const key = propsToUpdate[i];
                  const prev = oldProps[key];
                  const next = newProps[key];
                  if (next !== prev || key === "value") {
                    hostPatchProp(
                      el,
                      key,
                      prev,
                      next,
                      isSVG,
                      n1.children,
                      parentComponent,
                      parentSuspense,
                      unmountChildren
                    );
                  }
                }
              }
            }
            if (patchFlag & 1) {
              if (n1.children !== n2.children) {
                hostSetElementText(el, n2.children);
              }
            }
          } else if (!optimized && dynamicChildren == null) {
            patchProps(
              el,
              n2,
              oldProps,
              newProps,
              parentComponent,
              parentSuspense,
              isSVG
            );
          }
          if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
              dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
            }, parentSuspense);
          }
        };
        const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
          for (let i = 0; i < newChildren.length; i++) {
            const oldVNode = oldChildren[i];
            const newVNode = newChildren[i];
            const container = (
              // oldVNode may be an errored async setup() component inside Suspense
              // which will not have a mounted element
              oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
              // of the Fragment itself so it can move its children.
              (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
              // which also requires the correct parent container
              !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
              oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
                // In other cases, the parent container is not actually used so we
                // just pass the block element here to avoid a DOM parentNode call.
                fallbackContainer
              )
            );
            patch(
              oldVNode,
              newVNode,
              container,
              null,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              true
            );
          }
        };
        const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
          if (oldProps !== newProps) {
            if (oldProps !== shared.EMPTY_OBJ) {
              for (const key in oldProps) {
                if (!shared.isReservedProp(key) && !(key in newProps)) {
                  hostPatchProp(
                    el,
                    key,
                    oldProps[key],
                    null,
                    isSVG,
                    vnode.children,
                    parentComponent,
                    parentSuspense,
                    unmountChildren
                  );
                }
              }
            }
            for (const key in newProps) {
              if (shared.isReservedProp(key))
                continue;
              const next = newProps[key];
              const prev = oldProps[key];
              if (next !== prev && key !== "value") {
                hostPatchProp(
                  el,
                  key,
                  prev,
                  next,
                  isSVG,
                  vnode.children,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                );
              }
            }
            if ("value" in newProps) {
              hostPatchProp(el, "value", oldProps.value, newProps.value);
            }
          }
        };
        const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
          const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
          let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
          if (
            // #5523 dev root fragment may inherit directives
            isHmrUpdating || patchFlag & 2048
          ) {
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
          }
          if (fragmentSlotScopeIds) {
            slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
          }
          if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            mountChildren(
              n2.children,
              container,
              fragmentEndAnchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          } else {
            if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
            // of renderSlot() with no valid children
            n1.dynamicChildren) {
              patchBlockChildren(
                n1.dynamicChildren,
                dynamicChildren,
                container,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds
              );
              {
                traverseStaticChildren(n1, n2);
              }
            } else {
              patchChildren(
                n1,
                n2,
                container,
                fragmentEndAnchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
            }
          }
        };
        const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          n2.slotScopeIds = slotScopeIds;
          if (n1 == null) {
            if (n2.shapeFlag & 512) {
              parentComponent.ctx.activate(
                n2,
                container,
                anchor,
                isSVG,
                optimized
              );
            } else {
              mountComponent(
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                optimized
              );
            }
          } else {
            updateComponent(n1, n2, optimized);
          }
        };
        const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
          const instance = initialVNode.component = createComponentInstance(
            initialVNode,
            parentComponent,
            parentSuspense
          );
          if (instance.type.__hmrId) {
            registerHMR(instance);
          }
          {
            pushWarningContext(initialVNode);
            startMeasure(instance, `mount`);
          }
          if (isKeepAlive(initialVNode)) {
            instance.ctx.renderer = internals;
          }
          {
            {
              startMeasure(instance, `init`);
            }
            setupComponent(instance);
            {
              endMeasure(instance, `init`);
            }
          }
          if (instance.asyncDep) {
            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
            if (!initialVNode.el) {
              const placeholder = instance.subTree = createVNode(Comment);
              processCommentNode(null, placeholder, container, anchor);
            }
            return;
          }
          setupRenderEffect(
            instance,
            initialVNode,
            container,
            anchor,
            parentSuspense,
            isSVG,
            optimized
          );
          {
            popWarningContext();
            endMeasure(instance, `mount`);
          }
        };
        const updateComponent = (n1, n2, optimized) => {
          const instance = n2.component = n1.component;
          if (shouldUpdateComponent(n1, n2, optimized)) {
            if (instance.asyncDep && !instance.asyncResolved) {
              {
                pushWarningContext(n2);
              }
              updateComponentPreRender(instance, n2, optimized);
              {
                popWarningContext();
              }
              return;
            } else {
              instance.next = n2;
              invalidateJob(instance.update);
              instance.update();
            }
          } else {
            n2.el = n1.el;
            instance.vnode = n2;
          }
        };
        const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
          const componentUpdateFn = () => {
            if (!instance.isMounted) {
              let vnodeHook;
              const { el, props } = initialVNode;
              const { bm, m, parent } = instance;
              const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
              toggleRecurse(instance, false);
              if (bm) {
                shared.invokeArrayFns(bm);
              }
              if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
                invokeVNodeHook(vnodeHook, parent, initialVNode);
              }
              toggleRecurse(instance, true);
              if (el && hydrateNode) {
                const hydrateSubTree = () => {
                  {
                    startMeasure(instance, `render`);
                  }
                  instance.subTree = renderComponentRoot(instance);
                  {
                    endMeasure(instance, `render`);
                  }
                  {
                    startMeasure(instance, `hydrate`);
                  }
                  hydrateNode(
                    el,
                    instance.subTree,
                    instance,
                    parentSuspense,
                    null
                  );
                  {
                    endMeasure(instance, `hydrate`);
                  }
                };
                if (isAsyncWrapperVNode) {
                  initialVNode.type.__asyncLoader().then(
                    // note: we are moving the render call into an async callback,
                    // which means it won't track dependencies - but it's ok because
                    // a server-rendered async wrapper is already in resolved state
                    // and it will never need to change.
                    () => !instance.isUnmounted && hydrateSubTree()
                  );
                } else {
                  hydrateSubTree();
                }
              } else {
                {
                  startMeasure(instance, `render`);
                }
                const subTree = instance.subTree = renderComponentRoot(instance);
                {
                  endMeasure(instance, `render`);
                }
                {
                  startMeasure(instance, `patch`);
                }
                patch(
                  null,
                  subTree,
                  container,
                  anchor,
                  instance,
                  parentSuspense,
                  isSVG
                );
                {
                  endMeasure(instance, `patch`);
                }
                initialVNode.el = subTree.el;
              }
              if (m) {
                queuePostRenderEffect(m, parentSuspense);
              }
              if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
                const scopedInitialVNode = initialVNode;
                queuePostRenderEffect(
                  () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                  parentSuspense
                );
              }
              if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
                instance.a && queuePostRenderEffect(instance.a, parentSuspense);
              }
              instance.isMounted = true;
              {
                devtoolsComponentAdded(instance);
              }
              initialVNode = container = anchor = null;
            } else {
              let { next, bu, u, parent, vnode } = instance;
              let originNext = next;
              let vnodeHook;
              {
                pushWarningContext(next || instance.vnode);
              }
              toggleRecurse(instance, false);
              if (next) {
                next.el = vnode.el;
                updateComponentPreRender(instance, next, optimized);
              } else {
                next = vnode;
              }
              if (bu) {
                shared.invokeArrayFns(bu);
              }
              if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
                invokeVNodeHook(vnodeHook, parent, next, vnode);
              }
              toggleRecurse(instance, true);
              {
                startMeasure(instance, `render`);
              }
              const nextTree = renderComponentRoot(instance);
              {
                endMeasure(instance, `render`);
              }
              const prevTree = instance.subTree;
              instance.subTree = nextTree;
              {
                startMeasure(instance, `patch`);
              }
              patch(
                prevTree,
                nextTree,
                // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el),
                // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree),
                instance,
                parentSuspense,
                isSVG
              );
              {
                endMeasure(instance, `patch`);
              }
              next.el = nextTree.el;
              if (originNext === null) {
                updateHOCHostEl(instance, nextTree.el);
              }
              if (u) {
                queuePostRenderEffect(u, parentSuspense);
              }
              if (vnodeHook = next.props && next.props.onVnodeUpdated) {
                queuePostRenderEffect(
                  () => invokeVNodeHook(vnodeHook, parent, next, vnode),
                  parentSuspense
                );
              }
              {
                devtoolsComponentUpdated(instance);
              }
              {
                popWarningContext();
              }
            }
          };
          const effect = instance.effect = new reactivity.ReactiveEffect(
            componentUpdateFn,
            () => queueJob(update),
            instance.scope
            // track it in component's effect scope
          );
          const update = instance.update = () => effect.run();
          update.id = instance.uid;
          toggleRecurse(instance, true);
          {
            effect.onTrack = instance.rtc ? (e) => shared.invokeArrayFns(instance.rtc, e) : void 0;
            effect.onTrigger = instance.rtg ? (e) => shared.invokeArrayFns(instance.rtg, e) : void 0;
            update.ownerInstance = instance;
          }
          update();
        };
        const updateComponentPreRender = (instance, nextVNode, optimized) => {
          nextVNode.component = instance;
          const prevProps = instance.vnode.props;
          instance.vnode = nextVNode;
          instance.next = null;
          updateProps(instance, nextVNode.props, prevProps, optimized);
          updateSlots(instance, nextVNode.children, optimized);
          reactivity.pauseTracking();
          flushPreFlushCbs();
          reactivity.resetTracking();
        };
        const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
          const c1 = n1 && n1.children;
          const prevShapeFlag = n1 ? n1.shapeFlag : 0;
          const c2 = n2.children;
          const { patchFlag, shapeFlag } = n2;
          if (patchFlag > 0) {
            if (patchFlag & 128) {
              patchKeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
              return;
            } else if (patchFlag & 256) {
              patchUnkeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
              return;
            }
          }
          if (shapeFlag & 8) {
            if (prevShapeFlag & 16) {
              unmountChildren(c1, parentComponent, parentSuspense);
            }
            if (c2 !== c1) {
              hostSetElementText(container, c2);
            }
          } else {
            if (prevShapeFlag & 16) {
              if (shapeFlag & 16) {
                patchKeyedChildren(
                  c1,
                  c2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              } else {
                unmountChildren(c1, parentComponent, parentSuspense, true);
              }
            } else {
              if (prevShapeFlag & 8) {
                hostSetElementText(container, "");
              }
              if (shapeFlag & 16) {
                mountChildren(
                  c2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              }
            }
          }
        };
        const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          c1 = c1 || shared.EMPTY_ARR;
          c2 = c2 || shared.EMPTY_ARR;
          const oldLength = c1.length;
          const newLength = c2.length;
          const commonLength = Math.min(oldLength, newLength);
          let i;
          for (i = 0; i < commonLength; i++) {
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            patch(
              c1[i],
              nextChild,
              container,
              null,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          }
          if (oldLength > newLength) {
            unmountChildren(
              c1,
              parentComponent,
              parentSuspense,
              true,
              false,
              commonLength
            );
          } else {
            mountChildren(
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized,
              commonLength
            );
          }
        };
        const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          let i = 0;
          const l2 = c2.length;
          let e1 = c1.length - 1;
          let e2 = l2 - 1;
          while (i <= e1 && i <= e2) {
            const n1 = c1[i];
            const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (isSameVNodeType(n1, n2)) {
              patch(
                n1,
                n2,
                container,
                null,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
            } else {
              break;
            }
            i++;
          }
          while (i <= e1 && i <= e2) {
            const n1 = c1[e1];
            const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
            if (isSameVNodeType(n1, n2)) {
              patch(
                n1,
                n2,
                container,
                null,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
            } else {
              break;
            }
            e1--;
            e2--;
          }
          if (i > e1) {
            if (i <= e2) {
              const nextPos = e2 + 1;
              const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
              while (i <= e2) {
                patch(
                  null,
                  c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
                i++;
              }
            }
          } else if (i > e2) {
            while (i <= e1) {
              unmount(c1[i], parentComponent, parentSuspense, true);
              i++;
            }
          } else {
            const s1 = i;
            const s2 = i;
            const keyToNewIndexMap = /* @__PURE__ */ new Map();
            for (i = s2; i <= e2; i++) {
              const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
              if (nextChild.key != null) {
                if (keyToNewIndexMap.has(nextChild.key)) {
                  warn(
                    `Duplicate keys found during update:`,
                    JSON.stringify(nextChild.key),
                    `Make sure keys are unique.`
                  );
                }
                keyToNewIndexMap.set(nextChild.key, i);
              }
            }
            let j;
            let patched = 0;
            const toBePatched = e2 - s2 + 1;
            let moved = false;
            let maxNewIndexSoFar = 0;
            const newIndexToOldIndexMap = new Array(toBePatched);
            for (i = 0; i < toBePatched; i++)
              newIndexToOldIndexMap[i] = 0;
            for (i = s1; i <= e1; i++) {
              const prevChild = c1[i];
              if (patched >= toBePatched) {
                unmount(prevChild, parentComponent, parentSuspense, true);
                continue;
              }
              let newIndex;
              if (prevChild.key != null) {
                newIndex = keyToNewIndexMap.get(prevChild.key);
              } else {
                for (j = s2; j <= e2; j++) {
                  if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                    newIndex = j;
                    break;
                  }
                }
              }
              if (newIndex === void 0) {
                unmount(prevChild, parentComponent, parentSuspense, true);
              } else {
                newIndexToOldIndexMap[newIndex - s2] = i + 1;
                if (newIndex >= maxNewIndexSoFar) {
                  maxNewIndexSoFar = newIndex;
                } else {
                  moved = true;
                }
                patch(
                  prevChild,
                  c2[newIndex],
                  container,
                  null,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
                patched++;
              }
            }
            const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : shared.EMPTY_ARR;
            j = increasingNewIndexSequence.length - 1;
            for (i = toBePatched - 1; i >= 0; i--) {
              const nextIndex = s2 + i;
              const nextChild = c2[nextIndex];
              const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
              if (newIndexToOldIndexMap[i] === 0) {
                patch(
                  null,
                  nextChild,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              } else if (moved) {
                if (j < 0 || i !== increasingNewIndexSequence[j]) {
                  move(nextChild, container, anchor, 2);
                } else {
                  j--;
                }
              }
            }
          }
        };
        const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
          const { el, type, transition, children, shapeFlag } = vnode;
          if (shapeFlag & 6) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
          }
          if (shapeFlag & 128) {
            vnode.suspense.move(container, anchor, moveType);
            return;
          }
          if (shapeFlag & 64) {
            type.move(vnode, container, anchor, internals);
            return;
          }
          if (type === Fragment) {
            hostInsert(el, container, anchor);
            for (let i = 0; i < children.length; i++) {
              move(children[i], container, anchor, moveType);
            }
            hostInsert(vnode.anchor, container, anchor);
            return;
          }
          if (type === Static) {
            moveStaticNode(vnode, container, anchor);
            return;
          }
          const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
          if (needTransition) {
            if (moveType === 0) {
              transition.beforeEnter(el);
              hostInsert(el, container, anchor);
              queuePostRenderEffect(() => transition.enter(el), parentSuspense);
            } else {
              const { leave, delayLeave, afterLeave } = transition;
              const remove2 = () => hostInsert(el, container, anchor);
              const performLeave = () => {
                leave(el, () => {
                  remove2();
                  afterLeave && afterLeave();
                });
              };
              if (delayLeave) {
                delayLeave(el, remove2, performLeave);
              } else {
                performLeave();
              }
            }
          } else {
            hostInsert(el, container, anchor);
          }
        };
        const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
          const {
            type,
            props,
            ref,
            children,
            dynamicChildren,
            shapeFlag,
            patchFlag,
            dirs
          } = vnode;
          if (ref != null) {
            setRef(ref, null, parentSuspense, vnode, true);
          }
          if (shapeFlag & 256) {
            parentComponent.ctx.deactivate(vnode);
            return;
          }
          const shouldInvokeDirs = shapeFlag & 1 && dirs;
          const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
          let vnodeHook;
          if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
          if (shapeFlag & 6) {
            unmountComponent(vnode.component, parentSuspense, doRemove);
          } else {
            if (shapeFlag & 128) {
              vnode.suspense.unmount(parentSuspense, doRemove);
              return;
            }
            if (shouldInvokeDirs) {
              invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
            }
            if (shapeFlag & 64) {
              vnode.type.remove(
                vnode,
                parentComponent,
                parentSuspense,
                optimized,
                internals,
                doRemove
              );
            } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
            (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
              unmountChildren(
                dynamicChildren,
                parentComponent,
                parentSuspense,
                false,
                true
              );
            } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
              unmountChildren(children, parentComponent, parentSuspense);
            }
            if (doRemove) {
              remove(vnode);
            }
          }
          if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
              shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
            }, parentSuspense);
          }
        };
        const remove = (vnode) => {
          const { type, el, anchor, transition } = vnode;
          if (type === Fragment) {
            if (vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {
              vnode.children.forEach((child) => {
                if (child.type === Comment) {
                  hostRemove(child.el);
                } else {
                  remove(child);
                }
              });
            } else {
              removeFragment(el, anchor);
            }
            return;
          }
          if (type === Static) {
            removeStaticNode(vnode);
            return;
          }
          const performRemove = () => {
            hostRemove(el);
            if (transition && !transition.persisted && transition.afterLeave) {
              transition.afterLeave();
            }
          };
          if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
            const { leave, delayLeave } = transition;
            const performLeave = () => leave(el, performRemove);
            if (delayLeave) {
              delayLeave(vnode.el, performRemove, performLeave);
            } else {
              performLeave();
            }
          } else {
            performRemove();
          }
        };
        const removeFragment = (cur, end) => {
          let next;
          while (cur !== end) {
            next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
          }
          hostRemove(end);
        };
        const unmountComponent = (instance, parentSuspense, doRemove) => {
          if (instance.type.__hmrId) {
            unregisterHMR(instance);
          }
          const { bum, scope, update, subTree, um } = instance;
          if (bum) {
            shared.invokeArrayFns(bum);
          }
          scope.stop();
          if (update) {
            update.active = false;
            unmount(subTree, instance, parentSuspense, doRemove);
          }
          if (um) {
            queuePostRenderEffect(um, parentSuspense);
          }
          queuePostRenderEffect(() => {
            instance.isUnmounted = true;
          }, parentSuspense);
          if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0) {
              parentSuspense.resolve();
            }
          }
          {
            devtoolsComponentRemoved(instance);
          }
        };
        const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
          for (let i = start; i < children.length; i++) {
            unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
          }
        };
        const getNextHostNode = (vnode) => {
          if (vnode.shapeFlag & 6) {
            return getNextHostNode(vnode.component.subTree);
          }
          if (vnode.shapeFlag & 128) {
            return vnode.suspense.next();
          }
          return hostNextSibling(vnode.anchor || vnode.el);
        };
        const render = (vnode, container, isSVG) => {
          if (vnode == null) {
            if (container._vnode) {
              unmount(container._vnode, null, null, true);
            }
          } else {
            patch(container._vnode || null, vnode, container, null, null, null, isSVG);
          }
          flushPreFlushCbs();
          flushPostFlushCbs();
          container._vnode = vnode;
        };
        const internals = {
          p: patch,
          um: unmount,
          m: move,
          r: remove,
          mt: mountComponent,
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          n: getNextHostNode,
          o: options
        };
        let hydrate;
        let hydrateNode;
        if (createHydrationFns) {
          [hydrate, hydrateNode] = createHydrationFns(
            internals
          );
        }
        return {
          render,
          hydrate,
          createApp: createAppAPI(render, hydrate)
        };
      }
      function toggleRecurse({ effect, update }, allowed) {
        effect.allowRecurse = update.allowRecurse = allowed;
      }
      function traverseStaticChildren(n1, n2, shallow = false) {
        const ch1 = n1.children;
        const ch2 = n2.children;
        if (shared.isArray(ch1) && shared.isArray(ch2)) {
          for (let i = 0; i < ch1.length; i++) {
            const c1 = ch1[i];
            let c2 = ch2[i];
            if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
              if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
                c2 = ch2[i] = cloneIfMounted(ch2[i]);
                c2.el = c1.el;
              }
              if (!shallow)
                traverseStaticChildren(c1, c2);
            }
            if (c2.type === Text) {
              c2.el = c1.el;
            }
            if (c2.type === Comment && !c2.el) {
              c2.el = c1.el;
            }
          }
        }
      }
      function getSequence(arr) {
        const p = arr.slice();
        const result = [0];
        let i, j, u, v, c;
        const len = arr.length;
        for (i = 0; i < len; i++) {
          const arrI = arr[i];
          if (arrI !== 0) {
            j = result[result.length - 1];
            if (arr[j] < arrI) {
              p[i] = j;
              result.push(i);
              continue;
            }
            u = 0;
            v = result.length - 1;
            while (u < v) {
              c = u + v >> 1;
              if (arr[result[c]] < arrI) {
                u = c + 1;
              } else {
                v = c;
              }
            }
            if (arrI < arr[result[u]]) {
              if (u > 0) {
                p[i] = result[u - 1];
              }
              result[u] = i;
            }
          }
        }
        u = result.length;
        v = result[u - 1];
        while (u-- > 0) {
          result[u] = v;
          v = p[v];
        }
        return result;
      }
      var isTeleport = (type) => type.__isTeleport;
      var isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
      var isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
      var resolveTarget = (props, select) => {
        const targetSelector = props && props.to;
        if (shared.isString(targetSelector)) {
          if (!select) {
            warn(
              `Current renderer does not support string target for Teleports. (missing querySelector renderer option)`
            );
            return null;
          } else {
            const target = select(targetSelector);
            if (!target) {
              warn(
                `Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
              );
            }
            return target;
          }
        } else {
          if (!targetSelector && !isTeleportDisabled(props)) {
            warn(`Invalid Teleport target: ${targetSelector}`);
          }
          return targetSelector;
        }
      };
      var TeleportImpl = {
        __isTeleport: true,
        process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
          const {
            mc: mountChildren,
            pc: patchChildren,
            pbc: patchBlockChildren,
            o: { insert, querySelector, createText, createComment }
          } = internals;
          const disabled = isTeleportDisabled(n2.props);
          let { shapeFlag, children, dynamicChildren } = n2;
          if (isHmrUpdating) {
            optimized = false;
            dynamicChildren = null;
          }
          if (n1 == null) {
            const placeholder = n2.el = createComment("teleport start");
            const mainAnchor = n2.anchor = createComment("teleport end");
            insert(placeholder, container, anchor);
            insert(mainAnchor, container, anchor);
            const target = n2.target = resolveTarget(n2.props, querySelector);
            const targetAnchor = n2.targetAnchor = createText("");
            if (target) {
              insert(targetAnchor, target);
              isSVG = isSVG || isTargetSVG(target);
            } else if (!disabled) {
              warn("Invalid Teleport target on mount:", target, `(${typeof target})`);
            }
            const mount = (container2, anchor2) => {
              if (shapeFlag & 16) {
                mountChildren(
                  children,
                  container2,
                  anchor2,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              }
            };
            if (disabled) {
              mount(container, mainAnchor);
            } else if (target) {
              mount(target, targetAnchor);
            }
          } else {
            n2.el = n1.el;
            const mainAnchor = n2.anchor = n1.anchor;
            const target = n2.target = n1.target;
            const targetAnchor = n2.targetAnchor = n1.targetAnchor;
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container : target;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            isSVG = isSVG || isTargetSVG(target);
            if (dynamicChildren) {
              patchBlockChildren(
                n1.dynamicChildren,
                dynamicChildren,
                currentContainer,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds
              );
              traverseStaticChildren(n1, n2, true);
            } else if (!optimized) {
              patchChildren(
                n1,
                n2,
                currentContainer,
                currentAnchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                false
              );
            }
            if (disabled) {
              if (!wasDisabled) {
                moveTeleport(
                  n2,
                  container,
                  mainAnchor,
                  internals,
                  1
                );
              }
            } else {
              if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                const nextTarget = n2.target = resolveTarget(
                  n2.props,
                  querySelector
                );
                if (nextTarget) {
                  moveTeleport(
                    n2,
                    nextTarget,
                    null,
                    internals,
                    0
                  );
                } else {
                  warn(
                    "Invalid Teleport target on update:",
                    target,
                    `(${typeof target})`
                  );
                }
              } else if (wasDisabled) {
                moveTeleport(
                  n2,
                  target,
                  targetAnchor,
                  internals,
                  1
                );
              }
            }
          }
          updateCssVars(n2);
        },
        remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
          const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
          if (target) {
            hostRemove(targetAnchor);
          }
          if (doRemove || !isTeleportDisabled(props)) {
            hostRemove(anchor);
            if (shapeFlag & 16) {
              for (let i = 0; i < children.length; i++) {
                const child = children[i];
                unmount(
                  child,
                  parentComponent,
                  parentSuspense,
                  true,
                  !!child.dynamicChildren
                );
              }
            }
          }
        },
        move: moveTeleport,
        hydrate: hydrateTeleport
      };
      function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
        if (moveType === 0) {
          insert(vnode.targetAnchor, container, parentAnchor);
        }
        const { el, anchor, shapeFlag, children, props } = vnode;
        const isReorder = moveType === 2;
        if (isReorder) {
          insert(el, container, parentAnchor);
        }
        if (!isReorder || isTeleportDisabled(props)) {
          if (shapeFlag & 16) {
            for (let i = 0; i < children.length; i++) {
              move(
                children[i],
                container,
                parentAnchor,
                2
              );
            }
          }
        }
        if (isReorder) {
          insert(anchor, container, parentAnchor);
        }
      }
      function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
        o: { nextSibling, parentNode, querySelector }
      }, hydrateChildren) {
        const target = vnode.target = resolveTarget(
          vnode.props,
          querySelector
        );
        if (target) {
          const targetNode = target._lpa || target.firstChild;
          if (vnode.shapeFlag & 16) {
            if (isTeleportDisabled(vnode.props)) {
              vnode.anchor = hydrateChildren(
                nextSibling(node),
                vnode,
                parentNode(node),
                parentComponent,
                parentSuspense,
                slotScopeIds,
                optimized
              );
              vnode.targetAnchor = targetNode;
            } else {
              vnode.anchor = nextSibling(node);
              let targetAnchor = targetNode;
              while (targetAnchor) {
                targetAnchor = nextSibling(targetAnchor);
                if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
                  vnode.targetAnchor = targetAnchor;
                  target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                  break;
                }
              }
              hydrateChildren(
                targetNode,
                vnode,
                target,
                parentComponent,
                parentSuspense,
                slotScopeIds,
                optimized
              );
            }
          }
          updateCssVars(vnode);
        }
        return vnode.anchor && nextSibling(vnode.anchor);
      }
      var Teleport = TeleportImpl;
      function updateCssVars(vnode) {
        const ctx = vnode.ctx;
        if (ctx && ctx.ut) {
          let node = vnode.children[0].el;
          while (node !== vnode.targetAnchor) {
            if (node.nodeType === 1)
              node.setAttribute("data-v-owner", ctx.uid);
            node = node.nextSibling;
          }
          ctx.ut();
        }
      }
      var Fragment = Symbol.for("v-fgt");
      var Text = Symbol.for("v-txt");
      var Comment = Symbol.for("v-cmt");
      var Static = Symbol.for("v-stc");
      var blockStack = [];
      var currentBlock = null;
      function openBlock(disableTracking = false) {
        blockStack.push(currentBlock = disableTracking ? null : []);
      }
      function closeBlock() {
        blockStack.pop();
        currentBlock = blockStack[blockStack.length - 1] || null;
      }
      var isBlockTreeEnabled = 1;
      function setBlockTracking(value) {
        isBlockTreeEnabled += value;
      }
      function setupBlock(vnode) {
        vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || shared.EMPTY_ARR : null;
        closeBlock();
        if (isBlockTreeEnabled > 0 && currentBlock) {
          currentBlock.push(vnode);
        }
        return vnode;
      }
      function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
        return setupBlock(
          createBaseVNode(
            type,
            props,
            children,
            patchFlag,
            dynamicProps,
            shapeFlag,
            true
            /* isBlock */
          )
        );
      }
      function createBlock(type, props, children, patchFlag, dynamicProps) {
        return setupBlock(
          createVNode(
            type,
            props,
            children,
            patchFlag,
            dynamicProps,
            true
            /* isBlock: prevent a block from tracking itself */
          )
        );
      }
      function isVNode(value) {
        return value ? value.__v_isVNode === true : false;
      }
      function isSameVNodeType(n1, n2) {
        if (n2.shapeFlag & 6 && hmrDirtyComponents.has(n2.type)) {
          n1.shapeFlag &= ~256;
          n2.shapeFlag &= ~512;
          return false;
        }
        return n1.type === n2.type && n1.key === n2.key;
      }
      var vnodeArgsTransformer;
      function transformVNodeArgs(transformer) {
        vnodeArgsTransformer = transformer;
      }
      var createVNodeWithArgsTransform = (...args) => {
        return _createVNode(
          ...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args
        );
      };
      var InternalObjectKey = `__vInternal`;
      var normalizeKey = ({ key }) => key != null ? key : null;
      var normalizeRef = ({
        ref,
        ref_key,
        ref_for
      }) => {
        if (typeof ref === "number") {
          ref = "" + ref;
        }
        return ref != null ? shared.isString(ref) || reactivity.isRef(ref) || shared.isFunction(ref) ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for } : ref : null;
      };
      function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
        const vnode = {
          __v_isVNode: true,
          __v_skip: true,
          type,
          props,
          key: props && normalizeKey(props),
          ref: props && normalizeRef(props),
          scopeId: currentScopeId,
          slotScopeIds: null,
          children,
          component: null,
          suspense: null,
          ssContent: null,
          ssFallback: null,
          dirs: null,
          transition: null,
          el: null,
          anchor: null,
          target: null,
          targetAnchor: null,
          staticCount: 0,
          shapeFlag,
          patchFlag,
          dynamicProps,
          dynamicChildren: null,
          appContext: null,
          ctx: currentRenderingInstance
        };
        if (needFullChildrenNormalization) {
          normalizeChildren(vnode, children);
          if (shapeFlag & 128) {
            type.normalize(vnode);
          }
        } else if (children) {
          vnode.shapeFlag |= shared.isString(children) ? 8 : 16;
        }
        if (vnode.key !== vnode.key) {
          warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
        }
        if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
        !isBlockNode && // has current parent block
        currentBlock && // presence of a patch flag indicates this node needs patching on updates.
        // component nodes also should always be patched, because even if the
        // component doesn't need to update, it needs to persist the instance on to
        // the next vnode so that it can be properly unmounted later.
        (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
        // vnode should not be considered dynamic due to handler caching.
        vnode.patchFlag !== 32) {
          currentBlock.push(vnode);
        }
        return vnode;
      }
      var createVNode = createVNodeWithArgsTransform;
      function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
        if (!type || type === NULL_DYNAMIC_COMPONENT) {
          if (!type) {
            warn(`Invalid vnode type when creating vnode: ${type}.`);
          }
          type = Comment;
        }
        if (isVNode(type)) {
          const cloned = cloneVNode(
            type,
            props,
            true
            /* mergeRef: true */
          );
          if (children) {
            normalizeChildren(cloned, children);
          }
          if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
            if (cloned.shapeFlag & 6) {
              currentBlock[currentBlock.indexOf(type)] = cloned;
            } else {
              currentBlock.push(cloned);
            }
          }
          cloned.patchFlag |= -2;
          return cloned;
        }
        if (isClassComponent(type)) {
          type = type.__vccOpts;
        }
        if (props) {
          props = guardReactiveProps(props);
          let { class: klass, style } = props;
          if (klass && !shared.isString(klass)) {
            props.class = shared.normalizeClass(klass);
          }
          if (shared.isObject(style)) {
            if (reactivity.isProxy(style) && !shared.isArray(style)) {
              style = shared.extend({}, style);
            }
            props.style = shared.normalizeStyle(style);
          }
        }
        const shapeFlag = shared.isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : shared.isObject(type) ? 4 : shared.isFunction(type) ? 2 : 0;
        if (shapeFlag & 4 && reactivity.isProxy(type)) {
          type = reactivity.toRaw(type);
          warn(
            `Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`,
            `
Component that was made reactive: `,
            type
          );
        }
        return createBaseVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          shapeFlag,
          isBlockNode,
          true
        );
      }
      function guardReactiveProps(props) {
        if (!props)
          return null;
        return reactivity.isProxy(props) || InternalObjectKey in props ? shared.extend({}, props) : props;
      }
      function cloneVNode(vnode, extraProps, mergeRef = false) {
        const { props, ref, patchFlag, children } = vnode;
        const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
        const cloned = {
          __v_isVNode: true,
          __v_skip: true,
          type: vnode.type,
          props: mergedProps,
          key: mergedProps && normalizeKey(mergedProps),
          ref: extraProps && extraProps.ref ? (
            // #2078 in the case of <component :is="vnode" ref="extra"/>
            // if the vnode itself already has a ref, cloneVNode will need to merge
            // the refs so the single vnode can be set on multiple refs
            mergeRef && ref ? shared.isArray(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps)
          ) : ref,
          scopeId: vnode.scopeId,
          slotScopeIds: vnode.slotScopeIds,
          children: patchFlag === -1 && shared.isArray(children) ? children.map(deepCloneVNode) : children,
          target: vnode.target,
          targetAnchor: vnode.targetAnchor,
          staticCount: vnode.staticCount,
          shapeFlag: vnode.shapeFlag,
          // if the vnode is cloned with extra props, we can no longer assume its
          // existing patch flag to be reliable and need to add the FULL_PROPS flag.
          // note: preserve flag for fragments since they use the flag for children
          // fast paths only.
          patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
          dynamicProps: vnode.dynamicProps,
          dynamicChildren: vnode.dynamicChildren,
          appContext: vnode.appContext,
          dirs: vnode.dirs,
          transition: vnode.transition,
          // These should technically only be non-null on mounted VNodes. However,
          // they *should* be copied for kept-alive vnodes. So we just always copy
          // them since them being non-null during a mount doesn't affect the logic as
          // they will simply be overwritten.
          component: vnode.component,
          suspense: vnode.suspense,
          ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
          ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
          el: vnode.el,
          anchor: vnode.anchor,
          ctx: vnode.ctx,
          ce: vnode.ce
        };
        return cloned;
      }
      function deepCloneVNode(vnode) {
        const cloned = cloneVNode(vnode);
        if (shared.isArray(vnode.children)) {
          cloned.children = vnode.children.map(deepCloneVNode);
        }
        return cloned;
      }
      function createTextVNode(text = " ", flag = 0) {
        return createVNode(Text, null, text, flag);
      }
      function createStaticVNode(content, numberOfNodes) {
        const vnode = createVNode(Static, null, content);
        vnode.staticCount = numberOfNodes;
        return vnode;
      }
      function createCommentVNode(text = "", asBlock = false) {
        return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
      }
      function normalizeVNode(child) {
        if (child == null || typeof child === "boolean") {
          return createVNode(Comment);
        } else if (shared.isArray(child)) {
          return createVNode(
            Fragment,
            null,
            // #3666, avoid reference pollution when reusing vnode
            child.slice()
          );
        } else if (typeof child === "object") {
          return cloneIfMounted(child);
        } else {
          return createVNode(Text, null, String(child));
        }
      }
      function cloneIfMounted(child) {
        return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
      }
      function normalizeChildren(vnode, children) {
        let type = 0;
        const { shapeFlag } = vnode;
        if (children == null) {
          children = null;
        } else if (shared.isArray(children)) {
          type = 16;
        } else if (typeof children === "object") {
          if (shapeFlag & (1 | 64)) {
            const slot = children.default;
            if (slot) {
              slot._c && (slot._d = false);
              normalizeChildren(vnode, slot());
              slot._c && (slot._d = true);
            }
            return;
          } else {
            type = 32;
            const slotFlag = children._;
            if (!slotFlag && !(InternalObjectKey in children)) {
              children._ctx = currentRenderingInstance;
            } else if (slotFlag === 3 && currentRenderingInstance) {
              if (currentRenderingInstance.slots._ === 1) {
                children._ = 1;
              } else {
                children._ = 2;
                vnode.patchFlag |= 1024;
              }
            }
          }
        } else if (shared.isFunction(children)) {
          children = { default: children, _ctx: currentRenderingInstance };
          type = 32;
        } else {
          children = String(children);
          if (shapeFlag & 64) {
            type = 16;
            children = [createTextVNode(children)];
          } else {
            type = 8;
          }
        }
        vnode.children = children;
        vnode.shapeFlag |= type;
      }
      function mergeProps(...args) {
        const ret = {};
        for (let i = 0; i < args.length; i++) {
          const toMerge = args[i];
          for (const key in toMerge) {
            if (key === "class") {
              if (ret.class !== toMerge.class) {
                ret.class = shared.normalizeClass([ret.class, toMerge.class]);
              }
            } else if (key === "style") {
              ret.style = shared.normalizeStyle([ret.style, toMerge.style]);
            } else if (shared.isOn(key)) {
              const existing = ret[key];
              const incoming = toMerge[key];
              if (incoming && existing !== incoming && !(shared.isArray(existing) && existing.includes(incoming))) {
                ret[key] = existing ? [].concat(existing, incoming) : incoming;
              }
            } else if (key !== "") {
              ret[key] = toMerge[key];
            }
          }
        }
        return ret;
      }
      function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
        callWithAsyncErrorHandling(hook, instance, 7, [
          vnode,
          prevVNode
        ]);
      }
      var emptyAppContext = createAppContext();
      var uid = 0;
      function createComponentInstance(vnode, parent, suspense) {
        const type = vnode.type;
        const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
        const instance = {
          uid: uid++,
          vnode,
          type,
          parent,
          appContext,
          root: null,
          // to be immediately set
          next: null,
          subTree: null,
          // will be set synchronously right after creation
          effect: null,
          update: null,
          // will be set synchronously right after creation
          scope: new reactivity.EffectScope(
            true
            /* detached */
          ),
          render: null,
          proxy: null,
          exposed: null,
          exposeProxy: null,
          withProxy: null,
          provides: parent ? parent.provides : Object.create(appContext.provides),
          accessCache: null,
          renderCache: [],
          // local resolved assets
          components: null,
          directives: null,
          // resolved props and emits options
          propsOptions: normalizePropsOptions(type, appContext),
          emitsOptions: normalizeEmitsOptions(type, appContext),
          // emit
          emit: null,
          // to be set immediately
          emitted: null,
          // props default value
          propsDefaults: shared.EMPTY_OBJ,
          // inheritAttrs
          inheritAttrs: type.inheritAttrs,
          // state
          ctx: shared.EMPTY_OBJ,
          data: shared.EMPTY_OBJ,
          props: shared.EMPTY_OBJ,
          attrs: shared.EMPTY_OBJ,
          slots: shared.EMPTY_OBJ,
          refs: shared.EMPTY_OBJ,
          setupState: shared.EMPTY_OBJ,
          setupContext: null,
          attrsProxy: null,
          slotsProxy: null,
          // suspense related
          suspense,
          suspenseId: suspense ? suspense.pendingId : 0,
          asyncDep: null,
          asyncResolved: false,
          // lifecycle hooks
          // not using enums here because it results in computed properties
          isMounted: false,
          isUnmounted: false,
          isDeactivated: false,
          bc: null,
          c: null,
          bm: null,
          m: null,
          bu: null,
          u: null,
          um: null,
          bum: null,
          da: null,
          a: null,
          rtg: null,
          rtc: null,
          ec: null,
          sp: null
        };
        {
          instance.ctx = createDevRenderContext(instance);
        }
        instance.root = parent ? parent.root : instance;
        instance.emit = emit.bind(null, instance);
        if (vnode.ce) {
          vnode.ce(instance);
        }
        return instance;
      }
      var currentInstance = null;
      var getCurrentInstance = () => currentInstance || currentRenderingInstance;
      var internalSetCurrentInstance;
      var globalCurrentInstanceSetters;
      var settersKey = "__VUE_INSTANCE_SETTERS__";
      {
        if (!(globalCurrentInstanceSetters = shared.getGlobalThis()[settersKey])) {
          globalCurrentInstanceSetters = shared.getGlobalThis()[settersKey] = [];
        }
        globalCurrentInstanceSetters.push((i) => currentInstance = i);
        internalSetCurrentInstance = (instance) => {
          if (globalCurrentInstanceSetters.length > 1) {
            globalCurrentInstanceSetters.forEach((s) => s(instance));
          } else {
            globalCurrentInstanceSetters[0](instance);
          }
        };
      }
      var setCurrentInstance = (instance) => {
        internalSetCurrentInstance(instance);
        instance.scope.on();
      };
      var unsetCurrentInstance = () => {
        currentInstance && currentInstance.scope.off();
        internalSetCurrentInstance(null);
      };
      var isBuiltInTag = /* @__PURE__ */ shared.makeMap("slot,component");
      function validateComponentName(name, config) {
        const appIsNativeTag = config.isNativeTag || shared.NO;
        if (isBuiltInTag(name) || appIsNativeTag(name)) {
          warn(
            "Do not use built-in or reserved HTML elements as component id: " + name
          );
        }
      }
      function isStatefulComponent(instance) {
        return instance.vnode.shapeFlag & 4;
      }
      var isInSSRComponentSetup = false;
      function setupComponent(instance, isSSR = false) {
        isInSSRComponentSetup = isSSR;
        const { props, children } = instance.vnode;
        const isStateful = isStatefulComponent(instance);
        initProps(instance, props, isStateful, isSSR);
        initSlots(instance, children);
        const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
        isInSSRComponentSetup = false;
        return setupResult;
      }
      function setupStatefulComponent(instance, isSSR) {
        var _a;
        const Component = instance.type;
        {
          if (Component.name) {
            validateComponentName(Component.name, instance.appContext.config);
          }
          if (Component.components) {
            const names = Object.keys(Component.components);
            for (let i = 0; i < names.length; i++) {
              validateComponentName(names[i], instance.appContext.config);
            }
          }
          if (Component.directives) {
            const names = Object.keys(Component.directives);
            for (let i = 0; i < names.length; i++) {
              validateDirectiveName(names[i]);
            }
          }
          if (Component.compilerOptions && isRuntimeOnly()) {
            warn(
              `"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`
            );
          }
        }
        instance.accessCache = /* @__PURE__ */ Object.create(null);
        instance.proxy = reactivity.markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
        {
          exposePropsOnRenderContext(instance);
        }
        const { setup } = Component;
        if (setup) {
          const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
          setCurrentInstance(instance);
          reactivity.pauseTracking();
          const setupResult = callWithErrorHandling(
            setup,
            instance,
            0,
            [reactivity.shallowReadonly(instance.props), setupContext]
          );
          reactivity.resetTracking();
          unsetCurrentInstance();
          if (shared.isPromise(setupResult)) {
            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
            if (isSSR) {
              return setupResult.then((resolvedResult) => {
                handleSetupResult(instance, resolvedResult, isSSR);
              }).catch((e) => {
                handleError(e, instance, 0);
              });
            } else {
              instance.asyncDep = setupResult;
              if (!instance.suspense) {
                const name = (_a = Component.name) != null ? _a : "Anonymous";
                warn(
                  `Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
                );
              }
            }
          } else {
            handleSetupResult(instance, setupResult, isSSR);
          }
        } else {
          finishComponentSetup(instance, isSSR);
        }
      }
      function handleSetupResult(instance, setupResult, isSSR) {
        if (shared.isFunction(setupResult)) {
          if (instance.type.__ssrInlineRender) {
            instance.ssrRender = setupResult;
          } else {
            instance.render = setupResult;
          }
        } else if (shared.isObject(setupResult)) {
          if (isVNode(setupResult)) {
            warn(
              `setup() should not return VNodes directly - return a render function instead.`
            );
          }
          {
            instance.devtoolsRawSetupState = setupResult;
          }
          instance.setupState = reactivity.proxyRefs(setupResult);
          {
            exposeSetupStateOnRenderContext(instance);
          }
        } else if (setupResult !== void 0) {
          warn(
            `setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`
          );
        }
        finishComponentSetup(instance, isSSR);
      }
      var compile;
      var installWithProxy;
      function registerRuntimeCompiler(_compile) {
        compile = _compile;
        installWithProxy = (i) => {
          if (i.render._rc) {
            i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
          }
        };
      }
      var isRuntimeOnly = () => !compile;
      function finishComponentSetup(instance, isSSR, skipOptions) {
        const Component = instance.type;
        if (!instance.render) {
          if (!isSSR && compile && !Component.render) {
            const template = Component.template || resolveMergedOptions(instance).template;
            if (template) {
              {
                startMeasure(instance, `compile`);
              }
              const { isCustomElement, compilerOptions } = instance.appContext.config;
              const { delimiters, compilerOptions: componentCompilerOptions } = Component;
              const finalCompilerOptions = shared.extend(
                shared.extend(
                  {
                    isCustomElement,
                    delimiters
                  },
                  compilerOptions
                ),
                componentCompilerOptions
              );
              Component.render = compile(template, finalCompilerOptions);
              {
                endMeasure(instance, `compile`);
              }
            }
          }
          instance.render = Component.render || shared.NOOP;
          if (installWithProxy) {
            installWithProxy(instance);
          }
        }
        {
          setCurrentInstance(instance);
          reactivity.pauseTracking();
          applyOptions(instance);
          reactivity.resetTracking();
          unsetCurrentInstance();
        }
        if (!Component.render && instance.render === shared.NOOP && !isSSR) {
          if (!compile && Component.template) {
            warn(
              `Component provided template option but runtime compilation is not supported in this build of Vue.`
              /* should not happen */
            );
          } else {
            warn(`Component is missing template or render function.`);
          }
        }
      }
      function getAttrsProxy(instance) {
        return instance.attrsProxy || (instance.attrsProxy = new Proxy(
          instance.attrs,
          {
            get(target, key) {
              markAttrsAccessed();
              reactivity.track(instance, "get", "$attrs");
              return target[key];
            },
            set() {
              warn(`setupContext.attrs is readonly.`);
              return false;
            },
            deleteProperty() {
              warn(`setupContext.attrs is readonly.`);
              return false;
            }
          }
        ));
      }
      function getSlotsProxy(instance) {
        return instance.slotsProxy || (instance.slotsProxy = new Proxy(instance.slots, {
          get(target, key) {
            reactivity.track(instance, "get", "$slots");
            return target[key];
          }
        }));
      }
      function createSetupContext(instance) {
        const expose = (exposed) => {
          {
            if (instance.exposed) {
              warn(`expose() should be called only once per setup().`);
            }
            if (exposed != null) {
              let exposedType = typeof exposed;
              if (exposedType === "object") {
                if (shared.isArray(exposed)) {
                  exposedType = "array";
                } else if (reactivity.isRef(exposed)) {
                  exposedType = "ref";
                }
              }
              if (exposedType !== "object") {
                warn(
                  `expose() should be passed a plain object, received ${exposedType}.`
                );
              }
            }
          }
          instance.exposed = exposed || {};
        };
        {
          return Object.freeze({
            get attrs() {
              return getAttrsProxy(instance);
            },
            get slots() {
              return getSlotsProxy(instance);
            },
            get emit() {
              return (event, ...args) => instance.emit(event, ...args);
            },
            expose
          });
        }
      }
      function getExposeProxy(instance) {
        if (instance.exposed) {
          return instance.exposeProxy || (instance.exposeProxy = new Proxy(reactivity.proxyRefs(reactivity.markRaw(instance.exposed)), {
            get(target, key) {
              if (key in target) {
                return target[key];
              } else if (key in publicPropertiesMap) {
                return publicPropertiesMap[key](instance);
              }
            },
            has(target, key) {
              return key in target || key in publicPropertiesMap;
            }
          }));
        }
      }
      var classifyRE = /(?:^|[-_])(\w)/g;
      var classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
      function getComponentName(Component, includeInferred = true) {
        return shared.isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
      }
      function formatComponentName(instance, Component, isRoot = false) {
        let name = getComponentName(Component);
        if (!name && Component.__file) {
          const match = Component.__file.match(/([^/\\]+)\.\w+$/);
          if (match) {
            name = match[1];
          }
        }
        if (!name && instance && instance.parent) {
          const inferFromRegistry = (registry) => {
            for (const key in registry) {
              if (registry[key] === Component) {
                return key;
              }
            }
          };
          name = inferFromRegistry(
            instance.components || instance.parent.type.components
          ) || inferFromRegistry(instance.appContext.components);
        }
        return name ? classify(name) : isRoot ? `App` : `Anonymous`;
      }
      function isClassComponent(value) {
        return shared.isFunction(value) && "__vccOpts" in value;
      }
      var computed = (getterOrOptions, debugOptions) => {
        return reactivity.computed(getterOrOptions, debugOptions, isInSSRComponentSetup);
      };
      function h(type, propsOrChildren, children) {
        const l = arguments.length;
        if (l === 2) {
          if (shared.isObject(propsOrChildren) && !shared.isArray(propsOrChildren)) {
            if (isVNode(propsOrChildren)) {
              return createVNode(type, null, [propsOrChildren]);
            }
            return createVNode(type, propsOrChildren);
          } else {
            return createVNode(type, null, propsOrChildren);
          }
        } else {
          if (l > 3) {
            children = Array.prototype.slice.call(arguments, 2);
          } else if (l === 3 && isVNode(children)) {
            children = [children];
          }
          return createVNode(type, propsOrChildren, children);
        }
      }
      var ssrContextKey = Symbol.for("v-scx");
      var useSSRContext = () => {
        {
          const ctx = inject(ssrContextKey);
          if (!ctx) {
            warn(
              `Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`
            );
          }
          return ctx;
        }
      };
      function isShallow(value) {
        return !!(value && value["__v_isShallow"]);
      }
      function initCustomFormatter() {
        if (typeof window === "undefined") {
          return;
        }
        const vueStyle = { style: "color:#3ba776" };
        const numberStyle = { style: "color:#0b1bc9" };
        const stringStyle = { style: "color:#b62e24" };
        const keywordStyle = { style: "color:#9d288c" };
        const formatter = {
          header(obj) {
            if (!shared.isObject(obj)) {
              return null;
            }
            if (obj.__isVue) {
              return ["div", vueStyle, `VueInstance`];
            } else if (reactivity.isRef(obj)) {
              return [
                "div",
                {},
                ["span", vueStyle, genRefFlag(obj)],
                "<",
                formatValue(obj.value),
                `>`
              ];
            } else if (reactivity.isReactive(obj)) {
              return [
                "div",
                {},
                ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"],
                "<",
                formatValue(obj),
                `>${reactivity.isReadonly(obj) ? ` (readonly)` : ``}`
              ];
            } else if (reactivity.isReadonly(obj)) {
              return [
                "div",
                {},
                ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"],
                "<",
                formatValue(obj),
                ">"
              ];
            }
            return null;
          },
          hasBody(obj) {
            return obj && obj.__isVue;
          },
          body(obj) {
            if (obj && obj.__isVue) {
              return [
                "div",
                {},
                ...formatInstance(obj.$)
              ];
            }
          }
        };
        function formatInstance(instance) {
          const blocks = [];
          if (instance.type.props && instance.props) {
            blocks.push(createInstanceBlock("props", reactivity.toRaw(instance.props)));
          }
          if (instance.setupState !== shared.EMPTY_OBJ) {
            blocks.push(createInstanceBlock("setup", instance.setupState));
          }
          if (instance.data !== shared.EMPTY_OBJ) {
            blocks.push(createInstanceBlock("data", reactivity.toRaw(instance.data)));
          }
          const computed2 = extractKeys(instance, "computed");
          if (computed2) {
            blocks.push(createInstanceBlock("computed", computed2));
          }
          const injected = extractKeys(instance, "inject");
          if (injected) {
            blocks.push(createInstanceBlock("injected", injected));
          }
          blocks.push([
            "div",
            {},
            [
              "span",
              {
                style: keywordStyle.style + ";opacity:0.66"
              },
              "$ (internal): "
            ],
            ["object", { object: instance }]
          ]);
          return blocks;
        }
        function createInstanceBlock(type, target) {
          target = shared.extend({}, target);
          if (!Object.keys(target).length) {
            return ["span", {}];
          }
          return [
            "div",
            { style: "line-height:1.25em;margin-bottom:0.6em" },
            [
              "div",
              {
                style: "color:#476582"
              },
              type
            ],
            [
              "div",
              {
                style: "padding-left:1.25em"
              },
              ...Object.keys(target).map((key) => {
                return [
                  "div",
                  {},
                  ["span", keywordStyle, key + ": "],
                  formatValue(target[key], false)
                ];
              })
            ]
          ];
        }
        function formatValue(v, asRaw = true) {
          if (typeof v === "number") {
            return ["span", numberStyle, v];
          } else if (typeof v === "string") {
            return ["span", stringStyle, JSON.stringify(v)];
          } else if (typeof v === "boolean") {
            return ["span", keywordStyle, v];
          } else if (shared.isObject(v)) {
            return ["object", { object: asRaw ? reactivity.toRaw(v) : v }];
          } else {
            return ["span", stringStyle, String(v)];
          }
        }
        function extractKeys(instance, type) {
          const Comp = instance.type;
          if (shared.isFunction(Comp)) {
            return;
          }
          const extracted = {};
          for (const key in instance.ctx) {
            if (isKeyOfType(Comp, key, type)) {
              extracted[key] = instance.ctx[key];
            }
          }
          return extracted;
        }
        function isKeyOfType(Comp, key, type) {
          const opts = Comp[type];
          if (shared.isArray(opts) && opts.includes(key) || shared.isObject(opts) && key in opts) {
            return true;
          }
          if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
            return true;
          }
          if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type))) {
            return true;
          }
        }
        function genRefFlag(v) {
          if (isShallow(v)) {
            return `ShallowRef`;
          }
          if (v.effect) {
            return `ComputedRef`;
          }
          return `Ref`;
        }
        if (window.devtoolsFormatters) {
          window.devtoolsFormatters.push(formatter);
        } else {
          window.devtoolsFormatters = [formatter];
        }
      }
      function withMemo(memo, render, cache, index) {
        const cached = cache[index];
        if (cached && isMemoSame(cached, memo)) {
          return cached;
        }
        const ret = render();
        ret.memo = memo.slice();
        return cache[index] = ret;
      }
      function isMemoSame(cached, memo) {
        const prev = cached.memo;
        if (prev.length != memo.length) {
          return false;
        }
        for (let i = 0; i < prev.length; i++) {
          if (shared.hasChanged(prev[i], memo[i])) {
            return false;
          }
        }
        if (isBlockTreeEnabled > 0 && currentBlock) {
          currentBlock.push(cached);
        }
        return true;
      }
      var version = "3.3.4";
      var _ssrUtils = {
        createComponentInstance,
        setupComponent,
        renderComponentRoot,
        setCurrentRenderingInstance,
        isVNode,
        normalizeVNode
      };
      var ssrUtils = _ssrUtils;
      var resolveFilter = null;
      var compatUtils = null;
      exports.EffectScope = reactivity.EffectScope;
      exports.ReactiveEffect = reactivity.ReactiveEffect;
      exports.customRef = reactivity.customRef;
      exports.effect = reactivity.effect;
      exports.effectScope = reactivity.effectScope;
      exports.getCurrentScope = reactivity.getCurrentScope;
      exports.isProxy = reactivity.isProxy;
      exports.isReactive = reactivity.isReactive;
      exports.isReadonly = reactivity.isReadonly;
      exports.isRef = reactivity.isRef;
      exports.isShallow = reactivity.isShallow;
      exports.markRaw = reactivity.markRaw;
      exports.onScopeDispose = reactivity.onScopeDispose;
      exports.proxyRefs = reactivity.proxyRefs;
      exports.reactive = reactivity.reactive;
      exports.readonly = reactivity.readonly;
      exports.ref = reactivity.ref;
      exports.shallowReactive = reactivity.shallowReactive;
      exports.shallowReadonly = reactivity.shallowReadonly;
      exports.shallowRef = reactivity.shallowRef;
      exports.stop = reactivity.stop;
      exports.toRaw = reactivity.toRaw;
      exports.toRef = reactivity.toRef;
      exports.toRefs = reactivity.toRefs;
      exports.toValue = reactivity.toValue;
      exports.triggerRef = reactivity.triggerRef;
      exports.unref = reactivity.unref;
      exports.camelize = shared.camelize;
      exports.capitalize = shared.capitalize;
      exports.normalizeClass = shared.normalizeClass;
      exports.normalizeProps = shared.normalizeProps;
      exports.normalizeStyle = shared.normalizeStyle;
      exports.toDisplayString = shared.toDisplayString;
      exports.toHandlerKey = shared.toHandlerKey;
      exports.BaseTransition = BaseTransition;
      exports.BaseTransitionPropsValidators = BaseTransitionPropsValidators;
      exports.Comment = Comment;
      exports.Fragment = Fragment;
      exports.KeepAlive = KeepAlive;
      exports.Static = Static;
      exports.Suspense = Suspense;
      exports.Teleport = Teleport;
      exports.Text = Text;
      exports.assertNumber = assertNumber;
      exports.callWithAsyncErrorHandling = callWithAsyncErrorHandling;
      exports.callWithErrorHandling = callWithErrorHandling;
      exports.cloneVNode = cloneVNode;
      exports.compatUtils = compatUtils;
      exports.computed = computed;
      exports.createBlock = createBlock;
      exports.createCommentVNode = createCommentVNode;
      exports.createElementBlock = createElementBlock;
      exports.createElementVNode = createBaseVNode;
      exports.createHydrationRenderer = createHydrationRenderer;
      exports.createPropsRestProxy = createPropsRestProxy;
      exports.createRenderer = createRenderer;
      exports.createSlots = createSlots;
      exports.createStaticVNode = createStaticVNode;
      exports.createTextVNode = createTextVNode;
      exports.createVNode = createVNode;
      exports.defineAsyncComponent = defineAsyncComponent;
      exports.defineComponent = defineComponent;
      exports.defineEmits = defineEmits;
      exports.defineExpose = defineExpose;
      exports.defineModel = defineModel;
      exports.defineOptions = defineOptions;
      exports.defineProps = defineProps;
      exports.defineSlots = defineSlots;
      exports.getCurrentInstance = getCurrentInstance;
      exports.getTransitionRawChildren = getTransitionRawChildren;
      exports.guardReactiveProps = guardReactiveProps;
      exports.h = h;
      exports.handleError = handleError;
      exports.hasInjectionContext = hasInjectionContext;
      exports.initCustomFormatter = initCustomFormatter;
      exports.inject = inject;
      exports.isMemoSame = isMemoSame;
      exports.isRuntimeOnly = isRuntimeOnly;
      exports.isVNode = isVNode;
      exports.mergeDefaults = mergeDefaults;
      exports.mergeModels = mergeModels;
      exports.mergeProps = mergeProps;
      exports.nextTick = nextTick;
      exports.onActivated = onActivated;
      exports.onBeforeMount = onBeforeMount;
      exports.onBeforeUnmount = onBeforeUnmount;
      exports.onBeforeUpdate = onBeforeUpdate;
      exports.onDeactivated = onDeactivated;
      exports.onErrorCaptured = onErrorCaptured;
      exports.onMounted = onMounted;
      exports.onRenderTracked = onRenderTracked;
      exports.onRenderTriggered = onRenderTriggered;
      exports.onServerPrefetch = onServerPrefetch;
      exports.onUnmounted = onUnmounted;
      exports.onUpdated = onUpdated;
      exports.openBlock = openBlock;
      exports.popScopeId = popScopeId;
      exports.provide = provide;
      exports.pushScopeId = pushScopeId;
      exports.queuePostFlushCb = queuePostFlushCb;
      exports.registerRuntimeCompiler = registerRuntimeCompiler;
      exports.renderList = renderList;
      exports.renderSlot = renderSlot;
      exports.resolveComponent = resolveComponent;
      exports.resolveDirective = resolveDirective;
      exports.resolveDynamicComponent = resolveDynamicComponent;
      exports.resolveFilter = resolveFilter;
      exports.resolveTransitionHooks = resolveTransitionHooks;
      exports.setBlockTracking = setBlockTracking;
      exports.setDevtoolsHook = setDevtoolsHook;
      exports.setTransitionHooks = setTransitionHooks;
      exports.ssrContextKey = ssrContextKey;
      exports.ssrUtils = ssrUtils;
      exports.toHandlers = toHandlers;
      exports.transformVNodeArgs = transformVNodeArgs;
      exports.useAttrs = useAttrs;
      exports.useModel = useModel;
      exports.useSSRContext = useSSRContext;
      exports.useSlots = useSlots;
      exports.useTransitionState = useTransitionState;
      exports.version = version;
      exports.warn = warn;
      exports.watch = watch;
      exports.watchEffect = watchEffect;
      exports.watchPostEffect = watchPostEffect;
      exports.watchSyncEffect = watchSyncEffect;
      exports.withAsyncContext = withAsyncContext;
      exports.withCtx = withCtx;
      exports.withDefaults = withDefaults;
      exports.withDirectives = withDirectives;
      exports.withMemo = withMemo;
      exports.withScopeId = withScopeId;
    }
  });

  // node_modules/@vue/runtime-core/index.js
  var require_runtime_core = __commonJS({
    "node_modules/@vue/runtime-core/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_runtime_core_cjs();
      }
    }
  });

  // node_modules/@vue/runtime-dom/dist/runtime-dom.cjs.js
  var require_runtime_dom_cjs = __commonJS({
    "node_modules/@vue/runtime-dom/dist/runtime-dom.cjs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var runtimeCore = require_runtime_core();
      var shared = require_shared();
      var svgNS = "http://www.w3.org/2000/svg";
      var doc = typeof document !== "undefined" ? document : null;
      var templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
      var nodeOps = {
        insert: (child, parent, anchor) => {
          parent.insertBefore(child, anchor || null);
        },
        remove: (child) => {
          const parent = child.parentNode;
          if (parent) {
            parent.removeChild(child);
          }
        },
        createElement: (tag, isSVG, is, props) => {
          const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
          if (tag === "select" && props && props.multiple != null) {
            el.setAttribute("multiple", props.multiple);
          }
          return el;
        },
        createText: (text) => doc.createTextNode(text),
        createComment: (text) => doc.createComment(text),
        setText: (node, text) => {
          node.nodeValue = text;
        },
        setElementText: (el, text) => {
          el.textContent = text;
        },
        parentNode: (node) => node.parentNode,
        nextSibling: (node) => node.nextSibling,
        querySelector: (selector) => doc.querySelector(selector),
        setScopeId(el, id) {
          el.setAttribute(id, "");
        },
        // __UNSAFE__
        // Reason: innerHTML.
        // Static content here can only come from compiled templates.
        // As long as the user only uses trusted templates, this is safe.
        insertStaticContent(content, parent, anchor, isSVG, start, end) {
          const before = anchor ? anchor.previousSibling : parent.lastChild;
          if (start && (start === end || start.nextSibling)) {
            while (true) {
              parent.insertBefore(start.cloneNode(true), anchor);
              if (start === end || !(start = start.nextSibling))
                break;
            }
          } else {
            templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
            const template = templateContainer.content;
            if (isSVG) {
              const wrapper = template.firstChild;
              while (wrapper.firstChild) {
                template.appendChild(wrapper.firstChild);
              }
              template.removeChild(wrapper);
            }
            parent.insertBefore(template, anchor);
          }
          return [
            // first
            before ? before.nextSibling : parent.firstChild,
            // last
            anchor ? anchor.previousSibling : parent.lastChild
          ];
        }
      };
      function patchClass(el, value, isSVG) {
        const transitionClasses = el._vtc;
        if (transitionClasses) {
          value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
        }
        if (value == null) {
          el.removeAttribute("class");
        } else if (isSVG) {
          el.setAttribute("class", value);
        } else {
          el.className = value;
        }
      }
      function patchStyle(el, prev, next) {
        const style = el.style;
        const isCssString = shared.isString(next);
        if (next && !isCssString) {
          if (prev && !shared.isString(prev)) {
            for (const key in prev) {
              if (next[key] == null) {
                setStyle(style, key, "");
              }
            }
          }
          for (const key in next) {
            setStyle(style, key, next[key]);
          }
        } else {
          const currentDisplay = style.display;
          if (isCssString) {
            if (prev !== next) {
              style.cssText = next;
            }
          } else if (prev) {
            el.removeAttribute("style");
          }
          if ("_vod" in el) {
            style.display = currentDisplay;
          }
        }
      }
      var semicolonRE = /[^\\];\s*$/;
      var importantRE = /\s*!important$/;
      function setStyle(style, name, val) {
        if (shared.isArray(val)) {
          val.forEach((v) => setStyle(style, name, v));
        } else {
          if (val == null)
            val = "";
          {
            if (semicolonRE.test(val)) {
              runtimeCore.warn(
                `Unexpected semicolon at the end of '${name}' style value: '${val}'`
              );
            }
          }
          if (name.startsWith("--")) {
            style.setProperty(name, val);
          } else {
            const prefixed = autoPrefix(style, name);
            if (importantRE.test(val)) {
              style.setProperty(
                shared.hyphenate(prefixed),
                val.replace(importantRE, ""),
                "important"
              );
            } else {
              style[prefixed] = val;
            }
          }
        }
      }
      var prefixes = ["Webkit", "Moz", "ms"];
      var prefixCache = {};
      function autoPrefix(style, rawName) {
        const cached = prefixCache[rawName];
        if (cached) {
          return cached;
        }
        let name = runtimeCore.camelize(rawName);
        if (name !== "filter" && name in style) {
          return prefixCache[rawName] = name;
        }
        name = shared.capitalize(name);
        for (let i = 0; i < prefixes.length; i++) {
          const prefixed = prefixes[i] + name;
          if (prefixed in style) {
            return prefixCache[rawName] = prefixed;
          }
        }
        return rawName;
      }
      var xlinkNS = "http://www.w3.org/1999/xlink";
      function patchAttr(el, key, value, isSVG, instance) {
        if (isSVG && key.startsWith("xlink:")) {
          if (value == null) {
            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
          } else {
            el.setAttributeNS(xlinkNS, key, value);
          }
        } else {
          const isBoolean = shared.isSpecialBooleanAttr(key);
          if (value == null || isBoolean && !shared.includeBooleanAttr(value)) {
            el.removeAttribute(key);
          } else {
            el.setAttribute(key, isBoolean ? "" : value);
          }
        }
      }
      function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
        if (key === "innerHTML" || key === "textContent") {
          if (prevChildren) {
            unmountChildren(prevChildren, parentComponent, parentSuspense);
          }
          el[key] = value == null ? "" : value;
          return;
        }
        const tag = el.tagName;
        if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
        !tag.includes("-")) {
          el._value = value;
          const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
          const newValue = value == null ? "" : value;
          if (oldValue !== newValue) {
            el.value = newValue;
          }
          if (value == null) {
            el.removeAttribute(key);
          }
          return;
        }
        let needRemove = false;
        if (value === "" || value == null) {
          const type = typeof el[key];
          if (type === "boolean") {
            value = shared.includeBooleanAttr(value);
          } else if (value == null && type === "string") {
            value = "";
            needRemove = true;
          } else if (type === "number") {
            value = 0;
            needRemove = true;
          }
        }
        try {
          el[key] = value;
        } catch (e) {
          if (!needRemove) {
            runtimeCore.warn(
              `Failed setting prop "${key}" on <${tag.toLowerCase()}>: value ${value} is invalid.`,
              e
            );
          }
        }
        needRemove && el.removeAttribute(key);
      }
      function addEventListener(el, event, handler, options) {
        el.addEventListener(event, handler, options);
      }
      function removeEventListener(el, event, handler, options) {
        el.removeEventListener(event, handler, options);
      }
      function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
        const invokers = el._vei || (el._vei = {});
        const existingInvoker = invokers[rawName];
        if (nextValue && existingInvoker) {
          existingInvoker.value = nextValue;
        } else {
          const [name, options] = parseName(rawName);
          if (nextValue) {
            const invoker = invokers[rawName] = createInvoker(nextValue, instance);
            addEventListener(el, name, invoker, options);
          } else if (existingInvoker) {
            removeEventListener(el, name, existingInvoker, options);
            invokers[rawName] = void 0;
          }
        }
      }
      var optionsModifierRE = /(?:Once|Passive|Capture)$/;
      function parseName(name) {
        let options;
        if (optionsModifierRE.test(name)) {
          options = {};
          let m;
          while (m = name.match(optionsModifierRE)) {
            name = name.slice(0, name.length - m[0].length);
            options[m[0].toLowerCase()] = true;
          }
        }
        const event = name[2] === ":" ? name.slice(3) : shared.hyphenate(name.slice(2));
        return [event, options];
      }
      var cachedNow = 0;
      var p = /* @__PURE__ */ Promise.resolve();
      var getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
      function createInvoker(initialValue, instance) {
        const invoker = (e) => {
          if (!e._vts) {
            e._vts = Date.now();
          } else if (e._vts <= invoker.attached) {
            return;
          }
          runtimeCore.callWithAsyncErrorHandling(
            patchStopImmediatePropagation(e, invoker.value),
            instance,
            5,
            [e]
          );
        };
        invoker.value = initialValue;
        invoker.attached = getNow();
        return invoker;
      }
      function patchStopImmediatePropagation(e, value) {
        if (shared.isArray(value)) {
          const originalStop = e.stopImmediatePropagation;
          e.stopImmediatePropagation = () => {
            originalStop.call(e);
            e._stopped = true;
          };
          return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
        } else {
          return value;
        }
      }
      var nativeOnRE = /^on[a-z]/;
      var patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
        if (key === "class") {
          patchClass(el, nextValue, isSVG);
        } else if (key === "style") {
          patchStyle(el, prevValue, nextValue);
        } else if (shared.isOn(key)) {
          if (!shared.isModelListener(key)) {
            patchEvent(el, key, prevValue, nextValue, parentComponent);
          }
        } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
          patchDOMProp(
            el,
            key,
            nextValue,
            prevChildren,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        } else {
          if (key === "true-value") {
            el._trueValue = nextValue;
          } else if (key === "false-value") {
            el._falseValue = nextValue;
          }
          patchAttr(el, key, nextValue, isSVG);
        }
      };
      function shouldSetAsProp(el, key, value, isSVG) {
        if (isSVG) {
          if (key === "innerHTML" || key === "textContent") {
            return true;
          }
          if (key in el && nativeOnRE.test(key) && shared.isFunction(value)) {
            return true;
          }
          return false;
        }
        if (key === "spellcheck" || key === "draggable" || key === "translate") {
          return false;
        }
        if (key === "form") {
          return false;
        }
        if (key === "list" && el.tagName === "INPUT") {
          return false;
        }
        if (key === "type" && el.tagName === "TEXTAREA") {
          return false;
        }
        if (nativeOnRE.test(key) && shared.isString(value)) {
          return false;
        }
        return key in el;
      }
      function defineCustomElement(options, hydrate2) {
        const Comp = runtimeCore.defineComponent(options);
        class VueCustomElement extends VueElement {
          constructor(initialProps) {
            super(Comp, initialProps, hydrate2);
          }
        }
        VueCustomElement.def = Comp;
        return VueCustomElement;
      }
      var defineSSRCustomElement = (options) => {
        return defineCustomElement(options, hydrate);
      };
      var BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
      };
      var VueElement = class extends BaseClass {
        constructor(_def, _props = {}, hydrate2) {
          super();
          this._def = _def;
          this._props = _props;
          this._instance = null;
          this._connected = false;
          this._resolved = false;
          this._numberProps = null;
          if (this.shadowRoot && hydrate2) {
            hydrate2(this._createVNode(), this.shadowRoot);
          } else {
            if (this.shadowRoot) {
              runtimeCore.warn(
                `Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use \`defineSSRCustomElement\`.`
              );
            }
            this.attachShadow({ mode: "open" });
            if (!this._def.__asyncLoader) {
              this._resolveProps(this._def);
            }
          }
        }
        connectedCallback() {
          this._connected = true;
          if (!this._instance) {
            if (this._resolved) {
              this._update();
            } else {
              this._resolveDef();
            }
          }
        }
        disconnectedCallback() {
          this._connected = false;
          runtimeCore.nextTick(() => {
            if (!this._connected) {
              render(null, this.shadowRoot);
              this._instance = null;
            }
          });
        }
        /**
         * resolve inner component definition (handle possible async component)
         */
        _resolveDef() {
          this._resolved = true;
          for (let i = 0; i < this.attributes.length; i++) {
            this._setAttr(this.attributes[i].name);
          }
          new MutationObserver((mutations) => {
            for (const m of mutations) {
              this._setAttr(m.attributeName);
            }
          }).observe(this, { attributes: true });
          const resolve = (def, isAsync = false) => {
            const { props, styles } = def;
            let numberProps;
            if (props && !shared.isArray(props)) {
              for (const key in props) {
                const opt = props[key];
                if (opt === Number || opt && opt.type === Number) {
                  if (key in this._props) {
                    this._props[key] = shared.toNumber(this._props[key]);
                  }
                  (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[shared.camelize(key)] = true;
                }
              }
            }
            this._numberProps = numberProps;
            if (isAsync) {
              this._resolveProps(def);
            }
            this._applyStyles(styles);
            this._update();
          };
          const asyncDef = this._def.__asyncLoader;
          if (asyncDef) {
            asyncDef().then((def) => resolve(def, true));
          } else {
            resolve(this._def);
          }
        }
        _resolveProps(def) {
          const { props } = def;
          const declaredPropKeys = shared.isArray(props) ? props : Object.keys(props || {});
          for (const key of Object.keys(this)) {
            if (key[0] !== "_" && declaredPropKeys.includes(key)) {
              this._setProp(key, this[key], true, false);
            }
          }
          for (const key of declaredPropKeys.map(shared.camelize)) {
            Object.defineProperty(this, key, {
              get() {
                return this._getProp(key);
              },
              set(val) {
                this._setProp(key, val);
              }
            });
          }
        }
        _setAttr(key) {
          let value = this.getAttribute(key);
          const camelKey = shared.camelize(key);
          if (this._numberProps && this._numberProps[camelKey]) {
            value = shared.toNumber(value);
          }
          this._setProp(camelKey, value, false);
        }
        /**
         * @internal
         */
        _getProp(key) {
          return this._props[key];
        }
        /**
         * @internal
         */
        _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
          if (val !== this._props[key]) {
            this._props[key] = val;
            if (shouldUpdate && this._instance) {
              this._update();
            }
            if (shouldReflect) {
              if (val === true) {
                this.setAttribute(shared.hyphenate(key), "");
              } else if (typeof val === "string" || typeof val === "number") {
                this.setAttribute(shared.hyphenate(key), val + "");
              } else if (!val) {
                this.removeAttribute(shared.hyphenate(key));
              }
            }
          }
        }
        _update() {
          render(this._createVNode(), this.shadowRoot);
        }
        _createVNode() {
          const vnode = runtimeCore.createVNode(this._def, shared.extend({}, this._props));
          if (!this._instance) {
            vnode.ce = (instance) => {
              this._instance = instance;
              instance.isCE = true;
              {
                instance.ceReload = (newStyles) => {
                  if (this._styles) {
                    this._styles.forEach((s) => this.shadowRoot.removeChild(s));
                    this._styles.length = 0;
                  }
                  this._applyStyles(newStyles);
                  this._instance = null;
                  this._update();
                };
              }
              const dispatch = (event, args) => {
                this.dispatchEvent(
                  new CustomEvent(event, {
                    detail: args
                  })
                );
              };
              instance.emit = (event, ...args) => {
                dispatch(event, args);
                if (shared.hyphenate(event) !== event) {
                  dispatch(shared.hyphenate(event), args);
                }
              };
              let parent = this;
              while (parent = parent && (parent.parentNode || parent.host)) {
                if (parent instanceof VueElement) {
                  instance.parent = parent._instance;
                  instance.provides = parent._instance.provides;
                  break;
                }
              }
            };
          }
          return vnode;
        }
        _applyStyles(styles) {
          if (styles) {
            styles.forEach((css) => {
              const s = document.createElement("style");
              s.textContent = css;
              this.shadowRoot.appendChild(s);
              {
                (this._styles || (this._styles = [])).push(s);
              }
            });
          }
        }
      };
      function useCssModule(name = "$style") {
        {
          const instance = runtimeCore.getCurrentInstance();
          if (!instance) {
            runtimeCore.warn(`useCssModule must be called inside setup()`);
            return shared.EMPTY_OBJ;
          }
          const modules = instance.type.__cssModules;
          if (!modules) {
            runtimeCore.warn(`Current instance does not have CSS modules injected.`);
            return shared.EMPTY_OBJ;
          }
          const mod = modules[name];
          if (!mod) {
            runtimeCore.warn(`Current instance does not have CSS module named "${name}".`);
            return shared.EMPTY_OBJ;
          }
          return mod;
        }
      }
      function useCssVars(getter) {
        return;
      }
      var TRANSITION = "transition";
      var ANIMATION = "animation";
      var Transition = (props, { slots }) => runtimeCore.h(runtimeCore.BaseTransition, resolveTransitionProps(props), slots);
      Transition.displayName = "Transition";
      var DOMTransitionPropsValidators = {
        name: String,
        type: String,
        css: {
          type: Boolean,
          default: true
        },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String
      };
      var TransitionPropsValidators = Transition.props = /* @__PURE__ */ shared.extend(
        {},
        runtimeCore.BaseTransitionPropsValidators,
        DOMTransitionPropsValidators
      );
      var callHook = (hook, args = []) => {
        if (shared.isArray(hook)) {
          hook.forEach((h2) => h2(...args));
        } else if (hook) {
          hook(...args);
        }
      };
      var hasExplicitCallback = (hook) => {
        return hook ? shared.isArray(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
      };
      function resolveTransitionProps(rawProps) {
        const baseProps = {};
        for (const key in rawProps) {
          if (!(key in DOMTransitionPropsValidators)) {
            baseProps[key] = rawProps[key];
          }
        }
        if (rawProps.css === false) {
          return baseProps;
        }
        const {
          name = "v",
          type,
          duration,
          enterFromClass = `${name}-enter-from`,
          enterActiveClass = `${name}-enter-active`,
          enterToClass = `${name}-enter-to`,
          appearFromClass = enterFromClass,
          appearActiveClass = enterActiveClass,
          appearToClass = enterToClass,
          leaveFromClass = `${name}-leave-from`,
          leaveActiveClass = `${name}-leave-active`,
          leaveToClass = `${name}-leave-to`
        } = rawProps;
        const durations = normalizeDuration(duration);
        const enterDuration = durations && durations[0];
        const leaveDuration = durations && durations[1];
        const {
          onBeforeEnter,
          onEnter,
          onEnterCancelled,
          onLeave,
          onLeaveCancelled,
          onBeforeAppear = onBeforeEnter,
          onAppear = onEnter,
          onAppearCancelled = onEnterCancelled
        } = baseProps;
        const finishEnter = (el, isAppear, done) => {
          removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
          removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
          done && done();
        };
        const finishLeave = (el, done) => {
          el._isLeaving = false;
          removeTransitionClass(el, leaveFromClass);
          removeTransitionClass(el, leaveToClass);
          removeTransitionClass(el, leaveActiveClass);
          done && done();
        };
        const makeEnterHook = (isAppear) => {
          return (el, done) => {
            const hook = isAppear ? onAppear : onEnter;
            const resolve = () => finishEnter(el, isAppear, done);
            callHook(hook, [el, resolve]);
            nextFrame(() => {
              removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
              addTransitionClass(el, isAppear ? appearToClass : enterToClass);
              if (!hasExplicitCallback(hook)) {
                whenTransitionEnds(el, type, enterDuration, resolve);
              }
            });
          };
        };
        return shared.extend(baseProps, {
          onBeforeEnter(el) {
            callHook(onBeforeEnter, [el]);
            addTransitionClass(el, enterFromClass);
            addTransitionClass(el, enterActiveClass);
          },
          onBeforeAppear(el) {
            callHook(onBeforeAppear, [el]);
            addTransitionClass(el, appearFromClass);
            addTransitionClass(el, appearActiveClass);
          },
          onEnter: makeEnterHook(false),
          onAppear: makeEnterHook(true),
          onLeave(el, done) {
            el._isLeaving = true;
            const resolve = () => finishLeave(el, done);
            addTransitionClass(el, leaveFromClass);
            forceReflow();
            addTransitionClass(el, leaveActiveClass);
            nextFrame(() => {
              if (!el._isLeaving) {
                return;
              }
              removeTransitionClass(el, leaveFromClass);
              addTransitionClass(el, leaveToClass);
              if (!hasExplicitCallback(onLeave)) {
                whenTransitionEnds(el, type, leaveDuration, resolve);
              }
            });
            callHook(onLeave, [el, resolve]);
          },
          onEnterCancelled(el) {
            finishEnter(el, false);
            callHook(onEnterCancelled, [el]);
          },
          onAppearCancelled(el) {
            finishEnter(el, true);
            callHook(onAppearCancelled, [el]);
          },
          onLeaveCancelled(el) {
            finishLeave(el);
            callHook(onLeaveCancelled, [el]);
          }
        });
      }
      function normalizeDuration(duration) {
        if (duration == null) {
          return null;
        } else if (shared.isObject(duration)) {
          return [NumberOf(duration.enter), NumberOf(duration.leave)];
        } else {
          const n = NumberOf(duration);
          return [n, n];
        }
      }
      function NumberOf(val) {
        const res = shared.toNumber(val);
        {
          runtimeCore.assertNumber(res, "<transition> explicit duration");
        }
        return res;
      }
      function addTransitionClass(el, cls) {
        cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
        (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
      }
      function removeTransitionClass(el, cls) {
        cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
        const { _vtc } = el;
        if (_vtc) {
          _vtc.delete(cls);
          if (!_vtc.size) {
            el._vtc = void 0;
          }
        }
      }
      function nextFrame(cb) {
        requestAnimationFrame(() => {
          requestAnimationFrame(cb);
        });
      }
      var endId = 0;
      function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
        const id = el._endId = ++endId;
        const resolveIfNotStale = () => {
          if (id === el._endId) {
            resolve();
          }
        };
        if (explicitTimeout) {
          return setTimeout(resolveIfNotStale, explicitTimeout);
        }
        const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
        if (!type) {
          return resolve();
        }
        const endEvent = type + "end";
        let ended = 0;
        const end = () => {
          el.removeEventListener(endEvent, onEnd);
          resolveIfNotStale();
        };
        const onEnd = (e) => {
          if (e.target === el && ++ended >= propCount) {
            end();
          }
        };
        setTimeout(() => {
          if (ended < propCount) {
            end();
          }
        }, timeout + 1);
        el.addEventListener(endEvent, onEnd);
      }
      function getTransitionInfo(el, expectedType) {
        const styles = window.getComputedStyle(el);
        const getStyleProperties = (key) => (styles[key] || "").split(", ");
        const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
        const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
        const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
        const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
        const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
        const animationTimeout = getTimeout(animationDelays, animationDurations);
        let type = null;
        let timeout = 0;
        let propCount = 0;
        if (expectedType === TRANSITION) {
          if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
          }
        } else if (expectedType === ANIMATION) {
          if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
          }
        } else {
          timeout = Math.max(transitionTimeout, animationTimeout);
          type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
          propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
        }
        const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
          getStyleProperties(`${TRANSITION}Property`).toString()
        );
        return {
          type,
          timeout,
          propCount,
          hasTransform
        };
      }
      function getTimeout(delays, durations) {
        while (delays.length < durations.length) {
          delays = delays.concat(delays);
        }
        return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
      }
      function toMs(s) {
        return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
      }
      function forceReflow() {
        return document.body.offsetHeight;
      }
      var positionMap = /* @__PURE__ */ new WeakMap();
      var newPositionMap = /* @__PURE__ */ new WeakMap();
      var TransitionGroupImpl = {
        name: "TransitionGroup",
        props: /* @__PURE__ */ shared.extend({}, TransitionPropsValidators, {
          tag: String,
          moveClass: String
        }),
        setup(props, { slots }) {
          const instance = runtimeCore.getCurrentInstance();
          const state = runtimeCore.useTransitionState();
          let prevChildren;
          let children;
          runtimeCore.onUpdated(() => {
            if (!prevChildren.length) {
              return;
            }
            const moveClass = props.moveClass || `${props.name || "v"}-move`;
            if (!hasCSSTransform(
              prevChildren[0].el,
              instance.vnode.el,
              moveClass
            )) {
              return;
            }
            prevChildren.forEach(callPendingCbs);
            prevChildren.forEach(recordPosition);
            const movedChildren = prevChildren.filter(applyTranslation);
            forceReflow();
            movedChildren.forEach((c) => {
              const el = c.el;
              const style = el.style;
              addTransitionClass(el, moveClass);
              style.transform = style.webkitTransform = style.transitionDuration = "";
              const cb = el._moveCb = (e) => {
                if (e && e.target !== el) {
                  return;
                }
                if (!e || /transform$/.test(e.propertyName)) {
                  el.removeEventListener("transitionend", cb);
                  el._moveCb = null;
                  removeTransitionClass(el, moveClass);
                }
              };
              el.addEventListener("transitionend", cb);
            });
          });
          return () => {
            const rawProps = runtimeCore.toRaw(props);
            const cssTransitionProps = resolveTransitionProps(rawProps);
            let tag = rawProps.tag || runtimeCore.Fragment;
            prevChildren = children;
            children = slots.default ? runtimeCore.getTransitionRawChildren(slots.default()) : [];
            for (let i = 0; i < children.length; i++) {
              const child = children[i];
              if (child.key != null) {
                runtimeCore.setTransitionHooks(
                  child,
                  runtimeCore.resolveTransitionHooks(child, cssTransitionProps, state, instance)
                );
              } else {
                runtimeCore.warn(`<TransitionGroup> children must be keyed.`);
              }
            }
            if (prevChildren) {
              for (let i = 0; i < prevChildren.length; i++) {
                const child = prevChildren[i];
                runtimeCore.setTransitionHooks(
                  child,
                  runtimeCore.resolveTransitionHooks(child, cssTransitionProps, state, instance)
                );
                positionMap.set(child, child.el.getBoundingClientRect());
              }
            }
            return runtimeCore.createVNode(tag, null, children);
          };
        }
      };
      var removeMode = (props) => delete props.mode;
      /* @__PURE__ */ removeMode(TransitionGroupImpl.props);
      var TransitionGroup = TransitionGroupImpl;
      function callPendingCbs(c) {
        const el = c.el;
        if (el._moveCb) {
          el._moveCb();
        }
        if (el._enterCb) {
          el._enterCb();
        }
      }
      function recordPosition(c) {
        newPositionMap.set(c, c.el.getBoundingClientRect());
      }
      function applyTranslation(c) {
        const oldPos = positionMap.get(c);
        const newPos = newPositionMap.get(c);
        const dx = oldPos.left - newPos.left;
        const dy = oldPos.top - newPos.top;
        if (dx || dy) {
          const s = c.el.style;
          s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
          s.transitionDuration = "0s";
          return c;
        }
      }
      function hasCSSTransform(el, root, moveClass) {
        const clone = el.cloneNode();
        if (el._vtc) {
          el._vtc.forEach((cls) => {
            cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c));
          });
        }
        moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c));
        clone.style.display = "none";
        const container = root.nodeType === 1 ? root : root.parentNode;
        container.appendChild(clone);
        const { hasTransform } = getTransitionInfo(clone);
        container.removeChild(clone);
        return hasTransform;
      }
      var getModelAssigner = (vnode) => {
        const fn = vnode.props["onUpdate:modelValue"] || false;
        return shared.isArray(fn) ? (value) => shared.invokeArrayFns(fn, value) : fn;
      };
      function onCompositionStart(e) {
        e.target.composing = true;
      }
      function onCompositionEnd(e) {
        const target = e.target;
        if (target.composing) {
          target.composing = false;
          target.dispatchEvent(new Event("input"));
        }
      }
      var vModelText = {
        created(el, { modifiers: { lazy, trim, number } }, vnode) {
          el._assign = getModelAssigner(vnode);
          const castToNumber = number || vnode.props && vnode.props.type === "number";
          addEventListener(el, lazy ? "change" : "input", (e) => {
            if (e.target.composing)
              return;
            let domValue = el.value;
            if (trim) {
              domValue = domValue.trim();
            }
            if (castToNumber) {
              domValue = shared.looseToNumber(domValue);
            }
            el._assign(domValue);
          });
          if (trim) {
            addEventListener(el, "change", () => {
              el.value = el.value.trim();
            });
          }
          if (!lazy) {
            addEventListener(el, "compositionstart", onCompositionStart);
            addEventListener(el, "compositionend", onCompositionEnd);
            addEventListener(el, "change", onCompositionEnd);
          }
        },
        // set value on mounted so it's after min/max for type="range"
        mounted(el, { value }) {
          el.value = value == null ? "" : value;
        },
        beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {
          el._assign = getModelAssigner(vnode);
          if (el.composing)
            return;
          if (document.activeElement === el && el.type !== "range") {
            if (lazy) {
              return;
            }
            if (trim && el.value.trim() === value) {
              return;
            }
            if ((number || el.type === "number") && shared.looseToNumber(el.value) === value) {
              return;
            }
          }
          const newValue = value == null ? "" : value;
          if (el.value !== newValue) {
            el.value = newValue;
          }
        }
      };
      var vModelCheckbox = {
        // #4096 array checkboxes need to be deep traversed
        deep: true,
        created(el, _, vnode) {
          el._assign = getModelAssigner(vnode);
          addEventListener(el, "change", () => {
            const modelValue = el._modelValue;
            const elementValue = getValue(el);
            const checked = el.checked;
            const assign = el._assign;
            if (shared.isArray(modelValue)) {
              const index = shared.looseIndexOf(modelValue, elementValue);
              const found = index !== -1;
              if (checked && !found) {
                assign(modelValue.concat(elementValue));
              } else if (!checked && found) {
                const filtered = [...modelValue];
                filtered.splice(index, 1);
                assign(filtered);
              }
            } else if (shared.isSet(modelValue)) {
              const cloned = new Set(modelValue);
              if (checked) {
                cloned.add(elementValue);
              } else {
                cloned.delete(elementValue);
              }
              assign(cloned);
            } else {
              assign(getCheckboxValue(el, checked));
            }
          });
        },
        // set initial checked on mount to wait for true-value/false-value
        mounted: setChecked,
        beforeUpdate(el, binding, vnode) {
          el._assign = getModelAssigner(vnode);
          setChecked(el, binding, vnode);
        }
      };
      function setChecked(el, { value, oldValue }, vnode) {
        el._modelValue = value;
        if (shared.isArray(value)) {
          el.checked = shared.looseIndexOf(value, vnode.props.value) > -1;
        } else if (shared.isSet(value)) {
          el.checked = value.has(vnode.props.value);
        } else if (value !== oldValue) {
          el.checked = shared.looseEqual(value, getCheckboxValue(el, true));
        }
      }
      var vModelRadio = {
        created(el, { value }, vnode) {
          el.checked = shared.looseEqual(value, vnode.props.value);
          el._assign = getModelAssigner(vnode);
          addEventListener(el, "change", () => {
            el._assign(getValue(el));
          });
        },
        beforeUpdate(el, { value, oldValue }, vnode) {
          el._assign = getModelAssigner(vnode);
          if (value !== oldValue) {
            el.checked = shared.looseEqual(value, vnode.props.value);
          }
        }
      };
      var vModelSelect = {
        // <select multiple> value need to be deep traversed
        deep: true,
        created(el, { value, modifiers: { number } }, vnode) {
          const isSetModel = shared.isSet(value);
          addEventListener(el, "change", () => {
            const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
              (o) => number ? shared.looseToNumber(getValue(o)) : getValue(o)
            );
            el._assign(
              el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
            );
          });
          el._assign = getModelAssigner(vnode);
        },
        // set value in mounted & updated because <select> relies on its children
        // <option>s.
        mounted(el, { value }) {
          setSelected(el, value);
        },
        beforeUpdate(el, _binding, vnode) {
          el._assign = getModelAssigner(vnode);
        },
        updated(el, { value }) {
          setSelected(el, value);
        }
      };
      function setSelected(el, value) {
        const isMultiple = el.multiple;
        if (isMultiple && !shared.isArray(value) && !shared.isSet(value)) {
          runtimeCore.warn(
            `<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(value).slice(8, -1)}.`
          );
          return;
        }
        for (let i = 0, l = el.options.length; i < l; i++) {
          const option = el.options[i];
          const optionValue = getValue(option);
          if (isMultiple) {
            if (shared.isArray(value)) {
              option.selected = shared.looseIndexOf(value, optionValue) > -1;
            } else {
              option.selected = value.has(optionValue);
            }
          } else {
            if (shared.looseEqual(getValue(option), value)) {
              if (el.selectedIndex !== i)
                el.selectedIndex = i;
              return;
            }
          }
        }
        if (!isMultiple && el.selectedIndex !== -1) {
          el.selectedIndex = -1;
        }
      }
      function getValue(el) {
        return "_value" in el ? el._value : el.value;
      }
      function getCheckboxValue(el, checked) {
        const key = checked ? "_trueValue" : "_falseValue";
        return key in el ? el[key] : checked;
      }
      var vModelDynamic = {
        created(el, binding, vnode) {
          callModelHook(el, binding, vnode, null, "created");
        },
        mounted(el, binding, vnode) {
          callModelHook(el, binding, vnode, null, "mounted");
        },
        beforeUpdate(el, binding, vnode, prevVNode) {
          callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
        },
        updated(el, binding, vnode, prevVNode) {
          callModelHook(el, binding, vnode, prevVNode, "updated");
        }
      };
      function resolveDynamicModel(tagName, type) {
        switch (tagName) {
          case "SELECT":
            return vModelSelect;
          case "TEXTAREA":
            return vModelText;
          default:
            switch (type) {
              case "checkbox":
                return vModelCheckbox;
              case "radio":
                return vModelRadio;
              default:
                return vModelText;
            }
        }
      }
      function callModelHook(el, binding, vnode, prevVNode, hook) {
        const modelToUse = resolveDynamicModel(
          el.tagName,
          vnode.props && vnode.props.type
        );
        const fn = modelToUse[hook];
        fn && fn(el, binding, vnode, prevVNode);
      }
      function initVModelForSSR() {
        vModelText.getSSRProps = ({ value }) => ({ value });
        vModelRadio.getSSRProps = ({ value }, vnode) => {
          if (vnode.props && shared.looseEqual(vnode.props.value, value)) {
            return { checked: true };
          }
        };
        vModelCheckbox.getSSRProps = ({ value }, vnode) => {
          if (shared.isArray(value)) {
            if (vnode.props && shared.looseIndexOf(value, vnode.props.value) > -1) {
              return { checked: true };
            }
          } else if (shared.isSet(value)) {
            if (vnode.props && value.has(vnode.props.value)) {
              return { checked: true };
            }
          } else if (value) {
            return { checked: true };
          }
        };
        vModelDynamic.getSSRProps = (binding, vnode) => {
          if (typeof vnode.type !== "string") {
            return;
          }
          const modelToUse = resolveDynamicModel(
            // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
            vnode.type.toUpperCase(),
            vnode.props && vnode.props.type
          );
          if (modelToUse.getSSRProps) {
            return modelToUse.getSSRProps(binding, vnode);
          }
        };
      }
      var systemModifiers = ["ctrl", "shift", "alt", "meta"];
      var modifierGuards = {
        stop: (e) => e.stopPropagation(),
        prevent: (e) => e.preventDefault(),
        self: (e) => e.target !== e.currentTarget,
        ctrl: (e) => !e.ctrlKey,
        shift: (e) => !e.shiftKey,
        alt: (e) => !e.altKey,
        meta: (e) => !e.metaKey,
        left: (e) => "button" in e && e.button !== 0,
        middle: (e) => "button" in e && e.button !== 1,
        right: (e) => "button" in e && e.button !== 2,
        exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
      };
      var withModifiers = (fn, modifiers) => {
        return (event, ...args) => {
          for (let i = 0; i < modifiers.length; i++) {
            const guard = modifierGuards[modifiers[i]];
            if (guard && guard(event, modifiers))
              return;
          }
          return fn(event, ...args);
        };
      };
      var keyNames = {
        esc: "escape",
        space: " ",
        up: "arrow-up",
        left: "arrow-left",
        right: "arrow-right",
        down: "arrow-down",
        delete: "backspace"
      };
      var withKeys = (fn, modifiers) => {
        return (event) => {
          if (!("key" in event)) {
            return;
          }
          const eventKey = shared.hyphenate(event.key);
          if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
            return fn(event);
          }
        };
      };
      var vShow = {
        beforeMount(el, { value }, { transition }) {
          el._vod = el.style.display === "none" ? "" : el.style.display;
          if (transition && value) {
            transition.beforeEnter(el);
          } else {
            setDisplay(el, value);
          }
        },
        mounted(el, { value }, { transition }) {
          if (transition && value) {
            transition.enter(el);
          }
        },
        updated(el, { value, oldValue }, { transition }) {
          if (!value === !oldValue)
            return;
          if (transition) {
            if (value) {
              transition.beforeEnter(el);
              setDisplay(el, true);
              transition.enter(el);
            } else {
              transition.leave(el, () => {
                setDisplay(el, false);
              });
            }
          } else {
            setDisplay(el, value);
          }
        },
        beforeUnmount(el, { value }) {
          setDisplay(el, value);
        }
      };
      function setDisplay(el, value) {
        el.style.display = value ? el._vod : "none";
      }
      function initVShowForSSR() {
        vShow.getSSRProps = ({ value }) => {
          if (!value) {
            return { style: { display: "none" } };
          }
        };
      }
      var rendererOptions = /* @__PURE__ */ shared.extend({ patchProp }, nodeOps);
      var renderer;
      var enabledHydration = false;
      function ensureRenderer() {
        return renderer || (renderer = runtimeCore.createRenderer(rendererOptions));
      }
      function ensureHydrationRenderer() {
        renderer = enabledHydration ? renderer : runtimeCore.createHydrationRenderer(rendererOptions);
        enabledHydration = true;
        return renderer;
      }
      var render = (...args) => {
        ensureRenderer().render(...args);
      };
      var hydrate = (...args) => {
        ensureHydrationRenderer().hydrate(...args);
      };
      var createApp2 = (...args) => {
        const app2 = ensureRenderer().createApp(...args);
        {
          injectNativeTagCheck(app2);
          injectCompilerOptionsCheck(app2);
        }
        const { mount } = app2;
        app2.mount = (containerOrSelector) => {
          const container = normalizeContainer(containerOrSelector);
          if (!container)
            return;
          const component = app2._component;
          if (!shared.isFunction(component) && !component.render && !component.template) {
            component.template = container.innerHTML;
          }
          container.innerHTML = "";
          const proxy = mount(container, false, container instanceof SVGElement);
          if (container instanceof Element) {
            container.removeAttribute("v-cloak");
            container.setAttribute("data-v-app", "");
          }
          return proxy;
        };
        return app2;
      };
      var createSSRApp = (...args) => {
        const app2 = ensureHydrationRenderer().createApp(...args);
        {
          injectNativeTagCheck(app2);
          injectCompilerOptionsCheck(app2);
        }
        const { mount } = app2;
        app2.mount = (containerOrSelector) => {
          const container = normalizeContainer(containerOrSelector);
          if (container) {
            return mount(container, true, container instanceof SVGElement);
          }
        };
        return app2;
      };
      function injectNativeTagCheck(app2) {
        Object.defineProperty(app2.config, "isNativeTag", {
          value: (tag) => shared.isHTMLTag(tag) || shared.isSVGTag(tag),
          writable: false
        });
      }
      function injectCompilerOptionsCheck(app2) {
        if (runtimeCore.isRuntimeOnly()) {
          const isCustomElement = app2.config.isCustomElement;
          Object.defineProperty(app2.config, "isCustomElement", {
            get() {
              return isCustomElement;
            },
            set() {
              runtimeCore.warn(
                `The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`
              );
            }
          });
          const compilerOptions = app2.config.compilerOptions;
          const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
          Object.defineProperty(app2.config, "compilerOptions", {
            get() {
              runtimeCore.warn(msg);
              return compilerOptions;
            },
            set() {
              runtimeCore.warn(msg);
            }
          });
        }
      }
      function normalizeContainer(container) {
        if (shared.isString(container)) {
          const res = document.querySelector(container);
          if (!res) {
            runtimeCore.warn(
              `Failed to mount app: mount target selector "${container}" returned null.`
            );
          }
          return res;
        }
        if (window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
          runtimeCore.warn(
            `mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`
          );
        }
        return container;
      }
      var ssrDirectiveInitialized = false;
      var initDirectivesForSSR = () => {
        if (!ssrDirectiveInitialized) {
          ssrDirectiveInitialized = true;
          initVModelForSSR();
          initVShowForSSR();
        }
      };
      exports.Transition = Transition;
      exports.TransitionGroup = TransitionGroup;
      exports.VueElement = VueElement;
      exports.createApp = createApp2;
      exports.createSSRApp = createSSRApp;
      exports.defineCustomElement = defineCustomElement;
      exports.defineSSRCustomElement = defineSSRCustomElement;
      exports.hydrate = hydrate;
      exports.initDirectivesForSSR = initDirectivesForSSR;
      exports.render = render;
      exports.useCssModule = useCssModule;
      exports.useCssVars = useCssVars;
      exports.vModelCheckbox = vModelCheckbox;
      exports.vModelDynamic = vModelDynamic;
      exports.vModelRadio = vModelRadio;
      exports.vModelSelect = vModelSelect;
      exports.vModelText = vModelText;
      exports.vShow = vShow;
      exports.withKeys = withKeys;
      exports.withModifiers = withModifiers;
      Object.keys(runtimeCore).forEach(function(k) {
        if (k !== "default" && !exports.hasOwnProperty(k))
          exports[k] = runtimeCore[k];
      });
    }
  });

  // node_modules/@vue/runtime-dom/index.js
  var require_runtime_dom = __commonJS({
    "node_modules/@vue/runtime-dom/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_runtime_dom_cjs();
      }
    }
  });

  // node_modules/vue/dist/vue.cjs.js
  var require_vue_cjs = __commonJS({
    "node_modules/vue/dist/vue.cjs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var compilerDom = require_compiler_dom();
      var runtimeDom = require_runtime_dom();
      var shared = require_shared();
      function _interopNamespaceDefault(e) {
        var n = /* @__PURE__ */ Object.create(null);
        if (e) {
          for (var k in e) {
            n[k] = e[k];
          }
        }
        n.default = e;
        return Object.freeze(n);
      }
      var runtimeDom__namespace = /* @__PURE__ */ _interopNamespaceDefault(runtimeDom);
      var compileCache = /* @__PURE__ */ Object.create(null);
      function compileToFunction(template, options) {
        if (!shared.isString(template)) {
          if (template.nodeType) {
            template = template.innerHTML;
          } else {
            runtimeDom.warn(`invalid template option: `, template);
            return shared.NOOP;
          }
        }
        const key = template;
        const cached = compileCache[key];
        if (cached) {
          return cached;
        }
        if (template[0] === "#") {
          const el = document.querySelector(template);
          if (!el) {
            runtimeDom.warn(`Template element not found or is empty: ${template}`);
          }
          template = el ? el.innerHTML : ``;
        }
        const opts = shared.extend(
          {
            hoistStatic: true,
            onError,
            onWarn: (e) => onError(e, true)
          },
          options
        );
        if (!opts.isCustomElement && typeof customElements !== "undefined") {
          opts.isCustomElement = (tag) => !!customElements.get(tag);
        }
        const { code } = compilerDom.compile(template, opts);
        function onError(err, asWarning = false) {
          const message = asWarning ? err.message : `Template compilation error: ${err.message}`;
          const codeFrame = err.loc && shared.generateCodeFrame(
            template,
            err.loc.start.offset,
            err.loc.end.offset
          );
          runtimeDom.warn(codeFrame ? `${message}
${codeFrame}` : message);
        }
        const render = new Function("Vue", code)(runtimeDom__namespace);
        render._rc = true;
        return compileCache[key] = render;
      }
      runtimeDom.registerRuntimeCompiler(compileToFunction);
      exports.compile = compileToFunction;
      Object.keys(runtimeDom).forEach(function(k) {
        if (k !== "default" && !exports.hasOwnProperty(k))
          exports[k] = runtimeDom[k];
      });
    }
  });

  // node_modules/vue/index.js
  var require_vue = __commonJS({
    "node_modules/vue/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_vue_cjs();
      }
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/math-error.js
  var require_math_error = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/math-error.js"(exports, module) {
      var isBrowser = new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`);
      var MathError = class extends Error {
        constructor(message) {
          if (isBrowser()) {
            super(message);
          } else {
            super("\n\n\x1B[31m" + message + "\n\x1B[0m");
          }
        }
      };
      module.exports = MathError;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/assert.js
  var require_assert = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/assert.js"(exports, module) {
      var MathError = require_math_error();
      module.exports = function(isTrue, message) {
        if (!isTrue)
          throw new MathError(message);
      };
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/is-array.js
  var require_is_array = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/is-array.js"(exports, module) {
      function isArray(obj) {
        try {
          return obj instanceof Array || typeof obj.constructor !== "undefined" && obj.constructor.name === "Array";
        } catch (e) {
          return false;
        }
      }
      module.exports = isArray;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/is-dataframe.js
  var require_is_dataframe = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/is-dataframe.js"(exports, module) {
      function isDataFrame(x) {
        try {
          return !!x._symbol && x._symbol === Symbol.for("@jrc03c/js-math-tools/dataframe");
        } catch (e) {
          return false;
        }
      }
      module.exports = isDataFrame;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/is-function.js
  var require_is_function = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/is-function.js"(exports, module) {
      function isFunction(fn) {
        return typeof fn === "function";
      }
      module.exports = isFunction;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/is-number.js
  var require_is_number = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/is-number.js"(exports, module) {
      function isNumber(x) {
        return typeof x === "number" && !isNaN(x);
      }
      module.exports = isNumber;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/is-undefined.js
  var require_is_undefined = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/is-undefined.js"(exports, module) {
      function isUndefined(x) {
        return x === null || typeof x === "undefined";
      }
      module.exports = isUndefined;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/is-object.js
  var require_is_object = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/is-object.js"(exports, module) {
      var isArray = require_is_array();
      var isUndefined = require_is_undefined();
      function isObject(x) {
        return typeof x === "object" && !isUndefined(x) && !isArray(x);
      }
      module.exports = isObject;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/is-series.js
  var require_is_series = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/is-series.js"(exports, module) {
      function isSeries(x) {
        try {
          return !!x._symbol && x._symbol === Symbol.for("@jrc03c/js-math-tools/series");
        } catch (e) {
          return false;
        }
      }
      module.exports = isSeries;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/index-of.js
  var require_index_of = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/index-of.js"(exports, module) {
      var assert = require_assert();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isFunction = require_is_function();
      var isNumber = require_is_number();
      var isObject = require_is_object();
      var isSeries = require_is_series();
      function indexOf(x, fn) {
        if (isDataFrame(x)) {
          const index = indexOf(x.values, fn);
          if (index.length > 0 && isNumber(index[0]) && index[0] >= 0 && index[0] < x.index.length) {
            index[0] = x.index[index[0]];
          }
          if (index.length > 1 && isNumber(index[1]) && index[1] >= 0 && index[1] < x.columns.length) {
            index[1] = x.columns[index[1]];
          }
          return index;
        }
        if (isSeries(x)) {
          const index = indexOf(x.values, fn);
          if (index.length > 0 && isNumber(index[0]) && index[0] >= 0 && index[0] < x.index.length) {
            index[0] = x.index[index[0]];
          }
          return index;
        }
        assert(
          isObject(x) || isArray(x),
          "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"
        );
        if (!isFunction(fn)) {
          const value = fn;
          fn = (v) => v === value;
        }
        function helper(x2, fn2, checked) {
          checked = checked || [];
          if (checked.indexOf(x2) > -1) {
            return null;
          }
          if (isObject(x2)) {
            checked.push(x2);
            const keys = Object.keys(x2);
            for (let i = 0; i < keys.length; i++) {
              const key = keys[i];
              const value = x2[key];
              if (fn2(value)) {
                return [key];
              }
              const results = helper(value, fn2, checked);
              if (results && results.length > 0) {
                return [key].concat(results);
              }
            }
          } else if (isArray(x2)) {
            checked.push(x2);
            for (let i = 0; i < x2.length; i++) {
              const value = x2[i];
              if (fn2(value)) {
                return [i];
              }
              const results = helper(value, fn2, checked);
              if (results && results.length > 0) {
                return [i].concat(results);
              }
            }
          } else {
            if (fn2(x2)) {
              return [];
            }
          }
          return null;
        }
        function safeFn(v) {
          try {
            return fn(v);
          } catch (e) {
            return false;
          }
        }
        const paths = helper(x, safeFn);
        if (paths && paths.length > 0) {
          return paths;
        } else {
          return null;
        }
      }
      module.exports = indexOf;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/copy.js
  var require_copy = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/copy.js"(exports, module) {
      var indexOf = require_index_of();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isSeries = require_is_series();
      function copy(x) {
        try {
          const out = structuredClone(x);
          return out;
        } catch (e) {
          if (typeof x === "object") {
            if (x === null) {
              return null;
            }
            if (isArray(x)) {
              return x.map((v) => copy(v));
            }
            if (isSeries(x)) {
              const out2 = x.copy();
              out2.values = copy(out2.values);
              return out2;
            }
            if (isDataFrame(x)) {
              const out2 = x.copy();
              out2.values = copy(x.values);
              return out2;
            }
            x = decycle(x);
            const out = {};
            Object.keys(x).forEach((key) => {
              out[key] = copy(x[key]);
            });
            return out;
          } else {
            return x;
          }
        }
      }
      function decycle(x) {
        function helper(x2, checked, currentPath) {
          checked = checked || [];
          currentPath = currentPath || "";
          if (checked.indexOf(x2) > -1) {
            const parts = currentPath.split("/").slice(currentPath.startsWith("/") ? 1 : 0);
            const isANestedCopy = parts.some((v, i) => {
              const subParts = parts.slice(0, parts.length - i - 1);
              let temp = orig;
              subParts.forEach((part) => {
                temp = temp[part];
              });
              return temp === x2;
            });
            if (isANestedCopy) {
              const pathToCopy = orig === x2 ? "/" : "/" + indexOf(orig, x2).join("/");
              return `<reference to "${pathToCopy}">`;
            }
          }
          if (typeof x2 === "object") {
            if (x2 === null)
              return null;
            checked.push(x2);
            if (isArray(x2)) {
              return x2.map((v, i) => helper(v, checked, currentPath + "/" + i));
            } else {
              Object.keys(x2).forEach((key) => {
                x2[key] = helper(x2[key], checked, currentPath + "/" + key);
              });
              return x2;
            }
          } else {
            return x2;
          }
        }
        const orig = copy(x);
        let out = helper(orig);
        if (isDataFrame(x)) {
          const temp = x.copy();
          temp._values = out.values;
          temp._columns = out.columns;
          temp._index = out.index;
          out = temp;
        }
        if (isSeries(x)) {
          const temp = x.copy();
          temp.name = out.name;
          temp._values = out.values;
          temp._index = out.index;
          out = temp;
        }
        return out;
      }
      module.exports = { copy, decycle };
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/flatten.js
  var require_flatten = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/flatten.js"(exports, module) {
      var { copy } = require_copy();
      var assert = require_assert();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isSeries = require_is_series();
      function flatten(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return flatten(arr.values);
        }
        assert(
          isArray(arr),
          "The `flatten` function only works on arrays, Series, and DataFrames!"
        );
        function helper(arr2) {
          let out = [];
          copy(arr2).forEach((child) => {
            if (isArray(child)) {
              out = out.concat(helper(child));
            } else {
              out.push(child);
            }
          });
          return out;
        }
        return helper(arr);
      }
      module.exports = flatten;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/is-equal.js
  var require_is_equal = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/is-equal.js"(exports, module) {
      var { decycle } = require_copy();
      function isEqual(a, b) {
        function helper(a2, b2) {
          const aType = typeof a2;
          const bType = typeof b2;
          if (aType !== bType)
            return false;
          if (aType === "undefined")
            return true;
          if (aType === "boolean")
            return a2 === b2;
          if (aType === "symbol")
            return a2 === b2;
          if (aType === "number" || aType === "bigint") {
            if (a2.toString() === "NaN" && b2.toString() === "NaN") {
              return true;
            }
            return a2 === b2;
          }
          if (aType === "string")
            return a2 === b2;
          if (aType === "function")
            return a2 === b2;
          if (aType === "object") {
            if (a2 === null || b2 === null) {
              return a2 === null && b2 === null;
            } else {
              const aKeys = Object.keys(a2);
              const bKeys = Object.keys(b2);
              if (aKeys.length !== bKeys.length)
                return false;
              for (let i = 0; i < aKeys.length; i++) {
                const key = aKeys[i];
                if (!helper(a2[key], b2[key]))
                  return false;
              }
              return true;
            }
          }
        }
        try {
          if (a instanceof Date && b instanceof Date) {
            return a.getTime() === b.getTime();
          }
          return helper(a, b);
        } catch (e) {
          return helper(decycle(a), decycle(b));
        }
      }
      module.exports = isEqual;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/set.js
  var require_set = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/set.js"(exports, module) {
      var assert = require_assert();
      var flatten = require_flatten();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isFunction = require_is_function();
      var isSeries = require_is_series();
      var isUndefined = require_is_undefined();
      function makeKey(n) {
        const alpha = "abcdefg1234567890";
        let out = "";
        while (out.length < n)
          out += alpha[parseInt(Math.random() * alpha.length)];
        return out;
      }
      var NULL_KEY = makeKey(256);
      var UNDEFINED_KEY = makeKey(256);
      var INFINITY_KEY = makeKey(256);
      var MINUS_INFINITY_KEY = makeKey(256);
      var SYMBOL_KEY = makeKey(256);
      function set(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return set(arr.values);
        }
        assert(
          isArray(arr),
          "The `set` function only works on arrays, Series, and DataFrames!"
        );
        const out = [];
        const temp = {};
        flatten(arr).forEach((item) => {
          const key = typeof item === "object" && item === null ? NULL_KEY : isUndefined(item) ? UNDEFINED_KEY : isFunction(item) ? item.toString() : typeof item === "symbol" ? item.toString() + " - " + SYMBOL_KEY : item === Infinity ? INFINITY_KEY : item === -Infinity ? MINUS_INFINITY_KEY : isDataFrame(item) ? item.toJSONString() : isSeries(item) ? JSON.stringify(item.toObject()) : JSON.stringify(item);
          if (!temp[key])
            out.push(item);
          temp[key] = true;
        });
        return out;
      }
      module.exports = set;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/count.js
  var require_count = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/count.js"(exports, module) {
      var assert = require_assert();
      var flatten = require_flatten();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isEqual = require_is_equal();
      var isFunction = require_is_function();
      var isSeries = require_is_series();
      var set = require_set();
      function count(arr, matcher) {
        if (isDataFrame(arr) || isSeries(arr)) {
          if (arguments.length > 1) {
            return count(arr.values, matcher);
          } else {
            return count(arr.values, arr.values);
          }
        }
        assert(
          isArray(arr),
          "The first argument to the `count` function must be an array, Series, or DataFrame!"
        );
        if (isFunction(matcher)) {
          return flatten(arr).filter((value) => matcher(value)).length;
        } else if (isArray(matcher)) {
          const temp = flatten(arr);
          return set(matcher).map((value) => {
            return {
              value,
              count: temp.filter((v) => isEqual(v, value)).length
            };
          });
        } else if (arguments.length > 1) {
          return flatten(arr).filter((other) => isEqual(other, matcher)).length;
        } else {
          return count(arr, arr);
        }
      }
      module.exports = count;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/is-jagged.js
  var require_is_jagged = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/is-jagged.js"(exports, module) {
      var assert = require_assert();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isSeries = require_is_series();
      function isJagged(x) {
        if (isDataFrame(x) || isSeries(x)) {
          return isJagged(x.values);
        }
        assert(
          isArray(x),
          "The `isJagged` function only works on arrays, Series, and DataFrames!"
        );
        let childArrayCount = 0;
        let firstChildArrayLength = null;
        for (let i = 0; i < x.length; i++) {
          if (isArray(x[i])) {
            childArrayCount++;
            if (isJagged(x[i])) {
              return true;
            }
            if (firstChildArrayLength === null) {
              firstChildArrayLength = x[i].length;
            } else if (x[i].length !== firstChildArrayLength) {
              return true;
            }
          }
        }
        if (childArrayCount > 0 && childArrayCount < x.length) {
          return true;
        }
        return false;
      }
      module.exports = isJagged;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/is-nested.js
  var require_is_nested = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/is-nested.js"(exports, module) {
      var assert = require_assert();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isSeries = require_is_series();
      function isNested(x) {
        if (isDataFrame(x) || isSeries(x)) {
          return isNested(x.values);
        }
        assert(
          isArray(x),
          "The `isNested` function only works on arrays, Series, and DataFrames!"
        );
        for (let i = 0; i < x.length; i++) {
          if (isArray(x[i])) {
            return true;
          }
        }
        return false;
      }
      module.exports = isNested;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/ndarray.js
  var require_ndarray = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/ndarray.js"(exports, module) {
      var assert = require_assert();
      var isArray = require_is_array();
      var isNested = require_is_nested();
      var isNumber = require_is_number();
      var isUndefined = require_is_undefined();
      var error = "You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";
      function ndarray(shape) {
        assert(!isUndefined(shape), error);
        if (!isArray(shape))
          shape = [shape];
        assert(!isNested(shape), error);
        assert(shape.length > 0, error);
        const s = shape[0];
        assert(isNumber(s), error);
        assert(parseInt(s) === s, error);
        assert(s >= 0, error);
        assert(
          s !== Infinity,
          "We can't create an array containing an infinite number of values!"
        );
        if (shape.length === 1) {
          const out = [];
          for (let i = 0; i < s; i++)
            out.push(void 0);
          return out;
        } else {
          const out = [];
          for (let i = 0; i < s; i++) {
            out.push(ndarray(shape.slice(1)));
          }
          return out;
        }
      }
      module.exports = ndarray;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/reverse.js
  var require_reverse = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/reverse.js"(exports, module) {
      var assert = require_assert();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isSeries = require_is_series();
      function reverse(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          const out2 = arr.copy();
          out2.values = reverse(out2.values);
          out2.index = reverse(out2.index);
          return out2;
        }
        assert(
          isArray(arr),
          "The `reverse` function only works on arrays, Series, and DataFrames!"
        );
        const out = [];
        for (let i = arr.length - 1; i >= 0; i--)
          out.push(arr[i]);
        return out;
      }
      module.exports = reverse;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/range.js
  var require_range = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/range.js"(exports, module) {
      var assert = require_assert();
      var isNumber = require_is_number();
      var isUndefined = require_is_undefined();
      var reverse = require_reverse();
      function range(a, b, step = 1) {
        assert(
          !isUndefined(a) && !isUndefined(b) && !isUndefined(step),
          "You must pass two numbers and optionally a step value to the `range` function!"
        );
        assert(
          isNumber(a) && isNumber(b) && isNumber(step),
          "You must pass two numbers and optionally a step value to the `range` function!"
        );
        assert(
          step > 0,
          "The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)"
        );
        let shouldReverse = false;
        if (a > b) {
          shouldReverse = true;
          const buffer = a;
          a = b + step;
          b = buffer + step;
        }
        let out = [];
        for (let i = a; i < b; i += step)
          out.push(i);
        if (shouldReverse)
          out = reverse(out);
        return out;
      }
      module.exports = range;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/shape.js
  var require_shape = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/shape.js"(exports, module) {
      var assert = require_assert();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isEqual = require_is_equal();
      var isSeries = require_is_series();
      var isUndefined = require_is_undefined();
      function helper(x) {
        if (!isArray(x)) {
          return void 0;
        }
        const out = [x.length];
        let childArrayCount = 0;
        const childShapes = x.map((v) => {
          const s = helper(v);
          if (!isUndefined(s)) {
            childArrayCount++;
            if (s.length === 1) {
              return s[0];
            } else {
              return s;
            }
          } else {
            return s;
          }
        });
        if (childArrayCount > 0) {
          if (childArrayCount === x.length) {
            const childShapesAreIdentical = childShapes.slice(0, -1).every((s, i) => {
              return isEqual(s, childShapes[i + 1]);
            });
            if (childShapesAreIdentical) {
              return out.concat(childShapes[0]);
            } else {
              out.push(childShapes);
              return out;
            }
          } else {
            out.push(childShapes);
            return out;
          }
        } else {
          return out;
        }
      }
      function shape(x) {
        if (isDataFrame(x) || isSeries(x)) {
          return shape(x.values);
        }
        assert(
          isArray(x),
          "The `shape` function only works on arrays, Series, and DataFrames!"
        );
        return helper(x);
      }
      module.exports = shape;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-append.js
  var require_df_append = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-append.js"(exports, module) {
      var assert = require_assert();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isJagged = require_is_jagged();
      var isSeries = require_is_series();
      var isUndefined = require_is_undefined();
      var MathError = require_math_error();
      var ndarray = require_ndarray();
      var range = require_range();
      var set = require_set();
      var shape = require_shape();
      function dfAppend(df, x, axis) {
        if (isUndefined(axis)) {
          axis = 0;
        }
        assert(
          axis === 0 || axis === 1 || axis === "vertical" || axis === "horizontal",
          'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'
        );
        if (isArray(x)) {
          assert(
            !isJagged(x),
            "The array of data you're trying to append to this DataFrame is jagged!"
          );
          const xShape = shape(x);
          if (xShape.length === 1) {
            if (axis === 0) {
              const out = df.copy();
              out._values.push(x);
              const maxRowLength = Math.max(df.shape[1], xShape[0]);
              out._values.forEach((row) => {
                while (row.length < maxRowLength) {
                  row.push(void 0);
                }
              });
              while (out._index.length < out._values.length) {
                out._index.push("row" + out._index.length);
              }
              while (out._columns.length < maxRowLength) {
                out._columns.push("col" + out._columns.length);
              }
              return out;
            } else {
              const maxColLength = Math.max(df.shape[0], xShape[0]);
              const out = df.copy();
              range(0, maxColLength).forEach((i) => {
                if (i >= out._values.length) {
                  out._values.push(ndarray(df.shape[1]));
                }
                out._values[i].push(x[i]);
              });
              while (out._index.length < out._values.length) {
                out._index.push("row" + out._index.length);
              }
              while (out._columns.length < out._values[0].length) {
                out._columns.push("col" + out._columns.length);
              }
              return out;
            }
          } else if (xShape.length === 2) {
            if (axis === 0) {
              const maxRowLength = Math.max(
                ...x.map((row) => row.length).concat([df.shape[1]])
              );
              const out = df.copy();
              out._values = out._values.concat(x).map((row) => {
                while (row.length < maxRowLength) {
                  row.push(void 0);
                }
                return row;
              });
              while (out._index.length < out._values.length) {
                out._index.push("row" + out._index.length);
              }
              while (out._columns.length < maxRowLength) {
                out._columns.push("col" + out._columns.length);
              }
              return out;
            } else {
              const maxRowLength = Math.max(...x.map((row) => row.length)) + df.shape[1];
              const maxColLength = Math.max(df.shape[0], xShape[0]);
              const out = df.copy();
              range(0, maxColLength).forEach((i) => {
                if (i >= out._values.length) {
                  out._values.push(ndarray(df.shape[1]));
                }
                out._values[i] = out._values[i].concat(x[i]);
                while (out._values[i].length < maxRowLength) {
                  out._values[i].push(void 0);
                }
              });
              while (out._index.length < out._values.length) {
                out._index.push("row" + out._index.length);
              }
              while (out._columns.length < maxRowLength) {
                out._columns.push("col" + out._columns.length);
              }
              return out;
            }
          } else {
            throw new MathError(
              "Only 1- and 2-dimensional arrays can be appended to a DataFrame!"
            );
          }
        } else if (isSeries(x)) {
          const out = dfAppend(df, x.values, axis);
          if (axis === 0) {
            out.index[out.index.length - 1] = out.index.indexOf(x.name) > -1 ? x.name + " (2)" : x.name;
          } else {
            out.columns[out.columns.length - 1] = out.columns.indexOf(x.name) > -1 ? x.name + " (2)" : x.name;
          }
          return out;
        } else if (isDataFrame(x)) {
          if (axis === 0) {
            const out = df.copy();
            const maxRowLength = set(out._columns.concat(x._columns)).length;
            out._values.forEach((row) => {
              while (row.length < maxRowLength) {
                row.push(void 0);
              }
            });
            x.apply((row) => {
              const rowCopy = row.copy();
              const temp = [];
              out._columns.forEach((col) => {
                const index = rowCopy._index.indexOf(col);
                if (index > -1) {
                  temp.push(rowCopy._values[index]);
                  rowCopy._values.splice(index, 1);
                  rowCopy._index.splice(index, 1);
                } else {
                  temp.push(void 0);
                }
              });
              out._values.push(temp.concat(rowCopy._values));
            }, 1);
            out._columns = out._columns.concat(
              x._columns.filter((c) => out._columns.indexOf(c) < 0)
            );
            while (out._index.length < out._values.length) {
              const newRowName = "row" + out._index.length;
              out._index.push(
                newRowName + (df._index.indexOf(newRowName) > -1 ? " (2)" : "")
              );
            }
            return out;
          } else {
            const out = df.copy();
            out._index.forEach((rowName, i) => {
              const xIndex = x._index.indexOf(rowName);
              if (xIndex > -1) {
                out._values[i] = out._values[i].concat(x._values[xIndex]);
              } else {
                out._values[i] = out._values[i].concat(ndarray(x.shape[1]));
              }
            });
            x._index.forEach((rowName, i) => {
              const outIndex = out._index.indexOf(rowName);
              if (outIndex < 0) {
                out._index.push(rowName);
                out._values.push(ndarray(out._columns.length).concat(x._values[i]));
              }
            });
            out._columns = out._columns.concat(
              x._columns.map((c) => c + (out._columns.indexOf(c) > -1 ? " (2)" : ""))
            );
            return out;
          }
        } else {
          throw new MathError(
            "Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!"
          );
        }
      }
      module.exports = dfAppend;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-apply.js
  var require_df_apply = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-apply.js"(exports, module) {
      var assert = require_assert();
      var isArray = require_is_array();
      var isFunction = require_is_function();
      var isUndefined = require_is_undefined();
      function dfApply(DataFrame, Series, df, fn, axis) {
        axis = axis || 0;
        assert(
          isFunction(fn),
          "The first parameter to the `apply` method must be a function."
        );
        assert(
          axis === 0 || axis === 1,
          "The second parameter to the `apply` method (the `axis`) must be 0 or 1."
        );
        if (axis === 0) {
          const temp = {};
          let shouldReturnADataFrame;
          df.columns.forEach((colName, i) => {
            const series = new Series(df.values.map((row) => row[i]));
            series.name = colName;
            series.index = df.index;
            const value = fn(series, i, df);
            if (value instanceof Series) {
              temp[colName] = value.values;
            } else {
              temp[colName] = value;
            }
            if (isUndefined(shouldReturnADataFrame)) {
              shouldReturnADataFrame = value instanceof Series || isArray(value);
            }
          });
          if (shouldReturnADataFrame) {
            const out = new DataFrame(temp);
            out.index = df.index;
            return out;
          } else {
            const out = new Series(df.columns.map((colName) => temp[colName]));
            out.index = df.columns;
            return out;
          }
        } else if (axis === 1) {
          let shouldReturnADataFrame;
          const temp = df.values.map((row, i) => {
            const series = new Series(row);
            series.name = df.index[i];
            series.index = df.columns;
            const value = fn(series, i, df);
            if (isUndefined(shouldReturnADataFrame)) {
              shouldReturnADataFrame = value instanceof Series || isArray(value);
            }
            if (value instanceof Series) {
              return value.values;
            } else {
              return value;
            }
          });
          if (shouldReturnADataFrame) {
            const out = new DataFrame(temp);
            out.index = df.index;
            out.columns = df.columns;
            return out;
          } else {
            const out = new Series(temp);
            out.index = df.index;
            return out;
          }
        }
      }
      module.exports = dfApply;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/is-string.js
  var require_is_string = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/is-string.js"(exports, module) {
      function isString(s) {
        return typeof s === "string";
      }
      module.exports = isString;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-assign.js
  var require_df_assign = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-assign.js"(exports, module) {
      var assert = require_assert();
      var isArray = require_is_array();
      var isJagged = require_is_jagged();
      var isObject = require_is_object();
      var isString = require_is_string();
      var isUndefined = require_is_undefined();
      var MathError = require_math_error();
      var shape = require_shape();
      function dfAssign(DataFrame, Series, df, p1, p2) {
        const isDataFrame = (x) => x instanceof DataFrame;
        const isSeries = (x) => x instanceof Series;
        if (!isUndefined(p2)) {
          assert(
            isString(p1),
            "If passing two arguments into the `assign` method, then the first argument must be a string name!"
          );
          assert(
            isArray(p2) && !isJagged(p2) && shape(p2).length === 1,
            "If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!"
          );
          const out = df.append(p2, 1);
          out.columns[out.columns.length - 1] = p1;
          return out;
        } else {
          if (isDataFrame(p1)) {
            return df.append(p1, 1);
          } else if (isSeries(p1)) {
            return df.append(p1, 1);
          } else if (isObject(p1)) {
            const maxColumnLength = Math.max(
              ...Object.keys(p1).map((key) => p1[key].length)
            );
            Object.keys(p1).forEach((key) => {
              while (p1[key].length < maxColumnLength) {
                p1[key].push(void 0);
              }
            });
            return df.append(new DataFrame(p1), 1);
          } else {
            throw new MathError(
              "You must pass a DataFrame, Series, or object into the `assign` method!"
            );
          }
        }
      }
      module.exports = dfAssign;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-copy.js
  var require_df_copy = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-copy.js"(exports, module) {
      var { copy } = require_copy();
      function dfCopy(DataFrame, df) {
        if (df.isEmpty)
          return new DataFrame();
        const out = new DataFrame(copy(df.values));
        out.columns = df.columns.slice();
        out.index = df.index.slice();
        return out;
      }
      module.exports = dfCopy;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-drop.js
  var require_df_drop = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-drop.js"(exports, module) {
      var assert = require_assert();
      var isArray = require_is_array();
      var isNumber = require_is_number();
      var isString = require_is_string();
      var isUndefined = require_is_undefined();
      var shape = require_shape();
      function dfDrop(DataFrame, Series, df, rows, cols) {
        if (isUndefined(rows))
          rows = [];
        if (isUndefined(cols))
          cols = [];
        if (isString(rows) || isNumber(rows))
          rows = [rows];
        if (isString(cols) || isNumber(cols))
          cols = [cols];
        assert(
          isArray(rows),
          "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."
        );
        assert(
          isArray(cols),
          "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."
        );
        assert(
          shape(rows).length === 1,
          "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."
        );
        assert(
          shape(cols).length === 1,
          "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."
        );
        let outIndex, outColumns;
        df.index.forEach((row, i) => {
          if (rows.indexOf(row) < 0 && rows.indexOf(i) < 0) {
            if (!outIndex)
              outIndex = [];
            outIndex.push(row);
          }
        });
        df.columns.forEach((col, i) => {
          if (cols.indexOf(col) < 0 && cols.indexOf(i) < 0) {
            if (!outColumns)
              outColumns = [];
            outColumns.push(col);
          }
        });
        let out = df.get(outIndex, outColumns);
        if (out instanceof Series) {
          let temp = new DataFrame();
          temp = temp.assign(out);
          if (df.index.indexOf(out.name) > -1)
            temp = temp.transpose();
          out = temp;
        }
        return out;
      }
      module.exports = dfDrop;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/helpers/is-whole-number.js
  var require_is_whole_number = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/helpers/is-whole-number.js"(exports, module) {
      var isNumber = require_is_number();
      function isInteger(x) {
        return isNumber(x) && parseInt(x) === x;
      }
      function isWholeNumber(x) {
        return isInteger(x) && x >= 0;
      }
      module.exports = isWholeNumber;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-drop-missing.js
  var require_df_drop_missing = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-drop-missing.js"(exports, module) {
      var assert = require_assert();
      var isString = require_is_string();
      var isUndefined = require_is_undefined();
      var isWholeNumber = require_is_whole_number();
      var shape = require_shape();
      function dfDropMissing(DataFrame, Series, df, axis, condition, threshold) {
        axis = axis || 0;
        assert(
          axis === 0 || axis === 1,
          "The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."
        );
        threshold = threshold || 0;
        assert(
          isWholeNumber(threshold),
          "The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."
        );
        condition = threshold > 0 ? "none" : condition || "any";
        assert(
          condition === "any" || condition === "all" || condition === "none",
          "The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped)."
        );
        function helper(values) {
          if (threshold > 0) {
            let count = 0;
            for (let i = 0; i < values.length; i++) {
              const value = values[i];
              if (isUndefined(value))
                count++;
              if (count >= threshold)
                return [];
            }
          } else if (condition === "any") {
            for (let i = 0; i < values.length; i++) {
              const value = values[i];
              if (isUndefined(value))
                return [];
            }
          } else if (condition === "all") {
            for (let i = 0; i < values.length; i++) {
              const value = values[i];
              if (!isUndefined(value))
                return values;
            }
            return [];
          }
          return values;
        }
        let out = df.copy();
        const tempID = Math.random().toString();
        if (axis === 0) {
          out = out.assign(tempID, out.index);
          const newValues = out.values.map(helper).filter((row) => row.length > 0);
          if (shape(newValues).length < 2)
            return new DataFrame();
          out.values = newValues;
          let newIndex = out.get(null, tempID);
          if (isUndefined(newIndex))
            return new DataFrame();
          if (isString(newIndex))
            newIndex = [newIndex];
          if (newIndex instanceof Series)
            newIndex = newIndex.values;
          out.index = newIndex;
          out = out.drop(null, tempID);
        } else if (axis === 1) {
          const temp = {};
          out.columns.forEach((colName, i) => {
            const values = out.values.map((row) => row[i]);
            const newValues = helper(values);
            if (newValues.length > 0) {
              temp[colName] = newValues;
            }
          });
          if (Object.keys(temp).length === 0) {
            return new DataFrame();
          }
          const newOut = new DataFrame(temp);
          newOut.index = out.index;
          return newOut;
        }
        return out;
      }
      module.exports = dfDropMissing;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/drop-nan.js
  var require_drop_nan = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/drop-nan.js"(exports, module) {
      var assert = require_assert();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isNumber = require_is_number();
      var isSeries = require_is_series();
      function dropNaN(x) {
        if (isDataFrame(x) || isSeries(x)) {
          return x.dropNaN(...Object.values(arguments).slice(1));
        }
        assert(
          isArray(x),
          "The `dropNaN` function only works on arrays, Series, and DataFrames!"
        );
        const out = [];
        x.forEach((v) => {
          try {
            return out.push(dropNaN(v));
          } catch (e) {
            if (isNumber(v)) {
              return out.push(v);
            }
          }
        });
        return out;
      }
      module.exports = dropNaN;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-drop-nan.js
  var require_df_drop_nan = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-drop-nan.js"(exports, module) {
      var assert = require_assert();
      var dropNaN = require_drop_nan();
      var isWholeNumber = require_is_whole_number();
      function dfDropNaN(DataFrame, df, axis, condition, threshold) {
        axis = axis || 0;
        assert(
          axis === 0 || axis === 1,
          "The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."
        );
        threshold = threshold || 0;
        assert(
          isWholeNumber(threshold),
          "The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."
        );
        condition = threshold > 0 ? "none" : condition || "any";
        assert(
          condition === "any" || condition === "all" || condition === "none",
          "The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped)."
        );
        function helper(values) {
          const numericalValues = dropNaN(values);
          if (threshold > 0)
            return values.length - numericalValues.length < threshold;
          if (condition === "any")
            return numericalValues.length === values.length;
          if (condition === "all")
            return numericalValues.length > 0;
          return true;
        }
        const out = df.copy();
        if (axis === 0) {
          const rowsToKeep = out.index.filter((row) => {
            const values = out.get(row, null).values;
            return helper(values);
          });
          if (rowsToKeep.length > 0)
            return out.get(rowsToKeep, null);
          else
            return new DataFrame();
        } else if (axis === 1) {
          const colsToKeep = out.columns.filter((col) => {
            const values = out.get(null, col).values;
            return helper(values);
          });
          if (colsToKeep.length > 0)
            return out.get(null, colsToKeep);
          else
            return new DataFrame();
        }
        return out;
      }
      module.exports = dfDropNaN;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-filter.js
  var require_df_filter = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-filter.js"(exports, module) {
      var assert = require_assert();
      var flatten = require_flatten();
      var isFunction = require_is_function();
      var isUndefined = require_is_undefined();
      function arrayToObject(x) {
        const out = {};
        flatten(x).forEach((value, i) => {
          out[value] = i;
        });
        return out;
      }
      function undoArrayToObject(obj) {
        return Object.keys(obj).sort((a, b) => obj[a] - obj[b]);
      }
      function dfFilter(DataFrame, Series, df, fn, axis) {
        assert(
          isFunction(fn),
          "The `filter` method takes a single parameter: a function that is used to filter the values."
        );
        if (isUndefined(axis))
          axis = 0;
        assert(
          axis === 0 || axis === 1,
          "The `axis` parameter to the `filter` method must be 0 or 1."
        );
        let out = df.copy();
        if (out.isEmpty)
          return out;
        const index = arrayToObject(out.index);
        const columns = arrayToObject(out.columns);
        if (axis === 0) {
          const newValues = out.values.filter((row, i) => {
            const series = new Series(row);
            series.name = df.index[i];
            series.index = df.columns;
            const shouldKeep = fn(series, i, df);
            if (!shouldKeep)
              delete index[out.index[i]];
            return shouldKeep;
          });
          if (flatten(newValues).length === 0) {
            return new DataFrame();
          }
          if (newValues.length === 1) {
            const temp = new Series(flatten(newValues));
            temp.name = undoArrayToObject(index)[0];
            temp.index = undoArrayToObject(columns);
            return temp;
          }
          out.values = newValues;
          out.index = undoArrayToObject(index);
        } else if (axis === 1) {
          out = out.transpose();
          const newValues = out.values.filter((row, i) => {
            const series = new Series(row);
            series.name = df.columns[i];
            series.index = df.index;
            const shouldKeep = fn(series, i, df);
            if (!shouldKeep)
              delete columns[out.index[i]];
            return shouldKeep;
          });
          if (flatten(newValues).length === 0) {
            return new DataFrame();
          }
          if (newValues.length === 1) {
            const temp = new Series(flatten(newValues));
            temp.name = undoArrayToObject(columns)[0];
            temp.index = undoArrayToObject(index);
            return temp;
          }
          out.values = newValues;
          out.index = undoArrayToObject(columns);
          out = out.transpose();
        }
        return out;
      }
      module.exports = dfFilter;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-get.js
  var require_df_get = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-get.js"(exports, module) {
      var assert = require_assert();
      var isNumber = require_is_number();
      var isString = require_is_string();
      var isUndefined = require_is_undefined();
      var set = require_set();
      function dfGet(df, rows, cols) {
        if (isString(rows) || isNumber(rows))
          rows = [rows];
        if (isString(cols) || isNumber(cols))
          cols = [cols];
        const types = set((rows || []).concat(cols || []).map((v) => typeof v));
        assert(
          types.length <= 2,
          "Only whole numbers and/or strings are allowed in `get` arrays!"
        );
        if (types.length === 1) {
          assert(
            types[0] === "string" || types[0] === "number",
            "Only whole numbers and/or strings are allowed in `get` arrays!"
          );
        }
        if (types.length === 2) {
          assert(
            types.indexOf("string") > -1,
            "Only whole numbers and/or strings are allowed in `get` arrays!"
          );
          assert(
            types.indexOf("number") > -1,
            "Only whole numbers and/or strings are allowed in `get` arrays!"
          );
        }
        if (!isUndefined(rows)) {
          rows = rows.map((r) => {
            if (isString(r)) {
              assert(df.index.indexOf(r) > -1, `Row "${r}" does not exist!`);
              return r;
            }
            if (isNumber(r)) {
              assert(r >= 0, `Index ${r} is out of bounds!`);
              assert(parseInt(r) === r, `Row numbers must be integers!`);
              assert(r < df.index.length, `Index ${r} is out of bounds!`);
              return df.index[r];
            }
          });
        }
        if (!isUndefined(cols)) {
          cols = cols.map((c) => {
            if (isString(c)) {
              assert(df.columns.indexOf(c) > -1, `Column "${c}" does not exist!`);
              return c;
            }
            if (isNumber(c)) {
              assert(c >= 0, `Column ${c} is out of bounds!`);
              assert(parseInt(c) === c, `Column numbers must be integers!`);
              assert(c < df.columns.length, `Column ${c} is out of bounds!`);
              return df.columns[c];
            }
          });
        }
        return df.getSubsetByNames(rows, cols);
      }
      module.exports = dfGet;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/sort.js
  var require_sort = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/sort.js"(exports, module) {
      var assert = require_assert();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isFunction = require_is_function();
      var isSeries = require_is_series();
      var isUndefined = require_is_undefined();
      function alphaSort(a, b) {
        try {
          if (a < b)
            return -1;
          if (a > b)
            return 1;
          return 0;
        } catch (e) {
          a = typeof a === "object" && a !== null ? JSON.stringify(a) : a.toString();
          b = typeof b === "object" && b !== null ? JSON.stringify(b) : b.toString();
          if (a < b)
            return -1;
          if (a > b)
            return 1;
          return 0;
        }
      }
      function sort(arr, fn) {
        if (isUndefined(fn))
          fn = alphaSort;
        if (isDataFrame(arr) || isSeries(arr)) {
          return arr.sort(...Object.values(arguments).slice(1));
        }
        assert(
          isArray(arr),
          "The `sort` function only works on arrays, Series, and DataFrames!"
        );
        assert(
          isFunction(fn),
          "The second parameter of the `sort` function must be a comparison function!"
        );
        const out = arr.slice();
        out.sort(fn);
        return out;
      }
      module.exports = sort;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-get-dummies.js
  var require_df_get_dummies = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-get-dummies.js"(exports, module) {
      var assert = require_assert();
      var isString = require_is_string();
      var isUndefined = require_is_undefined();
      var set = require_set();
      var sort = require_sort();
      function camelify(text) {
        const temp = text.toLowerCase();
        let out = "";
        for (let i = 0; i < temp.length; i++) {
          const char = temp[i];
          if (char.match(/[a-z0-9]/g)) {
            out += char;
          } else {
            out += " ";
          }
        }
        const words = out.split(" ").filter((word) => word.length > 0);
        return words[0] + words.slice(1).map((word) => word[0].toUpperCase() + word.substring(1)).join("");
      }
      function dfGetDummies(DataFrame, df, columns) {
        if (isUndefined(columns)) {
          columns = df.columns;
        } else if (isString(columns)) {
          columns = [columns];
        }
        const temp = {};
        columns.forEach((col) => {
          assert(
            isString(col),
            "You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!"
          );
          const colIndex = df.columns.indexOf(col);
          assert(
            colIndex > -1,
            `The given DataFrame does not have a column called "${col}"!`
          );
          const values = df.values.map((row) => row[colIndex]);
          const valuesSet = sort(set(values));
          values.forEach((value) => {
            valuesSet.forEach((orig) => {
              const colName = col + "_" + camelify(orig.toString());
              if (!temp[colName]) {
                temp[colName] = [];
              }
              if (value === orig) {
                temp[colName].push(1);
              } else {
                temp[colName].push(0);
              }
            });
          });
        });
        const out = new DataFrame(temp);
        out.index = df.index;
        return out;
      }
      module.exports = dfGetDummies;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-get-subset-by-indices.js
  var require_df_get_subset_by_indices = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-get-subset-by-indices.js"(exports, module) {
      var assert = require_assert();
      var isArray = require_is_array();
      var isNumber = require_is_number();
      var isUndefined = require_is_undefined();
      var isWholeNumber = require_is_whole_number();
      var range = require_range();
      var shape = require_shape();
      function dfGetSubsetByIndices(df, rowIndices, colIndices) {
        const dataShape = df.shape;
        if (isUndefined(rowIndices))
          rowIndices = range(0, dataShape[0]);
        if (isUndefined(colIndices))
          colIndices = range(0, dataShape[1]);
        if (isNumber(rowIndices))
          rowIndices = [rowIndices];
        if (isNumber(colIndices))
          colIndices = [colIndices];
        assert(
          isArray(rowIndices) && isArray(colIndices),
          "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."
        );
        assert(
          shape(rowIndices).length === 1 && shape(colIndices).length === 1,
          "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."
        );
        assert(
          rowIndices.length > 0,
          "The `rowIndices` array must contain at least one index."
        );
        assert(
          colIndices.length > 0,
          "The `colIndices` array must contain at least one index."
        );
        rowIndices.forEach((rowIndex) => {
          assert(
            isWholeNumber(rowIndex),
            "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."
          );
          assert(
            rowIndex < df.index.length,
            `The row index ${rowIndex} is out of bounds.`
          );
        });
        colIndices.forEach((colIndex) => {
          assert(
            isWholeNumber(colIndex),
            "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."
          );
          assert(
            colIndex < df.columns.length,
            `The column index ${colIndex} is out of bounds.`
          );
        });
        const rows = rowIndices.map((i) => df.index[i]);
        const cols = colIndices.map((i) => df.columns[i]);
        return df.getSubsetByNames(rows, cols);
      }
      module.exports = dfGetSubsetByIndices;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-get-subset-by-names.js
  var require_df_get_subset_by_names = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-get-subset-by-names.js"(exports, module) {
      var assert = require_assert();
      var flatten = require_flatten();
      var isArray = require_is_array();
      var isString = require_is_string();
      var isUndefined = require_is_undefined();
      var shape = require_shape();
      function dfGetSubsetByNames(DataFrame, Series, df, rows, cols) {
        if (isUndefined(rows))
          rows = df.index;
        if (isUndefined(cols))
          cols = df.columns;
        if (isString(rows))
          rows = [rows];
        if (isString(cols))
          cols = [cols];
        assert(
          isArray(rows) && isArray(cols),
          "The `rows` and `cols` parameters must be 1-dimensional arrays of strings."
        );
        assert(
          shape(rows).length === 1 && shape(cols).length === 1,
          "The `rows` and `cols` parameters must be 1-dimensional arrays of strings."
        );
        assert(
          rows.length > 0,
          "The `rows` array must contain at least one row name."
        );
        assert(
          cols.length > 0,
          "The `cols` array must contain at least one column name."
        );
        rows.forEach((row) => {
          assert(
            isString(row),
            "The `rows` and `cols` parameters must be 1-dimensional arrays of strings."
          );
          assert(
            df.index.indexOf(row) > -1,
            `The row name "${row}" does not exist in the list of rows.`
          );
        });
        cols.forEach((col) => {
          assert(
            isString(col),
            "The `rows` and `cols` parameters must be 1-dimensional arrays of strings."
          );
          assert(
            df.columns.indexOf(col) > -1,
            `The column name "${col}" does not exist in the list of columns.`
          );
        });
        const values = rows.map((row) => {
          return cols.map((col) => {
            return df.values[df.index.indexOf(row)][df.columns.indexOf(col)];
          });
        });
        if (rows.length === 1 && cols.length === 1) {
          return flatten(values)[0];
        }
        if (rows.length === 1) {
          const out2 = new Series(flatten(values));
          out2.name = rows[0];
          out2.index = cols;
          return out2;
        }
        if (cols.length === 1) {
          const out2 = new Series(flatten(values));
          out2.name = cols[0];
          out2.index = rows;
          return out2;
        }
        const out = new DataFrame(values);
        out.columns = cols;
        out.index = rows;
        return out;
      }
      module.exports = dfGetSubsetByNames;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-print.js
  var require_df_print = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-print.js"(exports, module) {
      var isString = require_is_string();
      var range = require_range();
      function dfPrint(DataFrame, Series, df) {
        function truncate(s, maxLength2) {
          if (isString(s)) {
            if (s.length > maxLength2) {
              return s.substring(0, maxLength2 - 3) + "...";
            } else {
              return s;
            }
          } else {
            return s;
          }
        }
        if (df.isEmpty) {
          console.table({});
          console.log("Shape:", [0, 0], "\n");
          return df;
        }
        const maxRows = typeof window === "undefined" ? 20 : 10;
        const halfMaxRows = parseInt(maxRows / 2);
        const maxColumns = typeof process === "undefined" ? 10 : Math.floor(process.stdout.columns / 24) - 1;
        const halfMaxColumns = parseInt(maxColumns / 2);
        const tempRows = maxRows > df.index.length ? null : range(0, halfMaxRows).concat(
          range(df.index.length - halfMaxRows, df.index.length)
        );
        const tempColumns = maxColumns > df.columns.length ? null : range(0, halfMaxColumns).concat(
          range(df.columns.length - halfMaxColumns, df.columns.length)
        );
        let temp = df.get(tempRows, tempColumns);
        if (temp instanceof Series) {
          if (df.shape[0] === 1) {
            temp = new DataFrame([temp.values]);
            temp.index = df.index;
            temp.columns = new Series(df.columns).get(tempColumns).values;
          } else if (df.shape[1] === 1) {
            temp = new DataFrame([temp.values]).transpose();
            temp.index = new Series(df.index).get(tempRows).values;
            temp.columns = df.columns;
          }
        }
        if (maxRows <= df.index.length) {
          temp._index.splice(halfMaxRows, 0, "...");
          temp._values.splice(
            halfMaxRows,
            0,
            range(0, temp.columns.length).map(() => "...")
          );
        }
        if (maxColumns <= df.columns.length) {
          temp._columns.splice(halfMaxColumns, 0, "...");
          temp._values = temp._values.map((row) => {
            row.splice(halfMaxColumns, 0, "...");
            return row;
          });
        }
        const maxLength = 28;
        if (temp instanceof Series) {
          temp.values = temp.values.map((value) => truncate(value, maxLength));
          temp.name = truncate(temp.name, maxLength);
          temp.index = temp.index.map((row) => truncate(row, maxLength));
        } else {
          temp.values = temp.values.map((row) => {
            return row.map((value) => truncate(value, maxLength));
          });
          temp.columns = temp.columns.map((col) => truncate(col, maxLength));
          temp.index = temp.index.map((row) => truncate(row, maxLength));
        }
        console.table(temp.toObject());
        console.log("Shape:", df.shape, "\n");
        return df;
      }
      module.exports = dfPrint;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/helpers/left-pad.js
  var require_left_pad = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/helpers/left-pad.js"(exports, module) {
      var assert = require_assert();
      var isNumber = require_is_number();
      function leftPad(x, maxLength) {
        assert(isNumber(x), "The `leftPad` function only works on numbers!");
        let out = x.toString();
        while (out.length < maxLength)
          out = "0" + out;
        return out;
      }
      module.exports = leftPad;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-reset-index.js
  var require_df_reset_index = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-reset-index.js"(exports, module) {
      var leftPad = require_left_pad();
      var range = require_range();
      function dfResetIndex(df, shouldSkipCopying) {
        const out = shouldSkipCopying ? df : df.copy();
        out.index = range(0, df.shape[0]).map((i) => {
          return "row" + leftPad(i, (out.index.length - 1).toString().length);
        });
        return out;
      }
      module.exports = dfResetIndex;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/product.js
  var require_product = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/product.js"(exports, module) {
      var assert = require_assert();
      var flatten = require_flatten();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isSeries = require_is_series();
      function product(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return product(arr.values);
        }
        assert(
          isArray(arr),
          "The `product` function only works on arrays, Series, and DataFrames!"
        );
        try {
          if (arr.length === 0)
            return NaN;
          return flatten(arr).reduce((a, b) => a * b, 1);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = product;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/reshape.js
  var require_reshape = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/reshape.js"(exports, module) {
      var assert = require_assert();
      var flatten = require_flatten();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isNumber = require_is_number();
      var isSeries = require_is_series();
      var product = require_product();
      var shape = require_shape();
      function reshape(x, newShape) {
        if (isDataFrame(x) || isSeries(x)) {
          return reshape(x.values, newShape);
        }
        assert(
          isArray(x),
          "The first argument passed into the `reshape` function must be an array!"
        );
        if (isNumber(newShape))
          newShape = [newShape];
        assert(
          isArray(newShape),
          "The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"
        );
        assert(
          shape(newShape).length === 1,
          "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"
        );
        newShape.forEach((v) => {
          assert(
            isNumber(v) && parseInt(v) === v && v > 0,
            "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"
          );
        });
        if (newShape.length === 0) {
          return flatten(x);
        }
        const temp = flatten(x);
        if (newShape.length === 1 && newShape[0] === temp.length) {
          return temp;
        }
        assert(
          product(newShape) === temp.length,
          "The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!"
        );
        const out = [];
        const step = parseInt(temp.length / newShape[0]);
        for (let i = 0; i < newShape[0]; i++) {
          const row = temp.slice(i * step, (i + 1) * step);
          out.push(reshape(row, newShape.slice(1)));
        }
        return out;
      }
      module.exports = reshape;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/random.js
  var require_random = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/random.js"(exports, module) {
      var { copy } = require_copy();
      var assert = require_assert();
      var isArray = require_is_array();
      var isNumber = require_is_number();
      var isUndefined = require_is_undefined();
      var ndarray = require_ndarray();
      var product = require_product();
      var reshape = require_reshape();
      var MAX = Math.pow(2, 64);
      var s = [];
      seed(parseInt(Math.random() * MAX));
      function splitmix64(state, n) {
        state = uint(state);
        function helper() {
          state += uint("0x9e3779b97f4a7c15");
          let z = copy(state);
          z = (z ^ z >> BigInt(30)) * uint("0xbf58476d1ce4e5b9");
          z = (z ^ z >> BigInt(27)) * uint("0x94d049bb133111eb");
          return z ^ z >> BigInt(31);
        }
        const out = [];
        for (let i = 0; i < n; i++)
          out.push(helper());
        return out;
      }
      function uint(x) {
        return BigInt.asUintN(64, BigInt(x));
      }
      function rotl(x, k) {
        x = uint(x);
        k = BigInt(k);
        return uint(uint(x << k) | uint(x >> uint(BigInt(64) - k)));
      }
      function seed(val) {
        if (!isUndefined(val)) {
          assert(
            isNumber(val),
            "If passing a value into the `seed` function, then that value must be an integer!"
          );
          const temp = splitmix64(parseInt(val), 4);
          s[0] = temp[0];
          s[1] = temp[1];
          s[2] = temp[2];
          s[3] = temp[3];
        } else {
          return copy(s);
        }
      }
      function next() {
        const result = uint(rotl(s[0] + s[3], 23) + s[0]);
        const t = uint(s[1] << BigInt(17));
        s[2] = uint(s[2] ^ s[0]);
        s[3] = uint(s[3] ^ s[1]);
        s[1] = uint(s[1] ^ s[2]);
        s[0] = uint(s[0] ^ s[3]);
        s[2] = uint(s[2] ^ t);
        s[3] = rotl(s[3], 45);
        return parseInt(result) / MAX;
      }
      function random(shape) {
        if (isUndefined(shape))
          return next();
        if (!isArray(shape))
          shape = [shape];
        return reshape(ndarray(product(shape)).map(next), shape);
      }
      module.exports = { random, seed };
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/shuffle.js
  var require_shuffle = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/shuffle.js"(exports, module) {
      var { random } = require_random();
      var assert = require_assert();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isSeries = require_is_series();
      function shuffle(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return arr.shuffle(...Object.values(arguments).slice(1));
        }
        assert(
          isArray(arr),
          "The `shuffle` function only works on arrays, Series, and DataFrames!"
        );
        const out = [];
        const temp = arr.slice();
        for (let i = 0; i < arr.length; i++) {
          const index = parseInt(random() * temp.length);
          out.push(temp.splice(index, 1)[0]);
        }
        return out;
      }
      module.exports = shuffle;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-shuffle.js
  var require_df_shuffle = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-shuffle.js"(exports, module) {
      var assert = require_assert();
      var isUndefined = require_is_undefined();
      var shuffle = require_shuffle();
      function dfShuffle(df, axis) {
        if (isUndefined(axis))
          axis = 0;
        assert(
          axis === 0 || axis === 1,
          "The `axis` parameter to the `shuffle` must be 0, 1, or undefined."
        );
        return df.get(
          axis === 0 ? shuffle(df.index) : null,
          axis === 1 ? shuffle(df.columns) : null
        );
      }
      module.exports = dfShuffle;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/is-boolean.js
  var require_is_boolean = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/is-boolean.js"(exports, module) {
      function isBoolean(x) {
        return typeof x === "boolean";
      }
      module.exports = isBoolean;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-sort.js
  var require_df_sort = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-sort.js"(exports, module) {
      var { random } = require_random();
      var assert = require_assert();
      var flatten = require_flatten();
      var isArray = require_is_array();
      var isBoolean = require_is_boolean();
      var isFunction = require_is_function();
      var isNumber = require_is_number();
      var isString = require_is_string();
      var isUndefined = require_is_undefined();
      var range = require_range();
      var shape = require_shape();
      var sort = require_sort();
      function dfSort(df, a, b) {
        if (isFunction(a)) {
          return dfSortByFunction(df, a, b);
        } else {
          return dfSortByColumns(df, a, b);
        }
      }
      function dfSortByFunction(df, fn, axis) {
        axis = isUndefined(axis) ? 0 : axis;
        assert(
          isFunction(fn),
          "When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"
        );
        assert(
          isNumber(axis),
          "When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."
        );
        if (axis === 0) {
          const index = sort(df.index, (a, b) => {
            return fn(df.get(a, null), df.get(b, null));
          });
          return df.get(index, null);
        } else {
          const columns = sort(df.columns, (a, b) => {
            return fn(df.get(null, a), df.get(null, b));
          });
          return df.get(null, columns);
        }
      }
      function dfSortByColumns(df, cols, directions) {
        let out = df.copy();
        const indexID = random().toString();
        out = out.assign(indexID, out.index);
        if (isUndefined(cols)) {
          cols = [indexID];
          directions = [true];
        }
        if (isNumber(cols) || isString(cols)) {
          cols = [cols];
          if (isBoolean(directions) || isString(directions))
            directions = [directions];
        }
        assert(
          isArray(cols),
          "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."
        );
        assert(
          shape(cols).length === 1,
          "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."
        );
        if (isUndefined(directions))
          directions = range(0, cols.length).map(() => true);
        assert(
          isArray(directions),
          "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."
        );
        assert(
          shape(directions).length === 1,
          "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."
        );
        assert(
          cols.length === directions.length,
          "The arrays passed into the `sort` method must be equal in length."
        );
        cols = cols.map((col) => {
          assert(
            isString(col) || isNumber(col),
            "Column references can either be column names (as strings) or column indices (as whole numbers)."
          );
          if (isString(col)) {
            const index = out.columns.indexOf(col);
            assert(index > -1, `The column "${col}" does not exist!`);
            return index;
          }
          if (isNumber(col)) {
            assert(parseInt(col) === col, "Column indices must be whole numbers!");
            assert(col >= 0, `The column index ${col} is out of bounds!`);
            assert(col < out.columns.length, `The index ${col} is out of bounds!`);
            return col;
          }
        });
        directions = directions.map((dir) => {
          assert(
            isString(dir) || isBoolean(dir),
            "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."
          );
          if (isString(dir)) {
            const value = dir.trim().toLowerCase();
            assert(
              value === "ascending" || value === "descending",
              "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."
            );
            return value === "ascending";
          }
          if (isBoolean(dir)) {
            return dir;
          }
        });
        out.values = sort(out.values, (a, b) => {
          let counter = 0;
          while (a[cols[counter]] === b[cols[counter]] && counter < cols.length) {
            counter++;
          }
          const isAscending = directions[counter];
          if (a[cols[counter]] === b[cols[counter]])
            return 0;
          if (a[cols[counter]] < b[cols[counter]])
            return isAscending ? -1 : 1;
          if (a[cols[counter]] > b[cols[counter]])
            return isAscending ? 1 : -1;
        });
        out.index = flatten(out.get(null, indexID).values);
        out = out.dropColumns(indexID);
        return out;
      }
      module.exports = dfSort;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-to-json-string.js
  var require_df_to_json_string = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-to-json-string.js"(exports, module) {
      function dfToJSONString(df, axis) {
        return JSON.stringify(df.toObject(axis));
      }
      module.exports = dfToJSONString;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-to-json.js
  var require_df_to_json = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-to-json.js"(exports, module) {
      var MathError = require_math_error();
      var dfToJSONString = require_df_to_json_string();
      function toJSON(df, filename, axis) {
        const out = dfToJSONString(df, axis);
        let downloadedInBrowser = false;
        let wroteToDiskInNode = false;
        let browserError, nodeError;
        try {
          let newFilename = filename;
          if (filename.includes("/")) {
            const parts = filename.split("/");
            newFilename = parts[parts.length - 1];
          }
          const a = document.createElement("a");
          a.href = `data:application/json;charset=utf-8,${encodeURIComponent(out)}`;
          a.download = newFilename;
          a.dispatchEvent(new MouseEvent("click"));
          downloadedInBrowser = true;
        } catch (e) {
          browserError = e;
        }
        try {
          const fs = __require("fs");
          const path = __require("path");
          fs.writeFileSync(path.resolve(filename), out, "utf8");
          wroteToDiskInNode = true;
        } catch (e) {
          nodeError = e;
        }
        if (!downloadedInBrowser && !wroteToDiskInNode) {
          if (typeof window !== "undefined") {
            throw new MathError(browserError);
          } else if (typeof module !== "undefined") {
            throw new MathError(nodeError);
          } else {
            throw new MathError(
              "I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!"
            );
          }
        }
        return df;
      }
      module.exports = toJSON;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-to-object.js
  var require_df_to_object = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/df-to-object.js"(exports, module) {
      var assert = require_assert();
      var isUndefined = require_is_undefined();
      function dfToObject(df, axis) {
        if (isUndefined(axis)) {
          axis = 0;
        } else {
          assert(
            axis === 0 || axis === 1,
            "The axis parameter of the `toObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows."
          );
        }
        const out = {};
        if (axis === 0) {
          df.index.forEach((rowName, i) => {
            const temp = {};
            df.columns.forEach((colName, j) => {
              temp[colName] = df.values[i][j];
            });
            out[rowName] = temp;
          });
        } else {
          df.columns.forEach((colName, j) => {
            const temp = {};
            df.index.forEach((rowName, i) => {
              temp[rowName] = df.values[i][j];
            });
            out[colName] = temp;
          });
        }
        return out;
      }
      module.exports = dfToObject;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/transpose.js
  var require_transpose = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/transpose.js"(exports, module) {
      var assert = require_assert();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isSeries = require_is_series();
      var ndarray = require_ndarray();
      var reverse = require_reverse();
      var shape = require_shape();
      function transpose(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return arr.transpose();
        }
        assert(
          isArray(arr),
          "The `transpose` function only works on arrays, Series, and DataFrames!"
        );
        const theShape = shape(arr);
        assert(
          theShape.length <= 2,
          "I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"
        );
        if (theShape.length === 1) {
          return reverse(arr);
        } else if (theShape.length === 2) {
          const out = ndarray(reverse(theShape));
          for (let row = 0; row < theShape[0]; row++) {
            for (let col = 0; col < theShape[1]; col++) {
              out[col][row] = arr[row][col];
            }
          }
          return out;
        }
      }
      module.exports = transpose;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/series-append.js
  var require_series_append = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/series-append.js"(exports, module) {
      var assert = require_assert();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isNested = require_is_nested();
      var isSeries = require_is_series();
      var shape = require_shape();
      function seriesAppend(Series, series, x) {
        if (isSeries(x)) {
          return new Series(series.values.concat(x.values));
        }
        if (isArray(x)) {
          const xShape = shape(x);
          assert(
            xShape.length === 1 && !isNested(xShape),
            "Only vectors can be appended to Series!"
          );
          const out = series.copy();
          x.forEach((v, i) => {
            out._values.push(v);
            out._index.push("item" + (series.values.length + i));
          });
          return out;
        }
        assert(!isDataFrame(x), "DataFrames cannot be appended to Series!");
        return seriesAppend(series, [x]);
      }
      module.exports = seriesAppend;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/series-apply.js
  var require_series_apply = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/series-apply.js"(exports, module) {
      var assert = require_assert();
      var isFunction = require_is_function();
      function seriesApply(series, fn) {
        assert(
          isFunction(fn),
          "The parameter to the `apply` method must be a function."
        );
        const out = series.copy();
        out._values = out._values.map((v, i) => fn(v, i));
        return out;
      }
      module.exports = seriesApply;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/series-drop-missing.js
  var require_series_drop_missing = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/series-drop-missing.js"(exports, module) {
      var isUndefined = require_is_undefined();
      function seriesDropMissing(series) {
        const out = series.copy();
        const outIndex = [];
        out._values = out.values.filter((v, i) => {
          if (isUndefined(v)) {
            return false;
          } else {
            outIndex.push(out.index[i]);
            return true;
          }
        });
        out._index = outIndex;
        return out;
      }
      module.exports = seriesDropMissing;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/series-drop-nan.js
  var require_series_drop_nan = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/series-drop-nan.js"(exports, module) {
      var isNumber = require_is_number();
      function seriesDropNaN(Series, series) {
        const index = [];
        const values = [];
        series.values.forEach((value, i) => {
          if (isNumber(value)) {
            values.push(value);
            index.push(series.index[i]);
          }
        });
        const out = new Series(values);
        out.name = series.name;
        out.index = index;
        return out;
      }
      module.exports = seriesDropNaN;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/series-filter.js
  var require_series_filter = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/series-filter.js"(exports, module) {
      var { copy } = require_copy();
      function seriesFilter(Series, series, fn) {
        let out = series.copy();
        const index = copy(out.index);
        const indicesToRemove = [];
        const newValues = out.values.filter((value, i) => {
          const shouldKeep = fn(value, i, out.values);
          if (!shouldKeep)
            indicesToRemove.push(out.index[i]);
          return shouldKeep;
        });
        indicesToRemove.forEach((i) => {
          index.splice(index.indexOf(i), 1);
        });
        if (newValues.length === 0) {
          out = new Series();
          out.name = series.name;
          return out;
        }
        out.values = newValues;
        out.index = index;
        return out;
      }
      module.exports = seriesFilter;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/series-get.js
  var require_series_get = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/series-get.js"(exports, module) {
      var assert = require_assert();
      var isNumber = require_is_number();
      var isString = require_is_string();
      var isUndefined = require_is_undefined();
      var set = require_set();
      function seriesGet(series, indices) {
        if (isString(indices) || isNumber(indices))
          indices = [indices];
        const types = set((indices || []).map((v) => typeof v));
        assert(
          types.length <= 2,
          "Only whole numbers and/or strings are allowed in `get` arrays!"
        );
        if (types.length === 1) {
          assert(
            types[0] === "string" || types[0] === "number",
            "Only whole numbers and/or strings are allowed in `get` arrays!"
          );
        }
        if (types.length === 2) {
          assert(
            types.indexOf("string") > -1,
            "Only whole numbers and/or strings are allowed in `get` arrays!"
          );
          assert(
            types.indexOf("number") > -1,
            "Only whole numbers and/or strings are allowed in `get` arrays!"
          );
        }
        if (!isUndefined(indices)) {
          indices = indices.map((i) => {
            if (typeof i === "string") {
              assert(series.index.indexOf(i) > -1, `Index "${i}" does not exist!`);
              return i;
            }
            if (typeof i === "number") {
              assert(i >= 0, `Index ${i} is out of bounds!`);
              assert(parseInt(i) === i, `Indices must be integers!`);
              assert(i < series.index.length, `Index ${i} is out of bounds!`);
              return series.index[i];
            }
          });
        }
        return series.getSubsetByNames(indices);
      }
      module.exports = seriesGet;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/series-get-subset-by-indices.js
  var require_series_get_subset_by_indices = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/series-get-subset-by-indices.js"(exports, module) {
      var assert = require_assert();
      var isArray = require_is_array();
      var isUndefined = require_is_undefined();
      var isWholeNumber = require_is_whole_number();
      var range = require_range();
      var shape = require_shape();
      function seriesGetSubsetByIndices(series, indices) {
        const dataShape = series.shape;
        if (isUndefined(indices))
          indices = range(0, dataShape[0]);
        assert(
          isArray(indices),
          "The `indices` array must be 1-dimensional array of whole numbers."
        );
        assert(
          shape(indices).length === 1,
          "The `indices` array must be a 1-dimensional array of whole numbers."
        );
        assert(
          indices.length > 0,
          "The `indices` array must contain at least one index."
        );
        indices.forEach((index) => {
          assert(
            isWholeNumber(index),
            "The `indices` array must be a 1-dimensional array of whole numbers."
          );
          assert(
            index < series.index.length,
            `The row index ${index} is out of bounds.`
          );
        });
        const rows = indices.map((i) => series.index[i]);
        return series.getSubsetByNames(rows);
      }
      module.exports = seriesGetSubsetByIndices;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/series-get-subset-by-names.js
  var require_series_get_subset_by_names = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/series-get-subset-by-names.js"(exports, module) {
      var assert = require_assert();
      var isArray = require_is_array();
      var isString = require_is_string();
      var isUndefined = require_is_undefined();
      var shape = require_shape();
      function seriesGetSubsetByNames(Series, series, indices) {
        if (isUndefined(indices))
          indices = series.index;
        assert(
          isArray(indices),
          "The `indices` array must be a 1-dimensional array of strings."
        );
        assert(
          shape(indices).length === 1,
          "The `indices` array must be a 1-dimensional array of strings."
        );
        assert(
          indices.length > 0,
          "The `indices` array must contain at least one index name."
        );
        indices.forEach((name) => {
          assert(isString(name), "The `indices` array must contain only strings.");
          assert(
            series.index.indexOf(name) > -1,
            `The name "${name}" does not exist in the index.`
          );
        });
        const values = indices.map((name) => {
          return series.values[series.index.indexOf(name)];
        });
        if (values.length === 1)
          return values[0];
        const out = new Series(values);
        out.index = indices;
        out.name = series.name;
        return out;
      }
      module.exports = seriesGetSubsetByNames;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/series-print.js
  var require_series_print = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/series-print.js"(exports, module) {
      var { copy } = require_copy();
      var range = require_range();
      function seriesPrint(series) {
        let temp = series.copy();
        const maxRows = typeof window === "undefined" ? 20 : 10;
        if (temp.index.length > maxRows) {
          temp = temp.get(
            range(0, maxRows / 2).concat(
              range(temp.index.length - maxRows / 2, temp.index.length)
            )
          );
          const tempIndex = copy(temp.index);
          tempIndex.splice(parseInt(tempIndex.length / 2), 0, "...");
          temp.values.push("...");
          temp.index.push("...");
          temp = temp.get(tempIndex);
        }
        const out = {};
        temp.values.forEach((value, i) => {
          const obj = {};
          obj[temp.name] = value;
          out[temp.index[i]] = obj;
        });
        console.table(out);
        console.log("Shape:", series.shape, "\n");
        return series;
      }
      module.exports = seriesPrint;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/series-shuffle.js
  var require_series_shuffle = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/series-shuffle.js"(exports, module) {
      var shuffle = require_shuffle();
      function seriesShuffle(series) {
        const out = series.copy();
        return out.get(shuffle(out.index));
      }
      module.exports = seriesShuffle;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/series-sort.js
  var require_series_sort = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/series-sort.js"(exports, module) {
      var assert = require_assert();
      var isFunction = require_is_function();
      var isUndefined = require_is_undefined();
      var sort = require_sort();
      var transpose = require_transpose();
      function seriesSort(Series, series, fn) {
        fn = fn || ((a, b) => a < b ? -1 : 1);
        assert(
          isUndefined(fn) || isFunction(fn),
          "You must pass undefined, null, or a comparison function as the second argument to the `sort` method!"
        );
        const pairs = transpose([series.values, series.index]);
        const temp = sort(pairs, (aPair, bPair) => {
          return fn(aPair[0], bPair[0]);
        });
        const newValues = [];
        const newIndex = [];
        temp.forEach((pair) => {
          newValues.push(pair[0]);
          newIndex.push(pair[1]);
        });
        const out = new Series();
        out._values = newValues;
        out._index = newIndex;
        out.name = series.name;
        return out;
      }
      module.exports = seriesSort;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/series-sort-by-index.js
  var require_series_sort_by_index = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/series-sort-by-index.js"(exports, module) {
      var sort = require_sort();
      var transpose = require_transpose();
      function seriesSortByIndex(Series, series) {
        let temp = transpose([series.values, series.index]);
        temp = transpose(
          sort(temp, (a, b) => {
            if (a[1] === b[1])
              return 0;
            if (a[1] < b[1])
              return -1;
            if (a[1] > b[1])
              return 1;
          })
        );
        const out = new Series(temp[0]);
        out.index = temp[1];
        out.name = series.name;
        return out;
      }
      module.exports = seriesSortByIndex;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/series-to-object.js
  var require_series_to_object = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/series-to-object.js"(exports, module) {
      function seriesToObject(series) {
        const out = {};
        out[series.name] = {};
        series.index.forEach((index, i) => {
          out[series.name][index] = series.values[i];
        });
        return out;
      }
      module.exports = seriesToObject;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/index.js
  var require_series = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/series/index.js"(exports, module) {
      var { copy } = require_copy();
      var assert = require_assert();
      var isArray = require_is_array();
      var isString = require_is_string();
      var isUndefined = require_is_undefined();
      var leftPad = require_left_pad();
      var range = require_range();
      var reverse = require_reverse();
      var seriesAppend = require_series_append();
      var seriesApply = require_series_apply();
      var seriesDropMissing = require_series_drop_missing();
      var seriesDropNaN = require_series_drop_nan();
      var seriesFilter = require_series_filter();
      var seriesGet = require_series_get();
      var seriesGetSubsetByIndices = require_series_get_subset_by_indices();
      var seriesGetSubsetByNames = require_series_get_subset_by_names();
      var seriesPrint = require_series_print();
      var seriesShuffle = require_series_shuffle();
      var seriesSort = require_series_sort();
      var seriesSortByIndex = require_series_sort_by_index();
      var seriesToObject = require_series_to_object();
      var shape = require_shape();
      var transpose = require_transpose();
      var SERIES_SYMBOL = Symbol.for("@jrc03c/js-math-tools/series");
      module.exports = function(DataFrame) {
        class Series {
          static [Symbol.hasInstance](x) {
            try {
              return !!x._symbol && x._symbol === SERIES_SYMBOL;
            } catch (e) {
              return false;
            }
          }
          constructor(data) {
            const self2 = this;
            self2.name = "data";
            Object.defineProperty(self2, "_symbol", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: SERIES_SYMBOL
            });
            Object.defineProperty(self2, "_values", {
              value: [],
              configurable: true,
              enumerable: false,
              writable: true
            });
            Object.defineProperty(self2, "values", {
              configurable: true,
              enumerable: true,
              get() {
                return self2._values;
              },
              set(x) {
                assert(isArray(x), "The new values must be a 1-dimensional array!");
                const dataShape = shape(x);
                assert(
                  dataShape.length === 1,
                  "The new array of values must be 1-dimensional!"
                );
                if (dataShape[0] < self2._index.length) {
                  self2._index = self2._index.slice(0, dataShape[0]);
                } else if (dataShape[0] > self2._index.length) {
                  self2._index = self2._index.concat(
                    range(self2._index.length, dataShape[0]).map((i) => {
                      return "item" + leftPad(i, (x.length - 1).toString().length);
                    })
                  );
                }
                self2._values = x;
              }
            });
            Object.defineProperty(self2, "_index", {
              value: [],
              configurable: true,
              enumerable: false,
              writable: true
            });
            Object.defineProperty(self2, "index", {
              configurable: true,
              enumerable: true,
              get() {
                return self2._index;
              },
              set(x) {
                assert(
                  isArray(x),
                  "The new index must be a 1-dimensional array of strings!"
                );
                assert(
                  x.length === self2.shape[0],
                  "The new index must be the same length as the old index!"
                );
                assert(
                  shape(x).length === 1,
                  "The new index must be a 1-dimensional array of strings!"
                );
                x.forEach((value) => {
                  assert(isString(value), "All of the row names must be strings!");
                });
                self2._index = x;
              }
            });
            if (data) {
              if (data instanceof Series) {
                self2.name = data.name;
                self2.values = copy(data.values);
                self2.index = copy(data.index);
              } else if (isArray(data)) {
                const dataShape = shape(data);
                assert(
                  dataShape.length === 1,
                  "When passing an array into the constructor of a Series, the array must be 1-dimensional!"
                );
                self2.values = data;
              } else if (data instanceof Object) {
                const keys = Object.keys(data);
                assert(
                  keys.length === 1,
                  "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"
                );
                const name = keys[0];
                const values = data[name];
                assert(
                  shape(values).length === 1,
                  "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"
                );
                self2.name = name;
                self2.values = values.slice();
              }
            }
          }
          get shape() {
            const self2 = this;
            return shape(self2.values);
          }
          get length() {
            const self2 = this;
            return self2.shape[0];
          }
          get isEmpty() {
            const self2 = this;
            return self2.values.filter((v) => !isUndefined(v)).length === 0;
          }
          clear() {
            const self2 = this;
            const out = self2.copy();
            out.values.forEach((v, i) => {
              out.values[i] = void 0;
            });
            return out;
          }
          get(indices) {
            const self2 = this;
            return seriesGet(self2, indices);
          }
          getSubsetByNames(indices) {
            const self2 = this;
            return seriesGetSubsetByNames(Series, self2, indices);
          }
          getSubsetByIndices(indices) {
            const self2 = this;
            return seriesGetSubsetByIndices(self2, indices);
          }
          loc(indices) {
            const self2 = this;
            return self2.getSubsetByNames(indices);
          }
          iloc(indices) {
            const self2 = this;
            return self2.getSubsetByIndices(indices);
          }
          reverse() {
            const self2 = this;
            const out = new Series(reverse(self2.values));
            out.index = reverse(self2.index);
            out.name = self2.name;
            return out;
          }
          resetIndex() {
            const self2 = this;
            const out = self2.copy();
            out.index = range(0, self2.shape[0]).map((i) => {
              return "item" + leftPad(i, (out.index.length - 1).toString().length);
            });
            return out;
          }
          copy() {
            const self2 = this;
            const out = new Series();
            out._values = copy(self2.values);
            out._index = copy(self2.index);
            out.name = self2.name;
            return out;
          }
          append(x) {
            const self2 = this;
            return seriesAppend(Series, self2, x);
          }
          apply(fn) {
            const self2 = this;
            return seriesApply(self2, fn);
          }
          concat(x) {
            const self2 = this;
            return self2.append(x);
          }
          dropMissing(condition, threshold) {
            const self2 = this;
            return seriesDropMissing(self2, condition, threshold);
          }
          dropNaN() {
            const self2 = this;
            return seriesDropNaN(Series, self2);
          }
          toObject() {
            const self2 = this;
            return seriesToObject(self2);
          }
          print() {
            const self2 = this;
            return seriesPrint(self2);
          }
          shuffle() {
            const self2 = this;
            return seriesShuffle(self2);
          }
          sort(direction) {
            const self2 = this;
            return seriesSort(Series, self2, direction);
          }
          sortByIndex() {
            const self2 = this;
            return seriesSortByIndex(Series, self2);
          }
          filter(fn) {
            const self2 = this;
            return seriesFilter(Series, self2, fn);
          }
          toDataFrame() {
            const self2 = this;
            const out = new DataFrame(transpose([self2.values]));
            out.columns = [self2.name];
            out.index = self2.index;
            return out;
          }
          transpose() {
            const self2 = this;
            const out = self2.copy();
            out.values = reverse(out.values);
            out.index = reverse(out.index);
            return out;
          }
          getDummies() {
            const self2 = this;
            return self2.toDataFrame().getDummies();
          }
          oneHotEncode() {
            const self2 = this;
            return self2.getDummies();
          }
        }
        return Series;
      };
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/index.js
  var require_dataframe = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dataframe/index.js"(exports, module) {
      var { copy } = require_copy();
      var assert = require_assert();
      var count = require_count();
      var dfAppend = require_df_append();
      var dfApply = require_df_apply();
      var dfAssign = require_df_assign();
      var dfCopy = require_df_copy();
      var dfDrop = require_df_drop();
      var dfDropMissing = require_df_drop_missing();
      var dfDropNaN = require_df_drop_nan();
      var dfFilter = require_df_filter();
      var dfGet = require_df_get();
      var dfGetDummies = require_df_get_dummies();
      var dfGetSubsetByIndices = require_df_get_subset_by_indices();
      var dfGetSubsetByNames = require_df_get_subset_by_names();
      var dfPrint = require_df_print();
      var dfResetIndex = require_df_reset_index();
      var dfShuffle = require_df_shuffle();
      var dfSort = require_df_sort();
      var dfToJSON = require_df_to_json();
      var dfToJSONString = require_df_to_json_string();
      var dfToObject = require_df_to_object();
      var flatten = require_flatten();
      var isArray = require_is_array();
      var isObject = require_is_object();
      var isUndefined = require_is_undefined();
      var leftPad = require_left_pad();
      var ndarray = require_ndarray();
      var range = require_range();
      var shape = require_shape();
      var transpose = require_transpose();
      var DATAFRAME_SYMBOL = Symbol.for("@jrc03c/js-math-tools/dataframe");
      function makeKey(n) {
        const alpha = "abcdefghijklmnopqrstuvwxyz1234567890";
        let out = "";
        for (let i = 0; i < n; i++)
          out += alpha[parseInt(Math.random() * alpha.length)];
        return out;
      }
      var DataFrame = class {
        static [Symbol.hasInstance](x) {
          try {
            return !!x._symbol && x._symbol === DATAFRAME_SYMBOL;
          } catch (e) {
            return false;
          }
        }
        constructor(data) {
          const self2 = this;
          Object.defineProperty(self2, "_symbol", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: DATAFRAME_SYMBOL
          });
          Object.defineProperty(self2, "_values", {
            value: [],
            configurable: true,
            enumerable: false,
            writable: true
          });
          Object.defineProperty(self2, "values", {
            configurable: true,
            enumerable: true,
            get() {
              if (self2._values.length === 0 || !isUndefined(self2._values[0]) && self2._values[0].length === 0) {
                return [[]];
              }
              return self2._values;
            },
            set(x) {
              assert(isArray(x), "The new values must be a 2-dimensional array!");
              const dataShape = shape(x);
              assert(
                dataShape.length === 2,
                "The new array of values must be 2-dimensional!"
              );
              if (dataShape[0] < self2._index.length) {
                self2._index = self2._index.slice(0, dataShape[0]);
              } else if (dataShape[0] > self2._index.length) {
                self2._index = self2._index.concat(
                  range(self2._index.length, dataShape[0]).map((i) => {
                    return "row" + leftPad(i, (dataShape[0] - 1).toString().length);
                  })
                );
              }
              if (dataShape[1] < self2._columns.length) {
                self2._columns = self2._columns.slice(0, dataShape[1]);
              } else if (dataShape[1] > self2._columns.length) {
                self2._columns = self2._columns.concat(
                  range(self2._columns.length, dataShape[1]).map((i) => {
                    return "col" + leftPad(i, (dataShape[1] - 1).toString().length);
                  })
                );
              }
              self2._values = x;
            }
          });
          Object.defineProperty(self2, "_columns", {
            value: [],
            configurable: true,
            enumerable: false,
            writable: true
          });
          Object.defineProperty(self2, "columns", {
            configurable: true,
            enumerable: true,
            get() {
              return self2._columns;
            },
            set(x) {
              assert(
                isArray(x),
                "The new columns list must be a 1-dimensional array of strings!"
              );
              assert(
                self2.isEmpty || x.length === self2.shape[1],
                "The new columns list must be the same length as the old columns list!"
              );
              assert(
                shape(x).length === 1,
                "The new columns list must be a 1-dimensional array of strings!"
              );
              x = x.map((v) => {
                if (typeof v !== "string") {
                  v = JSON.stringify(v) || v.toString();
                }
                if (v.trim().length === 0) {
                  return "untitled_" + makeKey(8);
                }
                return v.trim();
              });
              const counts = (() => {
                const temp = count(x);
                const out = {};
                temp.forEach((obj) => {
                  out[obj.value] = obj.count;
                });
                return out;
              })();
              x = x.map((v) => {
                if (counts[v] > 1) {
                  return v + "_" + makeKey(8);
                }
                return v;
              });
              self2._columns = x;
            }
          });
          Object.defineProperty(self2, "_index", {
            value: [],
            configurable: true,
            enumerable: false,
            writable: true
          });
          Object.defineProperty(self2, "index", {
            configurable: true,
            enumerable: true,
            get() {
              return self2._index;
            },
            set(x) {
              assert(
                isArray(x),
                "The new index must be a 1-dimensional array of strings!"
              );
              assert(
                self2.isEmpty || x.length === self2.shape[0],
                "The new index must be the same length as the old index!"
              );
              assert(
                shape(x).length === 1,
                "The new index must be a 1-dimensional array of strings!"
              );
              x = x.map((v) => {
                if (typeof v !== "string") {
                  v = JSON.stringify(v) || v.toString();
                }
                if (v.trim().length === 0) {
                  return "untitled_" + makeKey(8);
                }
                return v.trim();
              });
              const counts = (() => {
                const temp = count(x);
                const out = {};
                temp.forEach((obj) => {
                  out[obj.value] = obj.count;
                });
                return out;
              })();
              x = x.map((v) => {
                if (counts[v] > 1) {
                  return v + "_" + makeKey(8);
                }
                return v;
              });
              self2._index = x;
            }
          });
          assert(
            isUndefined(data) || isObject(data) || isArray(data),
            "The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."
          );
          if (data) {
            if (data instanceof DataFrame) {
              self2.values = copy(data.values);
              self2.columns = copy(data.columns);
              self2.index = copy(data.index);
            } else if (isArray(data)) {
              const dataShape = shape(data);
              assert(
                dataShape.length === 2,
                "The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"
              );
              self2.values = data;
            } else {
              self2._columns = Object.keys(data);
              const temp = [];
              self2._columns.forEach((col) => {
                const values = data[col];
                temp.push(values);
              });
              self2._values = transpose(temp);
              const dataShape = shape(self2.values);
              self2._index = range(0, dataShape[0]).map((i) => {
                return "row" + leftPad(i, (dataShape[0] - 1).toString().length);
              });
            }
          }
        }
        get shape() {
          const self2 = this;
          return shape(self2.values);
        }
        get length() {
          const self2 = this;
          return self2.shape[0];
        }
        get width() {
          const self2 = this;
          return self2.shape[1];
        }
        get rows() {
          const self2 = this;
          return self2.index;
        }
        set rows(rows) {
          const self2 = this;
          self2.index = rows;
        }
        get isEmpty() {
          const self2 = this;
          return flatten(self2.values).length === 0;
        }
        clear() {
          const self2 = this;
          const out = new DataFrame(ndarray(self2.shape));
          out.columns = self2.columns.slice();
          out.index = self2.index.slice();
          return out;
        }
        get(rows, cols) {
          const self2 = this;
          if (arguments.length === 0) {
            return self2;
          }
          if (arguments.length === 1) {
            try {
              return self2.get(null, rows);
            } catch (e) {
              return self2.get(rows, null);
            }
          }
          return dfGet(self2, rows, cols);
        }
        getSubsetByNames(rows, cols) {
          const self2 = this;
          return dfGetSubsetByNames(DataFrame, Series, self2, rows, cols);
        }
        getSubsetByIndices(rowIndices, colIndices) {
          const self2 = this;
          return dfGetSubsetByIndices(self2, rowIndices, colIndices);
        }
        getDummies(columns) {
          const self2 = this;
          return dfGetDummies(DataFrame, self2, columns);
        }
        oneHotEncode(columns) {
          const self2 = this;
          return dfGetDummies(DataFrame, self2, columns);
        }
        transpose() {
          const self2 = this;
          const out = new DataFrame(transpose(self2.values));
          out.columns = self2.index.slice();
          out.index = self2.columns.slice();
          return out;
        }
        get T() {
          const self2 = this;
          return self2.transpose();
        }
        resetIndex(shouldSkipCopying) {
          const self2 = this;
          return dfResetIndex(self2, shouldSkipCopying);
        }
        copy() {
          const self2 = this;
          return dfCopy(DataFrame, self2);
        }
        assign(p1, p2) {
          const self2 = this;
          return dfAssign(DataFrame, Series, self2, p1, p2);
        }
        apply(fn, axis) {
          const self2 = this;
          return dfApply(DataFrame, Series, self2, fn, axis);
        }
        dropMissing(axis, condition, threshold) {
          const self2 = this;
          return dfDropMissing(DataFrame, Series, self2, axis, condition, threshold);
        }
        dropNaN(axis, condition, threshold) {
          const self2 = this;
          return dfDropNaN(DataFrame, self2, axis, condition, threshold);
        }
        drop(rows, cols) {
          const self2 = this;
          return dfDrop(DataFrame, Series, self2, rows, cols);
        }
        dropColumns(columns) {
          const self2 = this;
          return self2.drop(null, columns);
        }
        dropRows(rows) {
          const self2 = this;
          return self2.drop(rows, null);
        }
        toObject(axis) {
          const self2 = this;
          return dfToObject(self2, axis);
        }
        toJSONString(axis) {
          const self2 = this;
          return dfToJSONString(self2, axis);
        }
        saveAsJSON(filename, axis) {
          const self2 = this;
          return dfToJSON(self2, filename, axis);
        }
        print() {
          const self2 = this;
          return dfPrint(DataFrame, Series, self2);
        }
        sort(cols, directions) {
          const self2 = this;
          return dfSort(self2, cols, directions);
        }
        sortByIndex() {
          const self2 = this;
          return self2.sort();
        }
        filter(fn, axis) {
          const self2 = this;
          return dfFilter(DataFrame, Series, self2, fn, axis);
        }
        shuffle(axis) {
          const self2 = this;
          return dfShuffle(self2, axis);
        }
        append(x, axis) {
          const self2 = this;
          return dfAppend(self2, x, axis);
        }
        concat(x, axis) {
          const self2 = this;
          return self2.append(x, axis);
        }
        join(x, axis) {
          const self2 = this;
          return self2.append(x, axis);
        }
        toString() {
          const self2 = this;
          return JSON.stringify(self2);
        }
      };
      var Series = require_series()(DataFrame);
      module.exports = { DataFrame, Series };
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/max.js
  var require_max = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/max.js"(exports, module) {
      var assert = require_assert();
      var flatten = require_flatten();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isSeries = require_is_series();
      function max(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return max(arr.values);
        }
        assert(
          isArray(arr),
          "The `max` function only works on arrays, Series, and DataFrames!"
        );
        try {
          return Math.max(...flatten(arr));
        } catch (e) {
          return NaN;
        }
      }
      module.exports = max;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/vectorize.js
  var require_vectorize = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/vectorize.js"(exports, module) {
      var { DataFrame, Series } = require_dataframe();
      var assert = require_assert();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isEqual = require_is_equal();
      var isFunction = require_is_function();
      var isSeries = require_is_series();
      var max = require_max();
      var range = require_range();
      var shape = require_shape();
      function isArraySeriesOrDataFrame(x) {
        return isArray(x) || isSeries(x) || isDataFrame(x);
      }
      function vectorize(fn) {
        assert(
          isFunction(fn),
          "You must pass a function into the `vectorize` function!"
        );
        return function helper() {
          let hasSeries, hasDataFrames;
          const series = [];
          const dataframes = [];
          const childArrays = Object.keys(arguments).filter((key) => {
            const arg = arguments[key];
            if (isArray(arg)) {
              return true;
            } else if (isSeries(arg)) {
              hasSeries = true;
              series.push(arg);
              return true;
            } else if (isDataFrame(arg)) {
              hasDataFrames = true;
              dataframes.push(arg);
              return true;
            } else {
              return false;
            }
          }).map((key) => arguments[key]);
          childArrays.slice(0, -1).forEach((s, i) => {
            assert(
              isEqual(
                isArray(s) ? shape(s) : s.shape,
                isArray(childArrays[i + 1]) ? shape(childArrays[i + 1]) : childArrays[i + 1].shape
              ),
              `When passing multiple arrays into the \`${fn.name}\` function, all of the arrays must have the same shape!`
            );
          });
          if (childArrays.length > 0) {
            const maxLength = max(
              childArrays.map((a) => a.length ? a.length : a.values.length)
            );
            const out = range(0, maxLength).map((i) => {
              const args = Object.keys(arguments).map((key) => {
                if (isArraySeriesOrDataFrame(arguments[key])) {
                  if (isArray(arguments[key])) {
                    return arguments[key][i];
                  } else if (isSeries(arguments[key])) {
                    return arguments[key].values[i];
                  } else if (isDataFrame(arguments[key])) {
                    return arguments[key].values[i];
                  }
                } else {
                  return arguments[key];
                }
              });
              return helper(...args);
            });
            if (hasDataFrames) {
              try {
                if (dataframes.length === 1 && isEqual(shape(dataframes[0]), shape(out))) {
                  const temp = new DataFrame(out);
                  temp.index = dataframes[0].index.slice();
                  temp.columns = dataframes[0].columns.slice();
                  return temp;
                } else {
                  return new DataFrame(out);
                }
              } catch (e) {
                return out;
              }
            }
            if (hasSeries) {
              try {
                if (series.length === 1 && series[0].length === out.length) {
                  const temp = new Series(out);
                  temp.name = series[0].name;
                  temp.index = series[0].index.slice();
                  return temp;
                } else {
                  return new Series(out);
                }
              } catch (e) {
                return out;
              }
            }
            return out;
          } else {
            return fn(...arguments);
          }
        };
      }
      module.exports = vectorize;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/abs.js
  var require_abs = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/abs.js"(exports, module) {
      var isNumber = require_is_number();
      var vectorize = require_vectorize();
      function abs(x) {
        try {
          if (!isNumber(x))
            return NaN;
          return Math.abs(x);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(abs);
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/add.js
  var require_add = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/add.js"(exports, module) {
      var isNumber = require_is_number();
      var vectorize = require_vectorize();
      function add() {
        try {
          let out = 0;
          const x = Object.values(arguments);
          for (let i = 0; i < x.length; i++) {
            if (!isNumber(x[i]))
              return NaN;
            out += x[i];
          }
          return out;
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(add);
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/apply.js
  var require_apply = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/apply.js"(exports, module) {
      var vectorize = require_vectorize();
      function apply(x, fn) {
        try {
          return fn(x);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(apply);
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/arccos.js
  var require_arccos = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/arccos.js"(exports, module) {
      var isNumber = require_is_number();
      var vectorize = require_vectorize();
      function arccos(x) {
        try {
          if (!isNumber(x))
            return NaN;
          return Math.acos(x);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(arccos);
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/arcsin.js
  var require_arcsin = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/arcsin.js"(exports, module) {
      var isNumber = require_is_number();
      var vectorize = require_vectorize();
      function arcsin(x) {
        try {
          if (!isNumber(x))
            return NaN;
          return Math.asin(x);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(arcsin);
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/arctan.js
  var require_arctan = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/arctan.js"(exports, module) {
      var isNumber = require_is_number();
      var vectorize = require_vectorize();
      function arctan(x) {
        try {
          if (!isNumber(x))
            return NaN;
          return Math.atan(x);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(arctan);
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/argmax.js
  var require_argmax = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/argmax.js"(exports, module) {
      var assert = require_assert();
      var indexOf = require_index_of();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isSeries = require_is_series();
      var max = require_max();
      function argmax(x) {
        if (isDataFrame(x)) {
          const index = argmax(x.values);
          return [x.index[index[0]], x.columns[index[1]]];
        }
        if (isSeries(x)) {
          const index = argmax(x.values);
          return [x.index[index]];
        }
        assert(
          isArray(x),
          "The `argmax` function only works on arrays, Series, and DataFrames!"
        );
        try {
          const out = indexOf(x, max(x));
          if (out) {
            if (out.length === 0) {
              return void 0;
            } else if (out.length === 1) {
              return out[0];
            } else {
              return out;
            }
          } else {
            return void 0;
          }
        } catch (e) {
          return void 0;
        }
      }
      module.exports = argmax;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/min.js
  var require_min = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/min.js"(exports, module) {
      var assert = require_assert();
      var flatten = require_flatten();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isSeries = require_is_series();
      function min(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return min(arr.values);
        }
        assert(
          isArray(arr),
          "The `min` function only works on arrays, Series, and DataFrames!"
        );
        try {
          return Math.min(...flatten(arr));
        } catch (e) {
          return NaN;
        }
      }
      module.exports = min;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/argmin.js
  var require_argmin = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/argmin.js"(exports, module) {
      var assert = require_assert();
      var indexOf = require_index_of();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isSeries = require_is_series();
      var min = require_min();
      function argmin(x) {
        if (isDataFrame(x)) {
          const index = argmin(x.values);
          return [x.index[index[0]], x.columns[index[1]]];
        }
        if (isSeries(x)) {
          const index = argmin(x.values);
          return [x.index[index]];
        }
        assert(
          isArray(x),
          "The `argmin` function only works on arrays, Series, and DataFrames!"
        );
        try {
          const out = indexOf(x, min(x));
          if (out) {
            if (out.length === 0) {
              return void 0;
            } else if (out.length === 1) {
              return out[0];
            } else {
              return out;
            }
          } else {
            return void 0;
          }
        } catch (e) {
          return void 0;
        }
      }
      module.exports = argmin;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/cast.js
  var require_cast = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/cast.js"(exports, module) {
      var isArray = require_is_array();
      var isBoolean = require_is_boolean();
      var isDataFrame = require_is_dataframe();
      var isEqual = require_is_equal();
      var isNumber = require_is_number();
      var isObject = require_is_object();
      var isSeries = require_is_series();
      var isUndefined = require_is_undefined();
      function cast(value, type) {
        if (isDataFrame(value) || isSeries(value)) {
          return value.apply((item) => cast(item, type));
        }
        if (isArray(value)) {
          return value.map((v) => cast(v, type));
        }
        if (type === "null") {
          return null;
        }
        if (type === "number") {
          if (isUndefined(value)) {
            return NaN;
          }
          const booleanValue = cast(value, "boolean");
          if (isBoolean(booleanValue)) {
            return booleanValue ? 1 : 0;
          }
          try {
            JSON.parse(value);
          } catch (e) {
            const dateValue = cast(value, "date");
            if (dateValue instanceof Date) {
              return dateValue.getTime();
            }
          }
          const out = parseFloat(value);
          if (isNaN(out))
            return NaN;
          return out;
        }
        if (type === "boolean") {
          if (isBoolean(value)) {
            return value;
          }
          if (isNumber(value)) {
            if (value === 0) {
              return false;
            }
            if (value === 1) {
              return true;
            }
            return null;
          }
          try {
            const vBool = (typeof value === "object" ? value.toString() === "null" ? "false" : JSON.stringify(value) : value.toString()).trim().toLowerCase();
            if (vBool === "true" || vBool === "yes" || vBool === "y") {
              return true;
            }
            if (vBool === "false" || vBool === "no" || vBool === "n") {
              return false;
            }
            return null;
          } catch (e) {
            return null;
          }
        }
        if (type === "date") {
          if (value instanceof Date) {
            return value;
          }
          if (isUndefined(value)) {
            return null;
          }
          const valueFloat = parseFloat(value);
          if (!isNaN(valueFloat)) {
            const out = new Date(value);
            if (out.toString() === "Invalid Date")
              return null;
            return out;
          }
          const valueDate = Date.parse(value);
          if (!isNaN(valueDate)) {
            return new Date(valueDate);
          }
          return null;
        }
        if (type === "object") {
          if (isObject(value)) {
            return value;
          }
          const booleanValue = cast(value, "boolean");
          if (isBoolean(booleanValue)) {
            return null;
          }
          try {
            const numberValue = cast(value, "number");
            if (isNumber(numberValue)) {
              JSON.parse(value);
              return null;
            }
          } catch (e) {
          }
          const dateValue = cast(value, "date");
          if (dateValue) {
            return dateValue;
          }
          try {
            const out = JSON.parse(value);
            if (isArray(out)) {
              return out.map((v) => cast(v, type));
            } else {
              return out;
            }
          } catch (e) {
            return null;
          }
        }
        if (type === "string") {
          if (isUndefined(value)) {
            if (isEqual(value, void 0)) {
              return "undefined";
            }
            return "null";
          }
          if (value instanceof Date) {
            return value.toJSON();
          }
          const valueString = (() => {
            if (typeof value === "object") {
              if (value === null) {
                return "null";
              } else {
                return JSON.stringify(value);
              }
            } else {
              return value.toString();
            }
          })();
          return valueString;
        }
      }
      module.exports = cast;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/ceil.js
  var require_ceil = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/ceil.js"(exports, module) {
      var isNumber = require_is_number();
      var vectorize = require_vectorize();
      function ceil(x) {
        try {
          if (!isNumber(x))
            return NaN;
          return Math.ceil(x);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(ceil);
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/chop.js
  var require_chop = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/chop.js"(exports, module) {
      var abs = require_abs();
      var isNumber = require_is_number();
      var isUndefined = require_is_undefined();
      var vectorize = require_vectorize();
      function chop(x, threshold) {
        try {
          if (!isNumber(x))
            return NaN;
          if (isUndefined(threshold)) {
            threshold = 1e-10;
          } else if (!isNumber(threshold)) {
            return NaN;
          }
          return abs(x) < threshold ? 0 : x;
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(chop);
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/clamp.js
  var require_clamp = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/clamp.js"(exports, module) {
      var isNumber = require_is_number();
      var vectorize = require_vectorize();
      function clamp(x, a, b) {
        try {
          if (!isNumber(x))
            return NaN;
          if (!isNumber(a))
            return NaN;
          if (!isNumber(b))
            return NaN;
          if (x < a)
            return a;
          if (x > b)
            return b;
          return x;
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(clamp);
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/combinations.js
  var require_combinations = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/combinations.js"(exports, module) {
      var assert = require_assert();
      var flatten = require_flatten();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isNumber = require_is_number();
      var isSeries = require_is_series();
      function combinations(arr, r) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return combinations(arr.values, r);
        }
        assert(
          isArray(arr),
          "The `combinations` function only works on arrays, Series, and DataFrames!"
        );
        assert(isNumber(r), "`r` must be a whole number!");
        arr = flatten(arr);
        if (r > arr.length) {
          return [arr];
        }
        if (r <= 0) {
          return [[]];
        }
        assert(r === parseInt(r), "`r` must be a whole number!");
        if (arr.length < 2)
          return arr;
        const out = [];
        arr.forEach((item, i) => {
          const after = arr.slice(i + 1);
          if (after.length < r - 1)
            return;
          const children = combinations(after, r - 1);
          children.forEach((child) => {
            out.push([item].concat(child));
          });
        });
        return out;
      }
      module.exports = combinations;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/mean.js
  var require_mean = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/mean.js"(exports, module) {
      var assert = require_assert();
      var flatten = require_flatten();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isSeries = require_is_series();
      function mean(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return mean(arr.values);
        }
        assert(
          isArray(arr),
          "The `mean` function only works on arrays, Series, and DataFrames!"
        );
        try {
          const temp = flatten(arr);
          let out = 0;
          temp.forEach((v) => {
            out += v;
          });
          return out / temp.length;
        } catch (e) {
          return NaN;
        }
      }
      module.exports = mean;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/covariance.js
  var require_covariance = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/covariance.js"(exports, module) {
      var assert = require_assert();
      var isArray = require_is_array();
      var isNumber = require_is_number();
      var isSeries = require_is_series();
      var mean = require_mean();
      var shape = require_shape();
      function covariance(x, y) {
        if (isSeries(x)) {
          return covariance(x.values, y);
        }
        if (isSeries(y)) {
          return covariance(x, y.values);
        }
        assert(
          isArray(x) && isArray(y) && shape(x).length === 1 && shape(y).length === 1,
          "The `covariance` function only works on 1-dimensional arrays and Series!"
        );
        assert(
          x.length === y.length,
          "The two arrays or Series passed into the `covariance` function must have the same length!"
        );
        try {
          const mx = mean(x);
          const my = mean(y);
          if (!isNumber(mx) || !isNumber(my)) {
            return NaN;
          }
          const n = Math.max(x.length, y.length);
          let out = 0;
          for (let i = 0; i < n; i++) {
            if (!isNumber(x[i]))
              return NaN;
            if (!isNumber(y[i]))
              return NaN;
            out += (x[i] - mx) * (y[i] - my);
          }
          return out / x.length;
        } catch (e) {
          return NaN;
        }
      }
      module.exports = covariance;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/sqrt.js
  var require_sqrt = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/sqrt.js"(exports, module) {
      var isNumber = require_is_number();
      var vectorize = require_vectorize();
      function sqrt(x) {
        try {
          if (!isNumber(x))
            return NaN;
          return Math.sqrt(x);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(sqrt);
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/variance.js
  var require_variance = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/variance.js"(exports, module) {
      var assert = require_assert();
      var flatten = require_flatten();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isNumber = require_is_number();
      var isSeries = require_is_series();
      var mean = require_mean();
      function variance(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return variance(arr.values);
        }
        assert(
          isArray(arr),
          "The `variance` function only works on arrays, Series, and DataFrames!"
        );
        try {
          const temp = flatten(arr);
          const m = mean(temp);
          let out = 0;
          for (let i = 0; i < temp.length; i++) {
            if (!isNumber(temp[i]))
              return NaN;
            out += (temp[i] - m) * (temp[i] - m);
          }
          return out / temp.length;
        } catch (e) {
          return NaN;
        }
      }
      module.exports = variance;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/std.js
  var require_std = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/std.js"(exports, module) {
      var assert = require_assert();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isSeries = require_is_series();
      var sqrt = require_sqrt();
      var variance = require_variance();
      function std(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return std(arr.values);
        }
        assert(
          isArray(arr),
          "The `std` function only works on arrays, Series, and DataFrames!"
        );
        try {
          return sqrt(variance(arr));
        } catch (e) {
          return NaN;
        }
      }
      module.exports = std;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/correl.js
  var require_correl = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/correl.js"(exports, module) {
      var assert = require_assert();
      var covariance = require_covariance();
      var isArray = require_is_array();
      var isSeries = require_is_series();
      var shape = require_shape();
      var std = require_std();
      function correl(x, y) {
        if (isSeries(x)) {
          return correl(x.values, y);
        }
        if (isSeries(y)) {
          return correl(x, y.values);
        }
        assert(
          isArray(x) && isArray(y) && shape(x).length === 1 && shape(y).length === 1,
          "The `correl` function only works on 1-dimensional arrays and Series!"
        );
        assert(
          x.length === y.length,
          "The two arrays or Series passed into the `correl` function must have the same length!"
        );
        try {
          return covariance(x, y) / (std(x) * std(y));
        } catch (e) {
          return NaN;
        }
      }
      module.exports = correl;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/cos.js
  var require_cos = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/cos.js"(exports, module) {
      var isNumber = require_is_number();
      var vectorize = require_vectorize();
      function cos(x) {
        try {
          if (!isNumber(x))
            return NaN;
          return Math.cos(x);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(cos);
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/helpers/data-types.js
  var require_data_types = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/helpers/data-types.js"(exports, module) {
      module.exports = Object.freeze({
        boolean: "boolean",
        date: "date",
        null: "null",
        number: "number",
        object: "object",
        string: "string"
      });
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/diff.js
  var require_diff = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/diff.js"(exports, module) {
      var assert = require_assert();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isEqual = require_is_equal();
      var isSeries = require_is_series();
      var set = require_set();
      function diff(a, b) {
        if (isDataFrame(a) || isSeries(a)) {
          return diff(a.values, b);
        }
        if (isDataFrame(b) || isSeries(b)) {
          return diff(a, b.values);
        }
        assert(
          isArray(a) && isArray(b),
          "The `diff` function only works on arrays, Series, and DataFrames!"
        );
        const aTemp = set(a);
        const bTemp = set(b);
        const out = [];
        aTemp.forEach((item) => {
          if (bTemp.findIndex((other) => isEqual(other, item)) < 0) {
            out.push(item);
          }
        });
        return out;
      }
      module.exports = diff;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/pow.js
  var require_pow = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/pow.js"(exports, module) {
      var isNumber = require_is_number();
      var vectorize = require_vectorize();
      function pow(x, p) {
        try {
          if (!isNumber(x))
            return NaN;
          if (!isNumber(p))
            return NaN;
          return Math.pow(x, p);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(pow);
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/multiply.js
  var require_multiply = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/multiply.js"(exports, module) {
      var isNumber = require_is_number();
      var vectorize = require_vectorize();
      function multiply() {
        try {
          const values = Object.values(arguments);
          if (values.length === 0)
            return NaN;
          let out = 1;
          for (let i = 0; i < values.length; i++) {
            if (!isNumber(values[i]))
              return NaN;
            out *= values[i];
          }
          return out;
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(multiply);
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/scale.js
  var require_scale = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/scale.js"(exports, module) {
      var multiply = require_multiply();
      function scale() {
        return multiply(...arguments);
      }
      module.exports = scale;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/subtract.js
  var require_subtract = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/subtract.js"(exports, module) {
      var add = require_add();
      var scale = require_scale();
      function subtract(a, b) {
        return add(a, scale(b, -1));
      }
      module.exports = subtract;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/sum.js
  var require_sum = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/sum.js"(exports, module) {
      var assert = require_assert();
      var flatten = require_flatten();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isSeries = require_is_series();
      function sum(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return sum(arr.values);
        }
        assert(
          isArray(arr),
          "The `sum` function only works on arrays, Series, and DataFrames!"
        );
        try {
          if (arr.length === 0)
            return NaN;
          return flatten(arr).reduce((a, b) => a + b, 0);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = sum;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/distance.js
  var require_distance = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/distance.js"(exports, module) {
      var abs = require_abs();
      var assert = require_assert();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isEqual = require_is_equal();
      var isNumber = require_is_number();
      var isSeries = require_is_series();
      var pow = require_pow();
      var shape = require_shape();
      var sqrt = require_sqrt();
      var subtract = require_subtract();
      var sum = require_sum();
      function distance(a, b) {
        if (isNumber(a) && isNumber(b)) {
          return abs(a - b);
        }
        if (isDataFrame(a) || isSeries(a)) {
          return distance(a.values, b);
        }
        if (isDataFrame(b) || isSeries(b)) {
          return distance(a, b.values);
        }
        if (isArray(a) && isArray(b)) {
          assert(
            isEqual(shape(a), shape(b)),
            "If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!"
          );
        }
        try {
          return sqrt(sum(pow(subtract(a, b), 2)));
        } catch (e) {
          return NaN;
        }
      }
      module.exports = distance;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/divide.js
  var require_divide = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/divide.js"(exports, module) {
      var pow = require_pow();
      var scale = require_scale();
      function divide(a, b) {
        return scale(a, pow(b, -1));
      }
      module.exports = divide;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dot.js
  var require_dot = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/dot.js"(exports, module) {
      var { DataFrame, Series } = require_dataframe();
      var assert = require_assert();
      var flatten = require_flatten();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isNumber = require_is_number();
      var isSeries = require_is_series();
      var scale = require_scale();
      var shape = require_shape();
      var sum = require_sum();
      var transpose = require_transpose();
      function dot(a, b) {
        if (isDataFrame(a)) {
          const temp = dot(a.values, b);
          if (shape(temp).length === 1) {
            const out = new Series(temp);
            out.name = isSeries(b) ? b.name : out.name;
            out.index = a.index.slice();
            return out;
          } else {
            const out = new DataFrame(temp);
            out.index = a.index.slice();
            if (isDataFrame(b)) {
              out.columns = b.columns.slice();
            }
            return out;
          }
        }
        if (isDataFrame(b)) {
          const temp = dot(a, b.values);
          if (shape(temp).length === 1) {
            const out = new Series(temp);
            out.name = isSeries(a) ? a.name : out.name;
            out.index = b.columns.slice();
            return out;
          } else {
            const out = new DataFrame(temp);
            out.columns = b.columns.slice();
            return out;
          }
        }
        if (isSeries(a)) {
          return dot(a.values, b);
        }
        if (isSeries(b)) {
          return dot(a, b.values);
        }
        assert(
          isArray(a) && isArray(b),
          "The `dot` function only works on arrays, Series, and DataFrames!"
        );
        flatten(a).concat(flatten(b)).forEach((v) => {
          assert(
            isNumber(v),
            "One of the arrays you passed into the `dot` function contains non-numerical values!"
          );
        });
        const aShape = shape(a);
        const bShape = shape(b);
        assert(
          aShape.length <= 2 && bShape.length <= 2,
          "I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"
        );
        assert(
          aShape[aShape.length - 1] === bShape[0],
          `There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${aShape[aShape.length - 1]} !== ${bShape[0]})`
        );
        if (aShape.length === 1 && bShape.length === 1) {
          return sum(scale(a, b));
        } else if (aShape.length === 1 && bShape.length === 2) {
          return transpose(b).map((col) => dot(a, col));
        } else if (aShape.length === 2 && bShape.length === 1) {
          return a.map((row) => dot(row, b));
        } else if (aShape.length === 2 && bShape.length === 2) {
          const bTranspose = transpose(b);
          const out = [];
          for (let i = 0; i < a.length; i++) {
            const row = [];
            for (let j = 0; j < bTranspose.length; j++) {
              row.push(dot(a[i], bTranspose[j]));
            }
            out.push(row);
          }
          return out;
        }
      }
      module.exports = dot;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/drop-missing.js
  var require_drop_missing = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/drop-missing.js"(exports, module) {
      var assert = require_assert();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isSeries = require_is_series();
      var isUndefined = require_is_undefined();
      function dropMissing(x) {
        if (isDataFrame(x) || isSeries(x)) {
          return x.dropMissing(...Object.values(arguments).slice(1));
        }
        assert(
          isArray(x),
          "The `dropMissing` function only works on arrays, Series, and DataFrames!"
        );
        const out = [];
        x.forEach((v) => {
          try {
            return out.push(dropMissing(v));
          } catch (e) {
            if (!isUndefined(v)) {
              out.push(v);
            }
          }
        });
        return out;
      }
      module.exports = dropMissing;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/drop-missing-pairwise.js
  var require_drop_missing_pairwise = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/drop-missing-pairwise.js"(exports, module) {
      var assert = require_assert();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isEqual = require_is_equal();
      var isSeries = require_is_series();
      var isUndefined = require_is_undefined();
      var shape = require_shape();
      function dropMissingPairwise(a, b) {
        if (isDataFrame(a) || isSeries(a)) {
          return dropMissingPairwise(a.values, b);
        }
        if (isDataFrame(b) || isSeries(b)) {
          return dropMissingPairwise(a, b.values);
        }
        assert(
          isArray(a) && isArray(b),
          "The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"
        );
        assert(
          isEqual(shape(a), shape(b)),
          "The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!"
        );
        const aOut = [];
        const bOut = [];
        for (let i = 0; i < a.length; i++) {
          try {
            const [aChildren, bChildren] = dropMissingPairwise(a[i], b[i]);
            aOut.push(aChildren);
            bOut.push(bChildren);
          } catch (e) {
            if (!isUndefined(a[i]) && !isUndefined(b[i])) {
              aOut.push(a[i]);
              bOut.push(b[i]);
            }
          }
        }
        return [aOut, bOut];
      }
      module.exports = dropMissingPairwise;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/drop-nan-pairwise.js
  var require_drop_nan_pairwise = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/drop-nan-pairwise.js"(exports, module) {
      var assert = require_assert();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isEqual = require_is_equal();
      var isNumber = require_is_number();
      var isSeries = require_is_series();
      var shape = require_shape();
      function dropNaNPairwise(a, b) {
        if (isDataFrame(a) || isSeries(a)) {
          return dropNaNPairwise(a.values, b);
        }
        if (isDataFrame(b) || isSeries(b)) {
          return dropNaNPairwise(a, b.values);
        }
        assert(
          isArray(a) && isArray(b),
          "The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"
        );
        assert(
          isEqual(shape(a), shape(b)),
          "The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!"
        );
        const aOut = [];
        const bOut = [];
        for (let i = 0; i < a.length; i++) {
          try {
            const [aChildren, bChildren] = dropNaNPairwise(a[i], b[i]);
            aOut.push(aChildren);
            bOut.push(bChildren);
          } catch (e) {
            if (isNumber(a[i]) && isNumber(b[i])) {
              aOut.push(a[i]);
              bOut.push(b[i]);
            }
          }
        }
        return [aOut, bOut];
      }
      module.exports = dropNaNPairwise;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/drop-undefined.js
  var require_drop_undefined = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/drop-undefined.js"(exports, module) {
      var dropMissing = require_drop_missing();
      function dropUndefined(x) {
        return dropMissing(x);
      }
      module.exports = dropUndefined;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/exp.js
  var require_exp = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/exp.js"(exports, module) {
      var isNumber = require_is_number();
      var vectorize = require_vectorize();
      function exp(x) {
        try {
          if (!isNumber(x))
            return NaN;
          return Math.exp(x);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(exp);
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/factorial.js
  var require_factorial = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/factorial.js"(exports, module) {
      var vectorize = require_vectorize();
      function factorial(n) {
        try {
          if (n !== parseInt(n))
            return NaN;
          if (n <= 1)
            return 1;
          return n * factorial(n - 1);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(factorial);
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/find.js
  var require_find = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/find.js"(exports, module) {
      var assert = require_assert();
      var flatten = require_flatten();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isFunction = require_is_function();
      var isObject = require_is_object();
      var isSeries = require_is_series();
      function find(x, fn) {
        if (isDataFrame(x)) {
          return find(flatten(x.values), fn);
        }
        if (isSeries(x)) {
          return find(x.values, fn);
        }
        assert(
          isObject(x) || isArray(x),
          "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"
        );
        if (!isFunction(fn)) {
          const value = fn;
          fn = (v) => v === value;
        }
        function helper(x2, fn2, checked) {
          checked = checked || [];
          if (checked.indexOf(x2) > -1) {
            return null;
          }
          if (isObject(x2)) {
            checked.push(x2);
            const keys = Object.keys(x2);
            for (let i = 0; i < keys.length; i++) {
              const key = keys[i];
              const value = x2[key];
              if (fn2(value)) {
                return value;
              }
              const result = helper(value, fn2, checked);
              if (result) {
                return result;
              }
            }
          } else if (isArray(x2)) {
            checked.push(x2);
            for (let i = 0; i < x2.length; i++) {
              const value = x2[i];
              if (fn2(value)) {
                return value;
              }
              const result = helper(value, fn2, checked);
              if (result) {
                return result;
              }
            }
          } else {
            if (fn2(x2)) {
              return x2;
            }
          }
          return null;
        }
        function safeFn(v) {
          try {
            return fn(v);
          } catch (e) {
            return false;
          }
        }
        return helper(x, safeFn);
      }
      module.exports = find;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/find-all.js
  var require_find_all = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/find-all.js"(exports, module) {
      var assert = require_assert();
      var flatten = require_flatten();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isFunction = require_is_function();
      var isObject = require_is_object();
      var isSeries = require_is_series();
      function findAll(x, fn) {
        if (isDataFrame(x)) {
          return findAll(flatten(x.values), fn);
        }
        if (isSeries(x)) {
          return findAll(x.values, fn);
        }
        assert(
          isObject(x) || isArray(x),
          "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"
        );
        if (!isFunction(fn)) {
          const value = fn;
          fn = (v) => v === value;
        }
        function helper(x2, fn2, checked) {
          checked = checked || [];
          if (checked.indexOf(x2) > -1) {
            return null;
          }
          if (isObject(x2)) {
            checked.push(x2);
            const keys = Object.keys(x2);
            const out = [];
            for (let i = 0; i < keys.length; i++) {
              const key = keys[i];
              const value = x2[key];
              let alreadyStoredThisValue = false;
              if (fn2(value)) {
                out.push(value);
                alreadyStoredThisValue = true;
              }
              const results2 = helper(value, fn2, checked);
              if (results2 && results2.length > 0) {
                results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out.push(r));
              }
            }
            return out;
          } else if (isArray(x2)) {
            checked.push(x2);
            const out = [];
            for (let i = 0; i < x2.length; i++) {
              const value = x2[i];
              let alreadyStoredThisValue = false;
              if (fn2(value)) {
                out.push(value);
                alreadyStoredThisValue = true;
              }
              const results2 = helper(value, fn2, checked);
              if (results2 && results2.length > 0) {
                results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out.push(r));
              }
            }
            return out;
          } else {
            if (fn2(x2)) {
              return [x2];
            }
          }
          return null;
        }
        function safeFn(v) {
          try {
            return fn(v);
          } catch (e) {
            return false;
          }
        }
        const results = helper(x, safeFn);
        if (results && results.length > 0) {
          return results;
        } else {
          return null;
        }
      }
      module.exports = findAll;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/float.js
  var require_float = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/float.js"(exports, module) {
      var isNumber = require_is_number();
      var vectorize = require_vectorize();
      function float(x) {
        try {
          if (x === "Infinity") {
            return Infinity;
          }
          if (x === "-Infinity") {
            return -Infinity;
          }
          const out = JSON.parse(x);
          if (isNumber(out))
            return out;
          return NaN;
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(float);
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/floor.js
  var require_floor = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/floor.js"(exports, module) {
      var isNumber = require_is_number();
      var vectorize = require_vectorize();
      function floor(x) {
        try {
          if (!isNumber(x))
            return NaN;
          return Math.floor(x);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(floor);
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/zeros.js
  var require_zeros = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/zeros.js"(exports, module) {
      var isNumber = require_is_number();
      var product = require_product();
      var reshape = require_reshape();
      function zeros(shape) {
        if (isNumber(shape))
          shape = [shape];
        const out = [];
        const n = product(shape);
        for (let i = 0; i < n; i++)
          out.push(0);
        return reshape(out, shape);
      }
      module.exports = zeros;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/identity.js
  var require_identity = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/identity.js"(exports, module) {
      var assert = require_assert();
      var isNumber = require_is_number();
      var isUndefined = require_is_undefined();
      var zeros = require_zeros();
      function identity(size) {
        assert(
          !isUndefined(size),
          "You must pass an integer greater than 0 (representing the size) into the `identity` function!"
        );
        assert(
          isNumber(size),
          "You must pass an integer greater than 0 (representing the size) into the `identity` function!"
        );
        assert(
          parseInt(size) === size,
          "You must pass an integer greater than 0 (representing the size) into the `identity` function!"
        );
        assert(
          size > 0,
          "You must pass an integer greater than 0 (representing the size) into the `identity` function!"
        );
        const out = zeros([size, size]);
        for (let i = 0; i < size; i++)
          out[i][i] = 1;
        return out;
      }
      module.exports = identity;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/helpers/boolean-values.js
  var require_boolean_values = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/helpers/boolean-values.js"(exports, module) {
      module.exports = ["true", "false", "yes", "no"];
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/helpers/null-values.js
  var require_null_values = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/helpers/null-values.js"(exports, module) {
      module.exports = ["null", "none", "nan", "na", "n/a", "", "undefined"];
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/infer-type.js
  var require_infer_type = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/infer-type.js"(exports, module) {
      var apply = require_apply();
      var assert = require_assert();
      var booleanValues = require_boolean_values();
      var cast = require_cast();
      var count = require_count();
      var flatten = require_flatten();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isNumber = require_is_number();
      var isSeries = require_is_series();
      var isString = require_is_string();
      var nullValues = require_null_values();
      function inferType(arr) {
        if (isDataFrame(arr)) {
          const out = arr.copy();
          const results = inferType(arr.values);
          out.values = results.values;
          return { type: results.type, values: out };
        }
        if (isSeries(arr)) {
          const out = arr.copy();
          const results = inferType(arr.values);
          out.values = results.values;
          return { type: results.type, values: out };
        }
        if (!isArray(arr)) {
          const out = inferType([arr]);
          out.value = out.values[0];
          delete out.values;
          return out;
        }
        assert(
          isArray(arr),
          "The `inferType` function only works on arrays, Series, and DataFrames!"
        );
        const types = flatten(arr).map((v) => {
          if (v === void 0)
            return "null";
          try {
            if (typeof v === "object") {
              const temp = new Date(v.toString());
              if (temp instanceof Date && temp.toString() !== "Invalid Date") {
                return "date";
              }
            }
          } catch (e) {
          }
          if (!isString(v)) {
            v = JSON.stringify(v);
          }
          const vLower = v.toLowerCase();
          const vLowerTrimmed = vLower.trim();
          if (nullValues.indexOf(vLowerTrimmed) > -1) {
            return "null";
          }
          if (booleanValues.indexOf(vLowerTrimmed) > -1) {
            return "boolean";
          }
          try {
            const vParsed = JSON.parse(v);
            if (isNumber(vParsed)) {
              return "number";
            }
            if (typeof vParsed === "object") {
              if (isArray(vParsed))
                return "string";
              return "object";
            }
            return "string";
          } catch (e) {
            const vDate = new Date(v);
            if (vDate.toString() !== "Invalid Date") {
              return "date";
            }
            return "string";
          }
        });
        const counts = count(types).sort((a, b) => b.count - a.count);
        const primaryType = counts[0].value;
        return { type: primaryType, values: apply(arr, (v) => cast(v, primaryType)) };
      }
      module.exports = inferType;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/int.js
  var require_int = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/int.js"(exports, module) {
      var isNumber = require_is_number();
      var vectorize = require_vectorize();
      function int(x) {
        try {
          const out = JSON.parse(x);
          if (isNumber(out))
            return parseInt(out);
          return NaN;
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(int);
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/intersect.js
  var require_intersect = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/intersect.js"(exports, module) {
      var assert = require_assert();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isEqual = require_is_equal();
      var isSeries = require_is_series();
      var set = require_set();
      function intersect() {
        const arrays = Object.values(arguments).map((x) => {
          if (isDataFrame(x) || isSeries(x)) {
            return set(x.values);
          }
          assert(
            isArray(x),
            "The `intersect` function only works on arrays, Series, and DataFrames!"
          );
          return set(x);
        });
        const all = set(arrays);
        return all.filter((v) => {
          return arrays.every((arr) => arr.findIndex((other) => isEqual(other, v)) > -1);
        });
      }
      module.exports = intersect;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/inverse.js
  var require_inverse = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/inverse.js"(exports, module) {
      var add = require_add();
      var assert = require_assert();
      var dot = require_dot();
      var flatten = require_flatten();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isNumber = require_is_number();
      var scale = require_scale();
      var shape = require_shape();
      function inverse(x) {
        if (isDataFrame(x)) {
          const out = x.copy();
          out.values = inverse(out.values);
          return out;
        }
        assert(
          isArray(x),
          "The `inverse` function only works on square 2-dimensional arrays or DataFrames!"
        );
        flatten(x).forEach(
          (v) => assert(
            isNumber(v),
            "The array passed into the `inverse` function must contain only numbers!"
          )
        );
        const xShape = shape(x);
        assert(
          xShape.length === 2,
          "The array passed into the `inverse` function must be exactly two-dimensional and square!"
        );
        assert(
          xShape[0] === xShape[1],
          "The array passed into the `inverse` function must be exactly two-dimensional and square!"
        );
        assert(
          xShape[0] >= 0,
          "The array passed into the `inverse` function must be exactly two-dimensional and square!"
        );
        if (xShape[0] === 0) {
          return x;
        } else if (xShape[0] === 1) {
          assert(x[0][0] !== 0, "This matrix cannot be inverted!");
          return 1 / x[0][0];
        } else if (xShape[0] === 2) {
          const a = x[0][0];
          const b = x[0][1];
          const c = x[1][0];
          const d = x[1][1];
          const det = a * d - b * c;
          assert(det !== 0, "This matrix cannot be inverted!");
          const out = [
            [d, -b],
            [-c, a]
          ];
          return scale(out, 1 / det);
        } else if (xShape[0] > 1) {
          const times = (a, b) => isNumber(a) || isNumber(b) ? scale(a, b) : dot(a, b);
          for (let divider = 1; divider < xShape[0] - 1; divider++) {
            try {
              const A = x.slice(0, divider).map((row) => row.slice(0, divider));
              const B = x.slice(0, divider).map((row) => row.slice(divider, xShape[0]));
              const C = x.slice(divider, xShape[0]).map((row) => row.slice(0, divider));
              const D = x.slice(divider, xShape[0]).map((row) => row.slice(divider, xShape[0]));
              const AInv = inverse(A);
              const CompInv = inverse(add(D, times(-1, times(times(C, AInv), B))));
              const topLeft = add(
                AInv,
                times(times(times(times(AInv, B), CompInv), C), AInv)
              );
              const topRight = times(-1, times(times(AInv, B), CompInv));
              const bottomLeft = times(-1, times(times(CompInv, C), AInv));
              const bottomRight = CompInv;
              const out = topLeft.map((row, i) => row.concat(topRight[i])).concat(bottomLeft.map((row, i) => row.concat(bottomRight[i])));
              return out;
            } catch (e) {
            }
          }
          assert(false, "This matrix cannot be inverted!");
        }
      }
      module.exports = inverse;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/helpers/is-browser.js
  var require_is_browser = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/helpers/is-browser.js"(exports, module) {
      var isBrowser = new Function(
        `
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `
      );
      module.exports = isBrowser;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/lerp.js
  var require_lerp = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/lerp.js"(exports, module) {
      var isNumber = require_is_number();
      var vectorize = require_vectorize();
      function lerp(a, b, f) {
        try {
          if (!isNumber(a))
            return NaN;
          if (!isNumber(b))
            return NaN;
          if (!isNumber(f))
            return NaN;
          return f * (b - a) + a;
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(lerp);
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/log.js
  var require_log = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/log.js"(exports, module) {
      var isNumber = require_is_number();
      var isUndefined = require_is_undefined();
      var vectorize = require_vectorize();
      function log(x, base) {
        try {
          base = isUndefined(base) ? Math.E : base;
          if (!isNumber(x))
            return NaN;
          if (!isNumber(base))
            return NaN;
          return Math.log(x) / Math.log(base);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(log);
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/median.js
  var require_median = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/median.js"(exports, module) {
      var assert = require_assert();
      var flatten = require_flatten();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isSeries = require_is_series();
      var sort = require_sort();
      function median(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return median(arr.values);
        }
        assert(
          isArray(arr),
          "The `median` function only works on arrays, Series, and DataFrames!"
        );
        try {
          const temp = sort(flatten(arr));
          if (temp.length === 0) {
            return NaN;
          } else if (temp.length % 2 === 0) {
            return (temp[temp.length / 2 - 1] + temp[temp.length / 2]) / 2;
          } else {
            return temp[parseInt(temp.length / 2)];
          }
        } catch (e) {
          return NaN;
        }
      }
      module.exports = median;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/mod.js
  var require_mod = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/mod.js"(exports, module) {
      var isNumber = require_is_number();
      var vectorize = require_vectorize();
      function mod(a, b) {
        try {
          if (!isNumber(a))
            return NaN;
          if (!isNumber(b))
            return NaN;
          return a % b;
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(mod);
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/mode.js
  var require_mode = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/mode.js"(exports, module) {
      var assert = require_assert();
      var count = require_count();
      var flatten = require_flatten();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isSeries = require_is_series();
      var set = require_set();
      var sort = require_sort();
      function mode(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return mode(arr.values);
        }
        assert(
          isArray(arr),
          "The `mode` function only works on arrays, Series, and DataFrames!"
        );
        try {
          if (arr.length === 0)
            return NaN;
          const temp = flatten(arr);
          if (temp.length === 0)
            return NaN;
          const counts = {};
          const tempSet = set(temp);
          tempSet.forEach((value) => {
            counts[value] = count(temp, value);
          });
          const sortedTempSet = sort(tempSet, (a, b) => counts[b] - counts[a]);
          const mostCountedValue = sortedTempSet[0];
          const out = sort(
            sortedTempSet.filter((value) => counts[value] === counts[mostCountedValue])
          );
          return out;
        } catch (e) {
          return NaN;
        }
      }
      module.exports = mode;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/normal.js
  var require_normal = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/normal.js"(exports, module) {
      var { random } = require_random();
      var apply = require_apply();
      var isUndefined = require_is_undefined();
      var ndarray = require_ndarray();
      function helper() {
        const u1 = random();
        const u2 = random();
        return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
      }
      function normal(shape) {
        if (isUndefined(shape))
          return helper();
        return apply(ndarray(shape), helper);
      }
      module.exports = normal;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/ones.js
  var require_ones = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/ones.js"(exports, module) {
      var apply = require_apply();
      var ndarray = require_ndarray();
      function ones(shape) {
        return apply(ndarray(shape), () => 1);
      }
      module.exports = ones;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/permutations.js
  var require_permutations = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/permutations.js"(exports, module) {
      var assert = require_assert();
      var flatten = require_flatten();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isNumber = require_is_number();
      var isSeries = require_is_series();
      var isUndefined = require_is_undefined();
      function permutations(arr, r) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return permutations(arr.values, r);
        }
        assert(
          isArray(arr),
          "The `permutations` function only works on arrays, Series, and DataFrames!"
        );
        if (isUndefined(r))
          r = arr.length;
        assert(isNumber(r), "`r` must be a whole number!");
        arr = flatten(arr);
        if (r > arr.length) {
          return permutations(arr);
        }
        if (r <= 0) {
          return [[]];
        }
        assert(r === parseInt(r), "`r` must be a whole number!");
        if (arr.length < 2)
          return arr;
        const out = [];
        arr.forEach((item, i) => {
          const before = arr.slice(0, i);
          const after = arr.slice(i + 1);
          const others = before.concat(after);
          const children = permutations(others, r - 1);
          children.forEach((child) => {
            out.push([item].concat(child));
          });
        });
        return out;
      }
      module.exports = permutations;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/print.js
  var require_print = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/print.js"(exports, module) {
      var { DataFrame, Series } = require_dataframe();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isJagged = require_is_jagged();
      var isSeries = require_is_series();
      var shape = require_shape();
      function print() {
        Object.keys(arguments).forEach((key) => {
          const x = arguments[key];
          if (isArray(x)) {
            if (!isJagged(x)) {
              const xShape = shape(x);
              if (xShape.length === 1) {
                new Series(x).print();
              } else if (xShape.length == 2) {
                new DataFrame(x).print();
              } else {
                console.log(x);
              }
            } else {
              console.log(x);
            }
          } else if (isDataFrame(x) || isSeries(x)) {
            x.print();
          } else {
            console.log(x);
          }
        });
      }
      module.exports = print;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/remap.js
  var require_remap = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/remap.js"(exports, module) {
      var isArray = require_is_array();
      var isNumber = require_is_number();
      var isUndefined = require_is_undefined();
      var max = require_max();
      var min = require_min();
      var vectorize = require_vectorize();
      var helper = vectorize(function(x, a, b, c, d) {
        try {
          if (![x, a, b, c, d].every((v) => isNumber(v))) {
            return NaN;
          }
          if (b - a === 0)
            return NaN;
          return (d - c) * (x - a) / (b - a) + c;
        } catch (e) {
          return NaN;
        }
      });
      function remap(x, a, b, c, d) {
        if (isArray(x) && isUndefined(c) && isUndefined(d)) {
          c = a;
          d = b;
          a = min(x);
          b = max(x);
        }
        return helper(x, a, b, c, d);
      }
      module.exports = remap;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/round.js
  var require_round = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/round.js"(exports, module) {
      var isNumber = require_is_number();
      var vectorize = require_vectorize();
      function round(x) {
        try {
          if (!isNumber(x))
            return NaN;
          return Math.round(x);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(round);
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/sign.js
  var require_sign = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/sign.js"(exports, module) {
      var isNumber = require_is_number();
      var vectorize = require_vectorize();
      function sign(x) {
        try {
          if (!isNumber(x))
            return NaN;
          if (x < 0)
            return -1;
          if (x > 0)
            return 1;
          return 0;
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(sign);
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/sin.js
  var require_sin = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/sin.js"(exports, module) {
      var isNumber = require_is_number();
      var vectorize = require_vectorize();
      function sin(x) {
        try {
          if (!isNumber(x))
            return NaN;
          return Math.sin(x);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(sin);
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/stdev.js
  var require_stdev = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/stdev.js"(exports, module) {
      var std = require_std();
      function stdev(x) {
        return std(x);
      }
      module.exports = stdev;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/tan.js
  var require_tan = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/tan.js"(exports, module) {
      var isNumber = require_is_number();
      var vectorize = require_vectorize();
      function tan(x) {
        try {
          if (!isNumber(x))
            return NaN;
          return Math.tan(x);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(tan);
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/time.js
  var require_time = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/time.js"(exports, module) {
      var assert = require_assert();
      var isFunction = require_is_function();
      function timeSync(fn, args) {
        assert(isFunction(fn), "`fn` must be a function!");
        const start = /* @__PURE__ */ new Date();
        if (args) {
          fn(...args);
        } else {
          fn();
        }
        return /* @__PURE__ */ new Date() - start;
      }
      async function timeAsync(fn, args) {
        assert(isFunction(fn), "`fn` must be a function!");
        const start = /* @__PURE__ */ new Date();
        if (args) {
          await fn(...args);
        } else {
          await fn();
        }
        return /* @__PURE__ */ new Date() - start;
      }
      module.exports = { timeSync, timeAsync };
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/union.js
  var require_union = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/union.js"(exports, module) {
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isSeries = require_is_series();
      var set = require_set();
      function union() {
        return set(
          [...arguments].map((v) => {
            if (isArray(v))
              return v;
            if (isDataFrame(v))
              return v.values;
            if (isSeries(v))
              return v.values;
            return [v];
          })
        );
      }
      module.exports = union;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/zip.js
  var require_zip = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/zip.js"(exports, module) {
      var assert = require_assert();
      var isArray = require_is_array();
      var isDataFrame = require_is_dataframe();
      var isSeries = require_is_series();
      var isUndefined = require_is_undefined();
      var max = require_max();
      var range = require_range();
      function zip() {
        const out = [];
        const arrays = Object.values(arguments).map((arr) => {
          if (isDataFrame(arr) || isSeries(arr)) {
            arr = arr.values;
          }
          assert(
            isArray(arr),
            "The `zip` function only works on arrays, Series, and DataFrames!"
          );
          return arr;
        });
        range(0, max(arrays.map((arr) => arr.length))).forEach((i) => {
          const row = [];
          arrays.forEach((arr) => {
            const value = arr[i];
            row.push(isUndefined(value) ? void 0 : value);
          });
          out.push(row);
        });
        return out;
      }
      module.exports = zip;
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/index.js
  var require_src = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/node_modules/@jrc03c/js-math-tools/src/index.js"(exports, module) {
      var { copy, decycle } = require_copy();
      var { DataFrame, Series } = require_dataframe();
      var out = {
        abs: require_abs(),
        add: require_add(),
        apply: require_apply(),
        arccos: require_arccos(),
        arcsin: require_arcsin(),
        arctan: require_arctan(),
        argmax: require_argmax(),
        argmin: require_argmin(),
        assert: require_assert(),
        cast: require_cast(),
        ceil: require_ceil(),
        chop: require_chop(),
        clamp: require_clamp(),
        combinations: require_combinations(),
        copy,
        correl: require_correl(),
        cos: require_cos(),
        count: require_count(),
        covariance: require_covariance(),
        DataFrame,
        dataTypes: require_data_types(),
        decycle,
        diff: require_diff(),
        distance: require_distance(),
        divide: require_divide(),
        dot: require_dot(),
        dropMissing: require_drop_missing(),
        dropMissingPairwise: require_drop_missing_pairwise(),
        dropNaN: require_drop_nan(),
        dropNaNPairwise: require_drop_nan_pairwise(),
        dropUndefined: require_drop_undefined(),
        exp: require_exp(),
        factorial: require_factorial(),
        find: require_find(),
        findAll: require_find_all(),
        flatten: require_flatten(),
        float: require_float(),
        floor: require_floor(),
        identity: require_identity(),
        indexOf: require_index_of(),
        inferType: require_infer_type(),
        int: require_int(),
        intersect: require_intersect(),
        inverse: require_inverse(),
        isArray: require_is_array(),
        isBoolean: require_is_boolean(),
        isBrowser: require_is_browser(),
        isDataFrame: require_is_dataframe(),
        isEqual: require_is_equal(),
        isFunction: require_is_function(),
        isJagged: require_is_jagged(),
        isNested: require_is_nested(),
        isNumber: require_is_number(),
        isObject: require_is_object(),
        isSeries: require_is_series(),
        isString: require_is_string(),
        isUndefined: require_is_undefined(),
        lerp: require_lerp(),
        log: require_log(),
        MathError: require_math_error(),
        max: require_max(),
        mean: require_mean(),
        median: require_median(),
        min: require_min(),
        mod: require_mod(),
        mode: require_mode(),
        multiply: require_multiply(),
        ndarray: require_ndarray(),
        normal: require_normal(),
        ones: require_ones(),
        permutations: require_permutations(),
        pow: require_pow(),
        print: require_print(),
        product: require_product(),
        random: require_random().random,
        range: require_range(),
        remap: require_remap(),
        reshape: require_reshape(),
        reverse: require_reverse(),
        round: require_round(),
        scale: require_scale(),
        seed: require_random().seed,
        Series,
        set: require_set(),
        shape: require_shape(),
        shuffle: require_shuffle(),
        sign: require_sign(),
        sin: require_sin(),
        sort: require_sort(),
        sqrt: require_sqrt(),
        std: require_std(),
        stdev: require_stdev(),
        subtract: require_subtract(),
        sum: require_sum(),
        tan: require_tan(),
        time: require_time().timeSync,
        timeSync: require_time().timeSync,
        timeAsync: require_time().timeAsync,
        transpose: require_transpose(),
        union: require_union(),
        variance: require_variance(),
        vectorize: require_vectorize(),
        zeros: require_zeros(),
        zip: require_zip(),
        dump: function() {
          const pub = typeof global !== "undefined" ? global : window;
          if (!pub) {
            throw new out.MathError(
              "Cannot dump functions into global scope because neither `global` nor `window` exist in the current context!"
            );
          }
          Object.keys(out).forEach((key) => {
            try {
              Object.defineProperty(pub, key, {
                configurable: false,
                enumerable: true,
                writable: false,
                value: out[key]
              });
            } catch (e) {
              pub[key] = out[key];
            }
          });
        }
      };
      if (typeof module !== "undefined") {
        module.exports = out;
      }
      if (typeof window !== "undefined") {
        window.JSMathTools = out;
      }
    }
  });

  // node_modules/papaparse/papaparse.min.js
  var require_papaparse_min = __commonJS({
    "node_modules/papaparse/papaparse.min.js"(exports, module) {
      !function(e, t) {
        "function" == typeof define && define.amd ? define([], t) : "object" == typeof module && "undefined" != typeof exports ? module.exports = t() : e.Papa = t();
      }(exports, function s() {
        "use strict";
        var f = "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== f ? f : {};
        var n = !f.document && !!f.postMessage, o = n && /blob:/i.test((f.location || {}).protocol), a = {}, h = 0, b = { parse: function(e, t) {
          var i2 = (t = t || {}).dynamicTyping || false;
          M(i2) && (t.dynamicTypingFunction = i2, i2 = {});
          if (t.dynamicTyping = i2, t.transform = !!M(t.transform) && t.transform, t.worker && b.WORKERS_SUPPORTED) {
            var r = function() {
              if (!b.WORKERS_SUPPORTED)
                return false;
              var e2 = (i3 = f.URL || f.webkitURL || null, r2 = s.toString(), b.BLOB_URL || (b.BLOB_URL = i3.createObjectURL(new Blob(["(", r2, ")();"], { type: "text/javascript" })))), t2 = new f.Worker(e2);
              var i3, r2;
              return t2.onmessage = _, t2.id = h++, a[t2.id] = t2;
            }();
            return r.userStep = t.step, r.userChunk = t.chunk, r.userComplete = t.complete, r.userError = t.error, t.step = M(t.step), t.chunk = M(t.chunk), t.complete = M(t.complete), t.error = M(t.error), delete t.worker, void r.postMessage({ input: e, config: t, workerId: r.id });
          }
          var n2 = null;
          b.NODE_STREAM_INPUT, "string" == typeof e ? n2 = t.download ? new l(t) : new p(t) : true === e.readable && M(e.read) && M(e.on) ? n2 = new g(t) : (f.File && e instanceof File || e instanceof Object) && (n2 = new c(t));
          return n2.stream(e);
        }, unparse: function(e, t) {
          var n2 = false, _2 = true, m2 = ",", y2 = "\r\n", s2 = '"', a2 = s2 + s2, i2 = false, r = null, o2 = false;
          !function() {
            if ("object" != typeof t)
              return;
            "string" != typeof t.delimiter || b.BAD_DELIMITERS.filter(function(e2) {
              return -1 !== t.delimiter.indexOf(e2);
            }).length || (m2 = t.delimiter);
            ("boolean" == typeof t.quotes || "function" == typeof t.quotes || Array.isArray(t.quotes)) && (n2 = t.quotes);
            "boolean" != typeof t.skipEmptyLines && "string" != typeof t.skipEmptyLines || (i2 = t.skipEmptyLines);
            "string" == typeof t.newline && (y2 = t.newline);
            "string" == typeof t.quoteChar && (s2 = t.quoteChar);
            "boolean" == typeof t.header && (_2 = t.header);
            if (Array.isArray(t.columns)) {
              if (0 === t.columns.length)
                throw new Error("Option columns is empty");
              r = t.columns;
            }
            void 0 !== t.escapeChar && (a2 = t.escapeChar + s2);
            ("boolean" == typeof t.escapeFormulae || t.escapeFormulae instanceof RegExp) && (o2 = t.escapeFormulae instanceof RegExp ? t.escapeFormulae : /^[=+\-@\t\r].*$/);
          }();
          var h2 = new RegExp(j(s2), "g");
          "string" == typeof e && (e = JSON.parse(e));
          if (Array.isArray(e)) {
            if (!e.length || Array.isArray(e[0]))
              return u2(null, e, i2);
            if ("object" == typeof e[0])
              return u2(r || Object.keys(e[0]), e, i2);
          } else if ("object" == typeof e)
            return "string" == typeof e.data && (e.data = JSON.parse(e.data)), Array.isArray(e.data) && (e.fields || (e.fields = e.meta && e.meta.fields || r), e.fields || (e.fields = Array.isArray(e.data[0]) ? e.fields : "object" == typeof e.data[0] ? Object.keys(e.data[0]) : []), Array.isArray(e.data[0]) || "object" == typeof e.data[0] || (e.data = [e.data])), u2(e.fields || [], e.data || [], i2);
          throw new Error("Unable to serialize unrecognized input");
          function u2(e2, t2, i3) {
            var r2 = "";
            "string" == typeof e2 && (e2 = JSON.parse(e2)), "string" == typeof t2 && (t2 = JSON.parse(t2));
            var n3 = Array.isArray(e2) && 0 < e2.length, s3 = !Array.isArray(t2[0]);
            if (n3 && _2) {
              for (var a3 = 0; a3 < e2.length; a3++)
                0 < a3 && (r2 += m2), r2 += v2(e2[a3], a3);
              0 < t2.length && (r2 += y2);
            }
            for (var o3 = 0; o3 < t2.length; o3++) {
              var h3 = n3 ? e2.length : t2[o3].length, u3 = false, f2 = n3 ? 0 === Object.keys(t2[o3]).length : 0 === t2[o3].length;
              if (i3 && !n3 && (u3 = "greedy" === i3 ? "" === t2[o3].join("").trim() : 1 === t2[o3].length && 0 === t2[o3][0].length), "greedy" === i3 && n3) {
                for (var d2 = [], l2 = 0; l2 < h3; l2++) {
                  var c2 = s3 ? e2[l2] : l2;
                  d2.push(t2[o3][c2]);
                }
                u3 = "" === d2.join("").trim();
              }
              if (!u3) {
                for (var p2 = 0; p2 < h3; p2++) {
                  0 < p2 && !f2 && (r2 += m2);
                  var g2 = n3 && s3 ? e2[p2] : p2;
                  r2 += v2(t2[o3][g2], p2);
                }
                o3 < t2.length - 1 && (!i3 || 0 < h3 && !f2) && (r2 += y2);
              }
            }
            return r2;
          }
          function v2(e2, t2) {
            if (null == e2)
              return "";
            if (e2.constructor === Date)
              return JSON.stringify(e2).slice(1, 25);
            var i3 = false;
            o2 && "string" == typeof e2 && o2.test(e2) && (e2 = "'" + e2, i3 = true);
            var r2 = e2.toString().replace(h2, a2);
            return (i3 = i3 || true === n2 || "function" == typeof n2 && n2(e2, t2) || Array.isArray(n2) && n2[t2] || function(e3, t3) {
              for (var i4 = 0; i4 < t3.length; i4++)
                if (-1 < e3.indexOf(t3[i4]))
                  return true;
              return false;
            }(r2, b.BAD_DELIMITERS) || -1 < r2.indexOf(m2) || " " === r2.charAt(0) || " " === r2.charAt(r2.length - 1)) ? s2 + r2 + s2 : r2;
          }
        } };
        if (b.RECORD_SEP = String.fromCharCode(30), b.UNIT_SEP = String.fromCharCode(31), b.BYTE_ORDER_MARK = "\uFEFF", b.BAD_DELIMITERS = ["\r", "\n", '"', b.BYTE_ORDER_MARK], b.WORKERS_SUPPORTED = !n && !!f.Worker, b.NODE_STREAM_INPUT = 1, b.LocalChunkSize = 10485760, b.RemoteChunkSize = 5242880, b.DefaultDelimiter = ",", b.Parser = E, b.ParserHandle = i, b.NetworkStreamer = l, b.FileStreamer = c, b.StringStreamer = p, b.ReadableStreamStreamer = g, f.jQuery) {
          var d = f.jQuery;
          d.fn.parse = function(o2) {
            var i2 = o2.config || {}, h2 = [];
            return this.each(function(e2) {
              if (!("INPUT" === d(this).prop("tagName").toUpperCase() && "file" === d(this).attr("type").toLowerCase() && f.FileReader) || !this.files || 0 === this.files.length)
                return true;
              for (var t = 0; t < this.files.length; t++)
                h2.push({ file: this.files[t], inputElem: this, instanceConfig: d.extend({}, i2) });
            }), e(), this;
            function e() {
              if (0 !== h2.length) {
                var e2, t, i3, r, n2 = h2[0];
                if (M(o2.before)) {
                  var s2 = o2.before(n2.file, n2.inputElem);
                  if ("object" == typeof s2) {
                    if ("abort" === s2.action)
                      return e2 = "AbortError", t = n2.file, i3 = n2.inputElem, r = s2.reason, void (M(o2.error) && o2.error({ name: e2 }, t, i3, r));
                    if ("skip" === s2.action)
                      return void u2();
                    "object" == typeof s2.config && (n2.instanceConfig = d.extend(n2.instanceConfig, s2.config));
                  } else if ("skip" === s2)
                    return void u2();
                }
                var a2 = n2.instanceConfig.complete;
                n2.instanceConfig.complete = function(e3) {
                  M(a2) && a2(e3, n2.file, n2.inputElem), u2();
                }, b.parse(n2.file, n2.instanceConfig);
              } else
                M(o2.complete) && o2.complete();
            }
            function u2() {
              h2.splice(0, 1), e();
            }
          };
        }
        function u(e) {
          this._handle = null, this._finished = false, this._completed = false, this._halted = false, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = true, this._completeResults = { data: [], errors: [], meta: {} }, function(e2) {
            var t = w(e2);
            t.chunkSize = parseInt(t.chunkSize), e2.step || e2.chunk || (t.chunkSize = null);
            this._handle = new i(t), (this._handle.streamer = this)._config = t;
          }.call(this, e), this.parseChunk = function(e2, t) {
            if (this.isFirstChunk && M(this._config.beforeFirstChunk)) {
              var i2 = this._config.beforeFirstChunk(e2);
              void 0 !== i2 && (e2 = i2);
            }
            this.isFirstChunk = false, this._halted = false;
            var r = this._partialLine + e2;
            this._partialLine = "";
            var n2 = this._handle.parse(r, this._baseIndex, !this._finished);
            if (!this._handle.paused() && !this._handle.aborted()) {
              var s2 = n2.meta.cursor;
              this._finished || (this._partialLine = r.substring(s2 - this._baseIndex), this._baseIndex = s2), n2 && n2.data && (this._rowCount += n2.data.length);
              var a2 = this._finished || this._config.preview && this._rowCount >= this._config.preview;
              if (o)
                f.postMessage({ results: n2, workerId: b.WORKER_ID, finished: a2 });
              else if (M(this._config.chunk) && !t) {
                if (this._config.chunk(n2, this._handle), this._handle.paused() || this._handle.aborted())
                  return void (this._halted = true);
                n2 = void 0, this._completeResults = void 0;
              }
              return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(n2.data), this._completeResults.errors = this._completeResults.errors.concat(n2.errors), this._completeResults.meta = n2.meta), this._completed || !a2 || !M(this._config.complete) || n2 && n2.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = true), a2 || n2 && n2.meta.paused || this._nextChunk(), n2;
            }
            this._halted = true;
          }, this._sendError = function(e2) {
            M(this._config.error) ? this._config.error(e2) : o && this._config.error && f.postMessage({ workerId: b.WORKER_ID, error: e2, finished: false });
          };
        }
        function l(e) {
          var r;
          (e = e || {}).chunkSize || (e.chunkSize = b.RemoteChunkSize), u.call(this, e), this._nextChunk = n ? function() {
            this._readChunk(), this._chunkLoaded();
          } : function() {
            this._readChunk();
          }, this.stream = function(e2) {
            this._input = e2, this._nextChunk();
          }, this._readChunk = function() {
            if (this._finished)
              this._chunkLoaded();
            else {
              if (r = new XMLHttpRequest(), this._config.withCredentials && (r.withCredentials = this._config.withCredentials), n || (r.onload = v(this._chunkLoaded, this), r.onerror = v(this._chunkError, this)), r.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !n), this._config.downloadRequestHeaders) {
                var e2 = this._config.downloadRequestHeaders;
                for (var t in e2)
                  r.setRequestHeader(t, e2[t]);
              }
              if (this._config.chunkSize) {
                var i2 = this._start + this._config.chunkSize - 1;
                r.setRequestHeader("Range", "bytes=" + this._start + "-" + i2);
              }
              try {
                r.send(this._config.downloadRequestBody);
              } catch (e3) {
                this._chunkError(e3.message);
              }
              n && 0 === r.status && this._chunkError();
            }
          }, this._chunkLoaded = function() {
            4 === r.readyState && (r.status < 200 || 400 <= r.status ? this._chunkError() : (this._start += this._config.chunkSize ? this._config.chunkSize : r.responseText.length, this._finished = !this._config.chunkSize || this._start >= function(e2) {
              var t = e2.getResponseHeader("Content-Range");
              if (null === t)
                return -1;
              return parseInt(t.substring(t.lastIndexOf("/") + 1));
            }(r), this.parseChunk(r.responseText)));
          }, this._chunkError = function(e2) {
            var t = r.statusText || e2;
            this._sendError(new Error(t));
          };
        }
        function c(e) {
          var r, n2;
          (e = e || {}).chunkSize || (e.chunkSize = b.LocalChunkSize), u.call(this, e);
          var s2 = "undefined" != typeof FileReader;
          this.stream = function(e2) {
            this._input = e2, n2 = e2.slice || e2.webkitSlice || e2.mozSlice, s2 ? ((r = new FileReader()).onload = v(this._chunkLoaded, this), r.onerror = v(this._chunkError, this)) : r = new FileReaderSync(), this._nextChunk();
          }, this._nextChunk = function() {
            this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
          }, this._readChunk = function() {
            var e2 = this._input;
            if (this._config.chunkSize) {
              var t = Math.min(this._start + this._config.chunkSize, this._input.size);
              e2 = n2.call(e2, this._start, t);
            }
            var i2 = r.readAsText(e2, this._config.encoding);
            s2 || this._chunkLoaded({ target: { result: i2 } });
          }, this._chunkLoaded = function(e2) {
            this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(e2.target.result);
          }, this._chunkError = function() {
            this._sendError(r.error);
          };
        }
        function p(e) {
          var i2;
          u.call(this, e = e || {}), this.stream = function(e2) {
            return i2 = e2, this._nextChunk();
          }, this._nextChunk = function() {
            if (!this._finished) {
              var e2, t = this._config.chunkSize;
              return t ? (e2 = i2.substring(0, t), i2 = i2.substring(t)) : (e2 = i2, i2 = ""), this._finished = !i2, this.parseChunk(e2);
            }
          };
        }
        function g(e) {
          u.call(this, e = e || {});
          var t = [], i2 = true, r = false;
          this.pause = function() {
            u.prototype.pause.apply(this, arguments), this._input.pause();
          }, this.resume = function() {
            u.prototype.resume.apply(this, arguments), this._input.resume();
          }, this.stream = function(e2) {
            this._input = e2, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
          }, this._checkIsFinished = function() {
            r && 1 === t.length && (this._finished = true);
          }, this._nextChunk = function() {
            this._checkIsFinished(), t.length ? this.parseChunk(t.shift()) : i2 = true;
          }, this._streamData = v(function(e2) {
            try {
              t.push("string" == typeof e2 ? e2 : e2.toString(this._config.encoding)), i2 && (i2 = false, this._checkIsFinished(), this.parseChunk(t.shift()));
            } catch (e3) {
              this._streamError(e3);
            }
          }, this), this._streamError = v(function(e2) {
            this._streamCleanUp(), this._sendError(e2);
          }, this), this._streamEnd = v(function() {
            this._streamCleanUp(), r = true, this._streamData("");
          }, this), this._streamCleanUp = v(function() {
            this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
          }, this);
        }
        function i(m2) {
          var a2, o2, h2, r = Math.pow(2, 53), n2 = -r, s2 = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/, u2 = /^(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))$/, t = this, i2 = 0, f2 = 0, d2 = false, e = false, l2 = [], c2 = { data: [], errors: [], meta: {} };
          if (M(m2.step)) {
            var p2 = m2.step;
            m2.step = function(e2) {
              if (c2 = e2, _2())
                g2();
              else {
                if (g2(), 0 === c2.data.length)
                  return;
                i2 += e2.data.length, m2.preview && i2 > m2.preview ? o2.abort() : (c2.data = c2.data[0], p2(c2, t));
              }
            };
          }
          function y2(e2) {
            return "greedy" === m2.skipEmptyLines ? "" === e2.join("").trim() : 1 === e2.length && 0 === e2[0].length;
          }
          function g2() {
            return c2 && h2 && (k("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + b.DefaultDelimiter + "'"), h2 = false), m2.skipEmptyLines && (c2.data = c2.data.filter(function(e2) {
              return !y2(e2);
            })), _2() && function() {
              if (!c2)
                return;
              function e2(e3, t3) {
                M(m2.transformHeader) && (e3 = m2.transformHeader(e3, t3)), l2.push(e3);
              }
              if (Array.isArray(c2.data[0])) {
                for (var t2 = 0; _2() && t2 < c2.data.length; t2++)
                  c2.data[t2].forEach(e2);
                c2.data.splice(0, 1);
              } else
                c2.data.forEach(e2);
            }(), function() {
              if (!c2 || !m2.header && !m2.dynamicTyping && !m2.transform)
                return c2;
              function e2(e3, t3) {
                var i3, r2 = m2.header ? {} : [];
                for (i3 = 0; i3 < e3.length; i3++) {
                  var n3 = i3, s3 = e3[i3];
                  m2.header && (n3 = i3 >= l2.length ? "__parsed_extra" : l2[i3]), m2.transform && (s3 = m2.transform(s3, n3)), s3 = v2(n3, s3), "__parsed_extra" === n3 ? (r2[n3] = r2[n3] || [], r2[n3].push(s3)) : r2[n3] = s3;
                }
                return m2.header && (i3 > l2.length ? k("FieldMismatch", "TooManyFields", "Too many fields: expected " + l2.length + " fields but parsed " + i3, f2 + t3) : i3 < l2.length && k("FieldMismatch", "TooFewFields", "Too few fields: expected " + l2.length + " fields but parsed " + i3, f2 + t3)), r2;
              }
              var t2 = 1;
              !c2.data.length || Array.isArray(c2.data[0]) ? (c2.data = c2.data.map(e2), t2 = c2.data.length) : c2.data = e2(c2.data, 0);
              m2.header && c2.meta && (c2.meta.fields = l2);
              return f2 += t2, c2;
            }();
          }
          function _2() {
            return m2.header && 0 === l2.length;
          }
          function v2(e2, t2) {
            return i3 = e2, m2.dynamicTypingFunction && void 0 === m2.dynamicTyping[i3] && (m2.dynamicTyping[i3] = m2.dynamicTypingFunction(i3)), true === (m2.dynamicTyping[i3] || m2.dynamicTyping) ? "true" === t2 || "TRUE" === t2 || "false" !== t2 && "FALSE" !== t2 && (function(e3) {
              if (s2.test(e3)) {
                var t3 = parseFloat(e3);
                if (n2 < t3 && t3 < r)
                  return true;
              }
              return false;
            }(t2) ? parseFloat(t2) : u2.test(t2) ? new Date(t2) : "" === t2 ? null : t2) : t2;
            var i3;
          }
          function k(e2, t2, i3, r2) {
            var n3 = { type: e2, code: t2, message: i3 };
            void 0 !== r2 && (n3.row = r2), c2.errors.push(n3);
          }
          this.parse = function(e2, t2, i3) {
            var r2 = m2.quoteChar || '"';
            if (m2.newline || (m2.newline = function(e3, t3) {
              e3 = e3.substring(0, 1048576);
              var i4 = new RegExp(j(t3) + "([^]*?)" + j(t3), "gm"), r3 = (e3 = e3.replace(i4, "")).split("\r"), n4 = e3.split("\n"), s4 = 1 < n4.length && n4[0].length < r3[0].length;
              if (1 === r3.length || s4)
                return "\n";
              for (var a3 = 0, o3 = 0; o3 < r3.length; o3++)
                "\n" === r3[o3][0] && a3++;
              return a3 >= r3.length / 2 ? "\r\n" : "\r";
            }(e2, r2)), h2 = false, m2.delimiter)
              M(m2.delimiter) && (m2.delimiter = m2.delimiter(e2), c2.meta.delimiter = m2.delimiter);
            else {
              var n3 = function(e3, t3, i4, r3, n4) {
                var s4, a3, o3, h3;
                n4 = n4 || [",", "	", "|", ";", b.RECORD_SEP, b.UNIT_SEP];
                for (var u3 = 0; u3 < n4.length; u3++) {
                  var f3 = n4[u3], d3 = 0, l3 = 0, c3 = 0;
                  o3 = void 0;
                  for (var p3 = new E({ comments: r3, delimiter: f3, newline: t3, preview: 10 }).parse(e3), g3 = 0; g3 < p3.data.length; g3++)
                    if (i4 && y2(p3.data[g3]))
                      c3++;
                    else {
                      var _3 = p3.data[g3].length;
                      l3 += _3, void 0 !== o3 ? 0 < _3 && (d3 += Math.abs(_3 - o3), o3 = _3) : o3 = _3;
                    }
                  0 < p3.data.length && (l3 /= p3.data.length - c3), (void 0 === a3 || d3 <= a3) && (void 0 === h3 || h3 < l3) && 1.99 < l3 && (a3 = d3, s4 = f3, h3 = l3);
                }
                return { successful: !!(m2.delimiter = s4), bestDelimiter: s4 };
              }(e2, m2.newline, m2.skipEmptyLines, m2.comments, m2.delimitersToGuess);
              n3.successful ? m2.delimiter = n3.bestDelimiter : (h2 = true, m2.delimiter = b.DefaultDelimiter), c2.meta.delimiter = m2.delimiter;
            }
            var s3 = w(m2);
            return m2.preview && m2.header && s3.preview++, a2 = e2, o2 = new E(s3), c2 = o2.parse(a2, t2, i3), g2(), d2 ? { meta: { paused: true } } : c2 || { meta: { paused: false } };
          }, this.paused = function() {
            return d2;
          }, this.pause = function() {
            d2 = true, o2.abort(), a2 = M(m2.chunk) ? "" : a2.substring(o2.getCharIndex());
          }, this.resume = function() {
            t.streamer._halted ? (d2 = false, t.streamer.parseChunk(a2, true)) : setTimeout(t.resume, 3);
          }, this.aborted = function() {
            return e;
          }, this.abort = function() {
            e = true, o2.abort(), c2.meta.aborted = true, M(m2.complete) && m2.complete(c2), a2 = "";
          };
        }
        function j(e) {
          return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }
        function E(e) {
          var S, O = (e = e || {}).delimiter, x = e.newline, I = e.comments, T = e.step, D = e.preview, A = e.fastMode, L = S = void 0 === e.quoteChar || null === e.quoteChar ? '"' : e.quoteChar;
          if (void 0 !== e.escapeChar && (L = e.escapeChar), ("string" != typeof O || -1 < b.BAD_DELIMITERS.indexOf(O)) && (O = ","), I === O)
            throw new Error("Comment character same as delimiter");
          true === I ? I = "#" : ("string" != typeof I || -1 < b.BAD_DELIMITERS.indexOf(I)) && (I = false), "\n" !== x && "\r" !== x && "\r\n" !== x && (x = "\n");
          var F = 0, z = false;
          this.parse = function(r, t, i2) {
            if ("string" != typeof r)
              throw new Error("Input must be a string");
            var n2 = r.length, e2 = O.length, s2 = x.length, a2 = I.length, o2 = M(T), h2 = [], u2 = [], f2 = [], d2 = F = 0;
            if (!r)
              return C();
            if (A || false !== A && -1 === r.indexOf(S)) {
              for (var l2 = r.split(x), c2 = 0; c2 < l2.length; c2++) {
                if (f2 = l2[c2], F += f2.length, c2 !== l2.length - 1)
                  F += x.length;
                else if (i2)
                  return C();
                if (!I || f2.substring(0, a2) !== I) {
                  if (o2) {
                    if (h2 = [], k(f2.split(O)), R(), z)
                      return C();
                  } else
                    k(f2.split(O));
                  if (D && D <= c2)
                    return h2 = h2.slice(0, D), C(true);
                }
              }
              return C();
            }
            for (var p2 = r.indexOf(O, F), g2 = r.indexOf(x, F), _2 = new RegExp(j(L) + j(S), "g"), m2 = r.indexOf(S, F); ; )
              if (r[F] !== S)
                if (I && 0 === f2.length && r.substring(F, F + a2) === I) {
                  if (-1 === g2)
                    return C();
                  F = g2 + s2, g2 = r.indexOf(x, F), p2 = r.indexOf(O, F);
                } else if (-1 !== p2 && (p2 < g2 || -1 === g2))
                  f2.push(r.substring(F, p2)), F = p2 + e2, p2 = r.indexOf(O, F);
                else {
                  if (-1 === g2)
                    break;
                  if (f2.push(r.substring(F, g2)), w2(g2 + s2), o2 && (R(), z))
                    return C();
                  if (D && h2.length >= D)
                    return C(true);
                }
              else
                for (m2 = F, F++; ; ) {
                  if (-1 === (m2 = r.indexOf(S, m2 + 1)))
                    return i2 || u2.push({ type: "Quotes", code: "MissingQuotes", message: "Quoted field unterminated", row: h2.length, index: F }), E2();
                  if (m2 === n2 - 1)
                    return E2(r.substring(F, m2).replace(_2, S));
                  if (S !== L || r[m2 + 1] !== L) {
                    if (S === L || 0 === m2 || r[m2 - 1] !== L) {
                      -1 !== p2 && p2 < m2 + 1 && (p2 = r.indexOf(O, m2 + 1)), -1 !== g2 && g2 < m2 + 1 && (g2 = r.indexOf(x, m2 + 1));
                      var y2 = b2(-1 === g2 ? p2 : Math.min(p2, g2));
                      if (r.substr(m2 + 1 + y2, e2) === O) {
                        f2.push(r.substring(F, m2).replace(_2, S)), r[F = m2 + 1 + y2 + e2] !== S && (m2 = r.indexOf(S, F)), p2 = r.indexOf(O, F), g2 = r.indexOf(x, F);
                        break;
                      }
                      var v2 = b2(g2);
                      if (r.substring(m2 + 1 + v2, m2 + 1 + v2 + s2) === x) {
                        if (f2.push(r.substring(F, m2).replace(_2, S)), w2(m2 + 1 + v2 + s2), p2 = r.indexOf(O, F), m2 = r.indexOf(S, F), o2 && (R(), z))
                          return C();
                        if (D && h2.length >= D)
                          return C(true);
                        break;
                      }
                      u2.push({ type: "Quotes", code: "InvalidQuotes", message: "Trailing quote on quoted field is malformed", row: h2.length, index: F }), m2++;
                    }
                  } else
                    m2++;
                }
            return E2();
            function k(e3) {
              h2.push(e3), d2 = F;
            }
            function b2(e3) {
              var t2 = 0;
              if (-1 !== e3) {
                var i3 = r.substring(m2 + 1, e3);
                i3 && "" === i3.trim() && (t2 = i3.length);
              }
              return t2;
            }
            function E2(e3) {
              return i2 || (void 0 === e3 && (e3 = r.substring(F)), f2.push(e3), F = n2, k(f2), o2 && R()), C();
            }
            function w2(e3) {
              F = e3, k(f2), f2 = [], g2 = r.indexOf(x, F);
            }
            function C(e3) {
              return { data: h2, errors: u2, meta: { delimiter: O, linebreak: x, aborted: z, truncated: !!e3, cursor: d2 + (t || 0) } };
            }
            function R() {
              T(C()), h2 = [], u2 = [];
            }
          }, this.abort = function() {
            z = true;
          }, this.getCharIndex = function() {
            return F;
          };
        }
        function _(e) {
          var t = e.data, i2 = a[t.workerId], r = false;
          if (t.error)
            i2.userError(t.error, t.file);
          else if (t.results && t.results.data) {
            var n2 = { abort: function() {
              r = true, m(t.workerId, { data: [], errors: [], meta: { aborted: true } });
            }, pause: y, resume: y };
            if (M(i2.userStep)) {
              for (var s2 = 0; s2 < t.results.data.length && (i2.userStep({ data: t.results.data[s2], errors: t.results.errors, meta: t.results.meta }, n2), !r); s2++)
                ;
              delete t.results;
            } else
              M(i2.userChunk) && (i2.userChunk(t.results, n2, t.file), delete t.results);
          }
          t.finished && !r && m(t.workerId, t.results);
        }
        function m(e, t) {
          var i2 = a[e];
          M(i2.userComplete) && i2.userComplete(t), i2.terminate(), delete a[e];
        }
        function y() {
          throw new Error("Not implemented.");
        }
        function w(e) {
          if ("object" != typeof e || null === e)
            return e;
          var t = Array.isArray(e) ? [] : {};
          for (var i2 in e)
            t[i2] = w(e[i2]);
          return t;
        }
        function v(e, t) {
          return function() {
            e.apply(t, arguments);
          };
        }
        function M(e) {
          return "function" == typeof e;
        }
        return o && (f.onmessage = function(e) {
          var t = e.data;
          void 0 === b.WORKER_ID && t && (b.WORKER_ID = t.workerId);
          if ("string" == typeof t.input)
            f.postMessage({ workerId: b.WORKER_ID, results: b.parse(t.input, t.config), finished: true });
          else if (f.File && t.input instanceof File || t.input instanceof Object) {
            var i2 = b.parse(t.input, t.config);
            i2 && f.postMessage({ workerId: b.WORKER_ID, results: i2, finished: true });
          }
        }), (l.prototype = Object.create(u.prototype)).constructor = l, (c.prototype = Object.create(u.prototype)).constructor = c, (p.prototype = Object.create(p.prototype)).constructor = p, (g.prototype = Object.create(u.prototype)).constructor = g, b;
      });
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/src/parse.js
  var require_parse = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/src/parse.js"(exports, module) {
      var { DataFrame, inferType, max, range } = require_src();
      var papa = require_papaparse_min();
      function leftPad(x, n) {
        x = x.toString();
        while (x.length < n)
          x = "0" + x;
        return x;
      }
      module.exports = function parse(raw, config) {
        const defaults = {
          beforeFirstChunk: void 0,
          chunk: void 0,
          chunkSize: void 0,
          comments: false,
          complete: void 0,
          delimiter: "",
          delimitersToGuess: [",", "	", "|", ";", papa.RECORD_SEP, papa.UNIT_SEP],
          download: false,
          downloadRequestBody: void 0,
          downloadRequestHeaders: void 0,
          dynamicTyping: false,
          encoding: "",
          error: void 0,
          escapeChar: '"',
          fastMode: void 0,
          newline: "",
          preview: 0,
          quoteChar: '"',
          skipEmptyLines: false,
          step: void 0,
          transform: void 0,
          transformHeader: void 0,
          withCredentials: void 0,
          worker: false,
          // I've changed this value from the Papa defaults because, at least for my
          // purposes, I anticipate that most datasets will include a header row.
          header: true,
          // I'm adding this option in case a dataset has (or should have) an index
          // column (i.e., a first column filled with row names).
          index: false,
          // I'm also adding my own options to infer types using my `inferType`
          // function in @jrc03c/js-math-tools. Papa offers a "dynamicTyping" option,
          // but I think maybe mine is a little more extensive (i.e., I think it
          // infers more data types, but may not necessarily be more robust). I'm
          // willing to be wrong about that, though. By default, this value is set to
          // `false`, which means that the returned `DataFrame` will only contain
          // strings.
          inferTypes: false
        };
        config = config ? { ...defaults, ...config } : defaults;
        const results = papa.parse(raw.trim(), config);
        let data, columns, index;
        if (config.header) {
          data = {};
          columns = results.meta.fields;
          columns.forEach((col) => {
            data[col] = results.data.map((row) => row[col]);
          });
          if (config.index) {
            index = data[columns[0]];
            delete data[columns[0]];
            columns.shift();
          }
        } else {
          const maxRowLength = max(results.data.map((row) => row.length));
          columns = range(0, maxRowLength).map(
            (i) => `col${leftPad(i, maxRowLength.toString().length)}`
          );
          data = results.data.map((row) => {
            row.length = maxRowLength;
            return row;
          });
          if (config.index) {
            index = data.map((row) => row.shift());
            columns.pop();
          }
        }
        const out = new DataFrame(data);
        out.columns = columns;
        if (index) {
          out.index = index;
        }
        return config && config.inferTypes ? out.apply((col) => inferType(col).values) : out;
      };
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/src/load-csv.js
  var require_load_csv = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/src/load-csv.js"(exports, module) {
      var fs = (() => {
        try {
          return __require("fs/promises");
        } catch (e) {
          return null;
        }
      })();
      var { isBrowser } = require_src();
      var parse = require_parse();
      module.exports = async function loadCSV(path, config) {
        const raw = await (async () => {
          if (isBrowser()) {
            const response = await fetch(path);
            return await response.text();
          } else {
            return await fs.readFile(path, { encoding: "utf8" });
          }
        })();
        return parse(raw, config);
      };
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/src/unparse.js
  var require_unparse = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/src/unparse.js"(exports, module) {
      var { isUndefined } = require_src();
      var papa = require_papaparse_min();
      module.exports = function unparse(df, config) {
        const defaults = {
          columns: null,
          delimiter: ",",
          escapeChar: '"',
          header: true,
          quoteChar: '"',
          quotes: false,
          skipEmptyLines: false,
          // This is the only value that's been changed from Papa's defaults.
          newline: "\n",
          // I'm adding this option in case a dataset has (or should have) an index
          // column (i.e., a first column filled with row names).
          index: false
        };
        df = df.copy();
        config = config ? { ...defaults, ...config } : defaults;
        if (config.header) {
          config.columns = config.columns || df.columns;
          if (config.index) {
            df = df.assign("(index)", df.index);
            config.columns.splice(0, 0, "(index)");
            df = df.get(config.columns);
          }
        } else {
          config.columns = null;
          if (config.index) {
            const columns = ["(index)"].concat(df.columns);
            df = df.assign("(index)", df.index);
            df = df.get(columns);
          }
        }
        df = df.copy();
        df.values = df.values.map((row) => {
          return row.map((v) => {
            if (isUndefined(v)) {
              return "";
            }
            if (typeof v === "number" && isNaN(v)) {
              return "";
            }
            if (typeof v === "object") {
              if (v instanceof Date) {
                return v.toJSON();
              } else {
                return JSON.stringify(v);
              }
            }
            return v;
          });
        });
        const values = config.header ? [df.columns].concat(df.values) : df.values;
        return papa.unparse(values, config).trim();
      };
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/src/save-csv.js
  var require_save_csv = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/src/save-csv.js"(exports, module) {
      var fs = (() => {
        try {
          return __require("fs/promises");
        } catch (e) {
          return null;
        }
      })();
      var { isBrowser } = require_src();
      var unparse = require_unparse();
      function download(filename, text) {
        let a = document.createElement("a");
        a.href = "data:text/csv;charset=utf-8," + encodeURIComponent(text);
        a.download = filename;
        a.dispatchEvent(new MouseEvent("click"));
      }
      module.exports = async function saveCSV2(path, df, config) {
        const raw = unparse(df, config);
        if (isBrowser()) {
          download(path, raw);
        } else {
          const dir = path.split("/").slice(0, -1).join("/");
          try {
            await fs.mkdir(dir, { recursive: true });
          } catch (e) {
          }
          await fs.writeFile(path, raw, { encoding: "utf8" });
        }
      };
    }
  });

  // node_modules/@jrc03c/js-csv-helpers/src/index.js
  var require_src2 = __commonJS({
    "node_modules/@jrc03c/js-csv-helpers/src/index.js"(exports, module) {
      var JSCSVHelpers = {
        loadCSV: require_load_csv(),
        parse: require_parse(),
        saveCSV: require_save_csv(),
        unparse: require_unparse()
      };
      if (typeof window !== "undefined") {
        window.JSCSVHelpers = JSCSVHelpers;
      }
      if (typeof module !== "undefined") {
        module.exports = JSCSVHelpers;
      }
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/math-error.js
  var require_math_error2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/math-error.js"(exports, module) {
      var isBrowser = new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`);
      var MathError = class extends Error {
        constructor(message) {
          if (isBrowser()) {
            super(message);
          } else {
            super("\n\n\x1B[31m" + message + "\n\x1B[0m");
          }
        }
      };
      module.exports = MathError;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/assert.js
  var require_assert2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/assert.js"(exports, module) {
      var MathError = require_math_error2();
      module.exports = function(isTrue, message) {
        if (!isTrue)
          throw new MathError(message);
      };
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/is-array.js
  var require_is_array2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/is-array.js"(exports, module) {
      function isArray(obj) {
        try {
          return obj instanceof Array || typeof obj.constructor !== "undefined" && obj.constructor.name === "Array";
        } catch (e) {
          return false;
        }
      }
      module.exports = isArray;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/is-dataframe.js
  var require_is_dataframe2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/is-dataframe.js"(exports, module) {
      function isDataFrame(x) {
        try {
          return !!x._symbol && x._symbol === Symbol.for("@jrc03c/js-math-tools/dataframe");
        } catch (e) {
          return false;
        }
      }
      module.exports = isDataFrame;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/is-function.js
  var require_is_function2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/is-function.js"(exports, module) {
      function isFunction(fn) {
        return typeof fn === "function";
      }
      module.exports = isFunction;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/is-number.js
  var require_is_number2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/is-number.js"(exports, module) {
      function isNumber(x) {
        return typeof x === "number" && !isNaN(x);
      }
      module.exports = isNumber;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/is-undefined.js
  var require_is_undefined2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/is-undefined.js"(exports, module) {
      function isUndefined(x) {
        return x === null || typeof x === "undefined";
      }
      module.exports = isUndefined;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/is-object.js
  var require_is_object2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/is-object.js"(exports, module) {
      var isArray = require_is_array2();
      var isUndefined = require_is_undefined2();
      function isObject(x) {
        return typeof x === "object" && !isUndefined(x) && !isArray(x);
      }
      module.exports = isObject;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/is-series.js
  var require_is_series2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/is-series.js"(exports, module) {
      function isSeries(x) {
        try {
          return !!x._symbol && x._symbol === Symbol.for("@jrc03c/js-math-tools/series");
        } catch (e) {
          return false;
        }
      }
      module.exports = isSeries;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/index-of.js
  var require_index_of2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/index-of.js"(exports, module) {
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isFunction = require_is_function2();
      var isNumber = require_is_number2();
      var isObject = require_is_object2();
      var isSeries = require_is_series2();
      function indexOf(x, fn) {
        if (isDataFrame(x)) {
          const index = indexOf(x.values, fn);
          if (index.length > 0 && isNumber(index[0]) && index[0] >= 0 && index[0] < x.index.length) {
            index[0] = x.index[index[0]];
          }
          if (index.length > 1 && isNumber(index[1]) && index[1] >= 0 && index[1] < x.columns.length) {
            index[1] = x.columns[index[1]];
          }
          return index;
        }
        if (isSeries(x)) {
          const index = indexOf(x.values, fn);
          if (index.length > 0 && isNumber(index[0]) && index[0] >= 0 && index[0] < x.index.length) {
            index[0] = x.index[index[0]];
          }
          return index;
        }
        assert(
          isObject(x) || isArray(x),
          "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"
        );
        if (!isFunction(fn)) {
          const value = fn;
          fn = (v) => v === value;
        }
        function helper(x2, fn2, checked) {
          checked = checked || [];
          if (checked.indexOf(x2) > -1) {
            return null;
          }
          if (isObject(x2)) {
            checked.push(x2);
            const keys = Object.keys(x2);
            for (let i = 0; i < keys.length; i++) {
              const key = keys[i];
              const value = x2[key];
              if (fn2(value)) {
                return [key];
              }
              const results = helper(value, fn2, checked);
              if (results && results.length > 0) {
                return [key].concat(results);
              }
            }
          } else if (isArray(x2)) {
            checked.push(x2);
            for (let i = 0; i < x2.length; i++) {
              const value = x2[i];
              if (fn2(value)) {
                return [i];
              }
              const results = helper(value, fn2, checked);
              if (results && results.length > 0) {
                return [i].concat(results);
              }
            }
          } else {
            if (fn2(x2)) {
              return [];
            }
          }
          return null;
        }
        function safeFn(v) {
          try {
            return fn(v);
          } catch (e) {
            return false;
          }
        }
        const paths = helper(x, safeFn);
        if (paths && paths.length > 0) {
          return paths;
        } else {
          return null;
        }
      }
      module.exports = indexOf;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/copy.js
  var require_copy2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/copy.js"(exports, module) {
      var indexOf = require_index_of2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isSeries = require_is_series2();
      function copy(x) {
        try {
          const out = structuredClone(x);
          return out;
        } catch (e) {
          if (typeof x === "object") {
            if (x === null) {
              return null;
            }
            if (isArray(x)) {
              return x.map((v) => copy(v));
            }
            if (isSeries(x)) {
              const out2 = x.copy();
              out2.values = copy(out2.values);
              return out2;
            }
            if (isDataFrame(x)) {
              const out2 = x.copy();
              out2.values = copy(x.values);
              return out2;
            }
            x = decycle(x);
            const out = {};
            Object.keys(x).forEach((key) => {
              out[key] = copy(x[key]);
            });
            return out;
          } else {
            return x;
          }
        }
      }
      function decycle(x) {
        function helper(x2, checked, currentPath) {
          checked = checked || [];
          currentPath = currentPath || "";
          if (checked.indexOf(x2) > -1) {
            const parts = currentPath.split("/").slice(currentPath.startsWith("/") ? 1 : 0);
            const isANestedCopy = parts.some((v, i) => {
              const subParts = parts.slice(0, parts.length - i - 1);
              let temp = orig;
              subParts.forEach((part) => {
                temp = temp[part];
              });
              return temp === x2;
            });
            if (isANestedCopy) {
              const pathToCopy = orig === x2 ? "/" : "/" + indexOf(orig, x2).join("/");
              return `<reference to "${pathToCopy}">`;
            }
          }
          if (typeof x2 === "object") {
            if (x2 === null)
              return null;
            checked.push(x2);
            if (isArray(x2)) {
              return x2.map((v, i) => helper(v, checked, currentPath + "/" + i));
            } else {
              Object.keys(x2).forEach((key) => {
                x2[key] = helper(x2[key], checked, currentPath + "/" + key);
              });
              return x2;
            }
          } else {
            return x2;
          }
        }
        const orig = copy(x);
        let out = helper(orig);
        if (isDataFrame(x)) {
          const temp = x.copy();
          temp._values = out.values;
          temp._columns = out.columns;
          temp._index = out.index;
          out = temp;
        }
        if (isSeries(x)) {
          const temp = x.copy();
          temp.name = out.name;
          temp._values = out.values;
          temp._index = out.index;
          out = temp;
        }
        return out;
      }
      module.exports = { copy, decycle };
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/flatten.js
  var require_flatten2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/flatten.js"(exports, module) {
      var { copy } = require_copy2();
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isSeries = require_is_series2();
      function flatten(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return flatten(arr.values);
        }
        assert(
          isArray(arr),
          "The `flatten` function only works on arrays, Series, and DataFrames!"
        );
        function helper(arr2) {
          let out = [];
          copy(arr2).forEach((child) => {
            if (isArray(child)) {
              out = out.concat(helper(child));
            } else {
              out.push(child);
            }
          });
          return out;
        }
        return helper(arr);
      }
      module.exports = flatten;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/is-equal.js
  var require_is_equal2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/is-equal.js"(exports, module) {
      var { decycle } = require_copy2();
      var isArray = require_is_array2();
      function isEqual(a, b) {
        function helper(a2, b2) {
          const aType = typeof a2;
          const bType = typeof b2;
          if (aType !== bType)
            return false;
          if (aType === "undefined")
            return true;
          if (aType === "boolean")
            return a2 === b2;
          if (aType === "symbol")
            return a2 === b2;
          if (aType === "number" || aType === "bigint") {
            if (a2.toString() === "NaN" && b2.toString() === "NaN") {
              return true;
            }
            return a2 === b2;
          }
          if (aType === "string")
            return a2 === b2;
          if (aType === "function")
            return a2 === b2;
          if (aType === "object") {
            if (a2 === null || b2 === null) {
              return a2 === null && b2 === null;
            } else {
              if (isArray(a2) !== isArray(b2)) {
                return false;
              }
              const aKeys = Object.keys(a2);
              const bKeys = Object.keys(b2);
              if (aKeys.length !== bKeys.length)
                return false;
              for (let i = 0; i < aKeys.length; i++) {
                const key = aKeys[i];
                if (!helper(a2[key], b2[key]))
                  return false;
              }
              return true;
            }
          }
        }
        try {
          if (a instanceof Date && b instanceof Date) {
            return a.getTime() === b.getTime();
          }
          return helper(a, b);
        } catch (e) {
          return helper(decycle(a), decycle(b));
        }
      }
      module.exports = isEqual;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/set.js
  var require_set2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/set.js"(exports, module) {
      var assert = require_assert2();
      var flatten = require_flatten2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isFunction = require_is_function2();
      var isSeries = require_is_series2();
      var isUndefined = require_is_undefined2();
      function makeKey(n) {
        const alpha = "abcdefg1234567890";
        let out = "";
        while (out.length < n)
          out += alpha[parseInt(Math.random() * alpha.length)];
        return out;
      }
      var NULL_KEY = makeKey(256);
      var UNDEFINED_KEY = makeKey(256);
      var INFINITY_KEY = makeKey(256);
      var MINUS_INFINITY_KEY = makeKey(256);
      var SYMBOL_KEY = makeKey(256);
      function set(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return set(arr.values);
        }
        assert(
          isArray(arr),
          "The `set` function only works on arrays, Series, and DataFrames!"
        );
        const out = [];
        const temp = {};
        flatten(arr).forEach((item) => {
          const key = typeof item === "object" && item === null ? NULL_KEY : isUndefined(item) ? UNDEFINED_KEY : isFunction(item) ? item.toString() : typeof item === "symbol" ? item.toString() + " - " + SYMBOL_KEY : item === Infinity ? INFINITY_KEY : item === -Infinity ? MINUS_INFINITY_KEY : isDataFrame(item) ? item.toJSONString() : isSeries(item) ? JSON.stringify(item.toObject()) : JSON.stringify(item);
          if (!temp[key])
            out.push(item);
          temp[key] = true;
        });
        return out;
      }
      module.exports = set;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/count.js
  var require_count2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/count.js"(exports, module) {
      var assert = require_assert2();
      var flatten = require_flatten2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isEqual = require_is_equal2();
      var isFunction = require_is_function2();
      var isSeries = require_is_series2();
      var set = require_set2();
      function count(arr, matcher) {
        if (isDataFrame(arr) || isSeries(arr)) {
          if (arguments.length > 1) {
            return count(arr.values, matcher);
          } else {
            return count(arr.values, arr.values);
          }
        }
        assert(
          isArray(arr),
          "The first argument to the `count` function must be an array, Series, or DataFrame!"
        );
        if (isFunction(matcher)) {
          return flatten(arr).filter((value) => matcher(value)).length;
        } else if (isArray(matcher)) {
          const temp = flatten(arr);
          return set(matcher).map((value) => {
            return {
              value,
              count: temp.filter((v) => isEqual(v, value)).length
            };
          });
        } else if (arguments.length > 1) {
          return flatten(arr).filter((other) => isEqual(other, matcher)).length;
        } else {
          return count(arr, arr);
        }
      }
      module.exports = count;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/is-jagged.js
  var require_is_jagged2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/is-jagged.js"(exports, module) {
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isSeries = require_is_series2();
      function isJagged(x) {
        if (isDataFrame(x) || isSeries(x)) {
          return isJagged(x.values);
        }
        assert(
          isArray(x),
          "The `isJagged` function only works on arrays, Series, and DataFrames!"
        );
        let childArrayCount = 0;
        let firstChildArrayLength = null;
        for (let i = 0; i < x.length; i++) {
          if (isArray(x[i])) {
            childArrayCount++;
            if (isJagged(x[i])) {
              return true;
            }
            if (firstChildArrayLength === null) {
              firstChildArrayLength = x[i].length;
            } else if (x[i].length !== firstChildArrayLength) {
              return true;
            }
          }
        }
        if (childArrayCount > 0 && childArrayCount < x.length) {
          return true;
        }
        return false;
      }
      module.exports = isJagged;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/is-nested.js
  var require_is_nested2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/is-nested.js"(exports, module) {
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isSeries = require_is_series2();
      function isNested(x) {
        if (isDataFrame(x) || isSeries(x)) {
          return isNested(x.values);
        }
        assert(
          isArray(x),
          "The `isNested` function only works on arrays, Series, and DataFrames!"
        );
        for (let i = 0; i < x.length; i++) {
          if (isArray(x[i])) {
            return true;
          }
        }
        return false;
      }
      module.exports = isNested;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/ndarray.js
  var require_ndarray2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/ndarray.js"(exports, module) {
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isNested = require_is_nested2();
      var isNumber = require_is_number2();
      var isUndefined = require_is_undefined2();
      var error = "You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";
      function ndarray(shape) {
        assert(!isUndefined(shape), error);
        if (!isArray(shape))
          shape = [shape];
        assert(!isNested(shape), error);
        assert(shape.length > 0, error);
        const s = shape[0];
        assert(isNumber(s), error);
        assert(parseInt(s) === s, error);
        assert(s >= 0, error);
        assert(
          s !== Infinity,
          "We can't create an array containing an infinite number of values!"
        );
        if (shape.length === 1) {
          const out = [];
          for (let i = 0; i < s; i++)
            out.push(void 0);
          return out;
        } else {
          const out = [];
          for (let i = 0; i < s; i++) {
            out.push(ndarray(shape.slice(1)));
          }
          return out;
        }
      }
      module.exports = ndarray;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/reverse.js
  var require_reverse2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/reverse.js"(exports, module) {
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isSeries = require_is_series2();
      function reverse(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          const out2 = arr.copy();
          out2.values = reverse(out2.values);
          out2.index = reverse(out2.index);
          return out2;
        }
        assert(
          isArray(arr),
          "The `reverse` function only works on arrays, Series, and DataFrames!"
        );
        const out = [];
        for (let i = arr.length - 1; i >= 0; i--)
          out.push(arr[i]);
        return out;
      }
      module.exports = reverse;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/range.js
  var require_range2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/range.js"(exports, module) {
      var assert = require_assert2();
      var isNumber = require_is_number2();
      var isUndefined = require_is_undefined2();
      var reverse = require_reverse2();
      function range(a, b, step = 1) {
        assert(
          !isUndefined(a) && !isUndefined(b) && !isUndefined(step),
          "You must pass two numbers and optionally a step value to the `range` function!"
        );
        assert(
          isNumber(a) && isNumber(b) && isNumber(step),
          "You must pass two numbers and optionally a step value to the `range` function!"
        );
        assert(
          step > 0,
          "The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)"
        );
        let shouldReverse = false;
        if (a > b) {
          shouldReverse = true;
          const buffer = a;
          a = b + step;
          b = buffer + step;
        }
        let out = [];
        for (let i = a; i < b; i += step)
          out.push(i);
        if (shouldReverse)
          out = reverse(out);
        return out;
      }
      module.exports = range;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/shape.js
  var require_shape2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/shape.js"(exports, module) {
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isEqual = require_is_equal2();
      var isSeries = require_is_series2();
      var isUndefined = require_is_undefined2();
      function helper(x) {
        if (!isArray(x)) {
          return void 0;
        }
        const out = [x.length];
        let childArrayCount = 0;
        const childShapes = x.map((v) => {
          const s = helper(v);
          if (!isUndefined(s)) {
            childArrayCount++;
            if (s.length === 1) {
              return s[0];
            } else {
              return s;
            }
          } else {
            return s;
          }
        });
        if (childArrayCount > 0) {
          if (childArrayCount === x.length) {
            const childShapesAreIdentical = childShapes.slice(0, -1).every((s, i) => {
              return isEqual(s, childShapes[i + 1]);
            });
            if (childShapesAreIdentical) {
              return out.concat(childShapes[0]);
            } else {
              out.push(childShapes);
              return out;
            }
          } else {
            out.push(childShapes);
            return out;
          }
        } else {
          return out;
        }
      }
      function shape(x) {
        if (isDataFrame(x) || isSeries(x)) {
          return shape(x.values);
        }
        assert(
          isArray(x),
          "The `shape` function only works on arrays, Series, and DataFrames!"
        );
        return helper(x);
      }
      module.exports = shape;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/dataframe/df-append.js
  var require_df_append2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/dataframe/df-append.js"(exports, module) {
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isJagged = require_is_jagged2();
      var isSeries = require_is_series2();
      var isUndefined = require_is_undefined2();
      var MathError = require_math_error2();
      var ndarray = require_ndarray2();
      var range = require_range2();
      var set = require_set2();
      var shape = require_shape2();
      function dfAppend(df, x, axis) {
        if (isUndefined(axis)) {
          axis = 0;
        }
        assert(
          axis === 0 || axis === 1 || axis === "vertical" || axis === "horizontal",
          'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'
        );
        if (isArray(x)) {
          assert(
            !isJagged(x),
            "The array of data you're trying to append to this DataFrame is jagged!"
          );
          const xShape = shape(x);
          if (xShape.length === 1) {
            if (axis === 0) {
              const out = df.copy();
              out._values.push(x);
              const maxRowLength = Math.max(df.shape[1], xShape[0]);
              out._values.forEach((row) => {
                while (row.length < maxRowLength) {
                  row.push(void 0);
                }
              });
              while (out._index.length < out._values.length) {
                out._index.push("row" + out._index.length);
              }
              while (out._columns.length < maxRowLength) {
                out._columns.push("col" + out._columns.length);
              }
              return out;
            } else {
              const maxColLength = Math.max(df.shape[0], xShape[0]);
              const out = df.copy();
              range(0, maxColLength).forEach((i) => {
                if (i >= out._values.length) {
                  out._values.push(ndarray(df.shape[1]));
                }
                out._values[i].push(x[i]);
              });
              while (out._index.length < out._values.length) {
                out._index.push("row" + out._index.length);
              }
              while (out._columns.length < out._values[0].length) {
                out._columns.push("col" + out._columns.length);
              }
              return out;
            }
          } else if (xShape.length === 2) {
            if (axis === 0) {
              const maxRowLength = Math.max(
                ...x.map((row) => row.length).concat([df.shape[1]])
              );
              const out = df.copy();
              out._values = out._values.concat(x).map((row) => {
                while (row.length < maxRowLength) {
                  row.push(void 0);
                }
                return row;
              });
              while (out._index.length < out._values.length) {
                out._index.push("row" + out._index.length);
              }
              while (out._columns.length < maxRowLength) {
                out._columns.push("col" + out._columns.length);
              }
              return out;
            } else {
              const maxRowLength = Math.max(...x.map((row) => row.length)) + df.shape[1];
              const maxColLength = Math.max(df.shape[0], xShape[0]);
              const out = df.copy();
              range(0, maxColLength).forEach((i) => {
                if (i >= out._values.length) {
                  out._values.push(ndarray(df.shape[1]));
                }
                out._values[i] = out._values[i].concat(x[i]);
                while (out._values[i].length < maxRowLength) {
                  out._values[i].push(void 0);
                }
              });
              while (out._index.length < out._values.length) {
                out._index.push("row" + out._index.length);
              }
              while (out._columns.length < maxRowLength) {
                out._columns.push("col" + out._columns.length);
              }
              return out;
            }
          } else {
            throw new MathError(
              "Only 1- and 2-dimensional arrays can be appended to a DataFrame!"
            );
          }
        } else if (isSeries(x)) {
          const out = dfAppend(df, x.values, axis);
          if (axis === 0) {
            out.index[out.index.length - 1] = out.index.indexOf(x.name) > -1 ? x.name + " (2)" : x.name;
          } else {
            out.columns[out.columns.length - 1] = out.columns.indexOf(x.name) > -1 ? x.name + " (2)" : x.name;
          }
          return out;
        } else if (isDataFrame(x)) {
          if (axis === 0) {
            const out = df.copy();
            const maxRowLength = set(out._columns.concat(x._columns)).length;
            out._values.forEach((row) => {
              while (row.length < maxRowLength) {
                row.push(void 0);
              }
            });
            x.apply((row) => {
              const rowCopy = row.copy();
              const temp = [];
              out._columns.forEach((col) => {
                const index = rowCopy._index.indexOf(col);
                if (index > -1) {
                  temp.push(rowCopy._values[index]);
                  rowCopy._values.splice(index, 1);
                  rowCopy._index.splice(index, 1);
                } else {
                  temp.push(void 0);
                }
              });
              out._values.push(temp.concat(rowCopy._values));
            }, 1);
            out._columns = out._columns.concat(
              x._columns.filter((c) => out._columns.indexOf(c) < 0)
            );
            while (out._index.length < out._values.length) {
              const newRowName = "row" + out._index.length;
              out._index.push(
                newRowName + (df._index.indexOf(newRowName) > -1 ? " (2)" : "")
              );
            }
            return out;
          } else {
            const out = df.copy();
            out._index.forEach((rowName, i) => {
              const xIndex = x._index.indexOf(rowName);
              if (xIndex > -1) {
                out._values[i] = out._values[i].concat(x._values[xIndex]);
              } else {
                out._values[i] = out._values[i].concat(ndarray(x.shape[1]));
              }
            });
            x._index.forEach((rowName, i) => {
              const outIndex = out._index.indexOf(rowName);
              if (outIndex < 0) {
                out._index.push(rowName);
                out._values.push(ndarray(out._columns.length).concat(x._values[i]));
              }
            });
            out._columns = out._columns.concat(
              x._columns.map((c) => c + (out._columns.indexOf(c) > -1 ? " (2)" : ""))
            );
            return out;
          }
        } else {
          throw new MathError(
            "Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!"
          );
        }
      }
      module.exports = dfAppend;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/dataframe/df-apply.js
  var require_df_apply2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/dataframe/df-apply.js"(exports, module) {
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isFunction = require_is_function2();
      var isUndefined = require_is_undefined2();
      function dfApply(DataFrame, Series, df, fn, axis) {
        axis = axis || 0;
        assert(
          isFunction(fn),
          "The first parameter to the `apply` method must be a function."
        );
        assert(
          axis === 0 || axis === 1,
          "The second parameter to the `apply` method (the `axis`) must be 0 or 1."
        );
        if (axis === 0) {
          const temp = {};
          let shouldReturnADataFrame;
          df.columns.forEach((colName, i) => {
            const series = new Series(df.values.map((row) => row[i]));
            series.name = colName;
            series.index = df.index;
            const value = fn(series, i, df);
            if (value instanceof Series) {
              temp[colName] = value.values;
            } else {
              temp[colName] = value;
            }
            if (isUndefined(shouldReturnADataFrame)) {
              shouldReturnADataFrame = value instanceof Series || isArray(value);
            }
          });
          if (shouldReturnADataFrame) {
            const out = new DataFrame(temp);
            out.index = df.index;
            return out;
          } else {
            const out = new Series(df.columns.map((colName) => temp[colName]));
            out.index = df.columns;
            return out;
          }
        } else if (axis === 1) {
          let shouldReturnADataFrame;
          const temp = df.values.map((row, i) => {
            const series = new Series(row);
            series.name = df.index[i];
            series.index = df.columns;
            const value = fn(series, i, df);
            if (isUndefined(shouldReturnADataFrame)) {
              shouldReturnADataFrame = value instanceof Series || isArray(value);
            }
            if (value instanceof Series) {
              return value.values;
            } else {
              return value;
            }
          });
          if (shouldReturnADataFrame) {
            const out = new DataFrame(temp);
            out.index = df.index;
            out.columns = df.columns;
            return out;
          } else {
            const out = new Series(temp);
            out.index = df.index;
            return out;
          }
        }
      }
      module.exports = dfApply;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/is-string.js
  var require_is_string2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/is-string.js"(exports, module) {
      function isString(s) {
        return typeof s === "string";
      }
      module.exports = isString;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/dataframe/df-assign.js
  var require_df_assign2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/dataframe/df-assign.js"(exports, module) {
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isJagged = require_is_jagged2();
      var isObject = require_is_object2();
      var isString = require_is_string2();
      var isUndefined = require_is_undefined2();
      var MathError = require_math_error2();
      var shape = require_shape2();
      function dfAssign(DataFrame, Series, df, p1, p2) {
        const isDataFrame = (x) => x instanceof DataFrame;
        const isSeries = (x) => x instanceof Series;
        if (!isUndefined(p2)) {
          assert(
            isString(p1),
            "If passing two arguments into the `assign` method, then the first argument must be a string name!"
          );
          assert(
            isArray(p2) && !isJagged(p2) && shape(p2).length === 1,
            "If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!"
          );
          const out = df.append(p2, 1);
          out.columns[out.columns.length - 1] = p1;
          return out;
        } else {
          if (isDataFrame(p1)) {
            return df.append(p1, 1);
          } else if (isSeries(p1)) {
            return df.append(p1, 1);
          } else if (isObject(p1)) {
            const maxColumnLength = Math.max(
              ...Object.keys(p1).map((key) => p1[key].length)
            );
            Object.keys(p1).forEach((key) => {
              while (p1[key].length < maxColumnLength) {
                p1[key].push(void 0);
              }
            });
            return df.append(new DataFrame(p1), 1);
          } else {
            throw new MathError(
              "You must pass a DataFrame, Series, or object into the `assign` method!"
            );
          }
        }
      }
      module.exports = dfAssign;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/dataframe/df-copy.js
  var require_df_copy2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/dataframe/df-copy.js"(exports, module) {
      var { copy } = require_copy2();
      function dfCopy(DataFrame, df) {
        if (df.isEmpty)
          return new DataFrame();
        const out = new DataFrame(copy(df.values));
        out.columns = df.columns.slice();
        out.index = df.index.slice();
        return out;
      }
      module.exports = dfCopy;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/dataframe/df-drop.js
  var require_df_drop2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/dataframe/df-drop.js"(exports, module) {
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isNumber = require_is_number2();
      var isString = require_is_string2();
      var isUndefined = require_is_undefined2();
      var shape = require_shape2();
      function dfDrop(DataFrame, Series, df, rows, cols) {
        if (isUndefined(rows))
          rows = [];
        if (isUndefined(cols))
          cols = [];
        if (isString(rows) || isNumber(rows))
          rows = [rows];
        if (isString(cols) || isNumber(cols))
          cols = [cols];
        assert(
          isArray(rows),
          "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."
        );
        assert(
          isArray(cols),
          "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."
        );
        assert(
          shape(rows).length === 1,
          "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."
        );
        assert(
          shape(cols).length === 1,
          "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."
        );
        let outIndex, outColumns;
        df.index.forEach((row, i) => {
          if (rows.indexOf(row) < 0 && rows.indexOf(i) < 0) {
            if (!outIndex)
              outIndex = [];
            outIndex.push(row);
          }
        });
        df.columns.forEach((col, i) => {
          if (cols.indexOf(col) < 0 && cols.indexOf(i) < 0) {
            if (!outColumns)
              outColumns = [];
            outColumns.push(col);
          }
        });
        let out = df.get(outIndex, outColumns);
        if (out instanceof Series) {
          let temp = new DataFrame();
          temp = temp.assign(out);
          if (df.index.indexOf(out.name) > -1)
            temp = temp.transpose();
          out = temp;
        }
        return out;
      }
      module.exports = dfDrop;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/helpers/is-whole-number.js
  var require_is_whole_number2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/helpers/is-whole-number.js"(exports, module) {
      var isNumber = require_is_number2();
      function isInteger(x) {
        return isNumber(x) && parseInt(x) === x;
      }
      function isWholeNumber(x) {
        return isInteger(x) && x >= 0;
      }
      module.exports = isWholeNumber;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/dataframe/df-drop-missing.js
  var require_df_drop_missing2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/dataframe/df-drop-missing.js"(exports, module) {
      var assert = require_assert2();
      var isString = require_is_string2();
      var isUndefined = require_is_undefined2();
      var isWholeNumber = require_is_whole_number2();
      var shape = require_shape2();
      function dfDropMissing(DataFrame, Series, df, axis, condition, threshold) {
        axis = axis || 0;
        assert(
          axis === 0 || axis === 1,
          "The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."
        );
        threshold = threshold || 0;
        assert(
          isWholeNumber(threshold),
          "The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."
        );
        condition = threshold > 0 ? "none" : condition || "any";
        assert(
          condition === "any" || condition === "all" || condition === "none",
          "The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped)."
        );
        function helper(values) {
          if (threshold > 0) {
            let count = 0;
            for (let i = 0; i < values.length; i++) {
              const value = values[i];
              if (isUndefined(value))
                count++;
              if (count >= threshold)
                return [];
            }
          } else if (condition === "any") {
            for (let i = 0; i < values.length; i++) {
              const value = values[i];
              if (isUndefined(value))
                return [];
            }
          } else if (condition === "all") {
            for (let i = 0; i < values.length; i++) {
              const value = values[i];
              if (!isUndefined(value))
                return values;
            }
            return [];
          }
          return values;
        }
        let out = df.copy();
        const tempID = Math.random().toString();
        if (axis === 0) {
          out = out.assign(tempID, out.index);
          const newValues = out.values.map(helper).filter((row) => row.length > 0);
          if (shape(newValues).length < 2)
            return new DataFrame();
          out.values = newValues;
          let newIndex = out.get(null, tempID);
          if (isUndefined(newIndex))
            return new DataFrame();
          if (isString(newIndex))
            newIndex = [newIndex];
          if (newIndex instanceof Series)
            newIndex = newIndex.values;
          out.index = newIndex;
          out = out.drop(null, tempID);
        } else if (axis === 1) {
          const temp = {};
          out.columns.forEach((colName, i) => {
            const values = out.values.map((row) => row[i]);
            const newValues = helper(values);
            if (newValues.length > 0) {
              temp[colName] = newValues;
            }
          });
          if (Object.keys(temp).length === 0) {
            return new DataFrame();
          }
          const newOut = new DataFrame(temp);
          newOut.index = out.index;
          return newOut;
        }
        return out;
      }
      module.exports = dfDropMissing;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/drop-nan.js
  var require_drop_nan2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/drop-nan.js"(exports, module) {
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isNumber = require_is_number2();
      var isSeries = require_is_series2();
      function dropNaN(x) {
        if (isDataFrame(x) || isSeries(x)) {
          return x.dropNaN(...Object.values(arguments).slice(1));
        }
        assert(
          isArray(x),
          "The `dropNaN` function only works on arrays, Series, and DataFrames!"
        );
        const out = [];
        x.forEach((v) => {
          try {
            return out.push(dropNaN(v));
          } catch (e) {
            if (isNumber(v)) {
              return out.push(v);
            }
          }
        });
        return out;
      }
      module.exports = dropNaN;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/dataframe/df-drop-nan.js
  var require_df_drop_nan2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/dataframe/df-drop-nan.js"(exports, module) {
      var assert = require_assert2();
      var dropNaN = require_drop_nan2();
      var isWholeNumber = require_is_whole_number2();
      function dfDropNaN(DataFrame, df, axis, condition, threshold) {
        axis = axis || 0;
        assert(
          axis === 0 || axis === 1,
          "The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."
        );
        threshold = threshold || 0;
        assert(
          isWholeNumber(threshold),
          "The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."
        );
        condition = threshold > 0 ? "none" : condition || "any";
        assert(
          condition === "any" || condition === "all" || condition === "none",
          "The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped)."
        );
        function helper(values) {
          const numericalValues = dropNaN(values);
          if (threshold > 0)
            return values.length - numericalValues.length < threshold;
          if (condition === "any")
            return numericalValues.length === values.length;
          if (condition === "all")
            return numericalValues.length > 0;
          return true;
        }
        const out = df.copy();
        if (axis === 0) {
          const rowsToKeep = out.index.filter((row) => {
            const values = out.get(row, null).values;
            return helper(values);
          });
          if (rowsToKeep.length > 0)
            return out.get(rowsToKeep, null);
          else
            return new DataFrame();
        } else if (axis === 1) {
          const colsToKeep = out.columns.filter((col) => {
            const values = out.get(null, col).values;
            return helper(values);
          });
          if (colsToKeep.length > 0)
            return out.get(null, colsToKeep);
          else
            return new DataFrame();
        }
        return out;
      }
      module.exports = dfDropNaN;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/dataframe/df-filter.js
  var require_df_filter2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/dataframe/df-filter.js"(exports, module) {
      var assert = require_assert2();
      var flatten = require_flatten2();
      var isFunction = require_is_function2();
      var isUndefined = require_is_undefined2();
      function arrayToObject(x) {
        const out = {};
        flatten(x).forEach((value, i) => {
          out[value] = i;
        });
        return out;
      }
      function undoArrayToObject(obj) {
        return Object.keys(obj).sort((a, b) => obj[a] - obj[b]);
      }
      function dfFilter(DataFrame, Series, df, fn, axis) {
        assert(
          isFunction(fn),
          "The `filter` method takes a single parameter: a function that is used to filter the values."
        );
        if (isUndefined(axis))
          axis = 0;
        assert(
          axis === 0 || axis === 1,
          "The `axis` parameter to the `filter` method must be 0 or 1."
        );
        let out = df.copy();
        if (out.isEmpty)
          return out;
        const index = arrayToObject(out.index);
        const columns = arrayToObject(out.columns);
        if (axis === 0) {
          const newValues = out.values.filter((row, i) => {
            const series = new Series(row);
            series.name = df.index[i];
            series.index = df.columns;
            const shouldKeep = fn(series, i, df);
            if (!shouldKeep)
              delete index[out.index[i]];
            return shouldKeep;
          });
          if (flatten(newValues).length === 0) {
            return new DataFrame();
          }
          if (newValues.length === 1) {
            const temp = new Series(flatten(newValues));
            temp.name = undoArrayToObject(index)[0];
            temp.index = undoArrayToObject(columns);
            return temp;
          }
          out.values = newValues;
          out.index = undoArrayToObject(index);
        } else if (axis === 1) {
          out = out.transpose();
          const newValues = out.values.filter((row, i) => {
            const series = new Series(row);
            series.name = df.columns[i];
            series.index = df.index;
            const shouldKeep = fn(series, i, df);
            if (!shouldKeep)
              delete columns[out.index[i]];
            return shouldKeep;
          });
          if (flatten(newValues).length === 0) {
            return new DataFrame();
          }
          if (newValues.length === 1) {
            const temp = new Series(flatten(newValues));
            temp.name = undoArrayToObject(columns)[0];
            temp.index = undoArrayToObject(index);
            return temp;
          }
          out.values = newValues;
          out.index = undoArrayToObject(columns);
          out = out.transpose();
        }
        return out;
      }
      module.exports = dfFilter;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/dataframe/df-get.js
  var require_df_get2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/dataframe/df-get.js"(exports, module) {
      var assert = require_assert2();
      var isNumber = require_is_number2();
      var isString = require_is_string2();
      var isUndefined = require_is_undefined2();
      var set = require_set2();
      function dfGet(df, rows, cols) {
        if (isString(rows) || isNumber(rows))
          rows = [rows];
        if (isString(cols) || isNumber(cols))
          cols = [cols];
        const types = set((rows || []).concat(cols || []).map((v) => typeof v));
        assert(
          types.length <= 2,
          "Only whole numbers and/or strings are allowed in `get` arrays!"
        );
        if (types.length === 1) {
          assert(
            types[0] === "string" || types[0] === "number",
            "Only whole numbers and/or strings are allowed in `get` arrays!"
          );
        }
        if (types.length === 2) {
          assert(
            types.indexOf("string") > -1,
            "Only whole numbers and/or strings are allowed in `get` arrays!"
          );
          assert(
            types.indexOf("number") > -1,
            "Only whole numbers and/or strings are allowed in `get` arrays!"
          );
        }
        if (!isUndefined(rows)) {
          rows = rows.map((r) => {
            if (isString(r)) {
              assert(df.index.indexOf(r) > -1, `Row "${r}" does not exist!`);
              return r;
            }
            if (isNumber(r)) {
              assert(r >= 0, `Index ${r} is out of bounds!`);
              assert(parseInt(r) === r, `Row numbers must be integers!`);
              assert(r < df.index.length, `Index ${r} is out of bounds!`);
              return df.index[r];
            }
          });
        }
        if (!isUndefined(cols)) {
          cols = cols.map((c) => {
            if (isString(c)) {
              assert(df.columns.indexOf(c) > -1, `Column "${c}" does not exist!`);
              return c;
            }
            if (isNumber(c)) {
              assert(c >= 0, `Column ${c} is out of bounds!`);
              assert(parseInt(c) === c, `Column numbers must be integers!`);
              assert(c < df.columns.length, `Column ${c} is out of bounds!`);
              return df.columns[c];
            }
          });
        }
        return df.getSubsetByNames(rows, cols);
      }
      module.exports = dfGet;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/sort.js
  var require_sort2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/sort.js"(exports, module) {
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isFunction = require_is_function2();
      var isSeries = require_is_series2();
      var isUndefined = require_is_undefined2();
      function alphaSort(a, b) {
        try {
          if (a < b)
            return -1;
          if (a > b)
            return 1;
          return 0;
        } catch (e) {
          a = typeof a === "object" && a !== null ? JSON.stringify(a) : a.toString();
          b = typeof b === "object" && b !== null ? JSON.stringify(b) : b.toString();
          if (a < b)
            return -1;
          if (a > b)
            return 1;
          return 0;
        }
      }
      function sort(arr, fn) {
        if (isUndefined(fn))
          fn = alphaSort;
        if (isDataFrame(arr) || isSeries(arr)) {
          return arr.sort(...Object.values(arguments).slice(1));
        }
        assert(
          isArray(arr),
          "The `sort` function only works on arrays, Series, and DataFrames!"
        );
        assert(
          isFunction(fn),
          "The second parameter of the `sort` function must be a comparison function!"
        );
        const out = arr.slice();
        out.sort(fn);
        return out;
      }
      module.exports = sort;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/dataframe/df-get-dummies.js
  var require_df_get_dummies2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/dataframe/df-get-dummies.js"(exports, module) {
      var assert = require_assert2();
      var isString = require_is_string2();
      var isUndefined = require_is_undefined2();
      var set = require_set2();
      var sort = require_sort2();
      function camelify(text) {
        const temp = text.toLowerCase();
        let out = "";
        for (let i = 0; i < temp.length; i++) {
          const char = temp[i];
          if (char.match(/[a-z0-9]/g)) {
            out += char;
          } else {
            out += " ";
          }
        }
        const words = out.split(" ").filter((word) => word.length > 0);
        return words[0] + words.slice(1).map((word) => word[0].toUpperCase() + word.substring(1)).join("");
      }
      function dfGetDummies(DataFrame, df, columns) {
        if (isUndefined(columns)) {
          columns = df.columns;
        } else if (isString(columns)) {
          columns = [columns];
        }
        const temp = {};
        columns.forEach((col) => {
          assert(
            isString(col),
            "You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!"
          );
          const colIndex = df.columns.indexOf(col);
          assert(
            colIndex > -1,
            `The given DataFrame does not have a column called "${col}"!`
          );
          const values = df.values.map((row) => row[colIndex]);
          const valuesSet = sort(set(values));
          values.forEach((value) => {
            valuesSet.forEach((orig) => {
              const colName = col + "_" + camelify(orig.toString());
              if (!temp[colName]) {
                temp[colName] = [];
              }
              if (value === orig) {
                temp[colName].push(1);
              } else {
                temp[colName].push(0);
              }
            });
          });
        });
        const out = new DataFrame(temp);
        out.index = df.index;
        return out;
      }
      module.exports = dfGetDummies;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/dataframe/df-get-subset-by-indices.js
  var require_df_get_subset_by_indices2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/dataframe/df-get-subset-by-indices.js"(exports, module) {
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isNumber = require_is_number2();
      var isUndefined = require_is_undefined2();
      var isWholeNumber = require_is_whole_number2();
      var range = require_range2();
      var shape = require_shape2();
      function dfGetSubsetByIndices(df, rowIndices, colIndices) {
        const dataShape = df.shape;
        if (isUndefined(rowIndices))
          rowIndices = range(0, dataShape[0]);
        if (isUndefined(colIndices))
          colIndices = range(0, dataShape[1]);
        if (isNumber(rowIndices))
          rowIndices = [rowIndices];
        if (isNumber(colIndices))
          colIndices = [colIndices];
        assert(
          isArray(rowIndices) && isArray(colIndices),
          "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."
        );
        assert(
          shape(rowIndices).length === 1 && shape(colIndices).length === 1,
          "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."
        );
        assert(
          rowIndices.length > 0,
          "The `rowIndices` array must contain at least one index."
        );
        assert(
          colIndices.length > 0,
          "The `colIndices` array must contain at least one index."
        );
        rowIndices.forEach((rowIndex) => {
          assert(
            isWholeNumber(rowIndex),
            "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."
          );
          assert(
            rowIndex < df.index.length,
            `The row index ${rowIndex} is out of bounds.`
          );
        });
        colIndices.forEach((colIndex) => {
          assert(
            isWholeNumber(colIndex),
            "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."
          );
          assert(
            colIndex < df.columns.length,
            `The column index ${colIndex} is out of bounds.`
          );
        });
        const rows = rowIndices.map((i) => df.index[i]);
        const cols = colIndices.map((i) => df.columns[i]);
        return df.getSubsetByNames(rows, cols);
      }
      module.exports = dfGetSubsetByIndices;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/dataframe/df-get-subset-by-names.js
  var require_df_get_subset_by_names2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/dataframe/df-get-subset-by-names.js"(exports, module) {
      var assert = require_assert2();
      var flatten = require_flatten2();
      var isArray = require_is_array2();
      var isString = require_is_string2();
      var isUndefined = require_is_undefined2();
      var shape = require_shape2();
      function dfGetSubsetByNames(DataFrame, Series, df, rows, cols) {
        if (isUndefined(rows))
          rows = df.index;
        if (isUndefined(cols))
          cols = df.columns;
        if (isString(rows))
          rows = [rows];
        if (isString(cols))
          cols = [cols];
        assert(
          isArray(rows) && isArray(cols),
          "The `rows` and `cols` parameters must be 1-dimensional arrays of strings."
        );
        assert(
          shape(rows).length === 1 && shape(cols).length === 1,
          "The `rows` and `cols` parameters must be 1-dimensional arrays of strings."
        );
        assert(
          rows.length > 0,
          "The `rows` array must contain at least one row name."
        );
        assert(
          cols.length > 0,
          "The `cols` array must contain at least one column name."
        );
        rows.forEach((row) => {
          assert(
            isString(row),
            "The `rows` and `cols` parameters must be 1-dimensional arrays of strings."
          );
          assert(
            df.index.indexOf(row) > -1,
            `The row name "${row}" does not exist in the list of rows.`
          );
        });
        cols.forEach((col) => {
          assert(
            isString(col),
            "The `rows` and `cols` parameters must be 1-dimensional arrays of strings."
          );
          assert(
            df.columns.indexOf(col) > -1,
            `The column name "${col}" does not exist in the list of columns.`
          );
        });
        const values = rows.map((row) => {
          return cols.map((col) => {
            return df.values[df.index.indexOf(row)][df.columns.indexOf(col)];
          });
        });
        if (rows.length === 1 && cols.length === 1) {
          return flatten(values)[0];
        }
        if (rows.length === 1) {
          const out2 = new Series(flatten(values));
          out2.name = rows[0];
          out2.index = cols;
          return out2;
        }
        if (cols.length === 1) {
          const out2 = new Series(flatten(values));
          out2.name = cols[0];
          out2.index = rows;
          return out2;
        }
        const out = new DataFrame(values);
        out.columns = cols;
        out.index = rows;
        return out;
      }
      module.exports = dfGetSubsetByNames;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/dataframe/df-print.js
  var require_df_print2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/dataframe/df-print.js"(exports, module) {
      var isString = require_is_string2();
      var range = require_range2();
      function dfPrint(DataFrame, Series, df) {
        function truncate(s, maxLength2) {
          if (isString(s)) {
            if (s.length > maxLength2) {
              return s.substring(0, maxLength2 - 3) + "...";
            } else {
              return s;
            }
          } else {
            return s;
          }
        }
        if (df.isEmpty) {
          console.table({});
          console.log("Shape:", [0, 0], "\n");
          return df;
        }
        const maxRows = typeof window === "undefined" ? 20 : 10;
        const halfMaxRows = parseInt(maxRows / 2);
        const maxColumns = typeof process === "undefined" ? 10 : Math.floor(process.stdout.columns / 24) - 1;
        const halfMaxColumns = parseInt(maxColumns / 2);
        const tempRows = maxRows > df.index.length ? null : range(0, halfMaxRows).concat(
          range(df.index.length - halfMaxRows, df.index.length)
        );
        const tempColumns = maxColumns > df.columns.length ? null : range(0, halfMaxColumns).concat(
          range(df.columns.length - halfMaxColumns, df.columns.length)
        );
        let temp = df.get(tempRows, tempColumns);
        if (temp instanceof Series) {
          if (df.shape[0] === 1) {
            temp = new DataFrame([temp.values]);
            temp.index = df.index;
            temp.columns = new Series(df.columns).get(tempColumns).values;
          } else if (df.shape[1] === 1) {
            temp = new DataFrame([temp.values]).transpose();
            temp.index = new Series(df.index).get(tempRows).values;
            temp.columns = df.columns;
          }
        }
        if (maxRows <= df.index.length) {
          temp._index.splice(halfMaxRows, 0, "...");
          temp._values.splice(
            halfMaxRows,
            0,
            range(0, temp.columns.length).map(() => "...")
          );
        }
        if (maxColumns <= df.columns.length) {
          temp._columns.splice(halfMaxColumns, 0, "...");
          temp._values = temp._values.map((row) => {
            row.splice(halfMaxColumns, 0, "...");
            return row;
          });
        }
        const maxLength = 28;
        if (temp instanceof Series) {
          temp.values = temp.values.map((value) => truncate(value, maxLength));
          temp.name = truncate(temp.name, maxLength);
          temp.index = temp.index.map((row) => truncate(row, maxLength));
        } else {
          temp.values = temp.values.map((row) => {
            return row.map((value) => truncate(value, maxLength));
          });
          temp.columns = temp.columns.map((col) => truncate(col, maxLength));
          temp.index = temp.index.map((row) => truncate(row, maxLength));
        }
        console.table(temp.toObject());
        console.log("Shape:", df.shape, "\n");
        return df;
      }
      module.exports = dfPrint;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/helpers/left-pad.js
  var require_left_pad2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/helpers/left-pad.js"(exports, module) {
      var assert = require_assert2();
      var isNumber = require_is_number2();
      function leftPad(x, maxLength) {
        assert(isNumber(x), "The `leftPad` function only works on numbers!");
        let out = x.toString();
        while (out.length < maxLength)
          out = "0" + out;
        return out;
      }
      module.exports = leftPad;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/dataframe/df-reset-index.js
  var require_df_reset_index2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/dataframe/df-reset-index.js"(exports, module) {
      var leftPad = require_left_pad2();
      var range = require_range2();
      function dfResetIndex(df, shouldSkipCopying) {
        const out = shouldSkipCopying ? df : df.copy();
        out.index = range(0, df.shape[0]).map((i) => {
          return "row" + leftPad(i, (out.index.length - 1).toString().length);
        });
        return out;
      }
      module.exports = dfResetIndex;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/product.js
  var require_product2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/product.js"(exports, module) {
      var assert = require_assert2();
      var flatten = require_flatten2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isSeries = require_is_series2();
      function product(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return product(arr.values);
        }
        assert(
          isArray(arr),
          "The `product` function only works on arrays, Series, and DataFrames!"
        );
        try {
          if (arr.length === 0)
            return NaN;
          return flatten(arr).reduce((a, b) => a * b, 1);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = product;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/reshape.js
  var require_reshape2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/reshape.js"(exports, module) {
      var assert = require_assert2();
      var flatten = require_flatten2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isNumber = require_is_number2();
      var isSeries = require_is_series2();
      var product = require_product2();
      var shape = require_shape2();
      function reshape(x, newShape) {
        if (isDataFrame(x) || isSeries(x)) {
          return reshape(x.values, newShape);
        }
        assert(
          isArray(x),
          "The first argument passed into the `reshape` function must be an array!"
        );
        if (isNumber(newShape))
          newShape = [newShape];
        assert(
          isArray(newShape),
          "The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"
        );
        assert(
          shape(newShape).length === 1,
          "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"
        );
        newShape.forEach((v) => {
          assert(
            isNumber(v) && parseInt(v) === v && v > 0,
            "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"
          );
        });
        if (newShape.length === 0) {
          return flatten(x);
        }
        const temp = flatten(x);
        if (newShape.length === 1 && newShape[0] === temp.length) {
          return temp;
        }
        assert(
          product(newShape) === temp.length,
          "The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!"
        );
        const out = [];
        const step = parseInt(temp.length / newShape[0]);
        for (let i = 0; i < newShape[0]; i++) {
          const row = temp.slice(i * step, (i + 1) * step);
          out.push(reshape(row, newShape.slice(1)));
        }
        return out;
      }
      module.exports = reshape;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/random.js
  var require_random2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/random.js"(exports, module) {
      var { copy } = require_copy2();
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isNumber = require_is_number2();
      var isUndefined = require_is_undefined2();
      var ndarray = require_ndarray2();
      var product = require_product2();
      var reshape = require_reshape2();
      var MAX = Math.pow(2, 64);
      var s = [];
      seed(parseInt(Math.random() * MAX));
      function splitmix64(state, n) {
        state = uint(state);
        function helper() {
          state += uint("0x9e3779b97f4a7c15");
          let z = copy(state);
          z = (z ^ z >> BigInt(30)) * uint("0xbf58476d1ce4e5b9");
          z = (z ^ z >> BigInt(27)) * uint("0x94d049bb133111eb");
          return z ^ z >> BigInt(31);
        }
        const out = [];
        for (let i = 0; i < n; i++)
          out.push(helper());
        return out;
      }
      function uint(x) {
        return BigInt.asUintN(64, BigInt(x));
      }
      function rotl(x, k) {
        x = uint(x);
        k = BigInt(k);
        return uint(uint(x << k) | uint(x >> uint(BigInt(64) - k)));
      }
      function seed(val) {
        if (!isUndefined(val)) {
          assert(
            isNumber(val),
            "If passing a value into the `seed` function, then that value must be an integer!"
          );
          const temp = splitmix64(parseInt(val), 4);
          s[0] = temp[0];
          s[1] = temp[1];
          s[2] = temp[2];
          s[3] = temp[3];
        } else {
          return copy(s);
        }
      }
      function next() {
        const result = uint(rotl(s[0] + s[3], 23) + s[0]);
        const t = uint(s[1] << BigInt(17));
        s[2] = uint(s[2] ^ s[0]);
        s[3] = uint(s[3] ^ s[1]);
        s[1] = uint(s[1] ^ s[2]);
        s[0] = uint(s[0] ^ s[3]);
        s[2] = uint(s[2] ^ t);
        s[3] = rotl(s[3], 45);
        return parseInt(result) / MAX;
      }
      function random(shape) {
        if (isUndefined(shape))
          return next();
        if (!isArray(shape))
          shape = [shape];
        return reshape(ndarray(product(shape)).map(next), shape);
      }
      module.exports = { random, seed };
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/shuffle.js
  var require_shuffle2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/shuffle.js"(exports, module) {
      var { random } = require_random2();
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isSeries = require_is_series2();
      function shuffle(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return arr.shuffle(...Object.values(arguments).slice(1));
        }
        assert(
          isArray(arr),
          "The `shuffle` function only works on arrays, Series, and DataFrames!"
        );
        const out = [];
        const temp = arr.slice();
        for (let i = 0; i < arr.length; i++) {
          const index = parseInt(random() * temp.length);
          out.push(temp.splice(index, 1)[0]);
        }
        return out;
      }
      module.exports = shuffle;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/dataframe/df-shuffle.js
  var require_df_shuffle2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/dataframe/df-shuffle.js"(exports, module) {
      var assert = require_assert2();
      var isUndefined = require_is_undefined2();
      var shuffle = require_shuffle2();
      function dfShuffle(df, axis) {
        if (isUndefined(axis))
          axis = 0;
        assert(
          axis === 0 || axis === 1,
          "The `axis` parameter to the `shuffle` must be 0, 1, or undefined."
        );
        return df.get(
          axis === 0 ? shuffle(df.index) : null,
          axis === 1 ? shuffle(df.columns) : null
        );
      }
      module.exports = dfShuffle;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/is-boolean.js
  var require_is_boolean2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/is-boolean.js"(exports, module) {
      function isBoolean(x) {
        return typeof x === "boolean";
      }
      module.exports = isBoolean;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/dataframe/df-sort.js
  var require_df_sort2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/dataframe/df-sort.js"(exports, module) {
      var { random } = require_random2();
      var assert = require_assert2();
      var flatten = require_flatten2();
      var isArray = require_is_array2();
      var isBoolean = require_is_boolean2();
      var isFunction = require_is_function2();
      var isNumber = require_is_number2();
      var isString = require_is_string2();
      var isUndefined = require_is_undefined2();
      var range = require_range2();
      var shape = require_shape2();
      var sort = require_sort2();
      function dfSort(df, a, b) {
        if (isFunction(a)) {
          return dfSortByFunction(df, a, b);
        } else {
          return dfSortByColumns(df, a, b);
        }
      }
      function dfSortByFunction(df, fn, axis) {
        axis = isUndefined(axis) ? 0 : axis;
        assert(
          isFunction(fn),
          "When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"
        );
        assert(
          isNumber(axis),
          "When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."
        );
        if (axis === 0) {
          const index = sort(df.index, (a, b) => {
            return fn(df.get(a, null), df.get(b, null));
          });
          return df.get(index, null);
        } else {
          const columns = sort(df.columns, (a, b) => {
            return fn(df.get(null, a), df.get(null, b));
          });
          return df.get(null, columns);
        }
      }
      function dfSortByColumns(df, cols, directions) {
        let out = df.copy();
        const indexID = random().toString();
        out = out.assign(indexID, out.index);
        if (isUndefined(cols)) {
          cols = [indexID];
          directions = [true];
        }
        if (isNumber(cols) || isString(cols)) {
          cols = [cols];
          if (isBoolean(directions) || isString(directions))
            directions = [directions];
        }
        assert(
          isArray(cols),
          "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."
        );
        assert(
          shape(cols).length === 1,
          "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."
        );
        if (isUndefined(directions))
          directions = range(0, cols.length).map(() => true);
        assert(
          isArray(directions),
          "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."
        );
        assert(
          shape(directions).length === 1,
          "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."
        );
        assert(
          cols.length === directions.length,
          "The arrays passed into the `sort` method must be equal in length."
        );
        cols = cols.map((col) => {
          assert(
            isString(col) || isNumber(col),
            "Column references can either be column names (as strings) or column indices (as whole numbers)."
          );
          if (isString(col)) {
            const index = out.columns.indexOf(col);
            assert(index > -1, `The column "${col}" does not exist!`);
            return index;
          }
          if (isNumber(col)) {
            assert(parseInt(col) === col, "Column indices must be whole numbers!");
            assert(col >= 0, `The column index ${col} is out of bounds!`);
            assert(col < out.columns.length, `The index ${col} is out of bounds!`);
            return col;
          }
        });
        directions = directions.map((dir) => {
          assert(
            isString(dir) || isBoolean(dir),
            "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."
          );
          if (isString(dir)) {
            const value = dir.trim().toLowerCase();
            assert(
              value === "ascending" || value === "descending",
              "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."
            );
            return value === "ascending";
          }
          if (isBoolean(dir)) {
            return dir;
          }
        });
        out.values = sort(out.values, (a, b) => {
          let counter = 0;
          while (a[cols[counter]] === b[cols[counter]] && counter < cols.length) {
            counter++;
          }
          const isAscending = directions[counter];
          if (a[cols[counter]] === b[cols[counter]])
            return 0;
          if (a[cols[counter]] < b[cols[counter]])
            return isAscending ? -1 : 1;
          if (a[cols[counter]] > b[cols[counter]])
            return isAscending ? 1 : -1;
        });
        out.index = flatten(out.get(null, indexID).values);
        out = out.dropColumns(indexID);
        return out;
      }
      module.exports = dfSort;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/dataframe/df-to-json-string.js
  var require_df_to_json_string2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/dataframe/df-to-json-string.js"(exports, module) {
      function dfToJSONString(df, axis) {
        return JSON.stringify(df.toObject(axis));
      }
      module.exports = dfToJSONString;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/dataframe/df-to-json.js
  var require_df_to_json2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/dataframe/df-to-json.js"(exports, module) {
      var MathError = require_math_error2();
      var dfToJSONString = require_df_to_json_string2();
      function toJSON(df, filename, axis) {
        const out = dfToJSONString(df, axis);
        let downloadedInBrowser = false;
        let wroteToDiskInNode = false;
        let browserError, nodeError;
        try {
          let newFilename = filename;
          if (filename.includes("/")) {
            const parts = filename.split("/");
            newFilename = parts[parts.length - 1];
          }
          const a = document.createElement("a");
          a.href = `data:application/json;charset=utf-8,${encodeURIComponent(out)}`;
          a.download = newFilename;
          a.dispatchEvent(new MouseEvent("click"));
          downloadedInBrowser = true;
        } catch (e) {
          browserError = e;
        }
        try {
          const fs = __require("fs");
          const path = __require("path");
          fs.writeFileSync(path.resolve(filename), out, "utf8");
          wroteToDiskInNode = true;
        } catch (e) {
          nodeError = e;
        }
        if (!downloadedInBrowser && !wroteToDiskInNode) {
          if (typeof window !== "undefined") {
            throw new MathError(browserError);
          } else if (typeof module !== "undefined") {
            throw new MathError(nodeError);
          } else {
            throw new MathError(
              "I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!"
            );
          }
        }
        return df;
      }
      module.exports = toJSON;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/dataframe/df-to-object.js
  var require_df_to_object2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/dataframe/df-to-object.js"(exports, module) {
      var assert = require_assert2();
      var isUndefined = require_is_undefined2();
      function dfToObject(df, axis) {
        if (isUndefined(axis)) {
          axis = 0;
        } else {
          assert(
            axis === 0 || axis === 1,
            "The axis parameter of the `toObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows."
          );
        }
        const out = {};
        if (axis === 0) {
          df.index.forEach((rowName, i) => {
            const temp = {};
            df.columns.forEach((colName, j) => {
              temp[colName] = df.values[i][j];
            });
            out[rowName] = temp;
          });
        } else {
          df.columns.forEach((colName, j) => {
            const temp = {};
            df.index.forEach((rowName, i) => {
              temp[rowName] = df.values[i][j];
            });
            out[colName] = temp;
          });
        }
        return out;
      }
      module.exports = dfToObject;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/transpose.js
  var require_transpose2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/transpose.js"(exports, module) {
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isSeries = require_is_series2();
      var ndarray = require_ndarray2();
      var reverse = require_reverse2();
      var shape = require_shape2();
      function transpose(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return arr.transpose();
        }
        assert(
          isArray(arr),
          "The `transpose` function only works on arrays, Series, and DataFrames!"
        );
        const theShape = shape(arr);
        assert(
          theShape.length <= 2,
          "I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"
        );
        if (theShape.length === 1) {
          return reverse(arr);
        } else if (theShape.length === 2) {
          const out = ndarray(reverse(theShape));
          for (let row = 0; row < theShape[0]; row++) {
            for (let col = 0; col < theShape[1]; col++) {
              out[col][row] = arr[row][col];
            }
          }
          return out;
        }
      }
      module.exports = transpose;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/series/series-append.js
  var require_series_append2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/series/series-append.js"(exports, module) {
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isNested = require_is_nested2();
      var isSeries = require_is_series2();
      var shape = require_shape2();
      function seriesAppend(Series, series, x) {
        if (isSeries(x)) {
          return new Series(series.values.concat(x.values));
        }
        if (isArray(x)) {
          const xShape = shape(x);
          assert(
            xShape.length === 1 && !isNested(xShape),
            "Only vectors can be appended to Series!"
          );
          const out = series.copy();
          x.forEach((v, i) => {
            out._values.push(v);
            out._index.push("item" + (series.values.length + i));
          });
          return out;
        }
        assert(!isDataFrame(x), "DataFrames cannot be appended to Series!");
        return seriesAppend(series, [x]);
      }
      module.exports = seriesAppend;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/series/series-apply.js
  var require_series_apply2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/series/series-apply.js"(exports, module) {
      var assert = require_assert2();
      var isFunction = require_is_function2();
      function seriesApply(series, fn) {
        assert(
          isFunction(fn),
          "The parameter to the `apply` method must be a function."
        );
        const out = series.copy();
        out._values = out._values.map((v, i) => fn(v, i));
        return out;
      }
      module.exports = seriesApply;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/series/series-drop-missing.js
  var require_series_drop_missing2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/series/series-drop-missing.js"(exports, module) {
      var isUndefined = require_is_undefined2();
      function seriesDropMissing(series) {
        const out = series.copy();
        const outIndex = [];
        out._values = out.values.filter((v, i) => {
          if (isUndefined(v)) {
            return false;
          } else {
            outIndex.push(out.index[i]);
            return true;
          }
        });
        out._index = outIndex;
        return out;
      }
      module.exports = seriesDropMissing;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/series/series-drop-nan.js
  var require_series_drop_nan2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/series/series-drop-nan.js"(exports, module) {
      var isNumber = require_is_number2();
      function seriesDropNaN(Series, series) {
        const index = [];
        const values = [];
        series.values.forEach((value, i) => {
          if (isNumber(value)) {
            values.push(value);
            index.push(series.index[i]);
          }
        });
        const out = new Series(values);
        out.name = series.name;
        out.index = index;
        return out;
      }
      module.exports = seriesDropNaN;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/series/series-filter.js
  var require_series_filter2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/series/series-filter.js"(exports, module) {
      var { copy } = require_copy2();
      function seriesFilter(Series, series, fn) {
        let out = series.copy();
        const index = copy(out.index);
        const indicesToRemove = [];
        const newValues = out.values.filter((value, i) => {
          const shouldKeep = fn(value, i, out.values);
          if (!shouldKeep)
            indicesToRemove.push(out.index[i]);
          return shouldKeep;
        });
        indicesToRemove.forEach((i) => {
          index.splice(index.indexOf(i), 1);
        });
        if (newValues.length === 0) {
          out = new Series();
          out.name = series.name;
          return out;
        }
        out.values = newValues;
        out.index = index;
        return out;
      }
      module.exports = seriesFilter;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/series/series-get.js
  var require_series_get2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/series/series-get.js"(exports, module) {
      var assert = require_assert2();
      var isNumber = require_is_number2();
      var isString = require_is_string2();
      var isUndefined = require_is_undefined2();
      var set = require_set2();
      function seriesGet(series, indices) {
        if (isString(indices) || isNumber(indices))
          indices = [indices];
        const types = set((indices || []).map((v) => typeof v));
        assert(
          types.length <= 2,
          "Only whole numbers and/or strings are allowed in `get` arrays!"
        );
        if (types.length === 1) {
          assert(
            types[0] === "string" || types[0] === "number",
            "Only whole numbers and/or strings are allowed in `get` arrays!"
          );
        }
        if (types.length === 2) {
          assert(
            types.indexOf("string") > -1,
            "Only whole numbers and/or strings are allowed in `get` arrays!"
          );
          assert(
            types.indexOf("number") > -1,
            "Only whole numbers and/or strings are allowed in `get` arrays!"
          );
        }
        if (!isUndefined(indices)) {
          indices = indices.map((i) => {
            if (typeof i === "string") {
              assert(series.index.indexOf(i) > -1, `Index "${i}" does not exist!`);
              return i;
            }
            if (typeof i === "number") {
              assert(i >= 0, `Index ${i} is out of bounds!`);
              assert(parseInt(i) === i, `Indices must be integers!`);
              assert(i < series.index.length, `Index ${i} is out of bounds!`);
              return series.index[i];
            }
          });
        }
        return series.getSubsetByNames(indices);
      }
      module.exports = seriesGet;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/series/series-get-subset-by-indices.js
  var require_series_get_subset_by_indices2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/series/series-get-subset-by-indices.js"(exports, module) {
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isUndefined = require_is_undefined2();
      var isWholeNumber = require_is_whole_number2();
      var range = require_range2();
      var shape = require_shape2();
      function seriesGetSubsetByIndices(series, indices) {
        const dataShape = series.shape;
        if (isUndefined(indices))
          indices = range(0, dataShape[0]);
        assert(
          isArray(indices),
          "The `indices` array must be 1-dimensional array of whole numbers."
        );
        assert(
          shape(indices).length === 1,
          "The `indices` array must be a 1-dimensional array of whole numbers."
        );
        assert(
          indices.length > 0,
          "The `indices` array must contain at least one index."
        );
        indices.forEach((index) => {
          assert(
            isWholeNumber(index),
            "The `indices` array must be a 1-dimensional array of whole numbers."
          );
          assert(
            index < series.index.length,
            `The row index ${index} is out of bounds.`
          );
        });
        const rows = indices.map((i) => series.index[i]);
        return series.getSubsetByNames(rows);
      }
      module.exports = seriesGetSubsetByIndices;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/series/series-get-subset-by-names.js
  var require_series_get_subset_by_names2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/series/series-get-subset-by-names.js"(exports, module) {
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isString = require_is_string2();
      var isUndefined = require_is_undefined2();
      var shape = require_shape2();
      function seriesGetSubsetByNames(Series, series, indices) {
        if (isUndefined(indices))
          indices = series.index;
        assert(
          isArray(indices),
          "The `indices` array must be a 1-dimensional array of strings."
        );
        assert(
          shape(indices).length === 1,
          "The `indices` array must be a 1-dimensional array of strings."
        );
        assert(
          indices.length > 0,
          "The `indices` array must contain at least one index name."
        );
        indices.forEach((name) => {
          assert(isString(name), "The `indices` array must contain only strings.");
          assert(
            series.index.indexOf(name) > -1,
            `The name "${name}" does not exist in the index.`
          );
        });
        const values = indices.map((name) => {
          return series.values[series.index.indexOf(name)];
        });
        if (values.length === 1)
          return values[0];
        const out = new Series(values);
        out.index = indices;
        out.name = series.name;
        return out;
      }
      module.exports = seriesGetSubsetByNames;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/series/series-print.js
  var require_series_print2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/series/series-print.js"(exports, module) {
      var { copy } = require_copy2();
      var range = require_range2();
      function seriesPrint(series) {
        let temp = series.copy();
        const maxRows = typeof window === "undefined" ? 20 : 10;
        if (temp.index.length > maxRows) {
          temp = temp.get(
            range(0, maxRows / 2).concat(
              range(temp.index.length - maxRows / 2, temp.index.length)
            )
          );
          const tempIndex = copy(temp.index);
          tempIndex.splice(parseInt(tempIndex.length / 2), 0, "...");
          temp.values.push("...");
          temp.index.push("...");
          temp = temp.get(tempIndex);
        }
        const out = {};
        temp.values.forEach((value, i) => {
          const obj = {};
          obj[temp.name] = value;
          out[temp.index[i]] = obj;
        });
        console.table(out);
        console.log("Shape:", series.shape, "\n");
        return series;
      }
      module.exports = seriesPrint;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/series/series-shuffle.js
  var require_series_shuffle2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/series/series-shuffle.js"(exports, module) {
      var shuffle = require_shuffle2();
      function seriesShuffle(series) {
        const out = series.copy();
        return out.get(shuffle(out.index));
      }
      module.exports = seriesShuffle;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/series/series-sort.js
  var require_series_sort2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/series/series-sort.js"(exports, module) {
      var assert = require_assert2();
      var isFunction = require_is_function2();
      var isUndefined = require_is_undefined2();
      var sort = require_sort2();
      var transpose = require_transpose2();
      function seriesSort(Series, series, fn) {
        fn = fn || ((a, b) => a < b ? -1 : 1);
        assert(
          isUndefined(fn) || isFunction(fn),
          "You must pass undefined, null, or a comparison function as the second argument to the `sort` method!"
        );
        const pairs = transpose([series.values, series.index]);
        const temp = sort(pairs, (aPair, bPair) => {
          return fn(aPair[0], bPair[0]);
        });
        const newValues = [];
        const newIndex = [];
        temp.forEach((pair) => {
          newValues.push(pair[0]);
          newIndex.push(pair[1]);
        });
        const out = new Series();
        out._values = newValues;
        out._index = newIndex;
        out.name = series.name;
        return out;
      }
      module.exports = seriesSort;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/series/series-sort-by-index.js
  var require_series_sort_by_index2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/series/series-sort-by-index.js"(exports, module) {
      var sort = require_sort2();
      var transpose = require_transpose2();
      function seriesSortByIndex(Series, series) {
        let temp = transpose([series.values, series.index]);
        temp = transpose(
          sort(temp, (a, b) => {
            if (a[1] === b[1])
              return 0;
            if (a[1] < b[1])
              return -1;
            if (a[1] > b[1])
              return 1;
          })
        );
        const out = new Series(temp[0]);
        out.index = temp[1];
        out.name = series.name;
        return out;
      }
      module.exports = seriesSortByIndex;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/series/series-to-object.js
  var require_series_to_object2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/series/series-to-object.js"(exports, module) {
      function seriesToObject(series) {
        const out = {};
        out[series.name] = {};
        series.index.forEach((index, i) => {
          out[series.name][index] = series.values[i];
        });
        return out;
      }
      module.exports = seriesToObject;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/series/index.js
  var require_series2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/series/index.js"(exports, module) {
      var { copy } = require_copy2();
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isString = require_is_string2();
      var isUndefined = require_is_undefined2();
      var leftPad = require_left_pad2();
      var range = require_range2();
      var reverse = require_reverse2();
      var seriesAppend = require_series_append2();
      var seriesApply = require_series_apply2();
      var seriesDropMissing = require_series_drop_missing2();
      var seriesDropNaN = require_series_drop_nan2();
      var seriesFilter = require_series_filter2();
      var seriesGet = require_series_get2();
      var seriesGetSubsetByIndices = require_series_get_subset_by_indices2();
      var seriesGetSubsetByNames = require_series_get_subset_by_names2();
      var seriesPrint = require_series_print2();
      var seriesShuffle = require_series_shuffle2();
      var seriesSort = require_series_sort2();
      var seriesSortByIndex = require_series_sort_by_index2();
      var seriesToObject = require_series_to_object2();
      var shape = require_shape2();
      var transpose = require_transpose2();
      var SERIES_SYMBOL = Symbol.for("@jrc03c/js-math-tools/series");
      module.exports = function(DataFrame) {
        class Series {
          static [Symbol.hasInstance](x) {
            try {
              return !!x._symbol && x._symbol === SERIES_SYMBOL;
            } catch (e) {
              return false;
            }
          }
          constructor(data) {
            const self2 = this;
            self2.name = "data";
            Object.defineProperty(self2, "_symbol", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: SERIES_SYMBOL
            });
            Object.defineProperty(self2, "_values", {
              value: [],
              configurable: true,
              enumerable: false,
              writable: true
            });
            Object.defineProperty(self2, "values", {
              configurable: true,
              enumerable: true,
              get() {
                return self2._values;
              },
              set(x) {
                assert(isArray(x), "The new values must be a 1-dimensional array!");
                const dataShape = shape(x);
                assert(
                  dataShape.length === 1,
                  "The new array of values must be 1-dimensional!"
                );
                if (dataShape[0] < self2._index.length) {
                  self2._index = self2._index.slice(0, dataShape[0]);
                } else if (dataShape[0] > self2._index.length) {
                  self2._index = self2._index.concat(
                    range(self2._index.length, dataShape[0]).map((i) => {
                      return "item" + leftPad(i, (x.length - 1).toString().length);
                    })
                  );
                }
                self2._values = x;
              }
            });
            Object.defineProperty(self2, "_index", {
              value: [],
              configurable: true,
              enumerable: false,
              writable: true
            });
            Object.defineProperty(self2, "index", {
              configurable: true,
              enumerable: true,
              get() {
                return self2._index;
              },
              set(x) {
                assert(
                  isArray(x),
                  "The new index must be a 1-dimensional array of strings!"
                );
                assert(
                  x.length === self2.shape[0],
                  "The new index must be the same length as the old index!"
                );
                assert(
                  shape(x).length === 1,
                  "The new index must be a 1-dimensional array of strings!"
                );
                x.forEach((value) => {
                  assert(isString(value), "All of the row names must be strings!");
                });
                self2._index = x;
              }
            });
            if (data) {
              if (data instanceof Series) {
                self2.name = data.name;
                self2.values = copy(data.values);
                self2.index = copy(data.index);
              } else if (isArray(data)) {
                const dataShape = shape(data);
                assert(
                  dataShape.length === 1,
                  "When passing an array into the constructor of a Series, the array must be 1-dimensional!"
                );
                self2.values = data;
              } else if (data instanceof Object) {
                const keys = Object.keys(data);
                assert(
                  keys.length === 1,
                  "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"
                );
                const name = keys[0];
                const values = data[name];
                assert(
                  shape(values).length === 1,
                  "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"
                );
                self2.name = name;
                self2.values = values.slice();
              }
            }
          }
          get shape() {
            const self2 = this;
            return shape(self2.values);
          }
          get length() {
            const self2 = this;
            return self2.shape[0];
          }
          get isEmpty() {
            const self2 = this;
            return self2.values.filter((v) => !isUndefined(v)).length === 0;
          }
          clear() {
            const self2 = this;
            const out = self2.copy();
            out.values.forEach((v, i) => {
              out.values[i] = void 0;
            });
            return out;
          }
          get(indices) {
            const self2 = this;
            return seriesGet(self2, indices);
          }
          getSubsetByNames(indices) {
            const self2 = this;
            return seriesGetSubsetByNames(Series, self2, indices);
          }
          getSubsetByIndices(indices) {
            const self2 = this;
            return seriesGetSubsetByIndices(self2, indices);
          }
          loc(indices) {
            const self2 = this;
            return self2.getSubsetByNames(indices);
          }
          iloc(indices) {
            const self2 = this;
            return self2.getSubsetByIndices(indices);
          }
          reverse() {
            const self2 = this;
            const out = new Series(reverse(self2.values));
            out.index = reverse(self2.index);
            out.name = self2.name;
            return out;
          }
          resetIndex() {
            const self2 = this;
            const out = self2.copy();
            out.index = range(0, self2.shape[0]).map((i) => {
              return "item" + leftPad(i, (out.index.length - 1).toString().length);
            });
            return out;
          }
          copy() {
            const self2 = this;
            const out = new Series();
            out._values = copy(self2.values);
            out._index = copy(self2.index);
            out.name = self2.name;
            return out;
          }
          append(x) {
            const self2 = this;
            return seriesAppend(Series, self2, x);
          }
          apply(fn) {
            const self2 = this;
            return seriesApply(self2, fn);
          }
          concat(x) {
            const self2 = this;
            return self2.append(x);
          }
          dropMissing(condition, threshold) {
            const self2 = this;
            return seriesDropMissing(self2, condition, threshold);
          }
          dropNaN() {
            const self2 = this;
            return seriesDropNaN(Series, self2);
          }
          toObject() {
            const self2 = this;
            return seriesToObject(self2);
          }
          print() {
            const self2 = this;
            return seriesPrint(self2);
          }
          shuffle() {
            const self2 = this;
            return seriesShuffle(self2);
          }
          sort(direction) {
            const self2 = this;
            return seriesSort(Series, self2, direction);
          }
          sortByIndex() {
            const self2 = this;
            return seriesSortByIndex(Series, self2);
          }
          filter(fn) {
            const self2 = this;
            return seriesFilter(Series, self2, fn);
          }
          toDataFrame() {
            const self2 = this;
            const out = new DataFrame(transpose([self2.values]));
            out.columns = [self2.name];
            out.index = self2.index;
            return out;
          }
          transpose() {
            const self2 = this;
            const out = self2.copy();
            out.values = reverse(out.values);
            out.index = reverse(out.index);
            return out;
          }
          getDummies() {
            const self2 = this;
            return self2.toDataFrame().getDummies();
          }
          oneHotEncode() {
            const self2 = this;
            return self2.getDummies();
          }
        }
        return Series;
      };
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/dataframe/index.js
  var require_dataframe2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/dataframe/index.js"(exports, module) {
      var { copy } = require_copy2();
      var assert = require_assert2();
      var count = require_count2();
      var dfAppend = require_df_append2();
      var dfApply = require_df_apply2();
      var dfAssign = require_df_assign2();
      var dfCopy = require_df_copy2();
      var dfDrop = require_df_drop2();
      var dfDropMissing = require_df_drop_missing2();
      var dfDropNaN = require_df_drop_nan2();
      var dfFilter = require_df_filter2();
      var dfGet = require_df_get2();
      var dfGetDummies = require_df_get_dummies2();
      var dfGetSubsetByIndices = require_df_get_subset_by_indices2();
      var dfGetSubsetByNames = require_df_get_subset_by_names2();
      var dfPrint = require_df_print2();
      var dfResetIndex = require_df_reset_index2();
      var dfShuffle = require_df_shuffle2();
      var dfSort = require_df_sort2();
      var dfToJSON = require_df_to_json2();
      var dfToJSONString = require_df_to_json_string2();
      var dfToObject = require_df_to_object2();
      var flatten = require_flatten2();
      var isArray = require_is_array2();
      var isObject = require_is_object2();
      var isUndefined = require_is_undefined2();
      var leftPad = require_left_pad2();
      var ndarray = require_ndarray2();
      var range = require_range2();
      var shape = require_shape2();
      var transpose = require_transpose2();
      var DATAFRAME_SYMBOL = Symbol.for("@jrc03c/js-math-tools/dataframe");
      function makeKey(n) {
        const alpha = "abcdefghijklmnopqrstuvwxyz1234567890";
        let out = "";
        for (let i = 0; i < n; i++)
          out += alpha[parseInt(Math.random() * alpha.length)];
        return out;
      }
      var DataFrame = class {
        static [Symbol.hasInstance](x) {
          try {
            return !!x._symbol && x._symbol === DATAFRAME_SYMBOL;
          } catch (e) {
            return false;
          }
        }
        constructor(data) {
          const self2 = this;
          Object.defineProperty(self2, "_symbol", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: DATAFRAME_SYMBOL
          });
          Object.defineProperty(self2, "_values", {
            value: [],
            configurable: true,
            enumerable: false,
            writable: true
          });
          Object.defineProperty(self2, "values", {
            configurable: true,
            enumerable: true,
            get() {
              if (self2._values.length === 0 || !isUndefined(self2._values[0]) && self2._values[0].length === 0) {
                return [[]];
              }
              return self2._values;
            },
            set(x) {
              assert(isArray(x), "The new values must be a 2-dimensional array!");
              const dataShape = shape(x);
              assert(
                dataShape.length === 2,
                "The new array of values must be 2-dimensional!"
              );
              if (dataShape[0] < self2._index.length) {
                self2._index = self2._index.slice(0, dataShape[0]);
              } else if (dataShape[0] > self2._index.length) {
                self2._index = self2._index.concat(
                  range(self2._index.length, dataShape[0]).map((i) => {
                    return "row" + leftPad(i, (dataShape[0] - 1).toString().length);
                  })
                );
              }
              if (dataShape[1] < self2._columns.length) {
                self2._columns = self2._columns.slice(0, dataShape[1]);
              } else if (dataShape[1] > self2._columns.length) {
                self2._columns = self2._columns.concat(
                  range(self2._columns.length, dataShape[1]).map((i) => {
                    return "col" + leftPad(i, (dataShape[1] - 1).toString().length);
                  })
                );
              }
              self2._values = x;
            }
          });
          Object.defineProperty(self2, "_columns", {
            value: [],
            configurable: true,
            enumerable: false,
            writable: true
          });
          Object.defineProperty(self2, "columns", {
            configurable: true,
            enumerable: true,
            get() {
              return self2._columns;
            },
            set(x) {
              assert(
                isArray(x),
                "The new columns list must be a 1-dimensional array of strings!"
              );
              assert(
                self2.isEmpty || x.length === self2.shape[1],
                "The new columns list must be the same length as the old columns list!"
              );
              assert(
                shape(x).length === 1,
                "The new columns list must be a 1-dimensional array of strings!"
              );
              x = x.map((v) => {
                if (typeof v !== "string") {
                  v = JSON.stringify(v) || v.toString();
                }
                if (v.trim().length === 0) {
                  return "untitled_" + makeKey(8);
                }
                return v.trim();
              });
              const counts = (() => {
                const temp = count(x);
                const out = {};
                temp.forEach((obj) => {
                  out[obj.value] = obj.count;
                });
                return out;
              })();
              x = x.map((v) => {
                if (counts[v] > 1) {
                  return v + "_" + makeKey(8);
                }
                return v;
              });
              self2._columns = x;
            }
          });
          Object.defineProperty(self2, "_index", {
            value: [],
            configurable: true,
            enumerable: false,
            writable: true
          });
          Object.defineProperty(self2, "index", {
            configurable: true,
            enumerable: true,
            get() {
              return self2._index;
            },
            set(x) {
              assert(
                isArray(x),
                "The new index must be a 1-dimensional array of strings!"
              );
              assert(
                self2.isEmpty || x.length === self2.shape[0],
                "The new index must be the same length as the old index!"
              );
              assert(
                shape(x).length === 1,
                "The new index must be a 1-dimensional array of strings!"
              );
              x = x.map((v) => {
                if (typeof v !== "string") {
                  v = JSON.stringify(v) || v.toString();
                }
                if (v.trim().length === 0) {
                  return "untitled_" + makeKey(8);
                }
                return v.trim();
              });
              const counts = (() => {
                const temp = count(x);
                const out = {};
                temp.forEach((obj) => {
                  out[obj.value] = obj.count;
                });
                return out;
              })();
              x = x.map((v) => {
                if (counts[v] > 1) {
                  return v + "_" + makeKey(8);
                }
                return v;
              });
              self2._index = x;
            }
          });
          assert(
            isUndefined(data) || isObject(data) || isArray(data),
            "The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."
          );
          if (data) {
            if (data instanceof DataFrame) {
              self2.values = copy(data.values);
              self2.columns = copy(data.columns);
              self2.index = copy(data.index);
            } else if (isArray(data)) {
              const dataShape = shape(data);
              assert(
                dataShape.length === 2,
                "The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"
              );
              self2.values = data;
            } else {
              self2._columns = Object.keys(data);
              const temp = [];
              self2._columns.forEach((col) => {
                const values = data[col];
                temp.push(values);
              });
              self2._values = transpose(temp);
              const dataShape = shape(self2.values);
              self2._index = range(0, dataShape[0]).map((i) => {
                return "row" + leftPad(i, (dataShape[0] - 1).toString().length);
              });
            }
          }
        }
        get shape() {
          const self2 = this;
          return shape(self2.values);
        }
        get length() {
          const self2 = this;
          return self2.shape[0];
        }
        get width() {
          const self2 = this;
          return self2.shape[1];
        }
        get rows() {
          const self2 = this;
          return self2.index;
        }
        set rows(rows) {
          const self2 = this;
          self2.index = rows;
        }
        get isEmpty() {
          const self2 = this;
          return flatten(self2.values).length === 0;
        }
        clear() {
          const self2 = this;
          const out = new DataFrame(ndarray(self2.shape));
          out.columns = self2.columns.slice();
          out.index = self2.index.slice();
          return out;
        }
        get(rows, cols) {
          const self2 = this;
          if (arguments.length === 0) {
            return self2;
          }
          if (arguments.length === 1) {
            try {
              return self2.get(null, rows);
            } catch (e) {
              return self2.get(rows, null);
            }
          }
          return dfGet(self2, rows, cols);
        }
        getSubsetByNames(rows, cols) {
          const self2 = this;
          return dfGetSubsetByNames(DataFrame, Series, self2, rows, cols);
        }
        getSubsetByIndices(rowIndices, colIndices) {
          const self2 = this;
          return dfGetSubsetByIndices(self2, rowIndices, colIndices);
        }
        getDummies(columns) {
          const self2 = this;
          return dfGetDummies(DataFrame, self2, columns);
        }
        oneHotEncode(columns) {
          const self2 = this;
          return dfGetDummies(DataFrame, self2, columns);
        }
        transpose() {
          const self2 = this;
          const out = new DataFrame(transpose(self2.values));
          out.columns = self2.index.slice();
          out.index = self2.columns.slice();
          return out;
        }
        get T() {
          const self2 = this;
          return self2.transpose();
        }
        resetIndex(shouldSkipCopying) {
          const self2 = this;
          return dfResetIndex(self2, shouldSkipCopying);
        }
        copy() {
          const self2 = this;
          return dfCopy(DataFrame, self2);
        }
        assign(p1, p2) {
          const self2 = this;
          return dfAssign(DataFrame, Series, self2, p1, p2);
        }
        apply(fn, axis) {
          const self2 = this;
          return dfApply(DataFrame, Series, self2, fn, axis);
        }
        dropMissing(axis, condition, threshold) {
          const self2 = this;
          return dfDropMissing(DataFrame, Series, self2, axis, condition, threshold);
        }
        dropNaN(axis, condition, threshold) {
          const self2 = this;
          return dfDropNaN(DataFrame, self2, axis, condition, threshold);
        }
        drop(rows, cols) {
          const self2 = this;
          return dfDrop(DataFrame, Series, self2, rows, cols);
        }
        dropColumns(columns) {
          const self2 = this;
          return self2.drop(null, columns);
        }
        dropRows(rows) {
          const self2 = this;
          return self2.drop(rows, null);
        }
        toObject(axis) {
          const self2 = this;
          return dfToObject(self2, axis);
        }
        toJSONString(axis) {
          const self2 = this;
          return dfToJSONString(self2, axis);
        }
        saveAsJSON(filename, axis) {
          const self2 = this;
          return dfToJSON(self2, filename, axis);
        }
        print() {
          const self2 = this;
          return dfPrint(DataFrame, Series, self2);
        }
        sort(cols, directions) {
          const self2 = this;
          return dfSort(self2, cols, directions);
        }
        sortByIndex() {
          const self2 = this;
          return self2.sort();
        }
        filter(fn, axis) {
          const self2 = this;
          return dfFilter(DataFrame, Series, self2, fn, axis);
        }
        shuffle(axis) {
          const self2 = this;
          return dfShuffle(self2, axis);
        }
        append(x, axis) {
          const self2 = this;
          return dfAppend(self2, x, axis);
        }
        concat(x, axis) {
          const self2 = this;
          return self2.append(x, axis);
        }
        join(x, axis) {
          const self2 = this;
          return self2.append(x, axis);
        }
        toString() {
          const self2 = this;
          return JSON.stringify(self2);
        }
      };
      var Series = require_series2()(DataFrame);
      module.exports = { DataFrame, Series };
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/max.js
  var require_max2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/max.js"(exports, module) {
      var assert = require_assert2();
      var flatten = require_flatten2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isSeries = require_is_series2();
      function max(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return max(arr.values);
        }
        assert(
          isArray(arr),
          "The `max` function only works on arrays, Series, and DataFrames!"
        );
        try {
          return Math.max(...flatten(arr));
        } catch (e) {
          return NaN;
        }
      }
      module.exports = max;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/vectorize.js
  var require_vectorize2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/vectorize.js"(exports, module) {
      var { DataFrame, Series } = require_dataframe2();
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isEqual = require_is_equal2();
      var isFunction = require_is_function2();
      var isSeries = require_is_series2();
      var max = require_max2();
      var range = require_range2();
      var shape = require_shape2();
      function isArraySeriesOrDataFrame(x) {
        return isArray(x) || isSeries(x) || isDataFrame(x);
      }
      function vectorize(fn) {
        assert(
          isFunction(fn),
          "You must pass a function into the `vectorize` function!"
        );
        return function helper() {
          let hasSeries, hasDataFrames;
          const series = [];
          const dataframes = [];
          const childArrays = Object.keys(arguments).filter((key) => {
            const arg = arguments[key];
            if (isArray(arg)) {
              return true;
            } else if (isSeries(arg)) {
              hasSeries = true;
              series.push(arg);
              return true;
            } else if (isDataFrame(arg)) {
              hasDataFrames = true;
              dataframes.push(arg);
              return true;
            } else {
              return false;
            }
          }).map((key) => arguments[key]);
          childArrays.slice(0, -1).forEach((s, i) => {
            assert(
              isEqual(
                isArray(s) ? shape(s) : s.shape,
                isArray(childArrays[i + 1]) ? shape(childArrays[i + 1]) : childArrays[i + 1].shape
              ),
              `When passing multiple arrays into the \`${fn.name}\` function, all of the arrays must have the same shape!`
            );
          });
          if (childArrays.length > 0) {
            const maxLength = max(
              childArrays.map((a) => a.length ? a.length : a.values.length)
            );
            const out = range(0, maxLength).map((i) => {
              const args = Object.keys(arguments).map((key) => {
                if (isArraySeriesOrDataFrame(arguments[key])) {
                  if (isArray(arguments[key])) {
                    return arguments[key][i];
                  } else if (isSeries(arguments[key])) {
                    return arguments[key].values[i];
                  } else if (isDataFrame(arguments[key])) {
                    return arguments[key].values[i];
                  }
                } else {
                  return arguments[key];
                }
              });
              return helper(...args);
            });
            if (hasDataFrames) {
              try {
                if (dataframes.length === 1 && isEqual(shape(dataframes[0]), shape(out))) {
                  const temp = new DataFrame(out);
                  temp.index = dataframes[0].index.slice();
                  temp.columns = dataframes[0].columns.slice();
                  return temp;
                } else {
                  return new DataFrame(out);
                }
              } catch (e) {
                return out;
              }
            }
            if (hasSeries) {
              try {
                if (series.length === 1 && series[0].length === out.length) {
                  const temp = new Series(out);
                  temp.name = series[0].name;
                  temp.index = series[0].index.slice();
                  return temp;
                } else {
                  return new Series(out);
                }
              } catch (e) {
                return out;
              }
            }
            return out;
          } else {
            return fn(...arguments);
          }
        };
      }
      module.exports = vectorize;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/abs.js
  var require_abs2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/abs.js"(exports, module) {
      var isNumber = require_is_number2();
      var vectorize = require_vectorize2();
      function abs(x) {
        try {
          if (!isNumber(x))
            return NaN;
          return Math.abs(x);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(abs);
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/add.js
  var require_add2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/add.js"(exports, module) {
      var isNumber = require_is_number2();
      var vectorize = require_vectorize2();
      function add() {
        try {
          let out = 0;
          const x = Object.values(arguments);
          for (let i = 0; i < x.length; i++) {
            if (!isNumber(x[i]))
              return NaN;
            out += x[i];
          }
          return out;
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(add);
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/apply.js
  var require_apply2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/apply.js"(exports, module) {
      var vectorize = require_vectorize2();
      function apply(x, fn) {
        try {
          return fn(x);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(apply);
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/arccos.js
  var require_arccos2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/arccos.js"(exports, module) {
      var isNumber = require_is_number2();
      var vectorize = require_vectorize2();
      function arccos(x) {
        try {
          if (!isNumber(x))
            return NaN;
          return Math.acos(x);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(arccos);
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/arcsin.js
  var require_arcsin2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/arcsin.js"(exports, module) {
      var isNumber = require_is_number2();
      var vectorize = require_vectorize2();
      function arcsin(x) {
        try {
          if (!isNumber(x))
            return NaN;
          return Math.asin(x);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(arcsin);
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/arctan.js
  var require_arctan2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/arctan.js"(exports, module) {
      var isNumber = require_is_number2();
      var vectorize = require_vectorize2();
      function arctan(x) {
        try {
          if (!isNumber(x))
            return NaN;
          return Math.atan(x);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(arctan);
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/argmax.js
  var require_argmax2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/argmax.js"(exports, module) {
      var assert = require_assert2();
      var indexOf = require_index_of2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isSeries = require_is_series2();
      var max = require_max2();
      function argmax(x) {
        if (isDataFrame(x)) {
          const index = argmax(x.values);
          return [x.index[index[0]], x.columns[index[1]]];
        }
        if (isSeries(x)) {
          const index = argmax(x.values);
          return [x.index[index]];
        }
        assert(
          isArray(x),
          "The `argmax` function only works on arrays, Series, and DataFrames!"
        );
        try {
          const out = indexOf(x, max(x));
          if (out) {
            if (out.length === 0) {
              return void 0;
            } else if (out.length === 1) {
              return out[0];
            } else {
              return out;
            }
          } else {
            return void 0;
          }
        } catch (e) {
          return void 0;
        }
      }
      module.exports = argmax;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/min.js
  var require_min2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/min.js"(exports, module) {
      var assert = require_assert2();
      var flatten = require_flatten2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isSeries = require_is_series2();
      function min(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return min(arr.values);
        }
        assert(
          isArray(arr),
          "The `min` function only works on arrays, Series, and DataFrames!"
        );
        try {
          return Math.min(...flatten(arr));
        } catch (e) {
          return NaN;
        }
      }
      module.exports = min;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/argmin.js
  var require_argmin2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/argmin.js"(exports, module) {
      var assert = require_assert2();
      var indexOf = require_index_of2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isSeries = require_is_series2();
      var min = require_min2();
      function argmin(x) {
        if (isDataFrame(x)) {
          const index = argmin(x.values);
          return [x.index[index[0]], x.columns[index[1]]];
        }
        if (isSeries(x)) {
          const index = argmin(x.values);
          return [x.index[index]];
        }
        assert(
          isArray(x),
          "The `argmin` function only works on arrays, Series, and DataFrames!"
        );
        try {
          const out = indexOf(x, min(x));
          if (out) {
            if (out.length === 0) {
              return void 0;
            } else if (out.length === 1) {
              return out[0];
            } else {
              return out;
            }
          } else {
            return void 0;
          }
        } catch (e) {
          return void 0;
        }
      }
      module.exports = argmin;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/cast.js
  var require_cast2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/cast.js"(exports, module) {
      var isArray = require_is_array2();
      var isBoolean = require_is_boolean2();
      var isDataFrame = require_is_dataframe2();
      var isEqual = require_is_equal2();
      var isNumber = require_is_number2();
      var isObject = require_is_object2();
      var isSeries = require_is_series2();
      var isUndefined = require_is_undefined2();
      function cast(value, type) {
        if (isDataFrame(value) || isSeries(value)) {
          return value.apply((item) => cast(item, type));
        }
        if (isArray(value)) {
          return value.map((v) => cast(v, type));
        }
        if (type === "null") {
          return null;
        }
        if (type === "number") {
          if (isUndefined(value)) {
            return NaN;
          }
          const booleanValue = cast(value, "boolean");
          if (isBoolean(booleanValue)) {
            return booleanValue ? 1 : 0;
          }
          try {
            JSON.parse(value);
          } catch (e) {
            const dateValue = cast(value, "date");
            if (dateValue instanceof Date) {
              return dateValue.getTime();
            }
          }
          const out = parseFloat(value);
          if (isNaN(out))
            return NaN;
          return out;
        }
        if (type === "boolean") {
          if (isBoolean(value)) {
            return value;
          }
          if (isNumber(value)) {
            if (value === 0) {
              return false;
            }
            if (value === 1) {
              return true;
            }
            return null;
          }
          try {
            const vBool = (typeof value === "object" ? value.toString() === "null" ? "false" : JSON.stringify(value) : value.toString()).trim().toLowerCase();
            if (vBool === "true" || vBool === "yes" || vBool === "y") {
              return true;
            }
            if (vBool === "false" || vBool === "no" || vBool === "n") {
              return false;
            }
            return null;
          } catch (e) {
            return null;
          }
        }
        if (type === "date") {
          if (value instanceof Date) {
            return value;
          }
          if (isUndefined(value)) {
            return null;
          }
          const valueFloat = parseFloat(value);
          if (!isNaN(valueFloat)) {
            const out = new Date(value);
            if (out.toString() === "Invalid Date")
              return null;
            return out;
          }
          const valueDate = Date.parse(value);
          if (!isNaN(valueDate)) {
            return new Date(valueDate);
          }
          return null;
        }
        if (type === "object") {
          if (isObject(value)) {
            return value;
          }
          const booleanValue = cast(value, "boolean");
          if (isBoolean(booleanValue)) {
            return null;
          }
          try {
            const numberValue = cast(value, "number");
            if (isNumber(numberValue)) {
              JSON.parse(value);
              return null;
            }
          } catch (e) {
          }
          const dateValue = cast(value, "date");
          if (dateValue) {
            return dateValue;
          }
          try {
            const out = JSON.parse(value);
            if (isArray(out)) {
              return out.map((v) => cast(v, type));
            } else {
              return out;
            }
          } catch (e) {
            return null;
          }
        }
        if (type === "string") {
          if (isUndefined(value)) {
            if (isEqual(value, void 0)) {
              return "undefined";
            }
            return "null";
          }
          if (value instanceof Date) {
            return value.toJSON();
          }
          const valueString = (() => {
            if (typeof value === "object") {
              if (value === null) {
                return "null";
              } else {
                return JSON.stringify(value);
              }
            } else {
              return value.toString();
            }
          })();
          return valueString;
        }
      }
      module.exports = cast;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/ceil.js
  var require_ceil2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/ceil.js"(exports, module) {
      var isNumber = require_is_number2();
      var vectorize = require_vectorize2();
      function ceil(x) {
        try {
          if (!isNumber(x))
            return NaN;
          return Math.ceil(x);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(ceil);
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/chop.js
  var require_chop2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/chop.js"(exports, module) {
      var abs = require_abs2();
      var isNumber = require_is_number2();
      var isUndefined = require_is_undefined2();
      var vectorize = require_vectorize2();
      function chop(x, threshold) {
        try {
          if (!isNumber(x))
            return NaN;
          if (isUndefined(threshold)) {
            threshold = 1e-10;
          } else if (!isNumber(threshold)) {
            return NaN;
          }
          return abs(x) < threshold ? 0 : x;
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(chop);
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/clamp.js
  var require_clamp2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/clamp.js"(exports, module) {
      var isNumber = require_is_number2();
      var vectorize = require_vectorize2();
      function clamp(x, a, b) {
        try {
          if (!isNumber(x))
            return NaN;
          if (!isNumber(a))
            return NaN;
          if (!isNumber(b))
            return NaN;
          if (x < a)
            return a;
          if (x > b)
            return b;
          return x;
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(clamp);
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/combinations.js
  var require_combinations2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/combinations.js"(exports, module) {
      var assert = require_assert2();
      var flatten = require_flatten2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isNumber = require_is_number2();
      var isSeries = require_is_series2();
      function combinations(arr, r) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return combinations(arr.values, r);
        }
        assert(
          isArray(arr),
          "The `combinations` function only works on arrays, Series, and DataFrames!"
        );
        assert(isNumber(r), "`r` must be a whole number!");
        arr = flatten(arr);
        if (r > arr.length) {
          return [arr];
        }
        if (r <= 0) {
          return [[]];
        }
        assert(r === parseInt(r), "`r` must be a whole number!");
        if (arr.length < 2)
          return arr;
        const out = [];
        arr.forEach((item, i) => {
          const after = arr.slice(i + 1);
          if (after.length < r - 1)
            return;
          const children = combinations(after, r - 1);
          children.forEach((child) => {
            out.push([item].concat(child));
          });
        });
        return out;
      }
      module.exports = combinations;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/mean.js
  var require_mean2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/mean.js"(exports, module) {
      var assert = require_assert2();
      var flatten = require_flatten2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isSeries = require_is_series2();
      function mean(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return mean(arr.values);
        }
        assert(
          isArray(arr),
          "The `mean` function only works on arrays, Series, and DataFrames!"
        );
        try {
          const temp = flatten(arr);
          let out = 0;
          temp.forEach((v) => {
            out += v;
          });
          return out / temp.length;
        } catch (e) {
          return NaN;
        }
      }
      module.exports = mean;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/covariance.js
  var require_covariance2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/covariance.js"(exports, module) {
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isNumber = require_is_number2();
      var isSeries = require_is_series2();
      var mean = require_mean2();
      var shape = require_shape2();
      function covariance(x, y) {
        if (isSeries(x)) {
          return covariance(x.values, y);
        }
        if (isSeries(y)) {
          return covariance(x, y.values);
        }
        assert(
          isArray(x) && isArray(y) && shape(x).length === 1 && shape(y).length === 1,
          "The `covariance` function only works on 1-dimensional arrays and Series!"
        );
        assert(
          x.length === y.length,
          "The two arrays or Series passed into the `covariance` function must have the same length!"
        );
        try {
          const mx = mean(x);
          const my = mean(y);
          if (!isNumber(mx) || !isNumber(my)) {
            return NaN;
          }
          const n = Math.max(x.length, y.length);
          let out = 0;
          for (let i = 0; i < n; i++) {
            if (!isNumber(x[i]))
              return NaN;
            if (!isNumber(y[i]))
              return NaN;
            out += (x[i] - mx) * (y[i] - my);
          }
          return out / x.length;
        } catch (e) {
          return NaN;
        }
      }
      module.exports = covariance;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/sqrt.js
  var require_sqrt2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/sqrt.js"(exports, module) {
      var isNumber = require_is_number2();
      var vectorize = require_vectorize2();
      function sqrt(x) {
        try {
          if (!isNumber(x))
            return NaN;
          return Math.sqrt(x);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(sqrt);
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/variance.js
  var require_variance2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/variance.js"(exports, module) {
      var assert = require_assert2();
      var flatten = require_flatten2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isNumber = require_is_number2();
      var isSeries = require_is_series2();
      var mean = require_mean2();
      function variance(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return variance(arr.values);
        }
        assert(
          isArray(arr),
          "The `variance` function only works on arrays, Series, and DataFrames!"
        );
        try {
          const temp = flatten(arr);
          const m = mean(temp);
          let out = 0;
          for (let i = 0; i < temp.length; i++) {
            if (!isNumber(temp[i]))
              return NaN;
            out += (temp[i] - m) * (temp[i] - m);
          }
          return out / temp.length;
        } catch (e) {
          return NaN;
        }
      }
      module.exports = variance;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/std.js
  var require_std2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/std.js"(exports, module) {
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isSeries = require_is_series2();
      var sqrt = require_sqrt2();
      var variance = require_variance2();
      function std(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return std(arr.values);
        }
        assert(
          isArray(arr),
          "The `std` function only works on arrays, Series, and DataFrames!"
        );
        try {
          return sqrt(variance(arr));
        } catch (e) {
          return NaN;
        }
      }
      module.exports = std;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/correl.js
  var require_correl2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/correl.js"(exports, module) {
      var assert = require_assert2();
      var covariance = require_covariance2();
      var isArray = require_is_array2();
      var isSeries = require_is_series2();
      var shape = require_shape2();
      var std = require_std2();
      function correl(x, y) {
        if (isSeries(x)) {
          return correl(x.values, y);
        }
        if (isSeries(y)) {
          return correl(x, y.values);
        }
        assert(
          isArray(x) && isArray(y) && shape(x).length === 1 && shape(y).length === 1,
          "The `correl` function only works on 1-dimensional arrays and Series!"
        );
        assert(
          x.length === y.length,
          "The two arrays or Series passed into the `correl` function must have the same length!"
        );
        try {
          return covariance(x, y) / (std(x) * std(y));
        } catch (e) {
          return NaN;
        }
      }
      module.exports = correl;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/cos.js
  var require_cos2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/cos.js"(exports, module) {
      var isNumber = require_is_number2();
      var vectorize = require_vectorize2();
      function cos(x) {
        try {
          if (!isNumber(x))
            return NaN;
          return Math.cos(x);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(cos);
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/helpers/data-types.js
  var require_data_types2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/helpers/data-types.js"(exports, module) {
      module.exports = Object.freeze({
        boolean: "boolean",
        date: "date",
        null: "null",
        number: "number",
        object: "object",
        string: "string"
      });
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/diff.js
  var require_diff2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/diff.js"(exports, module) {
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isEqual = require_is_equal2();
      var isSeries = require_is_series2();
      var set = require_set2();
      function diff(a, b) {
        if (isDataFrame(a) || isSeries(a)) {
          return diff(a.values, b);
        }
        if (isDataFrame(b) || isSeries(b)) {
          return diff(a, b.values);
        }
        assert(
          isArray(a) && isArray(b),
          "The `diff` function only works on arrays, Series, and DataFrames!"
        );
        const aTemp = set(a);
        const bTemp = set(b);
        const out = [];
        aTemp.forEach((item) => {
          if (bTemp.findIndex((other) => isEqual(other, item)) < 0) {
            out.push(item);
          }
        });
        return out;
      }
      module.exports = diff;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/pow.js
  var require_pow2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/pow.js"(exports, module) {
      var isNumber = require_is_number2();
      var vectorize = require_vectorize2();
      function pow(x, p) {
        try {
          if (!isNumber(x))
            return NaN;
          if (!isNumber(p))
            return NaN;
          return Math.pow(x, p);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(pow);
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/multiply.js
  var require_multiply2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/multiply.js"(exports, module) {
      var isNumber = require_is_number2();
      var vectorize = require_vectorize2();
      function multiply() {
        try {
          const values = Object.values(arguments);
          if (values.length === 0)
            return NaN;
          let out = 1;
          for (let i = 0; i < values.length; i++) {
            if (!isNumber(values[i]))
              return NaN;
            out *= values[i];
          }
          return out;
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(multiply);
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/scale.js
  var require_scale2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/scale.js"(exports, module) {
      var multiply = require_multiply2();
      function scale() {
        return multiply(...arguments);
      }
      module.exports = scale;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/subtract.js
  var require_subtract2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/subtract.js"(exports, module) {
      var add = require_add2();
      var scale = require_scale2();
      function subtract(a, b) {
        return add(a, scale(b, -1));
      }
      module.exports = subtract;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/sum.js
  var require_sum2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/sum.js"(exports, module) {
      var assert = require_assert2();
      var flatten = require_flatten2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isSeries = require_is_series2();
      function sum(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return sum(arr.values);
        }
        assert(
          isArray(arr),
          "The `sum` function only works on arrays, Series, and DataFrames!"
        );
        try {
          if (arr.length === 0)
            return NaN;
          return flatten(arr).reduce((a, b) => a + b, 0);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = sum;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/distance.js
  var require_distance2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/distance.js"(exports, module) {
      var abs = require_abs2();
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isEqual = require_is_equal2();
      var isNumber = require_is_number2();
      var isSeries = require_is_series2();
      var pow = require_pow2();
      var shape = require_shape2();
      var sqrt = require_sqrt2();
      var subtract = require_subtract2();
      var sum = require_sum2();
      function distance(a, b) {
        if (isNumber(a) && isNumber(b)) {
          return abs(a - b);
        }
        if (isDataFrame(a) || isSeries(a)) {
          return distance(a.values, b);
        }
        if (isDataFrame(b) || isSeries(b)) {
          return distance(a, b.values);
        }
        if (isArray(a) && isArray(b)) {
          assert(
            isEqual(shape(a), shape(b)),
            "If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!"
          );
        }
        try {
          return sqrt(sum(pow(subtract(a, b), 2)));
        } catch (e) {
          return NaN;
        }
      }
      module.exports = distance;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/divide.js
  var require_divide2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/divide.js"(exports, module) {
      var pow = require_pow2();
      var scale = require_scale2();
      function divide(a, b) {
        return scale(a, pow(b, -1));
      }
      module.exports = divide;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/dot.js
  var require_dot2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/dot.js"(exports, module) {
      var { DataFrame, Series } = require_dataframe2();
      var assert = require_assert2();
      var flatten = require_flatten2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isNumber = require_is_number2();
      var isSeries = require_is_series2();
      var scale = require_scale2();
      var shape = require_shape2();
      var sum = require_sum2();
      var transpose = require_transpose2();
      function dot(a, b) {
        if (isDataFrame(a)) {
          const temp = dot(a.values, b);
          if (shape(temp).length === 1) {
            const out = new Series(temp);
            out.name = isSeries(b) ? b.name : out.name;
            out.index = a.index.slice();
            return out;
          } else {
            const out = new DataFrame(temp);
            out.index = a.index.slice();
            if (isDataFrame(b)) {
              out.columns = b.columns.slice();
            }
            return out;
          }
        }
        if (isDataFrame(b)) {
          const temp = dot(a, b.values);
          if (shape(temp).length === 1) {
            const out = new Series(temp);
            out.name = isSeries(a) ? a.name : out.name;
            out.index = b.columns.slice();
            return out;
          } else {
            const out = new DataFrame(temp);
            out.columns = b.columns.slice();
            return out;
          }
        }
        if (isSeries(a)) {
          return dot(a.values, b);
        }
        if (isSeries(b)) {
          return dot(a, b.values);
        }
        assert(
          isArray(a) && isArray(b),
          "The `dot` function only works on arrays, Series, and DataFrames!"
        );
        flatten(a).concat(flatten(b)).forEach((v) => {
          assert(
            isNumber(v),
            "One of the arrays you passed into the `dot` function contains non-numerical values!"
          );
        });
        const aShape = shape(a);
        const bShape = shape(b);
        assert(
          aShape.length <= 2 && bShape.length <= 2,
          "I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"
        );
        assert(
          aShape[aShape.length - 1] === bShape[0],
          `There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${aShape[aShape.length - 1]} !== ${bShape[0]})`
        );
        if (aShape.length === 1 && bShape.length === 1) {
          return sum(scale(a, b));
        } else if (aShape.length === 1 && bShape.length === 2) {
          return transpose(b).map((col) => dot(a, col));
        } else if (aShape.length === 2 && bShape.length === 1) {
          return a.map((row) => dot(row, b));
        } else if (aShape.length === 2 && bShape.length === 2) {
          const bTranspose = transpose(b);
          const out = [];
          for (let i = 0; i < a.length; i++) {
            const row = [];
            for (let j = 0; j < bTranspose.length; j++) {
              row.push(dot(a[i], bTranspose[j]));
            }
            out.push(row);
          }
          return out;
        }
      }
      module.exports = dot;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/drop-missing.js
  var require_drop_missing2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/drop-missing.js"(exports, module) {
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isSeries = require_is_series2();
      var isUndefined = require_is_undefined2();
      function dropMissing(x) {
        if (isDataFrame(x) || isSeries(x)) {
          return x.dropMissing(...Object.values(arguments).slice(1));
        }
        assert(
          isArray(x),
          "The `dropMissing` function only works on arrays, Series, and DataFrames!"
        );
        const out = [];
        x.forEach((v) => {
          try {
            return out.push(dropMissing(v));
          } catch (e) {
            if (!isUndefined(v)) {
              out.push(v);
            }
          }
        });
        return out;
      }
      module.exports = dropMissing;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/drop-missing-pairwise.js
  var require_drop_missing_pairwise2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/drop-missing-pairwise.js"(exports, module) {
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isEqual = require_is_equal2();
      var isSeries = require_is_series2();
      var isUndefined = require_is_undefined2();
      var shape = require_shape2();
      function dropMissingPairwise(a, b) {
        if (isDataFrame(a) || isSeries(a)) {
          return dropMissingPairwise(a.values, b);
        }
        if (isDataFrame(b) || isSeries(b)) {
          return dropMissingPairwise(a, b.values);
        }
        assert(
          isArray(a) && isArray(b),
          "The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"
        );
        assert(
          isEqual(shape(a), shape(b)),
          "The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!"
        );
        const aOut = [];
        const bOut = [];
        for (let i = 0; i < a.length; i++) {
          try {
            const [aChildren, bChildren] = dropMissingPairwise(a[i], b[i]);
            aOut.push(aChildren);
            bOut.push(bChildren);
          } catch (e) {
            if (!isUndefined(a[i]) && !isUndefined(b[i])) {
              aOut.push(a[i]);
              bOut.push(b[i]);
            }
          }
        }
        return [aOut, bOut];
      }
      module.exports = dropMissingPairwise;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/drop-nan-pairwise.js
  var require_drop_nan_pairwise2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/drop-nan-pairwise.js"(exports, module) {
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isEqual = require_is_equal2();
      var isNumber = require_is_number2();
      var isSeries = require_is_series2();
      var shape = require_shape2();
      function dropNaNPairwise(a, b) {
        if (isDataFrame(a) || isSeries(a)) {
          return dropNaNPairwise(a.values, b);
        }
        if (isDataFrame(b) || isSeries(b)) {
          return dropNaNPairwise(a, b.values);
        }
        assert(
          isArray(a) && isArray(b),
          "The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"
        );
        assert(
          isEqual(shape(a), shape(b)),
          "The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!"
        );
        const aOut = [];
        const bOut = [];
        for (let i = 0; i < a.length; i++) {
          try {
            const [aChildren, bChildren] = dropNaNPairwise(a[i], b[i]);
            aOut.push(aChildren);
            bOut.push(bChildren);
          } catch (e) {
            if (isNumber(a[i]) && isNumber(b[i])) {
              aOut.push(a[i]);
              bOut.push(b[i]);
            }
          }
        }
        return [aOut, bOut];
      }
      module.exports = dropNaNPairwise;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/drop-undefined.js
  var require_drop_undefined2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/drop-undefined.js"(exports, module) {
      var dropMissing = require_drop_missing2();
      function dropUndefined(x) {
        return dropMissing(x);
      }
      module.exports = dropUndefined;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/exp.js
  var require_exp2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/exp.js"(exports, module) {
      var isNumber = require_is_number2();
      var vectorize = require_vectorize2();
      function exp(x) {
        try {
          if (!isNumber(x))
            return NaN;
          return Math.exp(x);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(exp);
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/factorial.js
  var require_factorial2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/factorial.js"(exports, module) {
      var vectorize = require_vectorize2();
      function factorial(n) {
        try {
          if (n !== parseInt(n))
            return NaN;
          if (n <= 1)
            return 1;
          return n * factorial(n - 1);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(factorial);
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/find.js
  var require_find2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/find.js"(exports, module) {
      var assert = require_assert2();
      var flatten = require_flatten2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isFunction = require_is_function2();
      var isObject = require_is_object2();
      var isSeries = require_is_series2();
      function find(x, fn) {
        if (isDataFrame(x)) {
          return find(flatten(x.values), fn);
        }
        if (isSeries(x)) {
          return find(x.values, fn);
        }
        assert(
          isObject(x) || isArray(x),
          "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"
        );
        if (!isFunction(fn)) {
          const value = fn;
          fn = (v) => v === value;
        }
        function helper(x2, fn2, checked) {
          checked = checked || [];
          if (checked.indexOf(x2) > -1) {
            return null;
          }
          if (isObject(x2)) {
            checked.push(x2);
            const keys = Object.keys(x2);
            for (let i = 0; i < keys.length; i++) {
              const key = keys[i];
              const value = x2[key];
              if (fn2(value)) {
                return value;
              }
              const result = helper(value, fn2, checked);
              if (result) {
                return result;
              }
            }
          } else if (isArray(x2)) {
            checked.push(x2);
            for (let i = 0; i < x2.length; i++) {
              const value = x2[i];
              if (fn2(value)) {
                return value;
              }
              const result = helper(value, fn2, checked);
              if (result) {
                return result;
              }
            }
          } else {
            if (fn2(x2)) {
              return x2;
            }
          }
          return null;
        }
        function safeFn(v) {
          try {
            return fn(v);
          } catch (e) {
            return false;
          }
        }
        return helper(x, safeFn);
      }
      module.exports = find;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/find-all.js
  var require_find_all2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/find-all.js"(exports, module) {
      var assert = require_assert2();
      var flatten = require_flatten2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isFunction = require_is_function2();
      var isObject = require_is_object2();
      var isSeries = require_is_series2();
      function findAll(x, fn) {
        if (isDataFrame(x)) {
          return findAll(flatten(x.values), fn);
        }
        if (isSeries(x)) {
          return findAll(x.values, fn);
        }
        assert(
          isObject(x) || isArray(x),
          "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"
        );
        if (!isFunction(fn)) {
          const value = fn;
          fn = (v) => v === value;
        }
        function helper(x2, fn2, checked) {
          checked = checked || [];
          if (checked.indexOf(x2) > -1) {
            return null;
          }
          if (isObject(x2)) {
            checked.push(x2);
            const keys = Object.keys(x2);
            const out = [];
            for (let i = 0; i < keys.length; i++) {
              const key = keys[i];
              const value = x2[key];
              let alreadyStoredThisValue = false;
              if (fn2(value)) {
                out.push(value);
                alreadyStoredThisValue = true;
              }
              const results2 = helper(value, fn2, checked);
              if (results2 && results2.length > 0) {
                results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out.push(r));
              }
            }
            return out;
          } else if (isArray(x2)) {
            checked.push(x2);
            const out = [];
            for (let i = 0; i < x2.length; i++) {
              const value = x2[i];
              let alreadyStoredThisValue = false;
              if (fn2(value)) {
                out.push(value);
                alreadyStoredThisValue = true;
              }
              const results2 = helper(value, fn2, checked);
              if (results2 && results2.length > 0) {
                results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out.push(r));
              }
            }
            return out;
          } else {
            if (fn2(x2)) {
              return [x2];
            }
          }
          return null;
        }
        function safeFn(v) {
          try {
            return fn(v);
          } catch (e) {
            return false;
          }
        }
        const results = helper(x, safeFn);
        if (results && results.length > 0) {
          return results;
        } else {
          return null;
        }
      }
      module.exports = findAll;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/float.js
  var require_float2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/float.js"(exports, module) {
      var isNumber = require_is_number2();
      var vectorize = require_vectorize2();
      function float(x) {
        try {
          if (x === "Infinity") {
            return Infinity;
          }
          if (x === "-Infinity") {
            return -Infinity;
          }
          const out = JSON.parse(x);
          if (isNumber(out))
            return out;
          return NaN;
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(float);
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/floor.js
  var require_floor2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/floor.js"(exports, module) {
      var isNumber = require_is_number2();
      var vectorize = require_vectorize2();
      function floor(x) {
        try {
          if (!isNumber(x))
            return NaN;
          return Math.floor(x);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(floor);
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/zeros.js
  var require_zeros2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/zeros.js"(exports, module) {
      var isNumber = require_is_number2();
      var product = require_product2();
      var reshape = require_reshape2();
      function zeros(shape) {
        if (isNumber(shape))
          shape = [shape];
        const out = [];
        const n = product(shape);
        for (let i = 0; i < n; i++)
          out.push(0);
        return reshape(out, shape);
      }
      module.exports = zeros;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/identity.js
  var require_identity2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/identity.js"(exports, module) {
      var assert = require_assert2();
      var isNumber = require_is_number2();
      var isUndefined = require_is_undefined2();
      var zeros = require_zeros2();
      function identity(size) {
        assert(
          !isUndefined(size),
          "You must pass an integer greater than 0 (representing the size) into the `identity` function!"
        );
        assert(
          isNumber(size),
          "You must pass an integer greater than 0 (representing the size) into the `identity` function!"
        );
        assert(
          parseInt(size) === size,
          "You must pass an integer greater than 0 (representing the size) into the `identity` function!"
        );
        assert(
          size > 0,
          "You must pass an integer greater than 0 (representing the size) into the `identity` function!"
        );
        const out = zeros([size, size]);
        for (let i = 0; i < size; i++)
          out[i][i] = 1;
        return out;
      }
      module.exports = identity;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/helpers/boolean-values.js
  var require_boolean_values2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/helpers/boolean-values.js"(exports, module) {
      module.exports = ["true", "false", "yes", "no"];
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/helpers/null-values.js
  var require_null_values2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/helpers/null-values.js"(exports, module) {
      module.exports = ["null", "none", "nan", "na", "n/a", "", "undefined"];
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/infer-type.js
  var require_infer_type2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/infer-type.js"(exports, module) {
      var apply = require_apply2();
      var assert = require_assert2();
      var booleanValues = require_boolean_values2();
      var cast = require_cast2();
      var count = require_count2();
      var flatten = require_flatten2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isNumber = require_is_number2();
      var isSeries = require_is_series2();
      var isString = require_is_string2();
      var nullValues = require_null_values2();
      function checkIfInteger(results) {
        if (results.type === "number") {
          if (typeof results.value !== "undefined") {
            results.isInteger = parseInt(results.value) === results.value;
          } else {
            results.isInteger = flatten(results.values).every(
              (v) => isNumber(v) ? parseInt(v) === v : true
            );
          }
        }
        return results;
      }
      function inferType(arr) {
        if (isDataFrame(arr)) {
          const out = arr.copy();
          const results = inferType(arr.values);
          out.values = results.values;
          return checkIfInteger({ type: results.type, values: out });
        }
        if (isSeries(arr)) {
          const out = arr.copy();
          const results = inferType(arr.values);
          out.values = results.values;
          return checkIfInteger({ type: results.type, values: out });
        }
        if (!isArray(arr)) {
          const out = inferType([arr]);
          out.value = out.values[0];
          delete out.values;
          return checkIfInteger(out);
        }
        assert(
          isArray(arr),
          "The `inferType` function only works on arrays, Series, and DataFrames!"
        );
        const types = flatten(arr).map((v) => {
          if (v === void 0)
            return "null";
          try {
            if (typeof v === "object") {
              const temp = new Date(v.toString());
              if (temp instanceof Date && temp.toString() !== "Invalid Date") {
                return "date";
              }
            }
          } catch (e) {
          }
          if (!isString(v)) {
            v = JSON.stringify(v);
          }
          const vLower = v.toLowerCase();
          const vLowerTrimmed = vLower.trim();
          if (nullValues.indexOf(vLowerTrimmed) > -1) {
            return "null";
          }
          if (booleanValues.indexOf(vLowerTrimmed) > -1) {
            return "boolean";
          }
          try {
            const vParsed = JSON.parse(v);
            if (isNumber(vParsed)) {
              return "number";
            }
            if (typeof vParsed === "object") {
              if (isArray(vParsed))
                return "string";
              return "object";
            }
            return "string";
          } catch (e) {
            const vDate = new Date(v);
            if (vDate.toString() !== "Invalid Date") {
              return "date";
            }
            return "string";
          }
        });
        const counts = count(types).sort((a, b) => b.count - a.count);
        const primaryType = counts[0].value;
        return checkIfInteger({
          type: primaryType,
          values: apply(arr, (v) => cast(v, primaryType))
        });
      }
      module.exports = inferType;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/int.js
  var require_int2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/int.js"(exports, module) {
      var isNumber = require_is_number2();
      var vectorize = require_vectorize2();
      function int(x) {
        try {
          const out = JSON.parse(x);
          if (isNumber(out))
            return parseInt(out);
          return NaN;
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(int);
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/intersect.js
  var require_intersect2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/intersect.js"(exports, module) {
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isEqual = require_is_equal2();
      var isSeries = require_is_series2();
      var set = require_set2();
      function intersect() {
        const arrays = Object.values(arguments).map((x) => {
          if (isDataFrame(x) || isSeries(x)) {
            return set(x.values);
          }
          assert(
            isArray(x),
            "The `intersect` function only works on arrays, Series, and DataFrames!"
          );
          return set(x);
        });
        const all = set(arrays);
        return all.filter((v) => {
          return arrays.every((arr) => arr.findIndex((other) => isEqual(other, v)) > -1);
        });
      }
      module.exports = intersect;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/inverse.js
  var require_inverse2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/inverse.js"(exports, module) {
      var add = require_add2();
      var assert = require_assert2();
      var dot = require_dot2();
      var flatten = require_flatten2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isNumber = require_is_number2();
      var scale = require_scale2();
      var shape = require_shape2();
      function inverse(x) {
        if (isDataFrame(x)) {
          const out = x.copy();
          out.values = inverse(out.values);
          return out;
        }
        assert(
          isArray(x),
          "The `inverse` function only works on square 2-dimensional arrays or DataFrames!"
        );
        flatten(x).forEach(
          (v) => assert(
            isNumber(v),
            "The array passed into the `inverse` function must contain only numbers!"
          )
        );
        const xShape = shape(x);
        assert(
          xShape.length === 2,
          "The array passed into the `inverse` function must be exactly two-dimensional and square!"
        );
        assert(
          xShape[0] === xShape[1],
          "The array passed into the `inverse` function must be exactly two-dimensional and square!"
        );
        assert(
          xShape[0] >= 0,
          "The array passed into the `inverse` function must be exactly two-dimensional and square!"
        );
        if (xShape[0] === 0) {
          return x;
        } else if (xShape[0] === 1) {
          assert(x[0][0] !== 0, "This matrix cannot be inverted!");
          return 1 / x[0][0];
        } else if (xShape[0] === 2) {
          const a = x[0][0];
          const b = x[0][1];
          const c = x[1][0];
          const d = x[1][1];
          const det = a * d - b * c;
          assert(det !== 0, "This matrix cannot be inverted!");
          const out = [
            [d, -b],
            [-c, a]
          ];
          return scale(out, 1 / det);
        } else if (xShape[0] > 1) {
          const times = (a, b) => isNumber(a) || isNumber(b) ? scale(a, b) : dot(a, b);
          for (let divider = 1; divider < xShape[0] - 1; divider++) {
            try {
              const A = x.slice(0, divider).map((row) => row.slice(0, divider));
              const B = x.slice(0, divider).map((row) => row.slice(divider, xShape[0]));
              const C = x.slice(divider, xShape[0]).map((row) => row.slice(0, divider));
              const D = x.slice(divider, xShape[0]).map((row) => row.slice(divider, xShape[0]));
              const AInv = inverse(A);
              const CompInv = inverse(add(D, times(-1, times(times(C, AInv), B))));
              const topLeft = add(
                AInv,
                times(times(times(times(AInv, B), CompInv), C), AInv)
              );
              const topRight = times(-1, times(times(AInv, B), CompInv));
              const bottomLeft = times(-1, times(times(CompInv, C), AInv));
              const bottomRight = CompInv;
              const out = topLeft.map((row, i) => row.concat(topRight[i])).concat(bottomLeft.map((row, i) => row.concat(bottomRight[i])));
              return out;
            } catch (e) {
            }
          }
          assert(false, "This matrix cannot be inverted!");
        }
      }
      module.exports = inverse;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/helpers/is-browser.js
  var require_is_browser2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/helpers/is-browser.js"(exports, module) {
      var isBrowser = new Function(
        `
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `
      );
      module.exports = isBrowser;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/lerp.js
  var require_lerp2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/lerp.js"(exports, module) {
      var isNumber = require_is_number2();
      var vectorize = require_vectorize2();
      function lerp(a, b, f) {
        try {
          if (!isNumber(a))
            return NaN;
          if (!isNumber(b))
            return NaN;
          if (!isNumber(f))
            return NaN;
          return f * (b - a) + a;
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(lerp);
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/log.js
  var require_log2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/log.js"(exports, module) {
      var isNumber = require_is_number2();
      var isUndefined = require_is_undefined2();
      var vectorize = require_vectorize2();
      function log(x, base) {
        try {
          base = isUndefined(base) ? Math.E : base;
          if (!isNumber(x))
            return NaN;
          if (!isNumber(base))
            return NaN;
          return Math.log(x) / Math.log(base);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(log);
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/median.js
  var require_median2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/median.js"(exports, module) {
      var assert = require_assert2();
      var flatten = require_flatten2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isSeries = require_is_series2();
      var sort = require_sort2();
      function median(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return median(arr.values);
        }
        assert(
          isArray(arr),
          "The `median` function only works on arrays, Series, and DataFrames!"
        );
        try {
          const temp = sort(flatten(arr));
          if (temp.length === 0) {
            return NaN;
          } else if (temp.length % 2 === 0) {
            return (temp[temp.length / 2 - 1] + temp[temp.length / 2]) / 2;
          } else {
            return temp[parseInt(temp.length / 2)];
          }
        } catch (e) {
          return NaN;
        }
      }
      module.exports = median;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/mod.js
  var require_mod2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/mod.js"(exports, module) {
      var isNumber = require_is_number2();
      var vectorize = require_vectorize2();
      function mod(a, b) {
        try {
          if (!isNumber(a))
            return NaN;
          if (!isNumber(b))
            return NaN;
          return a % b;
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(mod);
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/mode.js
  var require_mode2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/mode.js"(exports, module) {
      var assert = require_assert2();
      var count = require_count2();
      var flatten = require_flatten2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isSeries = require_is_series2();
      var set = require_set2();
      var sort = require_sort2();
      function mode(arr) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return mode(arr.values);
        }
        assert(
          isArray(arr),
          "The `mode` function only works on arrays, Series, and DataFrames!"
        );
        try {
          if (arr.length === 0)
            return NaN;
          const temp = flatten(arr);
          if (temp.length === 0)
            return NaN;
          const counts = {};
          const tempSet = set(temp);
          tempSet.forEach((value) => {
            counts[value] = count(temp, value);
          });
          const sortedTempSet = sort(tempSet, (a, b) => counts[b] - counts[a]);
          const mostCountedValue = sortedTempSet[0];
          const out = sort(
            sortedTempSet.filter((value) => counts[value] === counts[mostCountedValue])
          );
          return out;
        } catch (e) {
          return NaN;
        }
      }
      module.exports = mode;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/normal.js
  var require_normal2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/normal.js"(exports, module) {
      var { random } = require_random2();
      var apply = require_apply2();
      var isUndefined = require_is_undefined2();
      var ndarray = require_ndarray2();
      function helper() {
        const u1 = random();
        const u2 = random();
        return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
      }
      function normal(shape) {
        if (isUndefined(shape))
          return helper();
        return apply(ndarray(shape), helper);
      }
      module.exports = normal;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/ones.js
  var require_ones2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/ones.js"(exports, module) {
      var apply = require_apply2();
      var ndarray = require_ndarray2();
      function ones(shape) {
        return apply(ndarray(shape), () => 1);
      }
      module.exports = ones;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/permutations.js
  var require_permutations2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/permutations.js"(exports, module) {
      var assert = require_assert2();
      var flatten = require_flatten2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isNumber = require_is_number2();
      var isSeries = require_is_series2();
      var isUndefined = require_is_undefined2();
      function permutations(arr, r) {
        if (isDataFrame(arr) || isSeries(arr)) {
          return permutations(arr.values, r);
        }
        assert(
          isArray(arr),
          "The `permutations` function only works on arrays, Series, and DataFrames!"
        );
        if (isUndefined(r))
          r = arr.length;
        assert(isNumber(r), "`r` must be a whole number!");
        arr = flatten(arr);
        if (r > arr.length) {
          return permutations(arr);
        }
        if (r <= 0) {
          return [[]];
        }
        assert(r === parseInt(r), "`r` must be a whole number!");
        if (arr.length < 2)
          return arr;
        const out = [];
        arr.forEach((item, i) => {
          const before = arr.slice(0, i);
          const after = arr.slice(i + 1);
          const others = before.concat(after);
          const children = permutations(others, r - 1);
          children.forEach((child) => {
            out.push([item].concat(child));
          });
        });
        return out;
      }
      module.exports = permutations;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/print.js
  var require_print2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/print.js"(exports, module) {
      var { DataFrame, Series } = require_dataframe2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isJagged = require_is_jagged2();
      var isSeries = require_is_series2();
      var shape = require_shape2();
      function print() {
        Object.keys(arguments).forEach((key) => {
          const x = arguments[key];
          if (isArray(x)) {
            if (!isJagged(x)) {
              const xShape = shape(x);
              if (xShape.length === 1) {
                new Series(x).print();
              } else if (xShape.length == 2) {
                new DataFrame(x).print();
              } else {
                console.log(x);
              }
            } else {
              console.log(x);
            }
          } else if (isDataFrame(x) || isSeries(x)) {
            x.print();
          } else {
            console.log(x);
          }
        });
      }
      module.exports = print;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/remap.js
  var require_remap2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/remap.js"(exports, module) {
      var isArray = require_is_array2();
      var isNumber = require_is_number2();
      var isUndefined = require_is_undefined2();
      var max = require_max2();
      var min = require_min2();
      var vectorize = require_vectorize2();
      var helper = vectorize(function(x, a, b, c, d) {
        try {
          if (![x, a, b, c, d].every((v) => isNumber(v))) {
            return NaN;
          }
          if (b - a === 0)
            return NaN;
          return (d - c) * (x - a) / (b - a) + c;
        } catch (e) {
          return NaN;
        }
      });
      function remap(x, a, b, c, d) {
        if (isArray(x) && isUndefined(c) && isUndefined(d)) {
          c = a;
          d = b;
          a = min(x);
          b = max(x);
        }
        return helper(x, a, b, c, d);
      }
      module.exports = remap;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/round.js
  var require_round2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/round.js"(exports, module) {
      var isNumber = require_is_number2();
      var vectorize = require_vectorize2();
      function round(x) {
        try {
          if (!isNumber(x))
            return NaN;
          return Math.round(x);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(round);
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/sign.js
  var require_sign2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/sign.js"(exports, module) {
      var isNumber = require_is_number2();
      var vectorize = require_vectorize2();
      function sign(x) {
        try {
          if (!isNumber(x))
            return NaN;
          if (x < 0)
            return -1;
          if (x > 0)
            return 1;
          return 0;
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(sign);
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/sin.js
  var require_sin2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/sin.js"(exports, module) {
      var isNumber = require_is_number2();
      var vectorize = require_vectorize2();
      function sin(x) {
        try {
          if (!isNumber(x))
            return NaN;
          return Math.sin(x);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(sin);
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/stdev.js
  var require_stdev2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/stdev.js"(exports, module) {
      var std = require_std2();
      function stdev(x) {
        return std(x);
      }
      module.exports = stdev;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/tan.js
  var require_tan2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/tan.js"(exports, module) {
      var isNumber = require_is_number2();
      var vectorize = require_vectorize2();
      function tan(x) {
        try {
          if (!isNumber(x))
            return NaN;
          return Math.tan(x);
        } catch (e) {
          return NaN;
        }
      }
      module.exports = vectorize(tan);
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/time.js
  var require_time2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/time.js"(exports, module) {
      var assert = require_assert2();
      var isFunction = require_is_function2();
      function timeSync(fn, args) {
        assert(isFunction(fn), "`fn` must be a function!");
        const start = /* @__PURE__ */ new Date();
        if (args) {
          fn(...args);
        } else {
          fn();
        }
        return /* @__PURE__ */ new Date() - start;
      }
      async function timeAsync(fn, args) {
        assert(isFunction(fn), "`fn` must be a function!");
        const start = /* @__PURE__ */ new Date();
        if (args) {
          await fn(...args);
        } else {
          await fn();
        }
        return /* @__PURE__ */ new Date() - start;
      }
      module.exports = { timeSync, timeAsync };
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/union.js
  var require_union2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/union.js"(exports, module) {
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isSeries = require_is_series2();
      var set = require_set2();
      function union() {
        return set(
          [...arguments].map((v) => {
            if (isArray(v))
              return v;
            if (isDataFrame(v))
              return v.values;
            if (isSeries(v))
              return v.values;
            return [v];
          })
        );
      }
      module.exports = union;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/zip.js
  var require_zip2 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/zip.js"(exports, module) {
      var assert = require_assert2();
      var isArray = require_is_array2();
      var isDataFrame = require_is_dataframe2();
      var isSeries = require_is_series2();
      var isUndefined = require_is_undefined2();
      var max = require_max2();
      var range = require_range2();
      function zip() {
        const out = [];
        const arrays = Object.values(arguments).map((arr) => {
          if (isDataFrame(arr) || isSeries(arr)) {
            arr = arr.values;
          }
          assert(
            isArray(arr),
            "The `zip` function only works on arrays, Series, and DataFrames!"
          );
          return arr;
        });
        range(0, max(arrays.map((arr) => arr.length))).forEach((i) => {
          const row = [];
          arrays.forEach((arr) => {
            const value = arr[i];
            row.push(isUndefined(value) ? void 0 : value);
          });
          out.push(row);
        });
        return out;
      }
      module.exports = zip;
    }
  });

  // node_modules/@jrc03c/js-math-tools/src/index.js
  var require_src3 = __commonJS({
    "node_modules/@jrc03c/js-math-tools/src/index.js"(exports, module) {
      var { copy, decycle } = require_copy2();
      var { DataFrame, Series } = require_dataframe2();
      var out = {
        abs: require_abs2(),
        add: require_add2(),
        apply: require_apply2(),
        arccos: require_arccos2(),
        arcsin: require_arcsin2(),
        arctan: require_arctan2(),
        argmax: require_argmax2(),
        argmin: require_argmin2(),
        assert: require_assert2(),
        cast: require_cast2(),
        ceil: require_ceil2(),
        chop: require_chop2(),
        clamp: require_clamp2(),
        combinations: require_combinations2(),
        copy,
        correl: require_correl2(),
        cos: require_cos2(),
        count: require_count2(),
        covariance: require_covariance2(),
        DataFrame,
        dataTypes: require_data_types2(),
        decycle,
        diff: require_diff2(),
        distance: require_distance2(),
        divide: require_divide2(),
        dot: require_dot2(),
        dropMissing: require_drop_missing2(),
        dropMissingPairwise: require_drop_missing_pairwise2(),
        dropNaN: require_drop_nan2(),
        dropNaNPairwise: require_drop_nan_pairwise2(),
        dropUndefined: require_drop_undefined2(),
        exp: require_exp2(),
        factorial: require_factorial2(),
        find: require_find2(),
        findAll: require_find_all2(),
        flatten: require_flatten2(),
        float: require_float2(),
        floor: require_floor2(),
        identity: require_identity2(),
        indexOf: require_index_of2(),
        inferType: require_infer_type2(),
        int: require_int2(),
        intersect: require_intersect2(),
        inverse: require_inverse2(),
        isArray: require_is_array2(),
        isBoolean: require_is_boolean2(),
        isBrowser: require_is_browser2(),
        isDataFrame: require_is_dataframe2(),
        isEqual: require_is_equal2(),
        isFunction: require_is_function2(),
        isJagged: require_is_jagged2(),
        isNested: require_is_nested2(),
        isNumber: require_is_number2(),
        isObject: require_is_object2(),
        isSeries: require_is_series2(),
        isString: require_is_string2(),
        isUndefined: require_is_undefined2(),
        lerp: require_lerp2(),
        log: require_log2(),
        MathError: require_math_error2(),
        max: require_max2(),
        mean: require_mean2(),
        median: require_median2(),
        min: require_min2(),
        mod: require_mod2(),
        mode: require_mode2(),
        multiply: require_multiply2(),
        ndarray: require_ndarray2(),
        normal: require_normal2(),
        ones: require_ones2(),
        permutations: require_permutations2(),
        pow: require_pow2(),
        print: require_print2(),
        product: require_product2(),
        random: require_random2().random,
        range: require_range2(),
        remap: require_remap2(),
        reshape: require_reshape2(),
        reverse: require_reverse2(),
        round: require_round2(),
        scale: require_scale2(),
        seed: require_random2().seed,
        Series,
        set: require_set2(),
        shape: require_shape2(),
        shuffle: require_shuffle2(),
        sign: require_sign2(),
        sin: require_sin2(),
        sort: require_sort2(),
        sqrt: require_sqrt2(),
        std: require_std2(),
        stdev: require_stdev2(),
        subtract: require_subtract2(),
        sum: require_sum2(),
        tan: require_tan2(),
        time: require_time2().timeSync,
        timeSync: require_time2().timeSync,
        timeAsync: require_time2().timeAsync,
        transpose: require_transpose2(),
        union: require_union2(),
        variance: require_variance2(),
        vectorize: require_vectorize2(),
        zeros: require_zeros2(),
        zip: require_zip2(),
        dump: function() {
          const pub = typeof global !== "undefined" ? global : window;
          if (!pub) {
            throw new out.MathError(
              "Cannot dump functions into global scope because neither `global` nor `window` exist in the current context!"
            );
          }
          Object.keys(out).forEach((key) => {
            try {
              Object.defineProperty(pub, key, {
                configurable: false,
                enumerable: true,
                writable: false,
                value: out[key]
              });
            } catch (e) {
              pub[key] = out[key];
            }
          });
        }
      };
      if (typeof module !== "undefined") {
        module.exports = out;
      }
      if (typeof window !== "undefined") {
        window.JSMathTools = out;
      }
    }
  });

  // node_modules/liquidjs/dist/liquid.browser.umd.js
  var require_liquid_browser_umd = __commonJS({
    "node_modules/liquidjs/dist/liquid.browser.umd.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.liquidjs = {}));
      })(exports, function(exports2) {
        "use strict";
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        function __extends(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        }
        var __assign = function() {
          __assign = Object.assign || function __assign2(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                  t[p] = s[p];
            }
            return t;
          };
          return __assign.apply(this, arguments);
        };
        function __awaiter(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve2) {
              resolve2(value);
            });
          }
          return new (P || (P = Promise))(function(resolve2, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        }
        function __generator(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        }
        function __values(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }
        function __read(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        }
        function __spreadArray(to, from, pack) {
          if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
          return to.concat(ar || Array.prototype.slice.call(from));
        }
        var Token = (
          /** @class */
          function() {
            function Token2(kind, input, begin, end, file) {
              this.kind = kind;
              this.input = input;
              this.begin = begin;
              this.end = end;
              this.file = file;
            }
            Token2.prototype.getText = function() {
              return this.input.slice(this.begin, this.end);
            };
            Token2.prototype.getPosition = function() {
              var _a = __read([1, 1], 2), row = _a[0], col = _a[1];
              for (var i = 0; i < this.begin; i++) {
                if (this.input[i] === "\n") {
                  row++;
                  col = 1;
                } else
                  col++;
              }
              return [row, col];
            };
            Token2.prototype.size = function() {
              return this.end - this.begin;
            };
            return Token2;
          }()
        );
        var Drop = (
          /** @class */
          function() {
            function Drop2() {
            }
            Drop2.prototype.liquidMethodMissing = function(key) {
              return void 0;
            };
            return Drop2;
          }()
        );
        var toString$1 = Object.prototype.toString;
        var toLowerCase = String.prototype.toLowerCase;
        var hasOwnProperty = Object.hasOwnProperty;
        function isString(value) {
          return typeof value === "string";
        }
        function isFunction(value) {
          return typeof value === "function";
        }
        function isPromise(val) {
          return val && isFunction(val.then);
        }
        function isIterator(val) {
          return val && isFunction(val.next) && isFunction(val.throw) && isFunction(val.return);
        }
        function escapeRegex(str) {
          return str.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
        }
        function stringify(value) {
          value = toValue(value);
          if (isString(value))
            return value;
          if (isNil(value))
            return "";
          if (isArray(value))
            return value.map(function(x) {
              return stringify(x);
            }).join("");
          return String(value);
        }
        function toValue(value) {
          return value instanceof Drop && isFunction(value.valueOf) ? value.valueOf() : value;
        }
        function isNumber(value) {
          return typeof value === "number";
        }
        function toLiquid(value) {
          if (value && isFunction(value.toLiquid))
            return toLiquid(value.toLiquid());
          return value;
        }
        function isNil(value) {
          return value == null;
        }
        function isArray(value) {
          return toString$1.call(value) === "[object Array]";
        }
        function isIterable(value) {
          return isObject(value) && Symbol.iterator in value;
        }
        function forOwn(obj, iteratee) {
          obj = obj || {};
          for (var k in obj) {
            if (hasOwnProperty.call(obj, k)) {
              if (iteratee(obj[k], k, obj) === false)
                break;
            }
          }
          return obj;
        }
        function last(arr) {
          return arr[arr.length - 1];
        }
        function isObject(value) {
          var type = typeof value;
          return value !== null && (type === "object" || type === "function");
        }
        function range(start, stop, step) {
          if (step === void 0) {
            step = 1;
          }
          var arr = [];
          for (var i = start; i < stop; i += step) {
            arr.push(i);
          }
          return arr;
        }
        function padStart(str, length, ch) {
          if (ch === void 0) {
            ch = " ";
          }
          return pad(str, length, ch, function(str2, ch2) {
            return ch2 + str2;
          });
        }
        function padEnd(str, length, ch) {
          if (ch === void 0) {
            ch = " ";
          }
          return pad(str, length, ch, function(str2, ch2) {
            return str2 + ch2;
          });
        }
        function pad(str, length, ch, add) {
          str = String(str);
          var n = length - str.length;
          while (n-- > 0)
            str = add(str, ch);
          return str;
        }
        function identify(val) {
          return val;
        }
        function changeCase(str) {
          var hasLowerCase = __spreadArray([], __read(str), false).some(function(ch) {
            return ch >= "a" && ch <= "z";
          });
          return hasLowerCase ? str.toUpperCase() : str.toLowerCase();
        }
        function ellipsis(str, N) {
          return str.length > N ? str.slice(0, N - 3) + "..." : str;
        }
        function caseInsensitiveCompare(a, b) {
          if (a == null && b == null)
            return 0;
          if (a == null)
            return 1;
          if (b == null)
            return -1;
          a = toLowerCase.call(a);
          b = toLowerCase.call(b);
          if (a < b)
            return -1;
          if (a > b)
            return 1;
          return 0;
        }
        function argumentsToValue(fn) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return fn.apply(void 0, __spreadArray([], __read(args.map(toValue)), false));
          };
        }
        function escapeRegExp(text) {
          return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
        }
        var LiquidError = (
          /** @class */
          function(_super) {
            __extends(LiquidError2, _super);
            function LiquidError2(err, token) {
              var _this = (
                /**
                 * note: for ES5 targeting, `this` will be replaced by return value of Error(),
                 * thus everything on `this` will be lost, avoid calling `LiquidError` methods here
                 */
                _super.call(this, typeof err === "string" ? err : err.message) || this
              );
              _this.context = "";
              if (typeof err !== "string")
                Object.defineProperty(_this, "originalError", { value: err, enumerable: false });
              Object.defineProperty(_this, "token", { value: token, enumerable: false });
              return _this;
            }
            LiquidError2.prototype.update = function() {
              Object.defineProperty(this, "context", { value: mkContext(this.token), enumerable: false });
              this.message = mkMessage(this.message, this.token);
              this.stack = this.message + "\n" + this.context + "\n" + this.stack;
              if (this.originalError)
                this.stack += "\nFrom " + this.originalError.stack;
            };
            return LiquidError2;
          }(Error)
        );
        var TokenizationError = (
          /** @class */
          function(_super) {
            __extends(TokenizationError2, _super);
            function TokenizationError2(message, token) {
              var _this = _super.call(this, message, token) || this;
              _this.name = "TokenizationError";
              _super.prototype.update.call(_this);
              return _this;
            }
            return TokenizationError2;
          }(LiquidError)
        );
        var ParseError = (
          /** @class */
          function(_super) {
            __extends(ParseError2, _super);
            function ParseError2(err, token) {
              var _this = _super.call(this, err, token) || this;
              _this.name = "ParseError";
              _this.message = err.message;
              _super.prototype.update.call(_this);
              return _this;
            }
            return ParseError2;
          }(LiquidError)
        );
        var RenderError = (
          /** @class */
          function(_super) {
            __extends(RenderError2, _super);
            function RenderError2(err, tpl) {
              var _this = _super.call(this, err, tpl.token) || this;
              _this.name = "RenderError";
              _this.message = err.message;
              _super.prototype.update.call(_this);
              return _this;
            }
            RenderError2.is = function(obj) {
              return obj.name === "RenderError";
            };
            return RenderError2;
          }(LiquidError)
        );
        var UndefinedVariableError = (
          /** @class */
          function(_super) {
            __extends(UndefinedVariableError2, _super);
            function UndefinedVariableError2(err, token) {
              var _this = _super.call(this, err, token) || this;
              _this.name = "UndefinedVariableError";
              _this.message = err.message;
              _super.prototype.update.call(_this);
              return _this;
            }
            return UndefinedVariableError2;
          }(LiquidError)
        );
        var InternalUndefinedVariableError = (
          /** @class */
          function(_super) {
            __extends(InternalUndefinedVariableError2, _super);
            function InternalUndefinedVariableError2(variableName) {
              var _this = _super.call(this, "undefined variable: ".concat(variableName)) || this;
              _this.name = "InternalUndefinedVariableError";
              _this.variableName = variableName;
              return _this;
            }
            return InternalUndefinedVariableError2;
          }(Error)
        );
        var AssertionError = (
          /** @class */
          function(_super) {
            __extends(AssertionError2, _super);
            function AssertionError2(message) {
              var _this = _super.call(this, message) || this;
              _this.name = "AssertionError";
              _this.message = message + "";
              return _this;
            }
            return AssertionError2;
          }(Error)
        );
        function mkContext(token) {
          var _a = __read(token.getPosition(), 2), line = _a[0], col = _a[1];
          var lines = token.input.split("\n");
          var begin = Math.max(line - 2, 1);
          var end = Math.min(line + 3, lines.length);
          var context = range(begin, end + 1).map(function(lineNumber) {
            var rowIndicator = lineNumber === line ? ">> " : "   ";
            var num = padStart(String(lineNumber), String(end).length);
            var text = "".concat(rowIndicator).concat(num, "| ");
            var colIndicator = lineNumber === line ? "\n" + padStart("^", col + text.length) : "";
            text += lines[lineNumber - 1];
            text += colIndicator;
            return text;
          }).join("\n");
          return context;
        }
        function mkMessage(msg, token) {
          if (token.file)
            msg += ", file:".concat(token.file);
          var _a = __read(token.getPosition(), 2), line = _a[0], col = _a[1];
          msg += ", line:".concat(line, ", col:").concat(col);
          return msg;
        }
        var TYPES = [0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 4, 4, 4, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 8, 0, 0, 0, 0, 8, 0, 0, 0, 64, 0, 65, 0, 0, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 0, 0, 2, 2, 2, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
        var IDENTIFIER = 1;
        var BLANK = 4;
        var QUOTE = 8;
        var INLINE_BLANK = 16;
        var NUMBER = 32;
        var SIGN = 64;
        TYPES[160] = TYPES[5760] = TYPES[6158] = TYPES[8192] = TYPES[8193] = TYPES[8194] = TYPES[8195] = TYPES[8196] = TYPES[8197] = TYPES[8198] = TYPES[8199] = TYPES[8200] = TYPES[8201] = TYPES[8202] = TYPES[8232] = TYPES[8233] = TYPES[8239] = TYPES[8287] = TYPES[12288] = BLANK;
        function assert(predicate, message) {
          if (!predicate) {
            var msg = typeof message === "function" ? message() : message || "expect ".concat(predicate, " to be true");
            throw new AssertionError(msg);
          }
        }
        var NullDrop = (
          /** @class */
          function(_super) {
            __extends(NullDrop2, _super);
            function NullDrop2() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            NullDrop2.prototype.equals = function(value) {
              return isNil(toValue(value));
            };
            NullDrop2.prototype.gt = function() {
              return false;
            };
            NullDrop2.prototype.geq = function() {
              return false;
            };
            NullDrop2.prototype.lt = function() {
              return false;
            };
            NullDrop2.prototype.leq = function() {
              return false;
            };
            NullDrop2.prototype.valueOf = function() {
              return null;
            };
            return NullDrop2;
          }(Drop)
        );
        var EmptyDrop = (
          /** @class */
          function(_super) {
            __extends(EmptyDrop2, _super);
            function EmptyDrop2() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            EmptyDrop2.prototype.equals = function(value) {
              if (value instanceof EmptyDrop2)
                return false;
              value = toValue(value);
              if (isString(value) || isArray(value))
                return value.length === 0;
              if (isObject(value))
                return Object.keys(value).length === 0;
              return false;
            };
            EmptyDrop2.prototype.gt = function() {
              return false;
            };
            EmptyDrop2.prototype.geq = function() {
              return false;
            };
            EmptyDrop2.prototype.lt = function() {
              return false;
            };
            EmptyDrop2.prototype.leq = function() {
              return false;
            };
            EmptyDrop2.prototype.valueOf = function() {
              return "";
            };
            return EmptyDrop2;
          }(Drop)
        );
        var BlankDrop = (
          /** @class */
          function(_super) {
            __extends(BlankDrop2, _super);
            function BlankDrop2() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            BlankDrop2.prototype.equals = function(value) {
              if (value === false)
                return true;
              if (isNil(toValue(value)))
                return true;
              if (isString(value))
                return /^\s*$/.test(value);
              return _super.prototype.equals.call(this, value);
            };
            return BlankDrop2;
          }(EmptyDrop)
        );
        var ForloopDrop = (
          /** @class */
          function(_super) {
            __extends(ForloopDrop2, _super);
            function ForloopDrop2(length, collection, variable) {
              var _this = _super.call(this) || this;
              _this.i = 0;
              _this.length = length;
              _this.name = "".concat(variable, "-").concat(collection);
              return _this;
            }
            ForloopDrop2.prototype.next = function() {
              this.i++;
            };
            ForloopDrop2.prototype.index0 = function() {
              return this.i;
            };
            ForloopDrop2.prototype.index = function() {
              return this.i + 1;
            };
            ForloopDrop2.prototype.first = function() {
              return this.i === 0;
            };
            ForloopDrop2.prototype.last = function() {
              return this.i === this.length - 1;
            };
            ForloopDrop2.prototype.rindex = function() {
              return this.length - this.i;
            };
            ForloopDrop2.prototype.rindex0 = function() {
              return this.length - this.i - 1;
            };
            ForloopDrop2.prototype.valueOf = function() {
              return JSON.stringify(this);
            };
            return ForloopDrop2;
          }(Drop)
        );
        var BlockDrop = (
          /** @class */
          function(_super) {
            __extends(BlockDrop2, _super);
            function BlockDrop2(superBlockRender) {
              if (superBlockRender === void 0) {
                superBlockRender = function() {
                  return "";
                };
              }
              var _this = _super.call(this) || this;
              _this.superBlockRender = superBlockRender;
              return _this;
            }
            BlockDrop2.prototype.super = function() {
              return this.superBlockRender();
            };
            return BlockDrop2;
          }(Drop)
        );
        function isComparable(arg) {
          return arg && isFunction(arg.equals);
        }
        var nil = new NullDrop();
        var literalValues = {
          "true": true,
          "false": false,
          "nil": nil,
          "null": nil,
          "empty": new EmptyDrop(),
          "blank": new BlankDrop()
        };
        function createTrie(operators) {
          var e_1, _a;
          var trie = {};
          try {
            for (var _b = __values(Object.entries(operators)), _c = _b.next(); !_c.done; _c = _b.next()) {
              var _d = __read(_c.value, 2), name_1 = _d[0], handler = _d[1];
              var node = trie;
              for (var i = 0; i < name_1.length; i++) {
                var c = name_1[i];
                node[c] = node[c] || {};
                if (i === name_1.length - 1 && TYPES[name_1.charCodeAt(i)] & IDENTIFIER) {
                  node[c].needBoundary = true;
                }
                node = node[c];
              }
              node.handler = handler;
              node.end = true;
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return))
                _a.call(_b);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          return trie;
        }
        function toPromise(val) {
          return __awaiter(this, void 0, void 0, function() {
            var value, done, next, state, err_1;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (!isIterator(val))
                    return [2, val];
                  done = false;
                  next = "next";
                  _a.label = 1;
                case 1:
                  state = val[next](value);
                  done = state.done;
                  value = state.value;
                  next = "next";
                  _a.label = 2;
                case 2:
                  _a.trys.push([2, 5, , 6]);
                  if (isIterator(value))
                    value = toPromise(value);
                  if (!isPromise(value))
                    return [3, 4];
                  return [4, value];
                case 3:
                  value = _a.sent();
                  _a.label = 4;
                case 4:
                  return [3, 6];
                case 5:
                  err_1 = _a.sent();
                  next = "throw";
                  value = err_1;
                  return [3, 6];
                case 6:
                  if (!done)
                    return [3, 1];
                  _a.label = 7;
                case 7:
                  return [2, value];
              }
            });
          });
        }
        function toValueSync(val) {
          if (!isIterator(val))
            return val;
          var value;
          var done = false;
          var next = "next";
          do {
            var state = val[next](value);
            done = state.done;
            value = state.value;
            next = "next";
            if (isIterator(value)) {
              try {
                value = toValueSync(value);
              } catch (err) {
                next = "throw";
                value = err;
              }
            }
          } while (!done);
          return value;
        }
        function toEnumerable(val) {
          val = toValue(val);
          if (isArray(val))
            return val;
          if (isString(val) && val.length > 0)
            return [val];
          if (isIterable(val))
            return Array.from(val);
          if (isObject(val))
            return Object.keys(val).map(function(key) {
              return [key, val[key]];
            });
          return [];
        }
        function toArray(val) {
          if (isNil(val))
            return [];
          if (isArray(val))
            return val;
          return [val];
        }
        var rFormat = /%([-_0^#:]+)?(\d+)?([EO])?(.)/;
        var monthNames = [
          "January",
          "February",
          "March",
          "April",
          "May",
          "June",
          "July",
          "August",
          "September",
          "October",
          "November",
          "December"
        ];
        var dayNames = [
          "Sunday",
          "Monday",
          "Tuesday",
          "Wednesday",
          "Thursday",
          "Friday",
          "Saturday"
        ];
        var monthNamesShort = monthNames.map(abbr);
        var dayNamesShort = dayNames.map(abbr);
        var suffixes = {
          1: "st",
          2: "nd",
          3: "rd",
          "default": "th"
        };
        function abbr(str) {
          return str.slice(0, 3);
        }
        function daysInMonth(d) {
          var feb = isLeapYear(d) ? 29 : 28;
          return [31, feb, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        }
        function getDayOfYear(d) {
          var num = 0;
          for (var i = 0; i < d.getMonth(); ++i) {
            num += daysInMonth(d)[i];
          }
          return num + d.getDate();
        }
        function getWeekOfYear(d, startDay) {
          var now = getDayOfYear(d) + (startDay - d.getDay());
          var jan1 = new Date(d.getFullYear(), 0, 1);
          var then = 7 - jan1.getDay() + startDay;
          return String(Math.floor((now - then) / 7) + 1);
        }
        function isLeapYear(d) {
          var year = d.getFullYear();
          return !!((year & 3) === 0 && (year % 100 || year % 400 === 0 && year));
        }
        function getSuffix(d) {
          var str = d.getDate().toString();
          var index = parseInt(str.slice(-1));
          return suffixes[index] || suffixes["default"];
        }
        function century(d) {
          return parseInt(d.getFullYear().toString().substring(0, 2), 10);
        }
        var padWidths = {
          d: 2,
          e: 2,
          H: 2,
          I: 2,
          j: 3,
          k: 2,
          l: 2,
          L: 3,
          m: 2,
          M: 2,
          S: 2,
          U: 2,
          W: 2
        };
        var padChars = {
          a: " ",
          A: " ",
          b: " ",
          B: " ",
          c: " ",
          e: " ",
          k: " ",
          l: " ",
          p: " ",
          P: " "
        };
        var formatCodes = {
          a: function(d) {
            return dayNamesShort[d.getDay()];
          },
          A: function(d) {
            return dayNames[d.getDay()];
          },
          b: function(d) {
            return monthNamesShort[d.getMonth()];
          },
          B: function(d) {
            return monthNames[d.getMonth()];
          },
          c: function(d) {
            return d.toLocaleString();
          },
          C: function(d) {
            return century(d);
          },
          d: function(d) {
            return d.getDate();
          },
          e: function(d) {
            return d.getDate();
          },
          H: function(d) {
            return d.getHours();
          },
          I: function(d) {
            return String(d.getHours() % 12 || 12);
          },
          j: function(d) {
            return getDayOfYear(d);
          },
          k: function(d) {
            return d.getHours();
          },
          l: function(d) {
            return String(d.getHours() % 12 || 12);
          },
          L: function(d) {
            return d.getMilliseconds();
          },
          m: function(d) {
            return d.getMonth() + 1;
          },
          M: function(d) {
            return d.getMinutes();
          },
          N: function(d, opts) {
            var width = Number(opts.width) || 9;
            var str = String(d.getMilliseconds()).slice(0, width);
            return padEnd(str, width, "0");
          },
          p: function(d) {
            return d.getHours() < 12 ? "AM" : "PM";
          },
          P: function(d) {
            return d.getHours() < 12 ? "am" : "pm";
          },
          q: function(d) {
            return getSuffix(d);
          },
          s: function(d) {
            return Math.round(d.getTime() / 1e3);
          },
          S: function(d) {
            return d.getSeconds();
          },
          u: function(d) {
            return d.getDay() || 7;
          },
          U: function(d) {
            return getWeekOfYear(d, 0);
          },
          w: function(d) {
            return d.getDay();
          },
          W: function(d) {
            return getWeekOfYear(d, 1);
          },
          x: function(d) {
            return d.toLocaleDateString();
          },
          X: function(d) {
            return d.toLocaleTimeString();
          },
          y: function(d) {
            return d.getFullYear().toString().slice(2, 4);
          },
          Y: function(d) {
            return d.getFullYear();
          },
          z: function(d, opts) {
            var nOffset = Math.abs(d.getTimezoneOffset());
            var h = Math.floor(nOffset / 60);
            var m = nOffset % 60;
            return (d.getTimezoneOffset() > 0 ? "-" : "+") + padStart(h, 2, "0") + (opts.flags[":"] ? ":" : "") + padStart(m, 2, "0");
          },
          "t": function() {
            return "	";
          },
          "n": function() {
            return "\n";
          },
          "%": function() {
            return "%";
          }
        };
        formatCodes.h = formatCodes.b;
        function strftime(d, formatStr) {
          var output = "";
          var remaining = formatStr;
          var match;
          while (match = rFormat.exec(remaining)) {
            output += remaining.slice(0, match.index);
            remaining = remaining.slice(match.index + match[0].length);
            output += format(d, match);
          }
          return output + remaining;
        }
        function format(d, match) {
          var e_1, _a;
          var _b = __read(match, 5), input = _b[0], _c = _b[1], flagStr = _c === void 0 ? "" : _c, width = _b[2], modifier = _b[3], conversion = _b[4];
          var convert = formatCodes[conversion];
          if (!convert)
            return input;
          var flags = {};
          try {
            for (var flagStr_1 = __values(flagStr), flagStr_1_1 = flagStr_1.next(); !flagStr_1_1.done; flagStr_1_1 = flagStr_1.next()) {
              var flag = flagStr_1_1.value;
              flags[flag] = true;
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (flagStr_1_1 && !flagStr_1_1.done && (_a = flagStr_1.return))
                _a.call(flagStr_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          var ret = String(convert(d, { flags, width, modifier }));
          var padChar = padChars[conversion] || "0";
          var padWidth = width || padWidths[conversion] || 0;
          if (flags["^"])
            ret = ret.toUpperCase();
          else if (flags["#"])
            ret = changeCase(ret);
          if (flags["_"])
            padChar = " ";
          else if (flags["0"])
            padChar = "0";
          if (flags["-"])
            padWidth = 0;
          return padStart(ret, padWidth, padChar);
        }
        var OneMinute = 6e4;
        var ISO8601_TIMEZONE_PATTERN = /([zZ]|([+-])(\d{2}):(\d{2}))$/;
        var TimezoneDate = (
          /** @class */
          function() {
            function TimezoneDate2(init, timezoneOffset) {
              this.date = init instanceof TimezoneDate2 ? init.date : new Date(init);
              this.timezoneOffset = timezoneOffset;
              var diff = (this.date.getTimezoneOffset() - this.timezoneOffset) * OneMinute;
              var time = this.date.getTime() + diff;
              this.displayDate = new Date(time);
            }
            TimezoneDate2.prototype.getTime = function() {
              return this.displayDate.getTime();
            };
            TimezoneDate2.prototype.getMilliseconds = function() {
              return this.displayDate.getMilliseconds();
            };
            TimezoneDate2.prototype.getSeconds = function() {
              return this.displayDate.getSeconds();
            };
            TimezoneDate2.prototype.getMinutes = function() {
              return this.displayDate.getMinutes();
            };
            TimezoneDate2.prototype.getHours = function() {
              return this.displayDate.getHours();
            };
            TimezoneDate2.prototype.getDay = function() {
              return this.displayDate.getDay();
            };
            TimezoneDate2.prototype.getDate = function() {
              return this.displayDate.getDate();
            };
            TimezoneDate2.prototype.getMonth = function() {
              return this.displayDate.getMonth();
            };
            TimezoneDate2.prototype.getFullYear = function() {
              return this.displayDate.getFullYear();
            };
            TimezoneDate2.prototype.toLocaleString = function(locale, init) {
              if (init === null || init === void 0 ? void 0 : init.timeZone) {
                return this.date.toLocaleString(locale, init);
              }
              return this.displayDate.toLocaleString(locale, init);
            };
            TimezoneDate2.prototype.toLocaleTimeString = function(locale) {
              return this.displayDate.toLocaleTimeString(locale);
            };
            TimezoneDate2.prototype.toLocaleDateString = function(locale) {
              return this.displayDate.toLocaleDateString(locale);
            };
            TimezoneDate2.prototype.getTimezoneOffset = function() {
              return this.timezoneOffset;
            };
            TimezoneDate2.createDateFixedToTimezone = function(dateString) {
              var m = dateString.match(ISO8601_TIMEZONE_PATTERN);
              if (m && m[1] === "Z") {
                return new TimezoneDate2(+new Date(dateString), 0);
              }
              if (m && m[2] && m[3] && m[4]) {
                var _a = __read(m, 5), sign = _a[2], hours = _a[3], minutes = _a[4];
                var offset2 = (sign === "+" ? -1 : 1) * (parseInt(hours, 10) * 60 + parseInt(minutes, 10));
                return new TimezoneDate2(+new Date(dateString), offset2);
              }
              return new Date(dateString);
            };
            return TimezoneDate2;
          }()
        );
        var DelimitedToken = (
          /** @class */
          function(_super) {
            __extends(DelimitedToken2, _super);
            function DelimitedToken2(kind, _a, input, begin, end, trimLeft2, trimRight2, file) {
              var _b = __read(_a, 2), contentBegin = _b[0], contentEnd = _b[1];
              var _this = _super.call(this, kind, input, begin, end, file) || this;
              _this.trimLeft = false;
              _this.trimRight = false;
              var tl = input[contentBegin] === "-";
              var tr = input[contentEnd - 1] === "-";
              var l = tl ? contentBegin + 1 : contentBegin;
              var r = tr ? contentEnd - 1 : contentEnd;
              while (l < r && TYPES[input.charCodeAt(l)] & BLANK)
                l++;
              while (r > l && TYPES[input.charCodeAt(r - 1)] & BLANK)
                r--;
              _this.contentRange = [l, r];
              _this.trimLeft = tl || trimLeft2;
              _this.trimRight = tr || trimRight2;
              return _this;
            }
            Object.defineProperty(DelimitedToken2.prototype, "content", {
              get: function() {
                return this.input.slice(this.contentRange[0], this.contentRange[1]);
              },
              enumerable: false,
              configurable: true
            });
            return DelimitedToken2;
          }(Token)
        );
        var TagToken = (
          /** @class */
          function(_super) {
            __extends(TagToken2, _super);
            function TagToken2(input, begin, end, options, file) {
              var _this = this;
              var trimTagLeft = options.trimTagLeft, trimTagRight = options.trimTagRight, tagDelimiterLeft = options.tagDelimiterLeft, tagDelimiterRight = options.tagDelimiterRight;
              var _a = __read([begin + tagDelimiterLeft.length, end - tagDelimiterRight.length], 2), valueBegin = _a[0], valueEnd = _a[1];
              _this = _super.call(this, exports2.TokenKind.Tag, [valueBegin, valueEnd], input, begin, end, trimTagLeft, trimTagRight, file) || this;
              _this.tokenizer = new Tokenizer(input, options.operators, file, _this.contentRange);
              _this.name = _this.tokenizer.readTagName();
              _this.tokenizer.assert(_this.name, "illegal tag syntax, tag name expected");
              _this.tokenizer.skipBlank();
              return _this;
            }
            Object.defineProperty(TagToken2.prototype, "args", {
              get: function() {
                return this.tokenizer.input.slice(this.tokenizer.p, this.contentRange[1]);
              },
              enumerable: false,
              configurable: true
            });
            return TagToken2;
          }(DelimitedToken)
        );
        var OutputToken = (
          /** @class */
          function(_super) {
            __extends(OutputToken2, _super);
            function OutputToken2(input, begin, end, options, file) {
              var trimOutputLeft = options.trimOutputLeft, trimOutputRight = options.trimOutputRight, outputDelimiterLeft = options.outputDelimiterLeft, outputDelimiterRight = options.outputDelimiterRight;
              var valueRange = [begin + outputDelimiterLeft.length, end - outputDelimiterRight.length];
              return _super.call(this, exports2.TokenKind.Output, valueRange, input, begin, end, trimOutputLeft, trimOutputRight, file) || this;
            }
            return OutputToken2;
          }(DelimitedToken)
        );
        var HTMLToken = (
          /** @class */
          function(_super) {
            __extends(HTMLToken2, _super);
            function HTMLToken2(input, begin, end, file) {
              var _this = _super.call(this, exports2.TokenKind.HTML, input, begin, end, file) || this;
              _this.input = input;
              _this.begin = begin;
              _this.end = end;
              _this.file = file;
              _this.trimLeft = 0;
              _this.trimRight = 0;
              return _this;
            }
            HTMLToken2.prototype.getContent = function() {
              return this.input.slice(this.begin + this.trimLeft, this.end - this.trimRight);
            };
            return HTMLToken2;
          }(Token)
        );
        var NumberToken = (
          /** @class */
          function(_super) {
            __extends(NumberToken2, _super);
            function NumberToken2(whole, decimal) {
              var _this = _super.call(this, exports2.TokenKind.Number, whole.input, whole.begin, decimal ? decimal.end : whole.end, whole.file) || this;
              _this.whole = whole;
              _this.decimal = decimal;
              return _this;
            }
            return NumberToken2;
          }(Token)
        );
        var IdentifierToken = (
          /** @class */
          function(_super) {
            __extends(IdentifierToken2, _super);
            function IdentifierToken2(input, begin, end, file) {
              var _this = _super.call(this, exports2.TokenKind.Word, input, begin, end, file) || this;
              _this.input = input;
              _this.begin = begin;
              _this.end = end;
              _this.file = file;
              _this.content = _this.getText();
              return _this;
            }
            IdentifierToken2.prototype.isNumber = function(allowSign) {
              if (allowSign === void 0) {
                allowSign = false;
              }
              var begin = allowSign && TYPES[this.input.charCodeAt(this.begin)] & SIGN ? this.begin + 1 : this.begin;
              for (var i = begin; i < this.end; i++) {
                if (!(TYPES[this.input.charCodeAt(i)] & NUMBER))
                  return false;
              }
              return true;
            };
            return IdentifierToken2;
          }(Token)
        );
        var LiteralToken = (
          /** @class */
          function(_super) {
            __extends(LiteralToken2, _super);
            function LiteralToken2(input, begin, end, file) {
              var _this = _super.call(this, exports2.TokenKind.Literal, input, begin, end, file) || this;
              _this.input = input;
              _this.begin = begin;
              _this.end = end;
              _this.file = file;
              _this.literal = _this.getText();
              return _this;
            }
            return LiteralToken2;
          }(Token)
        );
        var operatorPrecedences = {
          "==": 2,
          "!=": 2,
          ">": 2,
          "<": 2,
          ">=": 2,
          "<=": 2,
          "contains": 2,
          "not": 1,
          "and": 0,
          "or": 0
        };
        var operatorTypes = {
          "==": 0,
          "!=": 0,
          ">": 0,
          "<": 0,
          ">=": 0,
          "<=": 0,
          "contains": 0,
          "not": 1,
          "and": 0,
          "or": 0
          /* OperatorType.Binary */
        };
        var OperatorToken = (
          /** @class */
          function(_super) {
            __extends(OperatorToken2, _super);
            function OperatorToken2(input, begin, end, file) {
              var _this = _super.call(this, exports2.TokenKind.Operator, input, begin, end, file) || this;
              _this.input = input;
              _this.begin = begin;
              _this.end = end;
              _this.file = file;
              _this.operator = _this.getText();
              return _this;
            }
            OperatorToken2.prototype.getPrecedence = function() {
              var key = this.getText();
              return key in operatorPrecedences ? operatorPrecedences[key] : 1;
            };
            return OperatorToken2;
          }(Token)
        );
        var PropertyAccessToken = (
          /** @class */
          function(_super) {
            __extends(PropertyAccessToken2, _super);
            function PropertyAccessToken2(variable, props, end) {
              var _this = _super.call(this, exports2.TokenKind.PropertyAccess, variable.input, variable.begin, end, variable.file) || this;
              _this.variable = variable;
              _this.props = props;
              _this.propertyName = _this.variable instanceof IdentifierToken ? _this.variable.getText() : parseStringLiteral(_this.variable.getText());
              return _this;
            }
            return PropertyAccessToken2;
          }(Token)
        );
        var FilterToken = (
          /** @class */
          function(_super) {
            __extends(FilterToken2, _super);
            function FilterToken2(name, args, input, begin, end, file) {
              var _this = _super.call(this, exports2.TokenKind.Filter, input, begin, end, file) || this;
              _this.name = name;
              _this.args = args;
              return _this;
            }
            return FilterToken2;
          }(Token)
        );
        var HashToken = (
          /** @class */
          function(_super) {
            __extends(HashToken2, _super);
            function HashToken2(input, begin, end, name, value, file) {
              var _this = _super.call(this, exports2.TokenKind.Hash, input, begin, end, file) || this;
              _this.input = input;
              _this.begin = begin;
              _this.end = end;
              _this.name = name;
              _this.value = value;
              _this.file = file;
              return _this;
            }
            return HashToken2;
          }(Token)
        );
        var QuotedToken = (
          /** @class */
          function(_super) {
            __extends(QuotedToken2, _super);
            function QuotedToken2(input, begin, end, file) {
              var _this = _super.call(this, exports2.TokenKind.Quoted, input, begin, end, file) || this;
              _this.input = input;
              _this.begin = begin;
              _this.end = end;
              _this.file = file;
              return _this;
            }
            return QuotedToken2;
          }(Token)
        );
        var RangeToken = (
          /** @class */
          function(_super) {
            __extends(RangeToken2, _super);
            function RangeToken2(input, begin, end, lhs, rhs, file) {
              var _this = _super.call(this, exports2.TokenKind.Range, input, begin, end, file) || this;
              _this.input = input;
              _this.begin = begin;
              _this.end = end;
              _this.lhs = lhs;
              _this.rhs = rhs;
              _this.file = file;
              return _this;
            }
            return RangeToken2;
          }(Token)
        );
        var LiquidTagToken = (
          /** @class */
          function(_super) {
            __extends(LiquidTagToken2, _super);
            function LiquidTagToken2(input, begin, end, options, file) {
              var _this = _super.call(this, exports2.TokenKind.Tag, [begin, end], input, begin, end, false, false, file) || this;
              _this.tokenizer = new Tokenizer(input, options.operators, file, _this.contentRange);
              _this.name = _this.tokenizer.readTagName();
              _this.tokenizer.assert(_this.name, "illegal liquid tag syntax");
              _this.tokenizer.skipBlank();
              _this.args = _this.tokenizer.remaining();
              return _this;
            }
            return LiquidTagToken2;
          }(DelimitedToken)
        );
        var FilteredValueToken = (
          /** @class */
          function(_super) {
            __extends(FilteredValueToken2, _super);
            function FilteredValueToken2(initial, filters2, input, begin, end, file) {
              var _this = _super.call(this, exports2.TokenKind.FilteredValue, input, begin, end, file) || this;
              _this.initial = initial;
              _this.filters = filters2;
              _this.input = input;
              _this.begin = begin;
              _this.end = end;
              _this.file = file;
              return _this;
            }
            return FilteredValueToken2;
          }(Token)
        );
        var SimpleEmitter = (
          /** @class */
          function() {
            function SimpleEmitter2() {
              this.buffer = "";
            }
            SimpleEmitter2.prototype.write = function(html) {
              this.buffer += stringify(html);
            };
            return SimpleEmitter2;
          }()
        );
        var StreamedEmitter = (
          /** @class */
          function() {
            function StreamedEmitter2() {
              this.buffer = "";
              this.stream = null;
              throw new Error("streaming not supported in browser");
            }
            return StreamedEmitter2;
          }()
        );
        var KeepingTypeEmitter = (
          /** @class */
          function() {
            function KeepingTypeEmitter2() {
              this.buffer = "";
            }
            KeepingTypeEmitter2.prototype.write = function(html) {
              html = toValue(html);
              if (typeof html !== "string" && this.buffer === "") {
                this.buffer = html;
              } else {
                this.buffer = stringify(this.buffer) + stringify(html);
              }
            };
            return KeepingTypeEmitter2;
          }()
        );
        var Render = (
          /** @class */
          function() {
            function Render2() {
            }
            Render2.prototype.renderTemplatesToNodeStream = function(templates, ctx) {
              var _this = this;
              var emitter = new StreamedEmitter();
              Promise.resolve().then(function() {
                return toPromise(_this.renderTemplates(templates, ctx, emitter));
              }).then(function() {
                return emitter.end();
              }, function(err) {
                return emitter.error(err);
              });
              return emitter.stream;
            };
            Render2.prototype.renderTemplates = function(templates, ctx, emitter) {
              var templates_1, templates_1_1, tpl, html, e_1, err, e_2_1;
              var e_2, _a;
              return __generator(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    if (!emitter) {
                      emitter = ctx.opts.keepOutputType ? new KeepingTypeEmitter() : new SimpleEmitter();
                    }
                    _b.label = 1;
                  case 1:
                    _b.trys.push([1, 8, 9, 10]);
                    templates_1 = __values(templates), templates_1_1 = templates_1.next();
                    _b.label = 2;
                  case 2:
                    if (!!templates_1_1.done)
                      return [3, 7];
                    tpl = templates_1_1.value;
                    _b.label = 3;
                  case 3:
                    _b.trys.push([3, 5, , 6]);
                    return [
                      4,
                      tpl.render(ctx, emitter)
                      // if not, it'll return an `html`, write to the emitter for it
                    ];
                  case 4:
                    html = _b.sent();
                    html && emitter.write(html);
                    if (emitter["break"] || emitter["continue"])
                      return [3, 7];
                    return [3, 6];
                  case 5:
                    e_1 = _b.sent();
                    err = RenderError.is(e_1) ? e_1 : new RenderError(e_1, tpl);
                    throw err;
                  case 6:
                    templates_1_1 = templates_1.next();
                    return [3, 2];
                  case 7:
                    return [3, 10];
                  case 8:
                    e_2_1 = _b.sent();
                    e_2 = { error: e_2_1 };
                    return [3, 10];
                  case 9:
                    try {
                      if (templates_1_1 && !templates_1_1.done && (_a = templates_1.return))
                        _a.call(templates_1);
                    } finally {
                      if (e_2)
                        throw e_2.error;
                    }
                    return [
                      7
                      /*endfinally*/
                    ];
                  case 10:
                    return [2, emitter.buffer];
                }
              });
            };
            return Render2;
          }()
        );
        var Expression = (
          /** @class */
          function() {
            function Expression2(tokens) {
              this.postfix = __spreadArray([], __read(toPostfix(tokens)), false);
            }
            Expression2.prototype.evaluate = function(ctx, lenient) {
              var operands, _a, _b, token, r, result, l, _c, _d, e_1_1;
              var e_1, _e;
              return __generator(this, function(_f) {
                switch (_f.label) {
                  case 0:
                    assert(ctx, "unable to evaluate: context not defined");
                    operands = [];
                    _f.label = 1;
                  case 1:
                    _f.trys.push([1, 11, 12, 13]);
                    _a = __values(this.postfix), _b = _a.next();
                    _f.label = 2;
                  case 2:
                    if (!!_b.done)
                      return [3, 10];
                    token = _b.value;
                    if (!isOperatorToken(token))
                      return [3, 7];
                    r = operands.pop();
                    result = void 0;
                    if (!(operatorTypes[token.operator] === 1))
                      return [3, 4];
                    return [4, ctx.opts.operators[token.operator](r, ctx)];
                  case 3:
                    result = _f.sent();
                    return [3, 6];
                  case 4:
                    l = operands.pop();
                    return [4, ctx.opts.operators[token.operator](l, r, ctx)];
                  case 5:
                    result = _f.sent();
                    _f.label = 6;
                  case 6:
                    operands.push(result);
                    return [3, 9];
                  case 7:
                    _d = (_c = operands).push;
                    return [4, evalToken(token, ctx, lenient && this.postfix.length === 1)];
                  case 8:
                    _d.apply(_c, [_f.sent()]);
                    _f.label = 9;
                  case 9:
                    _b = _a.next();
                    return [3, 2];
                  case 10:
                    return [3, 13];
                  case 11:
                    e_1_1 = _f.sent();
                    e_1 = { error: e_1_1 };
                    return [3, 13];
                  case 12:
                    try {
                      if (_b && !_b.done && (_e = _a.return))
                        _e.call(_a);
                    } finally {
                      if (e_1)
                        throw e_1.error;
                    }
                    return [
                      7
                      /*endfinally*/
                    ];
                  case 13:
                    return [2, operands[0]];
                }
              });
            };
            Expression2.prototype.valid = function() {
              return !!this.postfix.length;
            };
            return Expression2;
          }()
        );
        function evalToken(token, ctx, lenient) {
          if (lenient === void 0) {
            lenient = false;
          }
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!isPropertyAccessToken(token))
                  return [3, 2];
                return [4, evalPropertyAccessToken(token, ctx, lenient)];
              case 1:
                return [2, _a.sent()];
              case 2:
                if (!isRangeToken(token))
                  return [3, 4];
                return [4, evalRangeToken(token, ctx)];
              case 3:
                return [2, _a.sent()];
              case 4:
                if (isLiteralToken(token))
                  return [2, evalLiteralToken(token)];
                if (isNumberToken(token))
                  return [2, evalNumberToken(token)];
                if (isWordToken(token))
                  return [2, token.getText()];
                if (isQuotedToken(token))
                  return [2, evalQuotedToken(token)];
                return [
                  2
                  /*return*/
                ];
            }
          });
        }
        function evalPropertyAccessToken(token, ctx, lenient) {
          var props, _a, _b, prop, _c, _d, e_2_1, e_3;
          var e_2, _e;
          return __generator(this, function(_f) {
            switch (_f.label) {
              case 0:
                props = [];
                _f.label = 1;
              case 1:
                _f.trys.push([1, 6, 7, 8]);
                _a = __values(token.props), _b = _a.next();
                _f.label = 2;
              case 2:
                if (!!_b.done)
                  return [3, 5];
                prop = _b.value;
                _d = (_c = props).push;
                return [4, evalToken(prop, ctx, false)];
              case 3:
                _d.apply(_c, [_f.sent()]);
                _f.label = 4;
              case 4:
                _b = _a.next();
                return [3, 2];
              case 5:
                return [3, 8];
              case 6:
                e_2_1 = _f.sent();
                e_2 = { error: e_2_1 };
                return [3, 8];
              case 7:
                try {
                  if (_b && !_b.done && (_e = _a.return))
                    _e.call(_a);
                } finally {
                  if (e_2)
                    throw e_2.error;
                }
                return [
                  7
                  /*endfinally*/
                ];
              case 8:
                _f.trys.push([8, 10, , 11]);
                return [4, ctx._get(__spreadArray([token.propertyName], __read(props), false))];
              case 9:
                return [2, _f.sent()];
              case 10:
                e_3 = _f.sent();
                if (lenient && e_3.name === "InternalUndefinedVariableError")
                  return [2, null];
                throw new UndefinedVariableError(e_3, token);
              case 11:
                return [
                  2
                  /*return*/
                ];
            }
          });
        }
        function evalNumberToken(token) {
          var str = token.whole.content + "." + (token.decimal ? token.decimal.content : "");
          return Number(str);
        }
        function evalQuotedToken(token) {
          return parseStringLiteral(token.getText());
        }
        function evalLiteralToken(token) {
          return literalValues[token.literal];
        }
        function evalRangeToken(token, ctx) {
          var low, high;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, evalToken(token.lhs, ctx)];
              case 1:
                low = _a.sent();
                return [4, evalToken(token.rhs, ctx)];
              case 2:
                high = _a.sent();
                return [2, range(+low, +high + 1)];
            }
          });
        }
        function toPostfix(tokens) {
          var ops, tokens_1, tokens_1_1, token, e_4_1;
          var e_4, _a;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                ops = [];
                _b.label = 1;
              case 1:
                _b.trys.push([1, 10, 11, 12]);
                tokens_1 = __values(tokens), tokens_1_1 = tokens_1.next();
                _b.label = 2;
              case 2:
                if (!!tokens_1_1.done)
                  return [3, 9];
                token = tokens_1_1.value;
                if (!isOperatorToken(token))
                  return [3, 6];
                _b.label = 3;
              case 3:
                if (!(ops.length && ops[ops.length - 1].getPrecedence() > token.getPrecedence()))
                  return [3, 5];
                return [4, ops.pop()];
              case 4:
                _b.sent();
                return [3, 3];
              case 5:
                ops.push(token);
                return [3, 8];
              case 6:
                return [4, token];
              case 7:
                _b.sent();
                _b.label = 8;
              case 8:
                tokens_1_1 = tokens_1.next();
                return [3, 2];
              case 9:
                return [3, 12];
              case 10:
                e_4_1 = _b.sent();
                e_4 = { error: e_4_1 };
                return [3, 12];
              case 11:
                try {
                  if (tokens_1_1 && !tokens_1_1.done && (_a = tokens_1.return))
                    _a.call(tokens_1);
                } finally {
                  if (e_4)
                    throw e_4.error;
                }
                return [
                  7
                  /*endfinally*/
                ];
              case 12:
                if (!ops.length)
                  return [3, 14];
                return [4, ops.pop()];
              case 13:
                _b.sent();
                return [3, 12];
              case 14:
                return [
                  2
                  /*return*/
                ];
            }
          });
        }
        function isTruthy(val, ctx) {
          return !isFalsy(val, ctx);
        }
        function isFalsy(val, ctx) {
          if (ctx.opts.jsTruthy) {
            return !val;
          } else {
            return val === false || void 0 === val || val === null;
          }
        }
        var defaultOperators = {
          "==": equal,
          "!=": function(l, r) {
            return !equal(l, r);
          },
          ">": function(l, r) {
            if (isComparable(l))
              return l.gt(r);
            if (isComparable(r))
              return r.lt(l);
            return toValue(l) > toValue(r);
          },
          "<": function(l, r) {
            if (isComparable(l))
              return l.lt(r);
            if (isComparable(r))
              return r.gt(l);
            return toValue(l) < toValue(r);
          },
          ">=": function(l, r) {
            if (isComparable(l))
              return l.geq(r);
            if (isComparable(r))
              return r.leq(l);
            return toValue(l) >= toValue(r);
          },
          "<=": function(l, r) {
            if (isComparable(l))
              return l.leq(r);
            if (isComparable(r))
              return r.geq(l);
            return toValue(l) <= toValue(r);
          },
          "contains": function(l, r) {
            l = toValue(l);
            r = toValue(r);
            return l && isFunction(l.indexOf) ? l.indexOf(r) > -1 : false;
          },
          "not": function(v, ctx) {
            return isFalsy(toValue(v), ctx);
          },
          "and": function(l, r, ctx) {
            return isTruthy(toValue(l), ctx) && isTruthy(toValue(r), ctx);
          },
          "or": function(l, r, ctx) {
            return isTruthy(toValue(l), ctx) || isTruthy(toValue(r), ctx);
          }
        };
        function equal(lhs, rhs) {
          if (isComparable(lhs))
            return lhs.equals(rhs);
          if (isComparable(rhs))
            return rhs.equals(lhs);
          lhs = toValue(lhs);
          rhs = toValue(rhs);
          if (isArray(lhs)) {
            return isArray(rhs) && arrayEqual(lhs, rhs);
          }
          return lhs === rhs;
        }
        function arrayEqual(lhs, rhs) {
          if (lhs.length !== rhs.length)
            return false;
          return !lhs.some(function(value, i) {
            return !equal(value, rhs[i]);
          });
        }
        var Node = (
          /** @class */
          function() {
            function Node2(key, value, next, prev) {
              this.key = key;
              this.value = value;
              this.next = next;
              this.prev = prev;
            }
            return Node2;
          }()
        );
        var LRU = (
          /** @class */
          function() {
            function LRU2(limit2, size2) {
              if (size2 === void 0) {
                size2 = 0;
              }
              this.limit = limit2;
              this.size = size2;
              this.cache = {};
              this.head = new Node("HEAD", null, null, null);
              this.tail = new Node("TAIL", null, null, null);
              this.head.next = this.tail;
              this.tail.prev = this.head;
            }
            LRU2.prototype.write = function(key, value) {
              if (this.cache[key]) {
                this.cache[key].value = value;
              } else {
                var node = new Node(key, value, this.head.next, this.head);
                this.head.next.prev = node;
                this.head.next = node;
                this.cache[key] = node;
                this.size++;
                this.ensureLimit();
              }
            };
            LRU2.prototype.read = function(key) {
              if (!this.cache[key])
                return;
              var value = this.cache[key].value;
              this.remove(key);
              this.write(key, value);
              return value;
            };
            LRU2.prototype.remove = function(key) {
              var node = this.cache[key];
              node.prev.next = node.next;
              node.next.prev = node.prev;
              delete this.cache[key];
              this.size--;
            };
            LRU2.prototype.clear = function() {
              this.head.next = this.tail;
              this.tail.prev = this.head;
              this.size = 0;
              this.cache = {};
            };
            LRU2.prototype.ensureLimit = function() {
              if (this.size > this.limit)
                this.remove(this.tail.prev.key);
            };
            return LRU2;
          }()
        );
        function domResolve(root, path) {
          var base = document.createElement("base");
          base.href = root;
          var head = document.getElementsByTagName("head")[0];
          head.insertBefore(base, head.firstChild);
          var a = document.createElement("a");
          a.href = path;
          var resolved = a.href;
          head.removeChild(base);
          return resolved;
        }
        function resolve(root, filepath, ext) {
          if (root.length && last(root) !== "/")
            root += "/";
          var url = domResolve(root, filepath);
          return url.replace(/^(\w+:\/\/[^/]+)(\/[^?]+)/, function(str, origin, path) {
            var last2 = path.split("/").pop();
            if (/\.\w+$/.test(last2))
              return str;
            return origin + path + ext;
          });
        }
        function readFile(url) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2, new Promise(function(resolve2, reject) {
                var xhr = new XMLHttpRequest();
                xhr.onload = function() {
                  if (xhr.status >= 200 && xhr.status < 300) {
                    resolve2(xhr.responseText);
                  } else {
                    reject(new Error(xhr.statusText));
                  }
                };
                xhr.onerror = function() {
                  reject(new Error("An error occurred whilst receiving the response."));
                };
                xhr.open("GET", url);
                xhr.send();
              })];
            });
          });
        }
        function readFileSync(url) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", url, false);
          xhr.send();
          if (xhr.status < 200 || xhr.status >= 300) {
            throw new Error(xhr.statusText);
          }
          return xhr.responseText;
        }
        function exists(filepath) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2, true];
            });
          });
        }
        function existsSync(filepath) {
          return true;
        }
        function dirname(filepath) {
          return domResolve(filepath, ".");
        }
        var sep = "/";
        var fs = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          resolve,
          readFile,
          readFileSync,
          exists,
          existsSync,
          dirname,
          sep
        });
        function Default(value, defaultValue) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          value = toValue(value);
          if (isArray(value) || isString(value))
            return value.length ? value : defaultValue;
          if (value === false && new Map(args).get("allow_false"))
            return false;
          return isFalsy(value, this.context) ? defaultValue : value;
        }
        function json(value, space) {
          if (space === void 0) {
            space = 0;
          }
          return JSON.stringify(value, null, space);
        }
        var raw = {
          raw: true,
          handler: identify
        };
        var escapeMap = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&#34;",
          "'": "&#39;"
        };
        var unescapeMap = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&#34;": '"',
          "&#39;": "'"
        };
        function escape(str) {
          return stringify(str).replace(/&|<|>|"|'/g, function(m) {
            return escapeMap[m];
          });
        }
        function unescape(str) {
          return stringify(str).replace(/&(amp|lt|gt|#34|#39);/g, function(m) {
            return unescapeMap[m];
          });
        }
        function escape_once(str) {
          return escape(unescape(stringify(str)));
        }
        function newline_to_br(v) {
          return stringify(v).replace(/\n/g, "<br />\n");
        }
        function strip_html(v) {
          return stringify(v).replace(/<script[\s\S]*?<\/script>|<style[\s\S]*?<\/style>|<.*?>|<!--[\s\S]*?-->/g, "");
        }
        var htmlFilters = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          escape,
          escape_once,
          newline_to_br,
          strip_html
        });
        var defaultOptions = {
          root: ["."],
          layouts: ["."],
          partials: ["."],
          relativeReference: true,
          jekyllInclude: false,
          cache: void 0,
          extname: "",
          fs,
          dynamicPartials: true,
          jsTruthy: false,
          dateFormat: "%A, %B %-e, %Y at %-l:%M %P %z",
          trimTagRight: false,
          trimTagLeft: false,
          trimOutputRight: false,
          trimOutputLeft: false,
          greedy: true,
          tagDelimiterLeft: "{%",
          tagDelimiterRight: "%}",
          outputDelimiterLeft: "{{",
          outputDelimiterRight: "}}",
          preserveTimezones: false,
          strictFilters: false,
          strictVariables: false,
          ownPropertyOnly: true,
          lenientIf: false,
          globals: {},
          keepOutputType: false,
          operators: defaultOperators
        };
        function normalize(options) {
          if (options.hasOwnProperty("root")) {
            if (!options.hasOwnProperty("partials"))
              options.partials = options.root;
            if (!options.hasOwnProperty("layouts"))
              options.layouts = options.root;
          }
          if (options.hasOwnProperty("cache")) {
            var cache = void 0;
            if (typeof options.cache === "number")
              cache = options.cache > 0 ? new LRU(options.cache) : void 0;
            else if (typeof options.cache === "object")
              cache = options.cache;
            else
              cache = options.cache ? new LRU(1024) : void 0;
            options.cache = cache;
          }
          options = __assign(__assign(__assign({}, defaultOptions), options.jekyllInclude ? { dynamicPartials: false } : {}), options);
          if ((!options.fs.dirname || !options.fs.sep) && options.relativeReference) {
            console.warn("[LiquidJS] `fs.dirname` and `fs.sep` are required for relativeReference, set relativeReference to `false` to suppress this warning");
            options.relativeReference = false;
          }
          options.root = normalizeDirectoryList(options.root);
          options.partials = normalizeDirectoryList(options.partials);
          options.layouts = normalizeDirectoryList(options.layouts);
          options.outputEscape = options.outputEscape && getOutputEscapeFunction(options.outputEscape);
          return options;
        }
        function getOutputEscapeFunction(nameOrFunction) {
          if (nameOrFunction === "escape")
            return escape;
          if (nameOrFunction === "json")
            return json;
          assert(isFunction(nameOrFunction), "`outputEscape` need to be of type string or function");
          return nameOrFunction;
        }
        function normalizeDirectoryList(value) {
          var list = [];
          if (isArray(value))
            list = value;
          if (isString(value))
            list = [value];
          return list;
        }
        function matchOperator(str, begin, trie, end) {
          if (end === void 0) {
            end = str.length;
          }
          var node = trie;
          var i = begin;
          var info;
          while (node[str[i]] && i < end) {
            node = node[str[i++]];
            if (node["end"])
              info = node;
          }
          if (!info)
            return -1;
          if (info["needBoundary"] && TYPES[str.charCodeAt(i)] & IDENTIFIER)
            return -1;
          return i;
        }
        function whiteSpaceCtrl(tokens, options) {
          var inRaw = false;
          for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            if (!isDelimitedToken(token))
              continue;
            if (!inRaw && token.trimLeft) {
              trimLeft(tokens[i - 1], options.greedy);
            }
            if (isTagToken(token)) {
              if (token.name === "raw")
                inRaw = true;
              else if (token.name === "endraw")
                inRaw = false;
            }
            if (!inRaw && token.trimRight) {
              trimRight(tokens[i + 1], options.greedy);
            }
          }
        }
        function trimLeft(token, greedy) {
          if (!token || !isHTMLToken(token))
            return;
          var mask = greedy ? BLANK : INLINE_BLANK;
          while (TYPES[token.input.charCodeAt(token.end - 1 - token.trimRight)] & mask)
            token.trimRight++;
        }
        function trimRight(token, greedy) {
          if (!token || !isHTMLToken(token))
            return;
          var mask = greedy ? BLANK : INLINE_BLANK;
          while (TYPES[token.input.charCodeAt(token.begin + token.trimLeft)] & mask)
            token.trimLeft++;
          if (token.input.charAt(token.begin + token.trimLeft) === "\n")
            token.trimLeft++;
        }
        var Tokenizer = (
          /** @class */
          function() {
            function Tokenizer2(input, operators, file, range2) {
              if (operators === void 0) {
                operators = defaultOptions.operators;
              }
              this.input = input;
              this.file = file;
              this.range = range2;
              this.rawBeginAt = -1;
              this.p = range2 ? range2[0] : 0;
              this.N = range2 ? range2[1] : input.length;
              this.opTrie = createTrie(operators);
            }
            Tokenizer2.prototype.readExpression = function() {
              return new Expression(this.readExpressionTokens());
            };
            Tokenizer2.prototype.readExpressionTokens = function() {
              var operator, operand;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    if (!(this.p < this.N))
                      return [3, 5];
                    operator = this.readOperator();
                    if (!operator)
                      return [3, 2];
                    return [4, operator];
                  case 1:
                    _a.sent();
                    return [3, 0];
                  case 2:
                    operand = this.readValue();
                    if (!operand)
                      return [3, 4];
                    return [4, operand];
                  case 3:
                    _a.sent();
                    return [3, 0];
                  case 4:
                    return [
                      2
                      /*return*/
                    ];
                  case 5:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            };
            Tokenizer2.prototype.readOperator = function() {
              this.skipBlank();
              var end = matchOperator(this.input, this.p, this.opTrie);
              if (end === -1)
                return;
              return new OperatorToken(this.input, this.p, this.p = end, this.file);
            };
            Tokenizer2.prototype.readFilteredValue = function() {
              var begin = this.p;
              var initial = this.readExpression();
              this.assert(initial.valid(), "invalid value expression: ".concat(this.snapshot()));
              var filters2 = this.readFilters();
              return new FilteredValueToken(initial, filters2, this.input, begin, this.p, this.file);
            };
            Tokenizer2.prototype.readFilters = function() {
              var filters2 = [];
              while (true) {
                var filter = this.readFilter();
                if (!filter)
                  return filters2;
                filters2.push(filter);
              }
            };
            Tokenizer2.prototype.readFilter = function() {
              var _this = this;
              this.skipBlank();
              if (this.end())
                return null;
              this.assert(this.peek() === "|", 'expected "|" before filter');
              this.p++;
              var begin = this.p;
              var name = this.readIdentifier();
              if (!name.size()) {
                this.assert(this.end(), "expected filter name");
                return null;
              }
              var args = [];
              this.skipBlank();
              if (this.peek() === ":") {
                do {
                  ++this.p;
                  var arg = this.readFilterArg();
                  arg && args.push(arg);
                  this.skipBlank();
                  this.assert(this.end() || this.peek() === "," || this.peek() === "|", function() {
                    return "unexpected character ".concat(_this.snapshot());
                  });
                } while (this.peek() === ",");
              } else if (this.peek() === "|" || this.end())
                ;
              else {
                throw this.error('expected ":" after filter name');
              }
              return new FilterToken(name.getText(), args, this.input, begin, this.p, this.file);
            };
            Tokenizer2.prototype.readFilterArg = function() {
              var key = this.readValue();
              if (!key)
                return;
              this.skipBlank();
              if (this.peek() !== ":")
                return key;
              ++this.p;
              var value = this.readValue();
              return [key.getText(), value];
            };
            Tokenizer2.prototype.readTopLevelTokens = function(options) {
              if (options === void 0) {
                options = defaultOptions;
              }
              var tokens = [];
              while (this.p < this.N) {
                var token = this.readTopLevelToken(options);
                tokens.push(token);
              }
              whiteSpaceCtrl(tokens, options);
              return tokens;
            };
            Tokenizer2.prototype.readTopLevelToken = function(options) {
              var tagDelimiterLeft = options.tagDelimiterLeft, outputDelimiterLeft = options.outputDelimiterLeft;
              if (this.rawBeginAt > -1)
                return this.readEndrawOrRawContent(options);
              if (this.match(tagDelimiterLeft))
                return this.readTagToken(options);
              if (this.match(outputDelimiterLeft))
                return this.readOutputToken(options);
              return this.readHTMLToken([tagDelimiterLeft, outputDelimiterLeft]);
            };
            Tokenizer2.prototype.readHTMLToken = function(stopStrings) {
              var _this = this;
              var begin = this.p;
              while (this.p < this.N) {
                if (stopStrings.some(function(str) {
                  return _this.match(str);
                }))
                  break;
                ++this.p;
              }
              return new HTMLToken(this.input, begin, this.p, this.file);
            };
            Tokenizer2.prototype.readTagToken = function(options) {
              if (options === void 0) {
                options = defaultOptions;
              }
              var _a = this, file = _a.file, input = _a.input;
              var begin = this.p;
              if (this.readToDelimiter(options.tagDelimiterRight) === -1) {
                throw this.error("tag ".concat(this.snapshot(begin), " not closed"), begin);
              }
              var token = new TagToken(input, begin, this.p, options, file);
              if (token.name === "raw")
                this.rawBeginAt = begin;
              return token;
            };
            Tokenizer2.prototype.readToDelimiter = function(delimiter) {
              while (this.p < this.N) {
                if (this.peekType() & QUOTE) {
                  this.readQuoted();
                  continue;
                }
                ++this.p;
                if (this.rmatch(delimiter))
                  return this.p;
              }
              return -1;
            };
            Tokenizer2.prototype.readOutputToken = function(options) {
              if (options === void 0) {
                options = defaultOptions;
              }
              var _a = this, file = _a.file, input = _a.input;
              var outputDelimiterRight = options.outputDelimiterRight;
              var begin = this.p;
              if (this.readToDelimiter(outputDelimiterRight) === -1) {
                throw this.error("output ".concat(this.snapshot(begin), " not closed"), begin);
              }
              return new OutputToken(input, begin, this.p, options, file);
            };
            Tokenizer2.prototype.readEndrawOrRawContent = function(options) {
              var tagDelimiterLeft = options.tagDelimiterLeft, tagDelimiterRight = options.tagDelimiterRight;
              var begin = this.p;
              var leftPos = this.readTo(tagDelimiterLeft) - tagDelimiterLeft.length;
              while (this.p < this.N) {
                if (this.readIdentifier().getText() !== "endraw") {
                  leftPos = this.readTo(tagDelimiterLeft) - tagDelimiterLeft.length;
                  continue;
                }
                while (this.p <= this.N) {
                  if (this.rmatch(tagDelimiterRight)) {
                    var end = this.p;
                    if (begin === leftPos) {
                      this.rawBeginAt = -1;
                      return new TagToken(this.input, begin, end, options, this.file);
                    } else {
                      this.p = leftPos;
                      return new HTMLToken(this.input, begin, leftPos, this.file);
                    }
                  }
                  if (this.rmatch(tagDelimiterLeft))
                    break;
                  this.p++;
                }
              }
              throw this.error("raw ".concat(this.snapshot(this.rawBeginAt), " not closed"), begin);
            };
            Tokenizer2.prototype.readLiquidTagTokens = function(options) {
              if (options === void 0) {
                options = defaultOptions;
              }
              var tokens = [];
              while (this.p < this.N) {
                var token = this.readLiquidTagToken(options);
                token && tokens.push(token);
              }
              return tokens;
            };
            Tokenizer2.prototype.readLiquidTagToken = function(options) {
              this.skipBlank();
              if (this.end())
                return;
              var begin = this.p;
              this.readToDelimiter("\n");
              var end = this.p;
              return new LiquidTagToken(this.input, begin, end, options, this.file);
            };
            Tokenizer2.prototype.error = function(msg, pos) {
              if (pos === void 0) {
                pos = this.p;
              }
              return new TokenizationError(msg, new IdentifierToken(this.input, pos, this.N, this.file));
            };
            Tokenizer2.prototype.assert = function(pred, msg, pos) {
              if (!pred)
                throw this.error(typeof msg === "function" ? msg() : msg, pos);
            };
            Tokenizer2.prototype.snapshot = function(begin) {
              if (begin === void 0) {
                begin = this.p;
              }
              return JSON.stringify(ellipsis(this.input.slice(begin, this.N), 32));
            };
            Tokenizer2.prototype.readWord = function() {
              return this.readIdentifier();
            };
            Tokenizer2.prototype.readIdentifier = function() {
              this.skipBlank();
              var begin = this.p;
              while (!this.end() && this.peekType() & IDENTIFIER)
                ++this.p;
              return new IdentifierToken(this.input, begin, this.p, this.file);
            };
            Tokenizer2.prototype.readTagName = function() {
              this.skipBlank();
              if (this.input[this.p] === "#")
                return this.input.slice(this.p, ++this.p);
              return this.readIdentifier().getText();
            };
            Tokenizer2.prototype.readHashes = function(jekyllStyle) {
              var hashes = [];
              while (true) {
                var hash = this.readHash(jekyllStyle);
                if (!hash)
                  return hashes;
                hashes.push(hash);
              }
            };
            Tokenizer2.prototype.readHash = function(jekyllStyle) {
              this.skipBlank();
              if (this.peek() === ",")
                ++this.p;
              var begin = this.p;
              var name = this.readIdentifier();
              if (!name.size())
                return;
              var value;
              this.skipBlank();
              var sep2 = jekyllStyle ? "=" : ":";
              if (this.peek() === sep2) {
                ++this.p;
                value = this.readValue();
              }
              return new HashToken(this.input, begin, this.p, name, value, this.file);
            };
            Tokenizer2.prototype.remaining = function() {
              return this.input.slice(this.p, this.N);
            };
            Tokenizer2.prototype.advance = function(i) {
              if (i === void 0) {
                i = 1;
              }
              this.p += i;
            };
            Tokenizer2.prototype.end = function() {
              return this.p >= this.N;
            };
            Tokenizer2.prototype.readTo = function(end) {
              while (this.p < this.N) {
                ++this.p;
                if (this.rmatch(end))
                  return this.p;
              }
              return -1;
            };
            Tokenizer2.prototype.readValue = function() {
              var value = this.readQuoted() || this.readRange();
              if (value)
                return value;
              if (this.peek() === "[") {
                this.p++;
                var prop = this.readQuoted();
                if (!prop)
                  return;
                if (this.peek() !== "]")
                  return;
                this.p++;
                return new PropertyAccessToken(prop, [], this.p);
              }
              var variable = this.readIdentifier();
              if (!variable.size())
                return;
              var isNumber2 = variable.isNumber(true);
              var props = [];
              while (true) {
                if (this.peek() === "[") {
                  isNumber2 = false;
                  this.p++;
                  var prop = this.readValue() || new IdentifierToken(this.input, this.p, this.p, this.file);
                  this.readTo("]");
                  props.push(prop);
                } else if (this.peek() === "." && this.peek(1) !== ".") {
                  this.p++;
                  var prop = this.readIdentifier();
                  if (!prop.size())
                    break;
                  if (!prop.isNumber())
                    isNumber2 = false;
                  props.push(prop);
                } else
                  break;
              }
              if (!props.length && literalValues.hasOwnProperty(variable.content)) {
                return new LiteralToken(this.input, variable.begin, variable.end, this.file);
              }
              if (isNumber2)
                return new NumberToken(variable, props[0]);
              return new PropertyAccessToken(variable, props, this.p);
            };
            Tokenizer2.prototype.readRange = function() {
              this.skipBlank();
              var begin = this.p;
              if (this.peek() !== "(")
                return;
              ++this.p;
              var lhs = this.readValueOrThrow();
              this.p += 2;
              var rhs = this.readValueOrThrow();
              ++this.p;
              return new RangeToken(this.input, begin, this.p, lhs, rhs, this.file);
            };
            Tokenizer2.prototype.readValueOrThrow = function() {
              var _this = this;
              var value = this.readValue();
              this.assert(value, function() {
                return "unexpected token ".concat(_this.snapshot(), ", value expected");
              });
              return value;
            };
            Tokenizer2.prototype.readQuoted = function() {
              this.skipBlank();
              var begin = this.p;
              if (!(this.peekType() & QUOTE))
                return;
              ++this.p;
              var escaped = false;
              while (this.p < this.N) {
                ++this.p;
                if (this.input[this.p - 1] === this.input[begin] && !escaped)
                  break;
                if (escaped)
                  escaped = false;
                else if (this.input[this.p - 1] === "\\")
                  escaped = true;
              }
              return new QuotedToken(this.input, begin, this.p, this.file);
            };
            Tokenizer2.prototype.readFileNameTemplate = function(options) {
              var outputDelimiterLeft, htmlStopStrings, htmlStopStringSet;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    outputDelimiterLeft = options.outputDelimiterLeft;
                    htmlStopStrings = [",", " ", outputDelimiterLeft];
                    htmlStopStringSet = new Set(htmlStopStrings);
                    _a.label = 1;
                  case 1:
                    if (!(this.p < this.N && !htmlStopStringSet.has(this.peek())))
                      return [3, 3];
                    return [4, this.match(outputDelimiterLeft) ? this.readOutputToken(options) : this.readHTMLToken(htmlStopStrings)];
                  case 2:
                    _a.sent();
                    return [3, 1];
                  case 3:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            };
            Tokenizer2.prototype.match = function(word) {
              for (var i = 0; i < word.length; i++) {
                if (word[i] !== this.input[this.p + i])
                  return false;
              }
              return true;
            };
            Tokenizer2.prototype.rmatch = function(pattern) {
              for (var i = 0; i < pattern.length; i++) {
                if (pattern[pattern.length - 1 - i] !== this.input[this.p - 1 - i])
                  return false;
              }
              return true;
            };
            Tokenizer2.prototype.peekType = function(n) {
              if (n === void 0) {
                n = 0;
              }
              return TYPES[this.input.charCodeAt(this.p + n)];
            };
            Tokenizer2.prototype.peek = function(n) {
              if (n === void 0) {
                n = 0;
              }
              return this.p + n >= this.N ? "" : this.input[this.p + n];
            };
            Tokenizer2.prototype.skipBlank = function() {
              while (this.peekType() & BLANK)
                ++this.p;
            };
            return Tokenizer2;
          }()
        );
        var ParseStream = (
          /** @class */
          function() {
            function ParseStream2(tokens, parseToken) {
              this.handlers = {};
              this.stopRequested = false;
              this.tokens = tokens;
              this.parseToken = parseToken;
            }
            ParseStream2.prototype.on = function(name, cb) {
              this.handlers[name] = cb;
              return this;
            };
            ParseStream2.prototype.trigger = function(event, arg) {
              var h = this.handlers[event];
              return h ? (h.call(this, arg), true) : false;
            };
            ParseStream2.prototype.start = function() {
              this.trigger("start");
              var token;
              while (!this.stopRequested && (token = this.tokens.shift())) {
                if (this.trigger("token", token))
                  continue;
                if (isTagToken(token) && this.trigger("tag:".concat(token.name), token)) {
                  continue;
                }
                var template = this.parseToken(token, this.tokens);
                this.trigger("template", template);
              }
              if (!this.stopRequested)
                this.trigger("end");
              return this;
            };
            ParseStream2.prototype.stop = function() {
              this.stopRequested = true;
              return this;
            };
            return ParseStream2;
          }()
        );
        var TemplateImpl = (
          /** @class */
          function() {
            function TemplateImpl2(token) {
              this.token = token;
            }
            return TemplateImpl2;
          }()
        );
        var Tag = (
          /** @class */
          function(_super) {
            __extends(Tag2, _super);
            function Tag2(token, remainTokens, liquid) {
              var _this = _super.call(this, token) || this;
              _this.name = token.name;
              _this.liquid = liquid;
              _this.tokenizer = token.tokenizer;
              return _this;
            }
            return Tag2;
          }(TemplateImpl)
        );
        var Hash = (
          /** @class */
          function() {
            function Hash2(markup, jekyllStyle) {
              var e_1, _a;
              this.hash = {};
              var tokenizer = new Tokenizer(markup, {});
              try {
                for (var _b = __values(tokenizer.readHashes(jekyllStyle)), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var hash = _c.value;
                  this.hash[hash.name.content] = hash.value;
                }
              } catch (e_1_1) {
                e_1 = { error: e_1_1 };
              } finally {
                try {
                  if (_c && !_c.done && (_a = _b.return))
                    _a.call(_b);
                } finally {
                  if (e_1)
                    throw e_1.error;
                }
              }
            }
            Hash2.prototype.render = function(ctx) {
              var hash, _a, _b, key, _c, _d, _e, e_2_1;
              var e_2, _f;
              return __generator(this, function(_g) {
                switch (_g.label) {
                  case 0:
                    hash = {};
                    _g.label = 1;
                  case 1:
                    _g.trys.push([1, 8, 9, 10]);
                    _a = __values(Object.keys(this.hash)), _b = _a.next();
                    _g.label = 2;
                  case 2:
                    if (!!_b.done)
                      return [3, 7];
                    key = _b.value;
                    _c = hash;
                    _d = key;
                    if (!(this.hash[key] === void 0))
                      return [3, 3];
                    _e = true;
                    return [3, 5];
                  case 3:
                    return [4, evalToken(this.hash[key], ctx)];
                  case 4:
                    _e = _g.sent();
                    _g.label = 5;
                  case 5:
                    _c[_d] = _e;
                    _g.label = 6;
                  case 6:
                    _b = _a.next();
                    return [3, 2];
                  case 7:
                    return [3, 10];
                  case 8:
                    e_2_1 = _g.sent();
                    e_2 = { error: e_2_1 };
                    return [3, 10];
                  case 9:
                    try {
                      if (_b && !_b.done && (_f = _a.return))
                        _f.call(_a);
                    } finally {
                      if (e_2)
                        throw e_2.error;
                    }
                    return [
                      7
                      /*endfinally*/
                    ];
                  case 10:
                    return [2, hash];
                }
              });
            };
            return Hash2;
          }()
        );
        function createTagClass(options) {
          return (
            /** @class */
            function(_super) {
              __extends(class_1, _super);
              function class_1(token, tokens, liquid) {
                var _this = _super.call(this, token, tokens, liquid) || this;
                if (isFunction(options.parse)) {
                  options.parse.call(_this, token, tokens);
                }
                return _this;
              }
              class_1.prototype.render = function(ctx, emitter) {
                var hash;
                return __generator(this, function(_a) {
                  switch (_a.label) {
                    case 0:
                      return [4, new Hash(this.token.args).render(ctx)];
                    case 1:
                      hash = _a.sent();
                      return [4, options.render.call(this, ctx, emitter, hash)];
                    case 2:
                      return [2, _a.sent()];
                  }
                });
              };
              return class_1;
            }(Tag)
          );
        }
        function isKeyValuePair(arr) {
          return isArray(arr);
        }
        var Filter = (
          /** @class */
          function() {
            function Filter2(name, options, args, liquid) {
              this.name = name;
              this.handler = isFunction(options) ? options : isFunction(options === null || options === void 0 ? void 0 : options.handler) ? options.handler : identify;
              this.raw = !isFunction(options) && !!(options === null || options === void 0 ? void 0 : options.raw);
              this.args = args;
              this.liquid = liquid;
            }
            Filter2.prototype.render = function(value, context) {
              var argv, _a, _b, arg, _c, _d, _e, _f, _g, e_1_1;
              var e_1, _h;
              return __generator(this, function(_j) {
                switch (_j.label) {
                  case 0:
                    argv = [];
                    _j.label = 1;
                  case 1:
                    _j.trys.push([1, 8, 9, 10]);
                    _a = __values(this.args), _b = _a.next();
                    _j.label = 2;
                  case 2:
                    if (!!_b.done)
                      return [3, 7];
                    arg = _b.value;
                    if (!isKeyValuePair(arg))
                      return [3, 4];
                    _d = (_c = argv).push;
                    _e = [arg[0]];
                    return [4, evalToken(arg[1], context)];
                  case 3:
                    _d.apply(_c, [_e.concat([_j.sent()])]);
                    return [3, 6];
                  case 4:
                    _g = (_f = argv).push;
                    return [4, evalToken(arg, context)];
                  case 5:
                    _g.apply(_f, [_j.sent()]);
                    _j.label = 6;
                  case 6:
                    _b = _a.next();
                    return [3, 2];
                  case 7:
                    return [3, 10];
                  case 8:
                    e_1_1 = _j.sent();
                    e_1 = { error: e_1_1 };
                    return [3, 10];
                  case 9:
                    try {
                      if (_b && !_b.done && (_h = _a.return))
                        _h.call(_a);
                    } finally {
                      if (e_1)
                        throw e_1.error;
                    }
                    return [
                      7
                      /*endfinally*/
                    ];
                  case 10:
                    return [2, this.handler.apply({ context, liquid: this.liquid }, __spreadArray([value], __read(argv), false))];
                }
              });
            };
            return Filter2;
          }()
        );
        var Value = (
          /** @class */
          function() {
            function Value2(input, liquid) {
              var _this = this;
              this.filters = [];
              var token = typeof input === "string" ? new Tokenizer(input, liquid.options.operators).readFilteredValue() : input;
              this.initial = token.initial;
              this.filters = token.filters.map(function(_a) {
                var name = _a.name, args = _a.args;
                return new Filter(name, _this.getFilter(liquid, name), args, liquid);
              });
            }
            Value2.prototype.value = function(ctx, lenient) {
              var val, _a, _b, filter, e_1_1;
              var e_1, _c;
              return __generator(this, function(_d) {
                switch (_d.label) {
                  case 0:
                    lenient = lenient || ctx.opts.lenientIf && this.filters.length > 0 && this.filters[0].name === "default";
                    return [4, this.initial.evaluate(ctx, lenient)];
                  case 1:
                    val = _d.sent();
                    _d.label = 2;
                  case 2:
                    _d.trys.push([2, 7, 8, 9]);
                    _a = __values(this.filters), _b = _a.next();
                    _d.label = 3;
                  case 3:
                    if (!!_b.done)
                      return [3, 6];
                    filter = _b.value;
                    return [4, filter.render(val, ctx)];
                  case 4:
                    val = _d.sent();
                    _d.label = 5;
                  case 5:
                    _b = _a.next();
                    return [3, 3];
                  case 6:
                    return [3, 9];
                  case 7:
                    e_1_1 = _d.sent();
                    e_1 = { error: e_1_1 };
                    return [3, 9];
                  case 8:
                    try {
                      if (_b && !_b.done && (_c = _a.return))
                        _c.call(_a);
                    } finally {
                      if (e_1)
                        throw e_1.error;
                    }
                    return [
                      7
                      /*endfinally*/
                    ];
                  case 9:
                    return [2, val];
                }
              });
            };
            Value2.prototype.getFilter = function(liquid, name) {
              var impl = liquid.filters[name];
              assert(impl || !liquid.options.strictFilters, function() {
                return "undefined filter: ".concat(name);
              });
              return impl;
            };
            return Value2;
          }()
        );
        var Output = (
          /** @class */
          function(_super) {
            __extends(Output2, _super);
            function Output2(token, liquid) {
              var _this = this;
              var _a;
              _this = _super.call(this, token) || this;
              var tokenizer = new Tokenizer(token.input, liquid.options.operators, token.file, token.contentRange);
              _this.value = new Value(tokenizer.readFilteredValue(), liquid);
              var filters2 = _this.value.filters;
              var outputEscape = liquid.options.outputEscape;
              if (!((_a = filters2[filters2.length - 1]) === null || _a === void 0 ? void 0 : _a.raw) && outputEscape) {
                filters2.push(new Filter(toString.call(outputEscape), outputEscape, [], liquid));
              }
              return _this;
            }
            Output2.prototype.render = function(ctx, emitter) {
              var val;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.value.value(ctx, false)];
                  case 1:
                    val = _a.sent();
                    emitter.write(val);
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            };
            return Output2;
          }(TemplateImpl)
        );
        var HTML = (
          /** @class */
          function(_super) {
            __extends(HTML2, _super);
            function HTML2(token) {
              var _this = _super.call(this, token) || this;
              _this.str = token.getContent();
              return _this;
            }
            HTML2.prototype.render = function(ctx, emitter) {
              return __generator(this, function(_a) {
                emitter.write(this.str);
                return [
                  2
                  /*return*/
                ];
              });
            };
            return HTML2;
          }(TemplateImpl)
        );
        var LookupType;
        (function(LookupType2) {
          LookupType2["Partials"] = "partials";
          LookupType2["Layouts"] = "layouts";
          LookupType2["Root"] = "root";
        })(LookupType || (LookupType = {}));
        var Loader = (
          /** @class */
          function() {
            function Loader2(options) {
              this.options = options;
              if (options.relativeReference) {
                var sep2 = options.fs.sep;
                assert(sep2, "`fs.sep` is required for relative reference");
                var rRelativePath_1 = new RegExp(["." + sep2, ".." + sep2, "./", "../"].map(function(prefix) {
                  return escapeRegex(prefix);
                }).join("|"));
                this.shouldLoadRelative = function(referencedFile) {
                  return rRelativePath_1.test(referencedFile);
                };
              } else {
                this.shouldLoadRelative = function(referencedFile) {
                  return false;
                };
              }
              this.contains = this.options.fs.contains || function() {
                return true;
              };
            }
            Loader2.prototype.lookup = function(file, type, sync, currentFile) {
              var fs2, dirs, _a, _b, filepath, _c, e_1_1;
              var e_1, _d;
              return __generator(this, function(_e) {
                switch (_e.label) {
                  case 0:
                    fs2 = this.options.fs;
                    dirs = this.options[type];
                    _e.label = 1;
                  case 1:
                    _e.trys.push([1, 8, 9, 10]);
                    _a = __values(this.candidates(file, dirs, currentFile, type !== LookupType.Root)), _b = _a.next();
                    _e.label = 2;
                  case 2:
                    if (!!_b.done)
                      return [3, 7];
                    filepath = _b.value;
                    if (!sync)
                      return [3, 3];
                    _c = fs2.existsSync(filepath);
                    return [3, 5];
                  case 3:
                    return [4, fs2.exists(filepath)];
                  case 4:
                    _c = _e.sent();
                    _e.label = 5;
                  case 5:
                    if (_c)
                      return [2, filepath];
                    _e.label = 6;
                  case 6:
                    _b = _a.next();
                    return [3, 2];
                  case 7:
                    return [3, 10];
                  case 8:
                    e_1_1 = _e.sent();
                    e_1 = { error: e_1_1 };
                    return [3, 10];
                  case 9:
                    try {
                      if (_b && !_b.done && (_d = _a.return))
                        _d.call(_a);
                    } finally {
                      if (e_1)
                        throw e_1.error;
                    }
                    return [
                      7
                      /*endfinally*/
                    ];
                  case 10:
                    throw this.lookupError(file, dirs);
                }
              });
            };
            Loader2.prototype.candidates = function(file, dirs, currentFile, enforceRoot) {
              var _a, fs2, extname, referenced, dirs_1, dirs_1_1, dir, e_2_1, dirs_2, dirs_2_1, dir, referenced, e_3_1, filepath;
              var e_2, _b, e_3, _c;
              return __generator(this, function(_d) {
                switch (_d.label) {
                  case 0:
                    _a = this.options, fs2 = _a.fs, extname = _a.extname;
                    if (!(this.shouldLoadRelative(file) && currentFile))
                      return [3, 8];
                    referenced = fs2.resolve(this.dirname(currentFile), file, extname);
                    _d.label = 1;
                  case 1:
                    _d.trys.push([1, 6, 7, 8]);
                    dirs_1 = __values(dirs), dirs_1_1 = dirs_1.next();
                    _d.label = 2;
                  case 2:
                    if (!!dirs_1_1.done)
                      return [3, 5];
                    dir = dirs_1_1.value;
                    if (!(!enforceRoot || this.contains(dir, referenced)))
                      return [3, 4];
                    return [4, referenced];
                  case 3:
                    _d.sent();
                    return [3, 5];
                  case 4:
                    dirs_1_1 = dirs_1.next();
                    return [3, 2];
                  case 5:
                    return [3, 8];
                  case 6:
                    e_2_1 = _d.sent();
                    e_2 = { error: e_2_1 };
                    return [3, 8];
                  case 7:
                    try {
                      if (dirs_1_1 && !dirs_1_1.done && (_b = dirs_1.return))
                        _b.call(dirs_1);
                    } finally {
                      if (e_2)
                        throw e_2.error;
                    }
                    return [
                      7
                      /*endfinally*/
                    ];
                  case 8:
                    _d.trys.push([8, 13, 14, 15]);
                    dirs_2 = __values(dirs), dirs_2_1 = dirs_2.next();
                    _d.label = 9;
                  case 9:
                    if (!!dirs_2_1.done)
                      return [3, 12];
                    dir = dirs_2_1.value;
                    referenced = fs2.resolve(dir, file, extname);
                    if (!(!enforceRoot || this.contains(dir, referenced)))
                      return [3, 11];
                    return [4, referenced];
                  case 10:
                    _d.sent();
                    _d.label = 11;
                  case 11:
                    dirs_2_1 = dirs_2.next();
                    return [3, 9];
                  case 12:
                    return [3, 15];
                  case 13:
                    e_3_1 = _d.sent();
                    e_3 = { error: e_3_1 };
                    return [3, 15];
                  case 14:
                    try {
                      if (dirs_2_1 && !dirs_2_1.done && (_c = dirs_2.return))
                        _c.call(dirs_2);
                    } finally {
                      if (e_3)
                        throw e_3.error;
                    }
                    return [
                      7
                      /*endfinally*/
                    ];
                  case 15:
                    if (!(fs2.fallback !== void 0))
                      return [3, 17];
                    filepath = fs2.fallback(file);
                    if (!(filepath !== void 0))
                      return [3, 17];
                    return [4, filepath];
                  case 16:
                    _d.sent();
                    _d.label = 17;
                  case 17:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            };
            Loader2.prototype.dirname = function(path) {
              var fs2 = this.options.fs;
              assert(fs2.dirname, "`fs.dirname` is required for relative reference");
              return fs2.dirname(path);
            };
            Loader2.prototype.lookupError = function(file, roots) {
              var err = new Error("ENOENT");
              err.message = 'ENOENT: Failed to lookup "'.concat(file, '" in "').concat(roots, '"');
              err.code = "ENOENT";
              return err;
            };
            return Loader2;
          }()
        );
        var Parser = (
          /** @class */
          function() {
            function Parser2(liquid) {
              this.liquid = liquid;
              this.cache = this.liquid.options.cache;
              this.fs = this.liquid.options.fs;
              this.parseFile = this.cache ? this._parseFileCached : this._parseFile;
              this.loader = new Loader(this.liquid.options);
            }
            Parser2.prototype.parse = function(html, filepath) {
              var tokenizer = new Tokenizer(html, this.liquid.options.operators, filepath);
              var tokens = tokenizer.readTopLevelTokens(this.liquid.options);
              return this.parseTokens(tokens);
            };
            Parser2.prototype.parseTokens = function(tokens) {
              var token;
              var templates = [];
              while (token = tokens.shift()) {
                templates.push(this.parseToken(token, tokens));
              }
              return templates;
            };
            Parser2.prototype.parseToken = function(token, remainTokens) {
              try {
                if (isTagToken(token)) {
                  var TagClass = this.liquid.tags[token.name];
                  assert(TagClass, 'tag "'.concat(token.name, '" not found'));
                  return new TagClass(token, remainTokens, this.liquid);
                }
                if (isOutputToken(token)) {
                  return new Output(token, this.liquid);
                }
                return new HTML(token);
              } catch (e) {
                if (e instanceof LiquidError)
                  throw e;
                throw new ParseError(e, token);
              }
            };
            Parser2.prototype.parseStream = function(tokens) {
              var _this = this;
              return new ParseStream(tokens, function(token, tokens2) {
                return _this.parseToken(token, tokens2);
              });
            };
            Parser2.prototype._parseFileCached = function(file, sync, type, currentFile) {
              var cache, key, tpls, task, taskOrTpl, _a, err_1;
              if (type === void 0) {
                type = LookupType.Root;
              }
              return __generator(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    cache = this.cache;
                    key = this.loader.shouldLoadRelative(file) ? currentFile + "," + file : type + ":" + file;
                    return [4, cache.read(key)];
                  case 1:
                    tpls = _b.sent();
                    if (tpls)
                      return [2, tpls];
                    task = this._parseFile(file, sync, type, currentFile);
                    if (!sync)
                      return [3, 3];
                    return [4, task];
                  case 2:
                    _a = _b.sent();
                    return [3, 4];
                  case 3:
                    _a = toPromise(task);
                    _b.label = 4;
                  case 4:
                    taskOrTpl = _a;
                    cache.write(key, taskOrTpl);
                    _b.label = 5;
                  case 5:
                    _b.trys.push([5, 7, , 8]);
                    return [4, taskOrTpl];
                  case 6:
                    return [2, _b.sent()];
                  case 7:
                    err_1 = _b.sent();
                    cache.remove(key);
                    throw err_1;
                  case 8:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            };
            Parser2.prototype._parseFile = function(file, sync, type, currentFile) {
              var filepath, _a, _b, _c;
              if (type === void 0) {
                type = LookupType.Root;
              }
              return __generator(this, function(_d) {
                switch (_d.label) {
                  case 0:
                    return [4, this.loader.lookup(file, type, sync, currentFile)];
                  case 1:
                    filepath = _d.sent();
                    _b = (_a = this.liquid).parse;
                    if (!sync)
                      return [3, 2];
                    _c = this.fs.readFileSync(filepath);
                    return [3, 4];
                  case 2:
                    return [4, this.fs.readFile(filepath)];
                  case 3:
                    _c = _d.sent();
                    _d.label = 4;
                  case 4:
                    return [2, _b.apply(_a, [_c, filepath])];
                }
              });
            };
            return Parser2;
          }()
        );
        var rHex = /[\da-fA-F]/;
        var rOct = /[0-7]/;
        var escapeChar = {
          b: "\b",
          f: "\f",
          n: "\n",
          r: "\r",
          t: "	",
          v: "\v"
        };
        function hexVal(c) {
          var code = c.charCodeAt(0);
          if (code >= 97)
            return code - 87;
          if (code >= 65)
            return code - 55;
          return code - 48;
        }
        function parseStringLiteral(str) {
          var ret = "";
          for (var i = 1; i < str.length - 1; i++) {
            if (str[i] !== "\\") {
              ret += str[i];
              continue;
            }
            if (escapeChar[str[i + 1]] !== void 0) {
              ret += escapeChar[str[++i]];
            } else if (str[i + 1] === "u") {
              var val = 0;
              var j = i + 2;
              while (j <= i + 5 && rHex.test(str[j])) {
                val = val * 16 + hexVal(str[j++]);
              }
              i = j - 1;
              ret += String.fromCharCode(val);
            } else if (!rOct.test(str[i + 1])) {
              ret += str[++i];
            } else {
              var j = i + 1;
              var val = 0;
              while (j <= i + 3 && rOct.test(str[j])) {
                val = val * 8 + hexVal(str[j++]);
              }
              i = j - 1;
              ret += String.fromCharCode(val);
            }
          }
          return ret;
        }
        (function(TokenKind) {
          TokenKind[TokenKind["Number"] = 1] = "Number";
          TokenKind[TokenKind["Literal"] = 2] = "Literal";
          TokenKind[TokenKind["Tag"] = 4] = "Tag";
          TokenKind[TokenKind["Output"] = 8] = "Output";
          TokenKind[TokenKind["HTML"] = 16] = "HTML";
          TokenKind[TokenKind["Filter"] = 32] = "Filter";
          TokenKind[TokenKind["Hash"] = 64] = "Hash";
          TokenKind[TokenKind["PropertyAccess"] = 128] = "PropertyAccess";
          TokenKind[TokenKind["Word"] = 256] = "Word";
          TokenKind[TokenKind["Range"] = 512] = "Range";
          TokenKind[TokenKind["Quoted"] = 1024] = "Quoted";
          TokenKind[TokenKind["Operator"] = 2048] = "Operator";
          TokenKind[TokenKind["FilteredValue"] = 4096] = "FilteredValue";
          TokenKind[TokenKind["Delimited"] = 12] = "Delimited";
        })(exports2.TokenKind || (exports2.TokenKind = {}));
        function isDelimitedToken(val) {
          return !!(getKind(val) & exports2.TokenKind.Delimited);
        }
        function isOperatorToken(val) {
          return getKind(val) === exports2.TokenKind.Operator;
        }
        function isHTMLToken(val) {
          return getKind(val) === exports2.TokenKind.HTML;
        }
        function isOutputToken(val) {
          return getKind(val) === exports2.TokenKind.Output;
        }
        function isTagToken(val) {
          return getKind(val) === exports2.TokenKind.Tag;
        }
        function isQuotedToken(val) {
          return getKind(val) === exports2.TokenKind.Quoted;
        }
        function isLiteralToken(val) {
          return getKind(val) === exports2.TokenKind.Literal;
        }
        function isNumberToken(val) {
          return getKind(val) === exports2.TokenKind.Number;
        }
        function isPropertyAccessToken(val) {
          return getKind(val) === exports2.TokenKind.PropertyAccess;
        }
        function isWordToken(val) {
          return getKind(val) === exports2.TokenKind.Word;
        }
        function isRangeToken(val) {
          return getKind(val) === exports2.TokenKind.Range;
        }
        function getKind(val) {
          return val ? val.kind : -1;
        }
        var typeGuards = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          isDelimitedToken,
          isOperatorToken,
          isHTMLToken,
          isOutputToken,
          isTagToken,
          isQuotedToken,
          isLiteralToken,
          isNumberToken,
          isPropertyAccessToken,
          isWordToken,
          isRangeToken
        });
        var Context = (
          /** @class */
          function() {
            function Context2(env, opts, renderOptions) {
              if (env === void 0) {
                env = {};
              }
              if (opts === void 0) {
                opts = defaultOptions;
              }
              if (renderOptions === void 0) {
                renderOptions = {};
              }
              var _a, _b, _c;
              this.scopes = [{}];
              this.registers = {};
              this.sync = !!renderOptions.sync;
              this.opts = opts;
              this.globals = (_a = renderOptions.globals) !== null && _a !== void 0 ? _a : opts.globals;
              this.environments = env;
              this.strictVariables = (_b = renderOptions.strictVariables) !== null && _b !== void 0 ? _b : this.opts.strictVariables;
              this.ownPropertyOnly = (_c = renderOptions.ownPropertyOnly) !== null && _c !== void 0 ? _c : opts.ownPropertyOnly;
            }
            Context2.prototype.getRegister = function(key) {
              return this.registers[key] = this.registers[key] || {};
            };
            Context2.prototype.setRegister = function(key, value) {
              return this.registers[key] = value;
            };
            Context2.prototype.saveRegister = function() {
              var _this = this;
              var keys = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                keys[_i] = arguments[_i];
              }
              return keys.map(function(key) {
                return [key, _this.getRegister(key)];
              });
            };
            Context2.prototype.restoreRegister = function(keyValues) {
              var _this = this;
              return keyValues.forEach(function(_a) {
                var _b = __read(_a, 2), key = _b[0], value = _b[1];
                return _this.setRegister(key, value);
              });
            };
            Context2.prototype.getAll = function() {
              return __spreadArray([this.globals, this.environments], __read(this.scopes), false).reduce(function(ctx, val) {
                return __assign(ctx, val);
              }, {});
            };
            Context2.prototype.get = function(paths) {
              return this.getSync(paths);
            };
            Context2.prototype.getSync = function(paths) {
              return toValueSync(this._get(paths));
            };
            Context2.prototype._get = function(paths) {
              var scope;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    scope = this.findScope(paths[0]);
                    return [4, this._getFromScope(scope, paths)];
                  case 1:
                    return [2, _a.sent()];
                }
              });
            };
            Context2.prototype.getFromScope = function(scope, paths) {
              return toValueSync(this._getFromScope(scope, paths));
            };
            Context2.prototype._getFromScope = function(scope, paths) {
              var i;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    if (isString(paths))
                      paths = paths.split(".");
                    i = 0;
                    _a.label = 1;
                  case 1:
                    if (!(i < paths.length))
                      return [3, 4];
                    return [4, readProperty(scope, paths[i], this.ownPropertyOnly)];
                  case 2:
                    scope = _a.sent();
                    if (isNil(scope) && this.strictVariables) {
                      throw new InternalUndefinedVariableError(paths.slice(0, i + 1).join("."));
                    }
                    _a.label = 3;
                  case 3:
                    i++;
                    return [3, 1];
                  case 4:
                    return [2, scope];
                }
              });
            };
            Context2.prototype.push = function(ctx) {
              return this.scopes.push(ctx);
            };
            Context2.prototype.pop = function() {
              return this.scopes.pop();
            };
            Context2.prototype.bottom = function() {
              return this.scopes[0];
            };
            Context2.prototype.findScope = function(key) {
              for (var i = this.scopes.length - 1; i >= 0; i--) {
                var candidate = this.scopes[i];
                if (key in candidate)
                  return candidate;
              }
              if (key in this.environments)
                return this.environments;
              return this.globals;
            };
            return Context2;
          }()
        );
        function readProperty(obj, key, ownPropertyOnly) {
          obj = toLiquid(obj);
          if (isNil(obj))
            return obj;
          if (isArray(obj) && key < 0)
            return obj[obj.length + +key];
          var value = readJSProperty(obj, key, ownPropertyOnly);
          if (value === void 0 && obj instanceof Drop)
            return obj.liquidMethodMissing(key);
          if (isFunction(value))
            return value.call(obj);
          if (key === "size")
            return readSize(obj);
          else if (key === "first")
            return readFirst(obj);
          else if (key === "last")
            return readLast(obj);
          return value;
        }
        function readJSProperty(obj, key, ownPropertyOnly) {
          if (ownPropertyOnly && !Object.hasOwnProperty.call(obj, key) && !(obj instanceof Drop))
            return void 0;
          return obj[key];
        }
        function readFirst(obj) {
          if (isArray(obj))
            return obj[0];
          return obj["first"];
        }
        function readLast(obj) {
          if (isArray(obj))
            return obj[obj.length - 1];
          return obj["last"];
        }
        function readSize(obj) {
          if (obj.hasOwnProperty("size") || obj["size"] !== void 0)
            return obj["size"];
          if (isArray(obj) || isString(obj))
            return obj.length;
          if (typeof obj === "object")
            return Object.keys(obj).length;
        }
        var BlockMode;
        (function(BlockMode2) {
          BlockMode2[BlockMode2["OUTPUT"] = 0] = "OUTPUT";
          BlockMode2[BlockMode2["STORE"] = 1] = "STORE";
        })(BlockMode || (BlockMode = {}));
        var abs = argumentsToValue(Math.abs);
        var at_least = argumentsToValue(Math.max);
        var at_most = argumentsToValue(Math.min);
        var ceil = argumentsToValue(Math.ceil);
        var divided_by = argumentsToValue(function(dividend, divisor, integerArithmetic) {
          if (integerArithmetic === void 0) {
            integerArithmetic = false;
          }
          return integerArithmetic ? Math.floor(dividend / divisor) : dividend / divisor;
        });
        var floor = argumentsToValue(Math.floor);
        var minus = argumentsToValue(function(v, arg) {
          return v - arg;
        });
        var modulo = argumentsToValue(function(v, arg) {
          return v % arg;
        });
        var times = argumentsToValue(function(v, arg) {
          return v * arg;
        });
        function round(v, arg) {
          if (arg === void 0) {
            arg = 0;
          }
          v = toValue(v);
          arg = toValue(arg);
          var amp = Math.pow(10, arg);
          return Math.round(v * amp) / amp;
        }
        function plus(v, arg) {
          v = toValue(v);
          arg = toValue(arg);
          return Number(v) + Number(arg);
        }
        var mathFilters = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          abs,
          at_least,
          at_most,
          ceil,
          divided_by,
          floor,
          minus,
          modulo,
          times,
          round,
          plus
        });
        var url_decode = function(x) {
          return stringify(x).split("+").map(decodeURIComponent).join(" ");
        };
        var url_encode = function(x) {
          return stringify(x).split(" ").map(encodeURIComponent).join("+");
        };
        var urlFilters = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          url_decode,
          url_encode
        });
        var join = argumentsToValue(function(v, arg) {
          return toArray(v).join(arg === void 0 ? " " : arg);
        });
        var last$1 = argumentsToValue(function(v) {
          return isArray(v) ? last(v) : "";
        });
        var first = argumentsToValue(function(v) {
          return isArray(v) ? v[0] : "";
        });
        var reverse = argumentsToValue(function(v) {
          return __spreadArray([], __read(toArray(v)), false).reverse();
        });
        function sort(arr, property) {
          var values, _a, _b, item, _c, _d, _e, _f, e_1_1;
          var e_1, _g;
          return __generator(this, function(_h) {
            switch (_h.label) {
              case 0:
                values = [];
                _h.label = 1;
              case 1:
                _h.trys.push([1, 8, 9, 10]);
                _a = __values(toArray(toValue(arr))), _b = _a.next();
                _h.label = 2;
              case 2:
                if (!!_b.done)
                  return [3, 7];
                item = _b.value;
                _d = (_c = values).push;
                _e = [item];
                if (!property)
                  return [3, 4];
                return [4, this.context._getFromScope(item, stringify(property).split("."))];
              case 3:
                _f = _h.sent();
                return [3, 5];
              case 4:
                _f = item;
                _h.label = 5;
              case 5:
                _d.apply(_c, [_e.concat([
                  _f
                ])]);
                _h.label = 6;
              case 6:
                _b = _a.next();
                return [3, 2];
              case 7:
                return [3, 10];
              case 8:
                e_1_1 = _h.sent();
                e_1 = { error: e_1_1 };
                return [3, 10];
              case 9:
                try {
                  if (_b && !_b.done && (_g = _a.return))
                    _g.call(_a);
                } finally {
                  if (e_1)
                    throw e_1.error;
                }
                return [
                  7
                  /*endfinally*/
                ];
              case 10:
                return [2, values.sort(function(lhs, rhs) {
                  var lvalue = lhs[1];
                  var rvalue = rhs[1];
                  return lvalue < rvalue ? -1 : lvalue > rvalue ? 1 : 0;
                }).map(function(tuple) {
                  return tuple[0];
                })];
            }
          });
        }
        function sort_natural(input, property) {
          input = toValue(input);
          var propertyString = stringify(property);
          var compare = property === void 0 ? caseInsensitiveCompare : function(lhs, rhs) {
            return caseInsensitiveCompare(lhs[propertyString], rhs[propertyString]);
          };
          return __spreadArray([], __read(toArray(input)), false).sort(compare);
        }
        var size = function(v) {
          return v && v.length || 0;
        };
        function map(arr, property) {
          var results, _a, _b, item, _c, _d, e_2_1;
          var e_2, _e;
          return __generator(this, function(_f) {
            switch (_f.label) {
              case 0:
                results = [];
                _f.label = 1;
              case 1:
                _f.trys.push([1, 6, 7, 8]);
                _a = __values(toArray(toValue(arr))), _b = _a.next();
                _f.label = 2;
              case 2:
                if (!!_b.done)
                  return [3, 5];
                item = _b.value;
                _d = (_c = results).push;
                return [4, this.context._getFromScope(item, stringify(property).split("."))];
              case 3:
                _d.apply(_c, [_f.sent()]);
                _f.label = 4;
              case 4:
                _b = _a.next();
                return [3, 2];
              case 5:
                return [3, 8];
              case 6:
                e_2_1 = _f.sent();
                e_2 = { error: e_2_1 };
                return [3, 8];
              case 7:
                try {
                  if (_b && !_b.done && (_e = _a.return))
                    _e.call(_a);
                } finally {
                  if (e_2)
                    throw e_2.error;
                }
                return [
                  7
                  /*endfinally*/
                ];
              case 8:
                return [2, results];
            }
          });
        }
        function compact(arr) {
          arr = toValue(arr);
          return toArray(arr).filter(function(x) {
            return !isNil(toValue(x));
          });
        }
        function concat(v, arg) {
          if (arg === void 0) {
            arg = [];
          }
          v = toValue(v);
          arg = toArray(arg).map(function(v2) {
            return toValue(v2);
          });
          return toArray(v).concat(arg);
        }
        function push(v, arg) {
          return concat(v, [arg]);
        }
        function slice(v, begin, length) {
          if (length === void 0) {
            length = 1;
          }
          v = toValue(v);
          if (isNil(v))
            return [];
          if (!isArray(v))
            v = stringify(v);
          begin = begin < 0 ? v.length + begin : begin;
          return v.slice(begin, begin + length);
        }
        function where(arr, property, expected) {
          var values, arr_1, arr_1_1, item, _a, _b, e_3_1;
          var e_3, _c;
          var _this = this;
          return __generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                values = [];
                arr = toArray(toValue(arr));
                _d.label = 1;
              case 1:
                _d.trys.push([1, 6, 7, 8]);
                arr_1 = __values(arr), arr_1_1 = arr_1.next();
                _d.label = 2;
              case 2:
                if (!!arr_1_1.done)
                  return [3, 5];
                item = arr_1_1.value;
                _b = (_a = values).push;
                return [4, this.context._getFromScope(item, stringify(property).split("."))];
              case 3:
                _b.apply(_a, [_d.sent()]);
                _d.label = 4;
              case 4:
                arr_1_1 = arr_1.next();
                return [3, 2];
              case 5:
                return [3, 8];
              case 6:
                e_3_1 = _d.sent();
                e_3 = { error: e_3_1 };
                return [3, 8];
              case 7:
                try {
                  if (arr_1_1 && !arr_1_1.done && (_c = arr_1.return))
                    _c.call(arr_1);
                } finally {
                  if (e_3)
                    throw e_3.error;
                }
                return [
                  7
                  /*endfinally*/
                ];
              case 8:
                return [2, arr.filter(function(_, i) {
                  if (expected === void 0)
                    return isTruthy(values[i], _this.context);
                  if (isComparable(expected))
                    return expected.equals(values[i]);
                  return values[i] === expected;
                })];
            }
          });
        }
        function uniq(arr) {
          arr = toValue(arr);
          var u = {};
          return (arr || []).filter(function(val) {
            if (hasOwnProperty.call(u, String(val)))
              return false;
            u[String(val)] = true;
            return true;
          });
        }
        function sample(v, count) {
          if (count === void 0) {
            count = 1;
          }
          v = toValue(v);
          if (isNil(v))
            return [];
          if (!isArray(v))
            v = stringify(v);
          var shuffled = __spreadArray([], __read(v), false).sort(function() {
            return Math.random() - 0.5;
          });
          if (count === 1)
            return shuffled[0];
          return shuffled.slice(0, count);
        }
        var arrayFilters = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          join,
          last: last$1,
          first,
          reverse,
          sort,
          sort_natural,
          size,
          map,
          compact,
          concat,
          push,
          slice,
          where,
          uniq,
          sample
        });
        function date(v, format2, timezoneOffset) {
          var opts = this.context.opts;
          var date2;
          v = toValue(v);
          format2 = toValue(format2);
          if (isNil(format2))
            format2 = opts.dateFormat;
          else
            format2 = stringify(format2);
          if (v === "now" || v === "today") {
            date2 = /* @__PURE__ */ new Date();
          } else if (isNumber(v)) {
            date2 = new Date(v * 1e3);
          } else if (isString(v)) {
            if (/^\d+$/.test(v)) {
              date2 = new Date(+v * 1e3);
            } else if (opts.preserveTimezones) {
              date2 = TimezoneDate.createDateFixedToTimezone(v);
            } else {
              date2 = new Date(v);
            }
          } else {
            date2 = v;
          }
          if (!isValidDate(date2))
            return v;
          if (timezoneOffset !== void 0) {
            date2 = new TimezoneDate(date2, parseTimezoneOffset(date2, timezoneOffset));
          } else if (!(date2 instanceof TimezoneDate) && opts.timezoneOffset !== void 0) {
            date2 = new TimezoneDate(date2, parseTimezoneOffset(date2, opts.timezoneOffset));
          }
          return strftime(date2, format2);
        }
        function isValidDate(date2) {
          return (date2 instanceof Date || date2 instanceof TimezoneDate) && !isNaN(date2.getTime());
        }
        function parseTimezoneOffset(date2, timeZone) {
          if (isNumber(timeZone))
            return timeZone;
          var utcDate = new Date(date2.toLocaleString("en-US", { timeZone: "UTC" }));
          var tzDate = new Date(date2.toLocaleString("en-US", { timeZone }));
          return (utcDate.getTime() - tzDate.getTime()) / 6e4;
        }
        var dateFilters = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          date
        });
        function append(v, arg) {
          assert(arguments.length === 2, "append expect 2 arguments");
          return stringify(v) + stringify(arg);
        }
        function prepend(v, arg) {
          assert(arguments.length === 2, "prepend expect 2 arguments");
          return stringify(arg) + stringify(v);
        }
        function lstrip(v, chars) {
          if (chars) {
            chars = escapeRegExp(stringify(chars));
            return stringify(v).replace(new RegExp("^[".concat(chars, "]+"), "g"), "");
          }
          return stringify(v).replace(/^\s+/, "");
        }
        function downcase(v) {
          return stringify(v).toLowerCase();
        }
        function upcase(str) {
          return stringify(str).toUpperCase();
        }
        function remove(v, arg) {
          return stringify(v).split(String(arg)).join("");
        }
        function remove_first(v, l) {
          return stringify(v).replace(String(l), "");
        }
        function remove_last(v, l) {
          var str = stringify(v);
          var pattern = String(l);
          var index = str.lastIndexOf(pattern);
          if (index === -1)
            return str;
          return str.substring(0, index) + str.substring(index + pattern.length + 1);
        }
        function rstrip(str, chars) {
          if (chars) {
            chars = escapeRegExp(stringify(chars));
            return stringify(str).replace(new RegExp("[".concat(chars, "]+$"), "g"), "");
          }
          return stringify(str).replace(/\s+$/, "");
        }
        function split(v, arg) {
          var arr = stringify(v).split(String(arg));
          while (arr.length && arr[arr.length - 1] === "")
            arr.pop();
          return arr;
        }
        function strip(v, chars) {
          if (chars) {
            chars = escapeRegExp(stringify(chars));
            return stringify(v).replace(new RegExp("^[".concat(chars, "]+"), "g"), "").replace(new RegExp("[".concat(chars, "]+$"), "g"), "");
          }
          return stringify(v).trim();
        }
        function strip_newlines(v) {
          return stringify(v).replace(/\n/g, "");
        }
        function capitalize(str) {
          str = stringify(str);
          return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
        }
        function replace(v, pattern, replacement) {
          return stringify(v).split(String(pattern)).join(replacement);
        }
        function replace_first(v, arg1, arg2) {
          return stringify(v).replace(String(arg1), arg2);
        }
        function replace_last(v, arg1, arg2) {
          var str = stringify(v);
          var pattern = String(arg1);
          var index = str.lastIndexOf(pattern);
          if (index === -1)
            return str;
          var replacement = String(arg2);
          return str.substring(0, index) + replacement + str.substring(index + pattern.length);
        }
        function truncate(v, l, o) {
          if (l === void 0) {
            l = 50;
          }
          if (o === void 0) {
            o = "...";
          }
          v = stringify(v);
          if (v.length <= l)
            return v;
          return v.substring(0, l - o.length) + o;
        }
        function truncatewords(v, words, o) {
          if (words === void 0) {
            words = 15;
          }
          if (o === void 0) {
            o = "...";
          }
          var arr = stringify(v).split(/\s+/);
          if (words <= 0)
            words = 1;
          var ret = arr.slice(0, words).join(" ");
          if (arr.length >= words)
            ret += o;
          return ret;
        }
        var stringFilters = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          append,
          prepend,
          lstrip,
          downcase,
          upcase,
          remove,
          remove_first,
          remove_last,
          rstrip,
          split,
          strip,
          strip_newlines,
          capitalize,
          replace,
          replace_first,
          replace_last,
          truncate,
          truncatewords
        });
        var filters = __assign(__assign(__assign(__assign(__assign(__assign(__assign({}, htmlFilters), mathFilters), urlFilters), arrayFilters), dateFilters), stringFilters), { json, raw, default: Default });
        var default_1 = (
          /** @class */
          function(_super) {
            __extends(default_12, _super);
            function default_12(token, remainTokens, liquid) {
              var _this = _super.call(this, token, remainTokens, liquid) || this;
              _this.key = _this.tokenizer.readIdentifier().content;
              _this.tokenizer.assert(_this.key, "expected variable name");
              _this.tokenizer.skipBlank();
              _this.tokenizer.assert(_this.tokenizer.peek() === "=", 'expected "="');
              _this.tokenizer.advance();
              _this.value = new Value(_this.tokenizer.readFilteredValue(), _this.liquid);
              return _this;
            }
            default_12.prototype.render = function(ctx) {
              var _a, _b;
              return __generator(this, function(_c) {
                switch (_c.label) {
                  case 0:
                    _a = ctx.bottom();
                    _b = this.key;
                    return [4, this.value.value(ctx, this.liquid.options.lenientIf)];
                  case 1:
                    _a[_b] = _c.sent();
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            };
            return default_12;
          }(Tag)
        );
        var MODIFIERS = ["offset", "limit", "reversed"];
        var default_1$1 = (
          /** @class */
          function(_super) {
            __extends(default_12, _super);
            function default_12(token, remainTokens, liquid) {
              var _this = _super.call(this, token, remainTokens, liquid) || this;
              var variable = _this.tokenizer.readIdentifier();
              var inStr = _this.tokenizer.readIdentifier();
              var collection = _this.tokenizer.readValue();
              if (!variable.size() || inStr.content !== "in" || !collection) {
                throw new Error("illegal tag: ".concat(token.getText()));
              }
              _this.variable = variable.content;
              _this.collection = collection;
              _this.hash = new Hash(_this.tokenizer.remaining());
              _this.templates = [];
              _this.elseTemplates = [];
              var p;
              var stream = _this.liquid.parser.parseStream(remainTokens).on("start", function() {
                return p = _this.templates;
              }).on("tag:else", function() {
                return p = _this.elseTemplates;
              }).on("tag:endfor", function() {
                return stream.stop();
              }).on("template", function(tpl) {
                return p.push(tpl);
              }).on("end", function() {
                throw new Error("tag ".concat(token.getText(), " not closed"));
              });
              stream.start();
              return _this;
            }
            default_12.prototype.render = function(ctx, emitter) {
              var r, collection, _a, continueKey, hash, modifiers, scope, collection_1, collection_1_1, item, e_1_1;
              var e_1, _b;
              return __generator(this, function(_c) {
                switch (_c.label) {
                  case 0:
                    r = this.liquid.renderer;
                    _a = toEnumerable;
                    return [4, evalToken(this.collection, ctx)];
                  case 1:
                    collection = _a.apply(void 0, [_c.sent()]);
                    if (!!collection.length)
                      return [3, 3];
                    return [4, r.renderTemplates(this.elseTemplates, ctx, emitter)];
                  case 2:
                    _c.sent();
                    return [
                      2
                      /*return*/
                    ];
                  case 3:
                    continueKey = "continue-" + this.variable + "-" + this.collection.getText();
                    ctx.push({ continue: ctx.getRegister(continueKey) });
                    return [4, this.hash.render(ctx)];
                  case 4:
                    hash = _c.sent();
                    ctx.pop();
                    modifiers = this.liquid.options.orderedFilterParameters ? Object.keys(hash).filter(function(x) {
                      return MODIFIERS.includes(x);
                    }) : MODIFIERS.filter(function(x) {
                      return hash[x] !== void 0;
                    });
                    collection = modifiers.reduce(function(collection2, modifier) {
                      if (modifier === "offset")
                        return offset(collection2, hash["offset"]);
                      if (modifier === "limit")
                        return limit(collection2, hash["limit"]);
                      return reversed(collection2);
                    }, collection);
                    ctx.setRegister(continueKey, (hash["offset"] || 0) + collection.length);
                    scope = { forloop: new ForloopDrop(collection.length, this.collection.getText(), this.variable) };
                    ctx.push(scope);
                    _c.label = 5;
                  case 5:
                    _c.trys.push([5, 10, 11, 12]);
                    collection_1 = __values(collection), collection_1_1 = collection_1.next();
                    _c.label = 6;
                  case 6:
                    if (!!collection_1_1.done)
                      return [3, 9];
                    item = collection_1_1.value;
                    scope[this.variable] = item;
                    return [4, r.renderTemplates(this.templates, ctx, emitter)];
                  case 7:
                    _c.sent();
                    if (emitter["break"]) {
                      emitter["break"] = false;
                      return [3, 9];
                    }
                    emitter["continue"] = false;
                    scope.forloop.next();
                    _c.label = 8;
                  case 8:
                    collection_1_1 = collection_1.next();
                    return [3, 6];
                  case 9:
                    return [3, 12];
                  case 10:
                    e_1_1 = _c.sent();
                    e_1 = { error: e_1_1 };
                    return [3, 12];
                  case 11:
                    try {
                      if (collection_1_1 && !collection_1_1.done && (_b = collection_1.return))
                        _b.call(collection_1);
                    } finally {
                      if (e_1)
                        throw e_1.error;
                    }
                    return [
                      7
                      /*endfinally*/
                    ];
                  case 12:
                    ctx.pop();
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            };
            return default_12;
          }(Tag)
        );
        function reversed(arr) {
          return __spreadArray([], __read(arr), false).reverse();
        }
        function offset(arr, count) {
          return arr.slice(count);
        }
        function limit(arr, count) {
          return arr.slice(0, count);
        }
        var default_1$2 = (
          /** @class */
          function(_super) {
            __extends(default_12, _super);
            function default_12(tagToken, remainTokens, liquid) {
              var _this = _super.call(this, tagToken, remainTokens, liquid) || this;
              _this.templates = [];
              _this.variable = _this.readVariableName();
              while (remainTokens.length) {
                var token = remainTokens.shift();
                if (isTagToken(token) && token.name === "endcapture")
                  return _this;
                _this.templates.push(liquid.parser.parseToken(token, remainTokens));
              }
              throw new Error("tag ".concat(tagToken.getText(), " not closed"));
            }
            default_12.prototype.render = function(ctx) {
              var r, html;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    r = this.liquid.renderer;
                    return [4, r.renderTemplates(this.templates, ctx)];
                  case 1:
                    html = _a.sent();
                    ctx.bottom()[this.variable] = html;
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            };
            default_12.prototype.readVariableName = function() {
              var word = this.tokenizer.readIdentifier().content;
              if (word)
                return word;
              var quoted = this.tokenizer.readQuoted();
              if (quoted)
                return evalQuotedToken(quoted);
              throw this.tokenizer.error("invalid capture name");
            };
            return default_12;
          }(Tag)
        );
        var default_1$3 = (
          /** @class */
          function(_super) {
            __extends(default_12, _super);
            function default_12(tagToken, remainTokens, liquid) {
              var _this = _super.call(this, tagToken, remainTokens, liquid) || this;
              _this.branches = [];
              _this.elseTemplates = [];
              _this.value = new Value(_this.tokenizer.readFilteredValue(), _this.liquid);
              _this.elseTemplates = [];
              var p = [];
              var stream = _this.liquid.parser.parseStream(remainTokens).on("tag:when", function(token) {
                p = [];
                var values = [];
                while (!token.tokenizer.end()) {
                  values.push(token.tokenizer.readValueOrThrow());
                  token.tokenizer.readTo(",");
                }
                _this.branches.push({
                  values,
                  templates: p
                });
              }).on("tag:else", function() {
                return p = _this.elseTemplates;
              }).on("tag:endcase", function() {
                return stream.stop();
              }).on("template", function(tpl) {
                return p.push(tpl);
              }).on("end", function() {
                throw new Error("tag ".concat(tagToken.getText(), " not closed"));
              });
              stream.start();
              return _this;
            }
            default_12.prototype.render = function(ctx, emitter) {
              var r, target, _a, branchHit, _b, _c, branch, _d, _e, valueToken, value, e_1_1, e_2_1;
              var e_2, _f, e_1, _g;
              return __generator(this, function(_h) {
                switch (_h.label) {
                  case 0:
                    r = this.liquid.renderer;
                    _a = toValue;
                    return [4, this.value.value(ctx, ctx.opts.lenientIf)];
                  case 1:
                    target = _a.apply(void 0, [_h.sent()]);
                    branchHit = false;
                    _h.label = 2;
                  case 2:
                    _h.trys.push([2, 14, 15, 16]);
                    _b = __values(this.branches), _c = _b.next();
                    _h.label = 3;
                  case 3:
                    if (!!_c.done)
                      return [3, 13];
                    branch = _c.value;
                    _h.label = 4;
                  case 4:
                    _h.trys.push([4, 10, 11, 12]);
                    _d = (e_1 = void 0, __values(branch.values)), _e = _d.next();
                    _h.label = 5;
                  case 5:
                    if (!!_e.done)
                      return [3, 9];
                    valueToken = _e.value;
                    return [4, evalToken(valueToken, ctx, ctx.opts.lenientIf)];
                  case 6:
                    value = _h.sent();
                    if (!(target === value))
                      return [3, 8];
                    return [4, r.renderTemplates(branch.templates, ctx, emitter)];
                  case 7:
                    _h.sent();
                    branchHit = true;
                    return [3, 9];
                  case 8:
                    _e = _d.next();
                    return [3, 5];
                  case 9:
                    return [3, 12];
                  case 10:
                    e_1_1 = _h.sent();
                    e_1 = { error: e_1_1 };
                    return [3, 12];
                  case 11:
                    try {
                      if (_e && !_e.done && (_g = _d.return))
                        _g.call(_d);
                    } finally {
                      if (e_1)
                        throw e_1.error;
                    }
                    return [
                      7
                      /*endfinally*/
                    ];
                  case 12:
                    _c = _b.next();
                    return [3, 3];
                  case 13:
                    return [3, 16];
                  case 14:
                    e_2_1 = _h.sent();
                    e_2 = { error: e_2_1 };
                    return [3, 16];
                  case 15:
                    try {
                      if (_c && !_c.done && (_f = _b.return))
                        _f.call(_b);
                    } finally {
                      if (e_2)
                        throw e_2.error;
                    }
                    return [
                      7
                      /*endfinally*/
                    ];
                  case 16:
                    if (!!branchHit)
                      return [3, 18];
                    return [4, r.renderTemplates(this.elseTemplates, ctx, emitter)];
                  case 17:
                    _h.sent();
                    _h.label = 18;
                  case 18:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            };
            return default_12;
          }(Tag)
        );
        var default_1$4 = (
          /** @class */
          function(_super) {
            __extends(default_12, _super);
            function default_12(tagToken, remainTokens, liquid) {
              var _this = _super.call(this, tagToken, remainTokens, liquid) || this;
              while (remainTokens.length) {
                var token = remainTokens.shift();
                if (isTagToken(token) && token.name === "endcomment")
                  return _this;
              }
              throw new Error("tag ".concat(tagToken.getText(), " not closed"));
            }
            default_12.prototype.render = function() {
            };
            return default_12;
          }(Tag)
        );
        var default_1$5 = (
          /** @class */
          function(_super) {
            __extends(default_12, _super);
            function default_12(token, remainTokens, liquid) {
              var _this = _super.call(this, token, remainTokens, liquid) || this;
              var tokenizer = _this.tokenizer;
              _this.file = parseFilePath(tokenizer, _this.liquid);
              _this.currentFile = token.file;
              while (!tokenizer.end()) {
                tokenizer.skipBlank();
                var begin = tokenizer.p;
                var keyword = tokenizer.readIdentifier();
                if (keyword.content === "with" || keyword.content === "for") {
                  tokenizer.skipBlank();
                  if (tokenizer.peek() !== ":") {
                    var value = tokenizer.readValue();
                    if (value) {
                      var beforeAs = tokenizer.p;
                      var asStr = tokenizer.readIdentifier();
                      var alias = void 0;
                      if (asStr.content === "as")
                        alias = tokenizer.readIdentifier();
                      else
                        tokenizer.p = beforeAs;
                      _this[keyword.content] = { value, alias: alias && alias.content };
                      tokenizer.skipBlank();
                      if (tokenizer.peek() === ",")
                        tokenizer.advance();
                      continue;
                    }
                  }
                }
                tokenizer.p = begin;
                break;
              }
              _this.hash = new Hash(tokenizer.remaining());
              return _this;
            }
            default_12.prototype.render = function(ctx, emitter) {
              var _a, liquid, hash, filepath, childCtx, scope, _b, _c, _d, value, alias, _e, _f, _g, value, alias, collection, _h, collection_1, collection_1_1, item, templates, e_1_1, templates;
              var e_1, _j;
              return __generator(this, function(_k) {
                switch (_k.label) {
                  case 0:
                    _a = this, liquid = _a.liquid, hash = _a.hash;
                    return [4, renderFilePath(this["file"], ctx, liquid)];
                  case 1:
                    filepath = _k.sent();
                    assert(filepath, function() {
                      return 'illegal file path "'.concat(filepath, '"');
                    });
                    childCtx = new Context({}, ctx.opts, { sync: ctx.sync, globals: ctx.globals, strictVariables: ctx.strictVariables });
                    scope = childCtx.bottom();
                    _b = __assign;
                    _c = [scope];
                    return [4, hash.render(ctx)];
                  case 2:
                    _b.apply(void 0, _c.concat([_k.sent()]));
                    if (!this["with"])
                      return [3, 4];
                    _d = this["with"], value = _d.value, alias = _d.alias;
                    _e = scope;
                    _f = alias || filepath;
                    return [4, evalToken(value, ctx)];
                  case 3:
                    _e[_f] = _k.sent();
                    _k.label = 4;
                  case 4:
                    if (!this["for"])
                      return [3, 15];
                    _g = this["for"], value = _g.value, alias = _g.alias;
                    _h = toEnumerable;
                    return [4, evalToken(value, ctx)];
                  case 5:
                    collection = _h.apply(void 0, [_k.sent()]);
                    scope["forloop"] = new ForloopDrop(collection.length, value.getText(), alias);
                    _k.label = 6;
                  case 6:
                    _k.trys.push([6, 12, 13, 14]);
                    collection_1 = __values(collection), collection_1_1 = collection_1.next();
                    _k.label = 7;
                  case 7:
                    if (!!collection_1_1.done)
                      return [3, 11];
                    item = collection_1_1.value;
                    scope[alias] = item;
                    return [4, liquid._parsePartialFile(filepath, childCtx.sync, this["currentFile"])];
                  case 8:
                    templates = _k.sent();
                    return [4, liquid.renderer.renderTemplates(templates, childCtx, emitter)];
                  case 9:
                    _k.sent();
                    scope["forloop"].next();
                    _k.label = 10;
                  case 10:
                    collection_1_1 = collection_1.next();
                    return [3, 7];
                  case 11:
                    return [3, 14];
                  case 12:
                    e_1_1 = _k.sent();
                    e_1 = { error: e_1_1 };
                    return [3, 14];
                  case 13:
                    try {
                      if (collection_1_1 && !collection_1_1.done && (_j = collection_1.return))
                        _j.call(collection_1);
                    } finally {
                      if (e_1)
                        throw e_1.error;
                    }
                    return [
                      7
                      /*endfinally*/
                    ];
                  case 14:
                    return [3, 18];
                  case 15:
                    return [4, liquid._parsePartialFile(filepath, childCtx.sync, this["currentFile"])];
                  case 16:
                    templates = _k.sent();
                    return [4, liquid.renderer.renderTemplates(templates, childCtx, emitter)];
                  case 17:
                    _k.sent();
                    _k.label = 18;
                  case 18:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            };
            return default_12;
          }(Tag)
        );
        function parseFilePath(tokenizer, liquid) {
          if (liquid.options.dynamicPartials) {
            var file = tokenizer.readValue();
            tokenizer.assert(file, "illegal file path");
            if (file.getText() === "none")
              return;
            if (isQuotedToken(file)) {
              var templates_1 = liquid.parse(evalQuotedToken(file));
              return optimize(templates_1);
            }
            return file;
          }
          var tokens = __spreadArray([], __read(tokenizer.readFileNameTemplate(liquid.options)), false);
          var templates = optimize(liquid.parser.parseTokens(tokens));
          return templates === "none" ? void 0 : templates;
        }
        function optimize(templates) {
          if (templates.length === 1 && isHTMLToken(templates[0].token))
            return templates[0].token.getContent();
          return templates;
        }
        function renderFilePath(file, ctx, liquid) {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (typeof file === "string")
                  return [2, file];
                if (Array.isArray(file))
                  return [2, liquid.renderer.renderTemplates(file, ctx)];
                return [4, evalToken(file, ctx)];
              case 1:
                return [2, _a.sent()];
            }
          });
        }
        var default_1$6 = (
          /** @class */
          function(_super) {
            __extends(default_12, _super);
            function default_12(token, remainTokens, liquid) {
              var _this = _super.call(this, token, remainTokens, liquid) || this;
              var tokenizer = token.tokenizer;
              _this["file"] = parseFilePath(tokenizer, _this.liquid);
              _this["currentFile"] = token.file;
              var begin = tokenizer.p;
              var withStr = tokenizer.readIdentifier();
              if (withStr.content === "with") {
                tokenizer.skipBlank();
                if (tokenizer.peek() !== ":") {
                  _this.withVar = tokenizer.readValue();
                } else
                  tokenizer.p = begin;
              } else
                tokenizer.p = begin;
              _this.hash = new Hash(tokenizer.remaining(), _this.liquid.options.jekyllInclude);
              return _this;
            }
            default_12.prototype.render = function(ctx, emitter) {
              var _a, liquid, hash, withVar, renderer, filepath, saved, scope, _b, _c, templates;
              return __generator(this, function(_d) {
                switch (_d.label) {
                  case 0:
                    _a = this, liquid = _a.liquid, hash = _a.hash, withVar = _a.withVar;
                    renderer = liquid.renderer;
                    return [4, renderFilePath(this["file"], ctx, liquid)];
                  case 1:
                    filepath = _d.sent();
                    assert(filepath, function() {
                      return 'illegal file path "'.concat(filepath, '"');
                    });
                    saved = ctx.saveRegister("blocks", "blockMode");
                    ctx.setRegister("blocks", {});
                    ctx.setRegister("blockMode", BlockMode.OUTPUT);
                    return [4, hash.render(ctx)];
                  case 2:
                    scope = _d.sent();
                    if (!withVar)
                      return [3, 4];
                    _b = scope;
                    _c = filepath;
                    return [4, evalToken(withVar, ctx)];
                  case 3:
                    _b[_c] = _d.sent();
                    _d.label = 4;
                  case 4:
                    return [4, liquid._parsePartialFile(filepath, ctx.sync, this["currentFile"])];
                  case 5:
                    templates = _d.sent();
                    ctx.push(ctx.opts.jekyllInclude ? { include: scope } : scope);
                    return [4, renderer.renderTemplates(templates, ctx, emitter)];
                  case 6:
                    _d.sent();
                    ctx.pop();
                    ctx.restoreRegister(saved);
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            };
            return default_12;
          }(Tag)
        );
        var default_1$7 = (
          /** @class */
          function(_super) {
            __extends(default_12, _super);
            function default_12(token, remainTokens, liquid) {
              var _this = _super.call(this, token, remainTokens, liquid) || this;
              _this.variable = _this.tokenizer.readIdentifier().content;
              return _this;
            }
            default_12.prototype.render = function(context, emitter) {
              var scope = context.environments;
              if (!isNumber(scope[this.variable])) {
                scope[this.variable] = 0;
              }
              emitter.write(stringify(--scope[this.variable]));
            };
            return default_12;
          }(Tag)
        );
        var default_1$8 = (
          /** @class */
          function(_super) {
            __extends(default_12, _super);
            function default_12(token, remainTokens, liquid) {
              var _this = _super.call(this, token, remainTokens, liquid) || this;
              _this.candidates = [];
              var group = _this.tokenizer.readValue();
              _this.tokenizer.skipBlank();
              if (group) {
                if (_this.tokenizer.peek() === ":") {
                  _this.group = group;
                  _this.tokenizer.advance();
                } else
                  _this.candidates.push(group);
              }
              while (!_this.tokenizer.end()) {
                var value = _this.tokenizer.readValue();
                if (value)
                  _this.candidates.push(value);
                _this.tokenizer.readTo(",");
              }
              _this.tokenizer.assert(_this.candidates.length, function() {
                return 'empty candidates: "'.concat(token.getText(), '"');
              });
              return _this;
            }
            default_12.prototype.render = function(ctx, emitter) {
              var group, fingerprint, groups, idx, candidate;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, evalToken(this.group, ctx)];
                  case 1:
                    group = _a.sent();
                    fingerprint = "cycle:".concat(group, ":") + this.candidates.join(",");
                    groups = ctx.getRegister("cycle");
                    idx = groups[fingerprint];
                    if (idx === void 0) {
                      idx = groups[fingerprint] = 0;
                    }
                    candidate = this.candidates[idx];
                    idx = (idx + 1) % this.candidates.length;
                    groups[fingerprint] = idx;
                    return [4, evalToken(candidate, ctx)];
                  case 2:
                    return [2, _a.sent()];
                }
              });
            };
            return default_12;
          }(Tag)
        );
        var default_1$9 = (
          /** @class */
          function(_super) {
            __extends(default_12, _super);
            function default_12(tagToken, remainTokens, liquid) {
              var _this = _super.call(this, tagToken, remainTokens, liquid) || this;
              _this.branches = [];
              _this.elseTemplates = [];
              var p;
              liquid.parser.parseStream(remainTokens).on("start", function() {
                return _this.branches.push({
                  value: new Value(tagToken.args, _this.liquid),
                  templates: p = []
                });
              }).on("tag:elsif", function(token) {
                return _this.branches.push({
                  value: new Value(token.args, _this.liquid),
                  templates: p = []
                });
              }).on("tag:else", function() {
                return p = _this.elseTemplates;
              }).on("tag:endif", function() {
                this.stop();
              }).on("template", function(tpl) {
                return p.push(tpl);
              }).on("end", function() {
                throw new Error("tag ".concat(tagToken.getText(), " not closed"));
              }).start();
              return _this;
            }
            default_12.prototype.render = function(ctx, emitter) {
              var r, _a, _b, _c, value, templates, v, e_1_1;
              var e_1, _d;
              return __generator(this, function(_e) {
                switch (_e.label) {
                  case 0:
                    r = this.liquid.renderer;
                    _e.label = 1;
                  case 1:
                    _e.trys.push([1, 7, 8, 9]);
                    _a = __values(this.branches), _b = _a.next();
                    _e.label = 2;
                  case 2:
                    if (!!_b.done)
                      return [3, 6];
                    _c = _b.value, value = _c.value, templates = _c.templates;
                    return [4, value.value(ctx, ctx.opts.lenientIf)];
                  case 3:
                    v = _e.sent();
                    if (!isTruthy(v, ctx))
                      return [3, 5];
                    return [4, r.renderTemplates(templates, ctx, emitter)];
                  case 4:
                    _e.sent();
                    return [
                      2
                      /*return*/
                    ];
                  case 5:
                    _b = _a.next();
                    return [3, 2];
                  case 6:
                    return [3, 9];
                  case 7:
                    e_1_1 = _e.sent();
                    e_1 = { error: e_1_1 };
                    return [3, 9];
                  case 8:
                    try {
                      if (_b && !_b.done && (_d = _a.return))
                        _d.call(_a);
                    } finally {
                      if (e_1)
                        throw e_1.error;
                    }
                    return [
                      7
                      /*endfinally*/
                    ];
                  case 9:
                    return [4, r.renderTemplates(this.elseTemplates, ctx, emitter)];
                  case 10:
                    _e.sent();
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            };
            return default_12;
          }(Tag)
        );
        var default_1$a = (
          /** @class */
          function(_super) {
            __extends(default_12, _super);
            function default_12(token, remainTokens, liquid) {
              var _this = _super.call(this, token, remainTokens, liquid) || this;
              _this.variable = _this.tokenizer.readIdentifier().content;
              return _this;
            }
            default_12.prototype.render = function(context, emitter) {
              var scope = context.environments;
              if (!isNumber(scope[this.variable])) {
                scope[this.variable] = 0;
              }
              var val = scope[this.variable];
              scope[this.variable]++;
              emitter.write(stringify(val));
            };
            return default_12;
          }(Tag)
        );
        var default_1$b = (
          /** @class */
          function(_super) {
            __extends(default_12, _super);
            function default_12(token, remainTokens, liquid) {
              var _this = _super.call(this, token, remainTokens, liquid) || this;
              _this.file = parseFilePath(_this.tokenizer, _this.liquid);
              _this["currentFile"] = token.file;
              _this.args = new Hash(_this.tokenizer.remaining());
              _this.templates = _this.liquid.parser.parseTokens(remainTokens);
              return _this;
            }
            default_12.prototype.render = function(ctx, emitter) {
              var _a, liquid, args, file, renderer, filepath, templates, html, blocks, _b, _c;
              return __generator(this, function(_d) {
                switch (_d.label) {
                  case 0:
                    _a = this, liquid = _a.liquid, args = _a.args, file = _a.file;
                    renderer = liquid.renderer;
                    if (!(file === void 0))
                      return [3, 2];
                    ctx.setRegister("blockMode", BlockMode.OUTPUT);
                    return [4, renderer.renderTemplates(this.templates, ctx, emitter)];
                  case 1:
                    _d.sent();
                    return [
                      2
                      /*return*/
                    ];
                  case 2:
                    return [4, renderFilePath(this.file, ctx, liquid)];
                  case 3:
                    filepath = _d.sent();
                    assert(filepath, function() {
                      return 'illegal file path "'.concat(filepath, '"');
                    });
                    return [4, liquid._parseLayoutFile(filepath, ctx.sync, this["currentFile"])];
                  case 4:
                    templates = _d.sent();
                    ctx.setRegister("blockMode", BlockMode.STORE);
                    return [4, renderer.renderTemplates(this.templates, ctx)];
                  case 5:
                    html = _d.sent();
                    blocks = ctx.getRegister("blocks");
                    if (blocks[""] === void 0)
                      blocks[""] = function(parent, emitter2) {
                        return emitter2.write(html);
                      };
                    ctx.setRegister("blockMode", BlockMode.OUTPUT);
                    _c = (_b = ctx).push;
                    return [4, args.render(ctx)];
                  case 6:
                    _c.apply(_b, [_d.sent()]);
                    return [4, renderer.renderTemplates(templates, ctx, emitter)];
                  case 7:
                    _d.sent();
                    ctx.pop();
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            };
            return default_12;
          }(Tag)
        );
        var default_1$c = (
          /** @class */
          function(_super) {
            __extends(default_12, _super);
            function default_12(token, remainTokens, liquid) {
              var _this = _super.call(this, token, remainTokens, liquid) || this;
              _this.templates = [];
              var match = /\w+/.exec(token.args);
              _this.block = match ? match[0] : "";
              while (remainTokens.length) {
                var token_1 = remainTokens.shift();
                if (isTagToken(token_1) && token_1.name === "endblock")
                  return _this;
                var template = liquid.parser.parseToken(token_1, remainTokens);
                _this.templates.push(template);
              }
              throw new Error("tag ".concat(token.getText(), " not closed"));
            }
            default_12.prototype.render = function(ctx, emitter) {
              var blockRender;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    blockRender = this.getBlockRender(ctx);
                    if (!(ctx.getRegister("blockMode") === BlockMode.STORE))
                      return [3, 1];
                    ctx.getRegister("blocks")[this.block] = blockRender;
                    return [3, 3];
                  case 1:
                    return [4, blockRender(new BlockDrop(), emitter)];
                  case 2:
                    _a.sent();
                    _a.label = 3;
                  case 3:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            };
            default_12.prototype.getBlockRender = function(ctx) {
              var _a = this, liquid = _a.liquid, templates = _a.templates;
              var renderChild = ctx.getRegister("blocks")[this.block];
              var renderCurrent = function(superBlock, emitter) {
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      ctx.push({ block: superBlock });
                      return [4, liquid.renderer.renderTemplates(templates, ctx, emitter)];
                    case 1:
                      _a2.sent();
                      ctx.pop();
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              };
              return renderChild ? function(superBlock, emitter) {
                return renderChild(new BlockDrop(function() {
                  return renderCurrent(superBlock, emitter);
                }), emitter);
              } : renderCurrent;
            };
            return default_12;
          }(Tag)
        );
        var default_1$d = (
          /** @class */
          function(_super) {
            __extends(default_12, _super);
            function default_12(tagToken, remainTokens, liquid) {
              var _this = _super.call(this, tagToken, remainTokens, liquid) || this;
              _this.tokens = [];
              while (remainTokens.length) {
                var token = remainTokens.shift();
                if (isTagToken(token) && token.name === "endraw")
                  return _this;
                _this.tokens.push(token);
              }
              throw new Error("tag ".concat(tagToken.getText(), " not closed"));
            }
            default_12.prototype.render = function() {
              return this.tokens.map(function(token) {
                return token.getText();
              }).join("");
            };
            return default_12;
          }(Tag)
        );
        var TablerowloopDrop = (
          /** @class */
          function(_super) {
            __extends(TablerowloopDrop2, _super);
            function TablerowloopDrop2(length, cols, collection, variable) {
              var _this = _super.call(this, length, collection, variable) || this;
              _this.length = length;
              _this.cols = cols;
              return _this;
            }
            TablerowloopDrop2.prototype.row = function() {
              return Math.floor(this.i / this.cols) + 1;
            };
            TablerowloopDrop2.prototype.col0 = function() {
              return this.i % this.cols;
            };
            TablerowloopDrop2.prototype.col = function() {
              return this.col0() + 1;
            };
            TablerowloopDrop2.prototype.col_first = function() {
              return this.col0() === 0;
            };
            TablerowloopDrop2.prototype.col_last = function() {
              return this.col() === this.cols;
            };
            return TablerowloopDrop2;
          }(ForloopDrop)
        );
        var default_1$e = (
          /** @class */
          function(_super) {
            __extends(default_12, _super);
            function default_12(tagToken, remainTokens, liquid) {
              var _this = _super.call(this, tagToken, remainTokens, liquid) || this;
              var variable = _this.tokenizer.readIdentifier();
              _this.tokenizer.skipBlank();
              var predicate = _this.tokenizer.readIdentifier();
              var collectionToken = _this.tokenizer.readValue();
              if (predicate.content !== "in" || !collectionToken) {
                throw new Error("illegal tag: ".concat(tagToken.getText()));
              }
              _this.variable = variable.content;
              _this.collection = collectionToken;
              _this.args = new Hash(_this.tokenizer.remaining());
              _this.templates = [];
              var p;
              var stream = _this.liquid.parser.parseStream(remainTokens).on("start", function() {
                return p = _this.templates;
              }).on("tag:endtablerow", function() {
                return stream.stop();
              }).on("template", function(tpl) {
                return p.push(tpl);
              }).on("end", function() {
                throw new Error("tag ".concat(tagToken.getText(), " not closed"));
              });
              stream.start();
              return _this;
            }
            default_12.prototype.render = function(ctx, emitter) {
              var collection, _a, args, offset2, limit2, cols, r, tablerowloop, scope, idx;
              return __generator(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    _a = toEnumerable;
                    return [4, evalToken(this.collection, ctx)];
                  case 1:
                    collection = _a.apply(void 0, [_b.sent()]);
                    return [4, this.args.render(ctx)];
                  case 2:
                    args = _b.sent();
                    offset2 = args.offset || 0;
                    limit2 = args.limit === void 0 ? collection.length : args.limit;
                    collection = collection.slice(offset2, offset2 + limit2);
                    cols = args.cols || collection.length;
                    r = this.liquid.renderer;
                    tablerowloop = new TablerowloopDrop(collection.length, cols, this.collection.getText(), this.variable);
                    scope = { tablerowloop };
                    ctx.push(scope);
                    idx = 0;
                    _b.label = 3;
                  case 3:
                    if (!(idx < collection.length))
                      return [3, 6];
                    scope[this.variable] = collection[idx];
                    if (tablerowloop.col0() === 0) {
                      if (tablerowloop.row() !== 1)
                        emitter.write("</tr>");
                      emitter.write('<tr class="row'.concat(tablerowloop.row(), '">'));
                    }
                    emitter.write('<td class="col'.concat(tablerowloop.col(), '">'));
                    return [4, r.renderTemplates(this.templates, ctx, emitter)];
                  case 4:
                    _b.sent();
                    emitter.write("</td>");
                    _b.label = 5;
                  case 5:
                    idx++, tablerowloop.next();
                    return [3, 3];
                  case 6:
                    if (collection.length)
                      emitter.write("</tr>");
                    ctx.pop();
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            };
            return default_12;
          }(Tag)
        );
        var default_1$f = (
          /** @class */
          function(_super) {
            __extends(default_12, _super);
            function default_12(tagToken, remainTokens, liquid) {
              var _this = _super.call(this, tagToken, remainTokens, liquid) || this;
              _this.branches = [];
              _this.elseTemplates = [];
              var p;
              _this.liquid.parser.parseStream(remainTokens).on("start", function() {
                return _this.branches.push({
                  value: new Value(tagToken.args, _this.liquid),
                  test: isFalsy,
                  templates: p = []
                });
              }).on("tag:elsif", function(token) {
                return _this.branches.push({
                  value: new Value(token.args, _this.liquid),
                  test: isTruthy,
                  templates: p = []
                });
              }).on("tag:else", function() {
                return p = _this.elseTemplates;
              }).on("tag:endunless", function() {
                this.stop();
              }).on("template", function(tpl) {
                return p.push(tpl);
              }).on("end", function() {
                throw new Error("tag ".concat(tagToken.getText(), " not closed"));
              }).start();
              return _this;
            }
            default_12.prototype.render = function(ctx, emitter) {
              var r, _a, _b, _c, value, test_1, templates, v, e_1_1;
              var e_1, _d;
              return __generator(this, function(_e) {
                switch (_e.label) {
                  case 0:
                    r = this.liquid.renderer;
                    _e.label = 1;
                  case 1:
                    _e.trys.push([1, 7, 8, 9]);
                    _a = __values(this.branches), _b = _a.next();
                    _e.label = 2;
                  case 2:
                    if (!!_b.done)
                      return [3, 6];
                    _c = _b.value, value = _c.value, test_1 = _c.test, templates = _c.templates;
                    return [4, value.value(ctx, ctx.opts.lenientIf)];
                  case 3:
                    v = _e.sent();
                    if (!test_1(v, ctx))
                      return [3, 5];
                    return [4, r.renderTemplates(templates, ctx, emitter)];
                  case 4:
                    _e.sent();
                    return [
                      2
                      /*return*/
                    ];
                  case 5:
                    _b = _a.next();
                    return [3, 2];
                  case 6:
                    return [3, 9];
                  case 7:
                    e_1_1 = _e.sent();
                    e_1 = { error: e_1_1 };
                    return [3, 9];
                  case 8:
                    try {
                      if (_b && !_b.done && (_d = _a.return))
                        _d.call(_a);
                    } finally {
                      if (e_1)
                        throw e_1.error;
                    }
                    return [
                      7
                      /*endfinally*/
                    ];
                  case 9:
                    return [4, r.renderTemplates(this.elseTemplates, ctx, emitter)];
                  case 10:
                    _e.sent();
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            };
            return default_12;
          }(Tag)
        );
        var default_1$g = (
          /** @class */
          function(_super) {
            __extends(default_12, _super);
            function default_12() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            default_12.prototype.render = function(ctx, emitter) {
              emitter["break"] = true;
            };
            return default_12;
          }(Tag)
        );
        var default_1$h = (
          /** @class */
          function(_super) {
            __extends(default_12, _super);
            function default_12() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            default_12.prototype.render = function(ctx, emitter) {
              emitter["continue"] = true;
            };
            return default_12;
          }(Tag)
        );
        var default_1$i = (
          /** @class */
          function(_super) {
            __extends(default_12, _super);
            function default_12(token, remainTokens, liquid) {
              var _this = _super.call(this, token, remainTokens, liquid) || this;
              _this.tokenizer.skipBlank();
              if (!_this.tokenizer.end()) {
                _this.value = new Value(_this.tokenizer.readFilteredValue(), _this.liquid);
              }
              return _this;
            }
            default_12.prototype.render = function(ctx, emitter) {
              var val;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    if (!this.value)
                      return [
                        2
                        /*return*/
                      ];
                    return [4, this.value.value(ctx, false)];
                  case 1:
                    val = _a.sent();
                    emitter.write(val);
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            };
            return default_12;
          }(Tag)
        );
        var default_1$j = (
          /** @class */
          function(_super) {
            __extends(default_12, _super);
            function default_12(token, remainTokens, liquid) {
              var _this = _super.call(this, token, remainTokens, liquid) || this;
              var tokens = _this.tokenizer.readLiquidTagTokens(_this.liquid.options);
              _this.templates = _this.liquid.parser.parseTokens(tokens);
              return _this;
            }
            default_12.prototype.render = function(ctx, emitter) {
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.liquid.renderer.renderTemplates(this.templates, ctx, emitter)];
                  case 1:
                    _a.sent();
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            };
            return default_12;
          }(Tag)
        );
        var default_1$k = (
          /** @class */
          function(_super) {
            __extends(default_12, _super);
            function default_12(tagToken, remainTokens, liquid) {
              var _this = _super.call(this, tagToken, remainTokens, liquid) || this;
              if (tagToken.args.search(/\n\s*[^#\s]/g) !== -1) {
                throw new Error("every line of an inline comment must start with a '#' character");
              }
              return _this;
            }
            default_12.prototype.render = function() {
            };
            return default_12;
          }(Tag)
        );
        var tags = {
          assign: default_1,
          "for": default_1$1,
          capture: default_1$2,
          "case": default_1$3,
          comment: default_1$4,
          include: default_1$6,
          render: default_1$5,
          decrement: default_1$7,
          increment: default_1$a,
          cycle: default_1$8,
          "if": default_1$9,
          layout: default_1$b,
          block: default_1$c,
          raw: default_1$d,
          tablerow: default_1$e,
          unless: default_1$f,
          "break": default_1$g,
          "continue": default_1$h,
          echo: default_1$i,
          liquid: default_1$j,
          "#": default_1$k
        };
        var Liquid = (
          /** @class */
          function() {
            function Liquid2(opts) {
              if (opts === void 0) {
                opts = {};
              }
              var _this = this;
              this.renderer = new Render();
              this.filters = {};
              this.tags = {};
              this.options = normalize(opts);
              this.parser = new Parser(this);
              forOwn(tags, function(conf, name) {
                return _this.registerTag(name, conf);
              });
              forOwn(filters, function(handler, name) {
                return _this.registerFilter(name, handler);
              });
            }
            Liquid2.prototype.parse = function(html, filepath) {
              return this.parser.parse(html, filepath);
            };
            Liquid2.prototype._render = function(tpl, scope, renderOptions) {
              var ctx = scope instanceof Context ? scope : new Context(scope, this.options, renderOptions);
              return this.renderer.renderTemplates(tpl, ctx);
            };
            Liquid2.prototype.render = function(tpl, scope, renderOptions) {
              return __awaiter(this, void 0, void 0, function() {
                return __generator(this, function(_a) {
                  return [2, toPromise(this._render(tpl, scope, __assign(__assign({}, renderOptions), { sync: false })))];
                });
              });
            };
            Liquid2.prototype.renderSync = function(tpl, scope, renderOptions) {
              return toValueSync(this._render(tpl, scope, __assign(__assign({}, renderOptions), { sync: true })));
            };
            Liquid2.prototype.renderToNodeStream = function(tpl, scope, renderOptions) {
              if (renderOptions === void 0) {
                renderOptions = {};
              }
              var ctx = new Context(scope, this.options, renderOptions);
              return this.renderer.renderTemplatesToNodeStream(tpl, ctx);
            };
            Liquid2.prototype._parseAndRender = function(html, scope, renderOptions) {
              var tpl = this.parse(html);
              return this._render(tpl, scope, renderOptions);
            };
            Liquid2.prototype.parseAndRender = function(html, scope, renderOptions) {
              return __awaiter(this, void 0, void 0, function() {
                return __generator(this, function(_a) {
                  return [2, toPromise(this._parseAndRender(html, scope, __assign(__assign({}, renderOptions), { sync: false })))];
                });
              });
            };
            Liquid2.prototype.parseAndRenderSync = function(html, scope, renderOptions) {
              return toValueSync(this._parseAndRender(html, scope, __assign(__assign({}, renderOptions), { sync: true })));
            };
            Liquid2.prototype._parsePartialFile = function(file, sync, currentFile) {
              return this.parser.parseFile(file, sync, LookupType.Partials, currentFile);
            };
            Liquid2.prototype._parseLayoutFile = function(file, sync, currentFile) {
              return this.parser.parseFile(file, sync, LookupType.Layouts, currentFile);
            };
            Liquid2.prototype._parseFile = function(file, sync, lookupType, currentFile) {
              return this.parser.parseFile(file, sync, lookupType, currentFile);
            };
            Liquid2.prototype.parseFile = function(file, lookupType) {
              return __awaiter(this, void 0, void 0, function() {
                return __generator(this, function(_a) {
                  return [2, toPromise(this.parser.parseFile(file, false, lookupType))];
                });
              });
            };
            Liquid2.prototype.parseFileSync = function(file, lookupType) {
              return toValueSync(this.parser.parseFile(file, true, lookupType));
            };
            Liquid2.prototype._renderFile = function(file, ctx, renderFileOptions) {
              var templates;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this._parseFile(file, renderFileOptions.sync, renderFileOptions.lookupType)];
                  case 1:
                    templates = _a.sent();
                    return [4, this._render(templates, ctx, renderFileOptions)];
                  case 2:
                    return [2, _a.sent()];
                }
              });
            };
            Liquid2.prototype.renderFile = function(file, ctx, renderFileOptions) {
              return __awaiter(this, void 0, void 0, function() {
                return __generator(this, function(_a) {
                  return [2, toPromise(this._renderFile(file, ctx, __assign(__assign({}, renderFileOptions), { sync: false })))];
                });
              });
            };
            Liquid2.prototype.renderFileSync = function(file, ctx, renderFileOptions) {
              return toValueSync(this._renderFile(file, ctx, __assign(__assign({}, renderFileOptions), { sync: true })));
            };
            Liquid2.prototype.renderFileToNodeStream = function(file, scope, renderOptions) {
              return __awaiter(this, void 0, void 0, function() {
                var templates;
                return __generator(this, function(_a) {
                  switch (_a.label) {
                    case 0:
                      return [4, this.parseFile(file)];
                    case 1:
                      templates = _a.sent();
                      return [2, this.renderToNodeStream(templates, scope, renderOptions)];
                  }
                });
              });
            };
            Liquid2.prototype._evalValue = function(str, scope) {
              var value = new Value(str, this);
              var ctx = scope instanceof Context ? scope : new Context(scope, this.options);
              return value.value(ctx);
            };
            Liquid2.prototype.evalValue = function(str, scope) {
              return __awaiter(this, void 0, void 0, function() {
                return __generator(this, function(_a) {
                  return [2, toPromise(this._evalValue(str, scope))];
                });
              });
            };
            Liquid2.prototype.evalValueSync = function(str, scope) {
              return toValueSync(this._evalValue(str, scope));
            };
            Liquid2.prototype.registerFilter = function(name, filter) {
              this.filters[name] = filter;
            };
            Liquid2.prototype.registerTag = function(name, tag) {
              this.tags[name] = isFunction(tag) ? tag : createTagClass(tag);
            };
            Liquid2.prototype.plugin = function(plugin) {
              return plugin.call(this, Liquid2);
            };
            Liquid2.prototype.express = function() {
              var self2 = this;
              var firstCall = true;
              return function(filePath, ctx, callback) {
                var _a, _b, _c;
                if (firstCall) {
                  firstCall = false;
                  var dirs = normalizeDirectoryList(this.root);
                  (_a = self2.options.root).unshift.apply(_a, __spreadArray([], __read(dirs), false));
                  (_b = self2.options.layouts).unshift.apply(_b, __spreadArray([], __read(dirs), false));
                  (_c = self2.options.partials).unshift.apply(_c, __spreadArray([], __read(dirs), false));
                }
                self2.renderFile(filePath, ctx).then(function(html) {
                  return callback(null, html);
                }, callback);
              };
            };
            return Liquid2;
          }()
        );
        var version = "10.8.2";
        exports2.AssertionError = AssertionError;
        exports2.AssignTag = default_1;
        exports2.BlockTag = default_1$c;
        exports2.BreakTag = default_1$g;
        exports2.CaptureTag = default_1$2;
        exports2.CaseTag = default_1$3;
        exports2.CommentTag = default_1$4;
        exports2.Context = Context;
        exports2.ContinueTag = default_1$h;
        exports2.CycleTag = default_1$8;
        exports2.DecrementTag = default_1$7;
        exports2.Drop = Drop;
        exports2.EchoTag = default_1$i;
        exports2.Expression = Expression;
        exports2.Filter = Filter;
        exports2.ForTag = default_1$1;
        exports2.Hash = Hash;
        exports2.IfTag = default_1$9;
        exports2.IncludeTag = default_1$6;
        exports2.IncrementTag = default_1$a;
        exports2.InlineCommentTag = default_1$k;
        exports2.LayoutTag = default_1$b;
        exports2.Liquid = Liquid;
        exports2.LiquidError = LiquidError;
        exports2.LiquidTag = default_1$j;
        exports2.Output = Output;
        exports2.ParseError = ParseError;
        exports2.ParseStream = ParseStream;
        exports2.RawTag = default_1$d;
        exports2.RenderError = RenderError;
        exports2.RenderTag = default_1$5;
        exports2.TablerowTag = default_1$e;
        exports2.Tag = Tag;
        exports2.TagToken = TagToken;
        exports2.TimezoneDate = TimezoneDate;
        exports2.Token = Token;
        exports2.TokenizationError = TokenizationError;
        exports2.Tokenizer = Tokenizer;
        exports2.TypeGuards = typeGuards;
        exports2.UndefinedVariableError = UndefinedVariableError;
        exports2.UnlessTag = default_1$f;
        exports2.Value = Value;
        exports2.assert = assert;
        exports2.createTrie = createTrie;
        exports2.defaultOperators = defaultOperators;
        exports2.defaultOptions = defaultOptions;
        exports2.evalQuotedToken = evalQuotedToken;
        exports2.evalToken = evalToken;
        exports2.filters = filters;
        exports2.isFalsy = isFalsy;
        exports2.isTruthy = isTruthy;
        exports2.tags = tags;
        exports2.toPromise = toPromise;
        exports2.toValue = toValue;
        exports2.toValueSync = toValueSync;
        exports2.version = version;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // src/index.js
  var require_src4 = __commonJS({
    "src/index.js"(exports, module) {
      var {
        DataFrame,
        isArray,
        isUndefined,
        Series
      } = require_src3();
      var { Liquid } = require_liquid_browser_umd();
      var liquid = new Liquid();
      if (!String.prototype.replaceAll) {
        String.prototype.replaceAll = function(a, b) {
          const self2 = this;
          return self2.split(a).join(b);
        };
      }
      function getIndentation(text) {
        return text.split(/[^\s]/g)[0];
      }
      var gt2 = {
        date: {
          toGTDateObject(date) {
            const out = {
              year: date.getFullYear(),
              month: date.getMonth() + 1,
              day: date.getDate(),
              hour: date.getHours(),
              minute: date.getMinutes()
            };
            return gt2.object.toAssociation(out);
          }
        },
        object: {
          toAssociation(obj) {
            function recursiveParse(obj2) {
              const type = typeof obj2;
              if (type === "string")
                return JSON.stringify(obj2);
              if (type === "number")
                return obj2;
              if (type === "boolean")
                return JSON.stringify(obj2.toString());
              if (type === "function")
                return JSON.stringify("<function>");
              if (type === "undefined")
                return JSON.stringify("undefined");
              if (obj2 === null)
                return JSON.stringify("null");
              if (obj2 instanceof Array) {
                return "[" + obj2.map((v) => recursiveParse(v)).join(", ") + "]";
              } else {
                const pairs = [];
                Object.keys(obj2).forEach((key) => {
                  const val = recursiveParse(obj2[key]);
                  pairs.push(`"` + key + `" -> ` + val);
                });
                return "{ " + pairs.join(", ") + " }";
              }
            }
            return recursiveParse(obj);
          }
        },
        template: {
          registerLiquidFilter(name, fn) {
            liquid.registerFilter(name, fn);
          },
          async liquidBuild(template, dict) {
            return await liquid.parseAndRender(template, dict);
          }
        },
        program: {
          extractQuestions(text) {
            const questionKeywords = [
              "after",
              "answers",
              "before",
              "blank",
              "confirm",
              "countdown",
              "date",
              "default",
              "max",
              "min",
              "multiple",
              "question",
              "save",
              "shuffle",
              "tags",
              "throwaway",
              "time",
              "tip",
              "type"
            ];
            const lines = text.split("\n");
            const questions = [];
            lines.forEach((line, i) => {
              const pattern = /^\s* \s*[^\s]/g;
              if (line.match(pattern)) {
                throw new Error(
                  `GT programs must be indented with spaces only! The indentation of line ${i + 1} in your program includes spaces!`
                );
              }
              if (line.trim().startsWith("*question:")) {
                const question = {
                  question: line.replace("*question: ", "").trim()
                };
                const indentation = getIndentation(line);
                const j = (() => {
                  const index = lines.findIndex((other, j2) => {
                    return j2 > i && getIndentation(other).length <= indentation.length && other.trim().length > 0;
                  });
                  if (index < 0)
                    return lines.length;
                  return index;
                })();
                const otherLines = lines.slice(i + 1, j).filter((other) => getIndentation(other) === indentation + "	");
                if (otherLines.length > 0) {
                  otherLines.forEach((other) => {
                    other = other.trim();
                    let startsWithAKeyword = false;
                    questionKeywords.forEach((keyword) => {
                      if (startsWithAKeyword)
                        return;
                      if (other.startsWith("*" + keyword)) {
                        startsWithAKeyword = true;
                        const value = (() => {
                          if (other.includes(":")) {
                            const parts = other.split(":");
                            const value2 = parts.slice(1).join(":").trim();
                            try {
                              return JSON.parse(value2);
                            } catch (e) {
                              return value2;
                            }
                          } else {
                            return true;
                          }
                        })();
                        question[keyword] = value;
                      }
                    });
                    if (!startsWithAKeyword) {
                      if (!question.answers) {
                        question.answers = [];
                      }
                      if (question.answers instanceof Array) {
                        question.answers.push(other);
                      }
                    }
                  });
                }
                if (isUndefined(question.type)) {
                  if (question.answers) {
                    question.type = "choice";
                  } else {
                    question.type = "text";
                  }
                }
                questions.push(question);
              }
            });
            if (questions.length === 0) {
              const out2 = new DataFrame([questionKeywords.map(() => void 0)]);
              out2.columns = questionKeywords;
              return out2;
            }
            let out = new DataFrame(
              questions.map(
                (question) => questionKeywords.map((keyword) => {
                  const value = question[keyword];
                  if (isArray(value)) {
                    return JSON.stringify(value);
                  } else {
                    return value;
                  }
                })
              )
            );
            out.columns = questionKeywords;
            out = out.get(
              null,
              ["question"].concat(questionKeywords.filter((k) => k !== "question"))
            );
            if (out instanceof Series) {
              return out.toDataFrame().transpose();
            } else {
              return out;
            }
          }
        }
      };
      if (typeof module !== "undefined") {
        module.exports = gt2;
      }
      if (typeof window !== "undefined") {
        window.gt = gt2;
      }
    }
  });

  // node_modules/brace/index.js
  var require_brace = __commonJS({
    "node_modules/brace/index.js"(exports, module) {
      (function() {
        var ACE_NAMESPACE = "ace";
        var global2 = function() {
          return this;
        }();
        if (!global2 && typeof window != "undefined")
          global2 = window;
        if (!ACE_NAMESPACE && typeof acequirejs !== "undefined")
          return;
        var define2 = function(module2, deps, payload) {
          if (typeof module2 !== "string") {
            if (define2.original)
              define2.original.apply(this, arguments);
            else {
              console.error("dropping module because define wasn't a string.");
              console.trace();
            }
            return;
          }
          if (arguments.length == 2)
            payload = deps;
          if (!define2.modules[module2]) {
            define2.payloads[module2] = payload;
            define2.modules[module2] = null;
          }
        };
        define2.modules = {};
        define2.payloads = {};
        var _acequire = function(parentId, module2, callback) {
          if (typeof module2 === "string") {
            var payload = lookup(parentId, module2);
            if (payload != void 0) {
              callback && callback();
              return payload;
            }
          } else if (Object.prototype.toString.call(module2) === "[object Array]") {
            var params = [];
            for (var i = 0, l = module2.length; i < l; ++i) {
              var dep = lookup(parentId, module2[i]);
              if (dep == void 0 && acequire.original)
                return;
              params.push(dep);
            }
            return callback && callback.apply(null, params) || true;
          }
        };
        var acequire = function(module2, callback) {
          var packagedModule = _acequire("", module2, callback);
          if (packagedModule == void 0 && acequire.original)
            return acequire.original.apply(this, arguments);
          return packagedModule;
        };
        var normalizeModule = function(parentId, moduleName) {
          if (moduleName.indexOf("!") !== -1) {
            var chunks = moduleName.split("!");
            return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
          }
          if (moduleName.charAt(0) == ".") {
            var base = parentId.split("/").slice(0, -1).join("/");
            moduleName = base + "/" + moduleName;
            while (moduleName.indexOf(".") !== -1 && previous != moduleName) {
              var previous = moduleName;
              moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
            }
          }
          return moduleName;
        };
        var lookup = function(parentId, moduleName) {
          moduleName = normalizeModule(parentId, moduleName);
          var module2 = define2.modules[moduleName];
          if (!module2) {
            module2 = define2.payloads[moduleName];
            if (typeof module2 === "function") {
              var exports2 = {};
              var mod = {
                id: moduleName,
                uri: "",
                exports: exports2,
                packaged: true
              };
              var req = function(module3, callback) {
                return _acequire(moduleName, module3, callback);
              };
              var returnValue = module2(req, exports2, mod);
              exports2 = returnValue || mod.exports;
              define2.modules[moduleName] = exports2;
              delete define2.payloads[moduleName];
            }
            module2 = define2.modules[moduleName] = exports2 || module2;
          }
          return module2;
        };
        function exportAce(ns) {
          var root = global2;
          if (ns) {
            if (!global2[ns])
              global2[ns] = {};
            root = global2[ns];
          }
          if (!root.define || !root.define.packaged) {
            define2.original = root.define;
            root.define = define2;
            root.define.packaged = true;
          }
          if (!root.acequire || !root.acequire.packaged) {
            acequire.original = root.acequire;
            root.acequire = acequire;
            root.acequire.packaged = true;
          }
        }
        exportAce(ACE_NAMESPACE);
      })();
      ace.define("ace/lib/regexp", ["require", "exports", "module"], function(acequire, exports2, module2) {
        "use strict";
        var real = {
          exec: RegExp.prototype.exec,
          test: RegExp.prototype.test,
          match: String.prototype.match,
          replace: String.prototype.replace,
          split: String.prototype.split
        }, compliantExecNpcg = real.exec.call(/()??/, "")[1] === void 0, compliantLastIndexIncrement = function() {
          var x = /^/g;
          real.test.call(x, "");
          return !x.lastIndex;
        }();
        if (compliantLastIndexIncrement && compliantExecNpcg)
          return;
        RegExp.prototype.exec = function(str) {
          var match = real.exec.apply(this, arguments), name, r2;
          if (typeof str == "string" && match) {
            if (!compliantExecNpcg && match.length > 1 && indexOf(match, "") > -1) {
              r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), "g", ""));
              real.replace.call(str.slice(match.index), r2, function() {
                for (var i2 = 1; i2 < arguments.length - 2; i2++) {
                  if (arguments[i2] === void 0)
                    match[i2] = void 0;
                }
              });
            }
            if (this._xregexp && this._xregexp.captureNames) {
              for (var i = 1; i < match.length; i++) {
                name = this._xregexp.captureNames[i - 1];
                if (name)
                  match[name] = match[i];
              }
            }
            if (!compliantLastIndexIncrement && this.global && !match[0].length && this.lastIndex > match.index)
              this.lastIndex--;
          }
          return match;
        };
        if (!compliantLastIndexIncrement) {
          RegExp.prototype.test = function(str) {
            var match = real.exec.call(this, str);
            if (match && this.global && !match[0].length && this.lastIndex > match.index)
              this.lastIndex--;
            return !!match;
          };
        }
        function getNativeFlags(regex) {
          return (regex.global ? "g" : "") + (regex.ignoreCase ? "i" : "") + (regex.multiline ? "m" : "") + (regex.extended ? "x" : "") + // Proposed for ES4; included in AS3
          (regex.sticky ? "y" : "");
        }
        function indexOf(array, item, from) {
          if (Array.prototype.indexOf)
            return array.indexOf(item, from);
          for (var i = from || 0; i < array.length; i++) {
            if (array[i] === item)
              return i;
          }
          return -1;
        }
      });
      ace.define("ace/lib/es5-shim", ["require", "exports", "module"], function(acequire, exports2, module2) {
        function Empty() {
        }
        if (!Function.prototype.bind) {
          Function.prototype.bind = function bind(that) {
            var target = this;
            if (typeof target != "function") {
              throw new TypeError("Function.prototype.bind called on incompatible " + target);
            }
            var args = slice.call(arguments, 1);
            var bound = function() {
              if (this instanceof bound) {
                var result = target.apply(
                  this,
                  args.concat(slice.call(arguments))
                );
                if (Object(result) === result) {
                  return result;
                }
                return this;
              } else {
                return target.apply(
                  that,
                  args.concat(slice.call(arguments))
                );
              }
            };
            if (target.prototype) {
              Empty.prototype = target.prototype;
              bound.prototype = new Empty();
              Empty.prototype = null;
            }
            return bound;
          };
        }
        var call = Function.prototype.call;
        var prototypeOfArray = Array.prototype;
        var prototypeOfObject = Object.prototype;
        var slice = prototypeOfArray.slice;
        var _toString = call.bind(prototypeOfObject.toString);
        var owns = call.bind(prototypeOfObject.hasOwnProperty);
        var defineGetter;
        var defineSetter;
        var lookupGetter;
        var lookupSetter;
        var supportsAccessors;
        if (supportsAccessors = owns(prototypeOfObject, "__defineGetter__")) {
          defineGetter = call.bind(prototypeOfObject.__defineGetter__);
          defineSetter = call.bind(prototypeOfObject.__defineSetter__);
          lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
          lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
        }
        if ([1, 2].splice(0).length != 2) {
          if (function() {
            function makeArray(l) {
              var a = new Array(l + 2);
              a[0] = a[1] = 0;
              return a;
            }
            var array = [], lengthBefore;
            array.splice.apply(array, makeArray(20));
            array.splice.apply(array, makeArray(26));
            lengthBefore = array.length;
            array.splice(5, 0, "XXX");
            lengthBefore + 1 == array.length;
            if (lengthBefore + 1 == array.length) {
              return true;
            }
          }()) {
            var array_splice = Array.prototype.splice;
            Array.prototype.splice = function(start, deleteCount) {
              if (!arguments.length) {
                return [];
              } else {
                return array_splice.apply(this, [
                  start === void 0 ? 0 : start,
                  deleteCount === void 0 ? this.length - start : deleteCount
                ].concat(slice.call(arguments, 2)));
              }
            };
          } else {
            Array.prototype.splice = function(pos, removeCount) {
              var length = this.length;
              if (pos > 0) {
                if (pos > length)
                  pos = length;
              } else if (pos == void 0) {
                pos = 0;
              } else if (pos < 0) {
                pos = Math.max(length + pos, 0);
              }
              if (!(pos + removeCount < length))
                removeCount = length - pos;
              var removed = this.slice(pos, pos + removeCount);
              var insert = slice.call(arguments, 2);
              var add = insert.length;
              if (pos === length) {
                if (add) {
                  this.push.apply(this, insert);
                }
              } else {
                var remove = Math.min(removeCount, length - pos);
                var tailOldPos = pos + remove;
                var tailNewPos = tailOldPos + add - remove;
                var tailCount = length - tailOldPos;
                var lengthAfterRemove = length - remove;
                if (tailNewPos < tailOldPos) {
                  for (var i = 0; i < tailCount; ++i) {
                    this[tailNewPos + i] = this[tailOldPos + i];
                  }
                } else if (tailNewPos > tailOldPos) {
                  for (i = tailCount; i--; ) {
                    this[tailNewPos + i] = this[tailOldPos + i];
                  }
                }
                if (add && pos === lengthAfterRemove) {
                  this.length = lengthAfterRemove;
                  this.push.apply(this, insert);
                } else {
                  this.length = lengthAfterRemove + add;
                  for (i = 0; i < add; ++i) {
                    this[pos + i] = insert[i];
                  }
                }
              }
              return removed;
            };
          }
        }
        if (!Array.isArray) {
          Array.isArray = function isArray(obj) {
            return _toString(obj) == "[object Array]";
          };
        }
        var boxedString = Object("a"), splitString = boxedString[0] != "a" || !(0 in boxedString);
        if (!Array.prototype.forEach) {
          Array.prototype.forEach = function forEach(fun) {
            var object = toObject(this), self2 = splitString && _toString(this) == "[object String]" ? this.split("") : object, thisp = arguments[1], i = -1, length = self2.length >>> 0;
            if (_toString(fun) != "[object Function]") {
              throw new TypeError();
            }
            while (++i < length) {
              if (i in self2) {
                fun.call(thisp, self2[i], i, object);
              }
            }
          };
        }
        if (!Array.prototype.map) {
          Array.prototype.map = function map(fun) {
            var object = toObject(this), self2 = splitString && _toString(this) == "[object String]" ? this.split("") : object, length = self2.length >>> 0, result = Array(length), thisp = arguments[1];
            if (_toString(fun) != "[object Function]") {
              throw new TypeError(fun + " is not a function");
            }
            for (var i = 0; i < length; i++) {
              if (i in self2)
                result[i] = fun.call(thisp, self2[i], i, object);
            }
            return result;
          };
        }
        if (!Array.prototype.filter) {
          Array.prototype.filter = function filter(fun) {
            var object = toObject(this), self2 = splitString && _toString(this) == "[object String]" ? this.split("") : object, length = self2.length >>> 0, result = [], value, thisp = arguments[1];
            if (_toString(fun) != "[object Function]") {
              throw new TypeError(fun + " is not a function");
            }
            for (var i = 0; i < length; i++) {
              if (i in self2) {
                value = self2[i];
                if (fun.call(thisp, value, i, object)) {
                  result.push(value);
                }
              }
            }
            return result;
          };
        }
        if (!Array.prototype.every) {
          Array.prototype.every = function every(fun) {
            var object = toObject(this), self2 = splitString && _toString(this) == "[object String]" ? this.split("") : object, length = self2.length >>> 0, thisp = arguments[1];
            if (_toString(fun) != "[object Function]") {
              throw new TypeError(fun + " is not a function");
            }
            for (var i = 0; i < length; i++) {
              if (i in self2 && !fun.call(thisp, self2[i], i, object)) {
                return false;
              }
            }
            return true;
          };
        }
        if (!Array.prototype.some) {
          Array.prototype.some = function some(fun) {
            var object = toObject(this), self2 = splitString && _toString(this) == "[object String]" ? this.split("") : object, length = self2.length >>> 0, thisp = arguments[1];
            if (_toString(fun) != "[object Function]") {
              throw new TypeError(fun + " is not a function");
            }
            for (var i = 0; i < length; i++) {
              if (i in self2 && fun.call(thisp, self2[i], i, object)) {
                return true;
              }
            }
            return false;
          };
        }
        if (!Array.prototype.reduce) {
          Array.prototype.reduce = function reduce(fun) {
            var object = toObject(this), self2 = splitString && _toString(this) == "[object String]" ? this.split("") : object, length = self2.length >>> 0;
            if (_toString(fun) != "[object Function]") {
              throw new TypeError(fun + " is not a function");
            }
            if (!length && arguments.length == 1) {
              throw new TypeError("reduce of empty array with no initial value");
            }
            var i = 0;
            var result;
            if (arguments.length >= 2) {
              result = arguments[1];
            } else {
              do {
                if (i in self2) {
                  result = self2[i++];
                  break;
                }
                if (++i >= length) {
                  throw new TypeError("reduce of empty array with no initial value");
                }
              } while (true);
            }
            for (; i < length; i++) {
              if (i in self2) {
                result = fun.call(void 0, result, self2[i], i, object);
              }
            }
            return result;
          };
        }
        if (!Array.prototype.reduceRight) {
          Array.prototype.reduceRight = function reduceRight(fun) {
            var object = toObject(this), self2 = splitString && _toString(this) == "[object String]" ? this.split("") : object, length = self2.length >>> 0;
            if (_toString(fun) != "[object Function]") {
              throw new TypeError(fun + " is not a function");
            }
            if (!length && arguments.length == 1) {
              throw new TypeError("reduceRight of empty array with no initial value");
            }
            var result, i = length - 1;
            if (arguments.length >= 2) {
              result = arguments[1];
            } else {
              do {
                if (i in self2) {
                  result = self2[i--];
                  break;
                }
                if (--i < 0) {
                  throw new TypeError("reduceRight of empty array with no initial value");
                }
              } while (true);
            }
            do {
              if (i in this) {
                result = fun.call(void 0, result, self2[i], i, object);
              }
            } while (i--);
            return result;
          };
        }
        if (!Array.prototype.indexOf || [0, 1].indexOf(1, 2) != -1) {
          Array.prototype.indexOf = function indexOf(sought) {
            var self2 = splitString && _toString(this) == "[object String]" ? this.split("") : toObject(this), length = self2.length >>> 0;
            if (!length) {
              return -1;
            }
            var i = 0;
            if (arguments.length > 1) {
              i = toInteger(arguments[1]);
            }
            i = i >= 0 ? i : Math.max(0, length + i);
            for (; i < length; i++) {
              if (i in self2 && self2[i] === sought) {
                return i;
              }
            }
            return -1;
          };
        }
        if (!Array.prototype.lastIndexOf || [0, 1].lastIndexOf(0, -3) != -1) {
          Array.prototype.lastIndexOf = function lastIndexOf(sought) {
            var self2 = splitString && _toString(this) == "[object String]" ? this.split("") : toObject(this), length = self2.length >>> 0;
            if (!length) {
              return -1;
            }
            var i = length - 1;
            if (arguments.length > 1) {
              i = Math.min(i, toInteger(arguments[1]));
            }
            i = i >= 0 ? i : length - Math.abs(i);
            for (; i >= 0; i--) {
              if (i in self2 && sought === self2[i]) {
                return i;
              }
            }
            return -1;
          };
        }
        if (!Object.getPrototypeOf) {
          Object.getPrototypeOf = function getPrototypeOf(object) {
            return object.__proto__ || (object.constructor ? object.constructor.prototype : prototypeOfObject);
          };
        }
        if (!Object.getOwnPropertyDescriptor) {
          var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a non-object: ";
          Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
            if (typeof object != "object" && typeof object != "function" || object === null)
              throw new TypeError(ERR_NON_OBJECT + object);
            if (!owns(object, property))
              return;
            var descriptor, getter, setter;
            descriptor = { enumerable: true, configurable: true };
            if (supportsAccessors) {
              var prototype = object.__proto__;
              object.__proto__ = prototypeOfObject;
              var getter = lookupGetter(object, property);
              var setter = lookupSetter(object, property);
              object.__proto__ = prototype;
              if (getter || setter) {
                if (getter)
                  descriptor.get = getter;
                if (setter)
                  descriptor.set = setter;
                return descriptor;
              }
            }
            descriptor.value = object[property];
            return descriptor;
          };
        }
        if (!Object.getOwnPropertyNames) {
          Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
            return Object.keys(object);
          };
        }
        if (!Object.create) {
          var createEmpty;
          if (Object.prototype.__proto__ === null) {
            createEmpty = function() {
              return { "__proto__": null };
            };
          } else {
            createEmpty = function() {
              var empty = {};
              for (var i in empty)
                empty[i] = null;
              empty.constructor = empty.hasOwnProperty = empty.propertyIsEnumerable = empty.isPrototypeOf = empty.toLocaleString = empty.toString = empty.valueOf = empty.__proto__ = null;
              return empty;
            };
          }
          Object.create = function create(prototype, properties) {
            var object;
            if (prototype === null) {
              object = createEmpty();
            } else {
              if (typeof prototype != "object")
                throw new TypeError("typeof prototype[" + typeof prototype + "] != 'object'");
              var Type = function() {
              };
              Type.prototype = prototype;
              object = new Type();
              object.__proto__ = prototype;
            }
            if (properties !== void 0)
              Object.defineProperties(object, properties);
            return object;
          };
        }
        function doesDefinePropertyWork(object) {
          try {
            Object.defineProperty(object, "sentinel", {});
            return "sentinel" in object;
          } catch (exception) {
          }
        }
        if (Object.defineProperty) {
          var definePropertyWorksOnObject = doesDefinePropertyWork({});
          var definePropertyWorksOnDom = typeof document == "undefined" || doesDefinePropertyWork(document.createElement("div"));
          if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
            var definePropertyFallback = Object.defineProperty;
          }
        }
        if (!Object.defineProperty || definePropertyFallback) {
          var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
          var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: ";
          var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined on this javascript engine";
          Object.defineProperty = function defineProperty(object, property, descriptor) {
            if (typeof object != "object" && typeof object != "function" || object === null)
              throw new TypeError(ERR_NON_OBJECT_TARGET + object);
            if (typeof descriptor != "object" && typeof descriptor != "function" || descriptor === null)
              throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
            if (definePropertyFallback) {
              try {
                return definePropertyFallback.call(Object, object, property, descriptor);
              } catch (exception) {
              }
            }
            if (owns(descriptor, "value")) {
              if (supportsAccessors && (lookupGetter(object, property) || lookupSetter(object, property))) {
                var prototype = object.__proto__;
                object.__proto__ = prototypeOfObject;
                delete object[property];
                object[property] = descriptor.value;
                object.__proto__ = prototype;
              } else {
                object[property] = descriptor.value;
              }
            } else {
              if (!supportsAccessors)
                throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
              if (owns(descriptor, "get"))
                defineGetter(object, property, descriptor.get);
              if (owns(descriptor, "set"))
                defineSetter(object, property, descriptor.set);
            }
            return object;
          };
        }
        if (!Object.defineProperties) {
          Object.defineProperties = function defineProperties(object, properties) {
            for (var property in properties) {
              if (owns(properties, property))
                Object.defineProperty(object, property, properties[property]);
            }
            return object;
          };
        }
        if (!Object.seal) {
          Object.seal = function seal(object) {
            return object;
          };
        }
        if (!Object.freeze) {
          Object.freeze = function freeze(object) {
            return object;
          };
        }
        try {
          Object.freeze(function() {
          });
        } catch (exception) {
          Object.freeze = function freeze(freezeObject) {
            return function freeze2(object) {
              if (typeof object == "function") {
                return object;
              } else {
                return freezeObject(object);
              }
            };
          }(Object.freeze);
        }
        if (!Object.preventExtensions) {
          Object.preventExtensions = function preventExtensions(object) {
            return object;
          };
        }
        if (!Object.isSealed) {
          Object.isSealed = function isSealed(object) {
            return false;
          };
        }
        if (!Object.isFrozen) {
          Object.isFrozen = function isFrozen(object) {
            return false;
          };
        }
        if (!Object.isExtensible) {
          Object.isExtensible = function isExtensible(object) {
            if (Object(object) === object) {
              throw new TypeError();
            }
            var name = "";
            while (owns(object, name)) {
              name += "?";
            }
            object[name] = true;
            var returnValue = owns(object, name);
            delete object[name];
            return returnValue;
          };
        }
        if (!Object.keys) {
          var hasDontEnumBug = true, dontEnums = [
            "toString",
            "toLocaleString",
            "valueOf",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "constructor"
          ], dontEnumsLength = dontEnums.length;
          for (var key in { "toString": null }) {
            hasDontEnumBug = false;
          }
          Object.keys = function keys(object) {
            if (typeof object != "object" && typeof object != "function" || object === null) {
              throw new TypeError("Object.keys called on a non-object");
            }
            var keys2 = [];
            for (var name in object) {
              if (owns(object, name)) {
                keys2.push(name);
              }
            }
            if (hasDontEnumBug) {
              for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
                var dontEnum = dontEnums[i];
                if (owns(object, dontEnum)) {
                  keys2.push(dontEnum);
                }
              }
            }
            return keys2;
          };
        }
        if (!Date.now) {
          Date.now = function now() {
            return (/* @__PURE__ */ new Date()).getTime();
          };
        }
        var ws = "	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
        if (!String.prototype.trim || ws.trim()) {
          ws = "[" + ws + "]";
          var trimBeginRegexp = new RegExp("^" + ws + ws + "*"), trimEndRegexp = new RegExp(ws + ws + "*$");
          String.prototype.trim = function trim() {
            return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
          };
        }
        function toInteger(n) {
          n = +n;
          if (n !== n) {
            n = 0;
          } else if (n !== 0 && n !== 1 / 0 && n !== -(1 / 0)) {
            n = (n > 0 || -1) * Math.floor(Math.abs(n));
          }
          return n;
        }
        function isPrimitive(input) {
          var type = typeof input;
          return input === null || type === "undefined" || type === "boolean" || type === "number" || type === "string";
        }
        function toPrimitive(input) {
          var val, valueOf, toString2;
          if (isPrimitive(input)) {
            return input;
          }
          valueOf = input.valueOf;
          if (typeof valueOf === "function") {
            val = valueOf.call(input);
            if (isPrimitive(val)) {
              return val;
            }
          }
          toString2 = input.toString;
          if (typeof toString2 === "function") {
            val = toString2.call(input);
            if (isPrimitive(val)) {
              return val;
            }
          }
          throw new TypeError();
        }
        var toObject = function(o) {
          if (o == null) {
            throw new TypeError("can't convert " + o + " to object");
          }
          return Object(o);
        };
      });
      ace.define("ace/lib/fixoldbrowsers", ["require", "exports", "module", "ace/lib/regexp", "ace/lib/es5-shim"], function(acequire, exports2, module2) {
        "use strict";
        acequire("./regexp");
        acequire("./es5-shim");
      });
      ace.define("ace/lib/dom", ["require", "exports", "module"], function(acequire, exports2, module2) {
        "use strict";
        var XHTML_NS = "http://www.w3.org/1999/xhtml";
        exports2.getDocumentHead = function(doc) {
          if (!doc)
            doc = document;
          return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
        };
        exports2.createElement = function(tag, ns) {
          return document.createElementNS ? document.createElementNS(ns || XHTML_NS, tag) : document.createElement(tag);
        };
        exports2.hasCssClass = function(el, name) {
          var classes = (el.className + "").split(/\s+/g);
          return classes.indexOf(name) !== -1;
        };
        exports2.addCssClass = function(el, name) {
          if (!exports2.hasCssClass(el, name)) {
            el.className += " " + name;
          }
        };
        exports2.removeCssClass = function(el, name) {
          var classes = el.className.split(/\s+/g);
          while (true) {
            var index = classes.indexOf(name);
            if (index == -1) {
              break;
            }
            classes.splice(index, 1);
          }
          el.className = classes.join(" ");
        };
        exports2.toggleCssClass = function(el, name) {
          var classes = el.className.split(/\s+/g), add = true;
          while (true) {
            var index = classes.indexOf(name);
            if (index == -1) {
              break;
            }
            add = false;
            classes.splice(index, 1);
          }
          if (add)
            classes.push(name);
          el.className = classes.join(" ");
          return add;
        };
        exports2.setCssClass = function(node, className, include) {
          if (include) {
            exports2.addCssClass(node, className);
          } else {
            exports2.removeCssClass(node, className);
          }
        };
        exports2.hasCssString = function(id, doc) {
          var index = 0, sheets;
          doc = doc || document;
          if (doc.createStyleSheet && (sheets = doc.styleSheets)) {
            while (index < sheets.length)
              if (sheets[index++].owningElement.id === id)
                return true;
          } else if (sheets = doc.getElementsByTagName("style")) {
            while (index < sheets.length)
              if (sheets[index++].id === id)
                return true;
          }
          return false;
        };
        exports2.importCssString = function importCssString(cssText, id, doc) {
          doc = doc || document;
          if (id && exports2.hasCssString(id, doc))
            return null;
          var style;
          if (id)
            cssText += "\n/*# sourceURL=ace/css/" + id + " */";
          if (doc.createStyleSheet) {
            style = doc.createStyleSheet();
            style.cssText = cssText;
            if (id)
              style.owningElement.id = id;
          } else {
            style = exports2.createElement("style");
            style.appendChild(doc.createTextNode(cssText));
            if (id)
              style.id = id;
            exports2.getDocumentHead(doc).appendChild(style);
          }
        };
        exports2.importCssStylsheet = function(uri, doc) {
          if (doc.createStyleSheet) {
            doc.createStyleSheet(uri);
          } else {
            var link = exports2.createElement("link");
            link.rel = "stylesheet";
            link.href = uri;
            exports2.getDocumentHead(doc).appendChild(link);
          }
        };
        exports2.getInnerWidth = function(element) {
          return parseInt(exports2.computedStyle(element, "paddingLeft"), 10) + parseInt(exports2.computedStyle(element, "paddingRight"), 10) + element.clientWidth;
        };
        exports2.getInnerHeight = function(element) {
          return parseInt(exports2.computedStyle(element, "paddingTop"), 10) + parseInt(exports2.computedStyle(element, "paddingBottom"), 10) + element.clientHeight;
        };
        exports2.scrollbarWidth = function(document2) {
          var inner = exports2.createElement("ace_inner");
          inner.style.width = "100%";
          inner.style.minWidth = "0px";
          inner.style.height = "200px";
          inner.style.display = "block";
          var outer = exports2.createElement("ace_outer");
          var style = outer.style;
          style.position = "absolute";
          style.left = "-10000px";
          style.overflow = "hidden";
          style.width = "200px";
          style.minWidth = "0px";
          style.height = "150px";
          style.display = "block";
          outer.appendChild(inner);
          var body = document2.documentElement;
          body.appendChild(outer);
          var noScrollbar = inner.offsetWidth;
          style.overflow = "scroll";
          var withScrollbar = inner.offsetWidth;
          if (noScrollbar == withScrollbar) {
            withScrollbar = outer.clientWidth;
          }
          body.removeChild(outer);
          return noScrollbar - withScrollbar;
        };
        if (typeof document == "undefined") {
          exports2.importCssString = function() {
          };
          return;
        }
        if (window.pageYOffset !== void 0) {
          exports2.getPageScrollTop = function() {
            return window.pageYOffset;
          };
          exports2.getPageScrollLeft = function() {
            return window.pageXOffset;
          };
        } else {
          exports2.getPageScrollTop = function() {
            return document.body.scrollTop;
          };
          exports2.getPageScrollLeft = function() {
            return document.body.scrollLeft;
          };
        }
        if (window.getComputedStyle)
          exports2.computedStyle = function(element, style) {
            if (style)
              return (window.getComputedStyle(element, "") || {})[style] || "";
            return window.getComputedStyle(element, "") || {};
          };
        else
          exports2.computedStyle = function(element, style) {
            if (style)
              return element.currentStyle[style];
            return element.currentStyle;
          };
        exports2.setInnerHtml = function(el, innerHtml) {
          var element = el.cloneNode(false);
          element.innerHTML = innerHtml;
          el.parentNode.replaceChild(element, el);
          return element;
        };
        if ("textContent" in document.documentElement) {
          exports2.setInnerText = function(el, innerText) {
            el.textContent = innerText;
          };
          exports2.getInnerText = function(el) {
            return el.textContent;
          };
        } else {
          exports2.setInnerText = function(el, innerText) {
            el.innerText = innerText;
          };
          exports2.getInnerText = function(el) {
            return el.innerText;
          };
        }
        exports2.getParentWindow = function(document2) {
          return document2.defaultView || document2.parentWindow;
        };
      });
      ace.define("ace/lib/oop", ["require", "exports", "module"], function(acequire, exports2, module2) {
        "use strict";
        exports2.inherits = function(ctor, superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        };
        exports2.mixin = function(obj, mixin) {
          for (var key in mixin) {
            obj[key] = mixin[key];
          }
          return obj;
        };
        exports2.implement = function(proto, mixin) {
          exports2.mixin(proto, mixin);
        };
      });
      ace.define("ace/lib/keys", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/oop"], function(acequire, exports2, module2) {
        "use strict";
        acequire("./fixoldbrowsers");
        var oop = acequire("./oop");
        var Keys = function() {
          var ret = {
            MODIFIER_KEYS: {
              16: "Shift",
              17: "Ctrl",
              18: "Alt",
              224: "Meta"
            },
            KEY_MODS: {
              "ctrl": 1,
              "alt": 2,
              "option": 2,
              "shift": 4,
              "super": 8,
              "meta": 8,
              "command": 8,
              "cmd": 8
            },
            FUNCTION_KEYS: {
              8: "Backspace",
              9: "Tab",
              13: "Return",
              19: "Pause",
              27: "Esc",
              32: "Space",
              33: "PageUp",
              34: "PageDown",
              35: "End",
              36: "Home",
              37: "Left",
              38: "Up",
              39: "Right",
              40: "Down",
              44: "Print",
              45: "Insert",
              46: "Delete",
              96: "Numpad0",
              97: "Numpad1",
              98: "Numpad2",
              99: "Numpad3",
              100: "Numpad4",
              101: "Numpad5",
              102: "Numpad6",
              103: "Numpad7",
              104: "Numpad8",
              105: "Numpad9",
              "-13": "NumpadEnter",
              112: "F1",
              113: "F2",
              114: "F3",
              115: "F4",
              116: "F5",
              117: "F6",
              118: "F7",
              119: "F8",
              120: "F9",
              121: "F10",
              122: "F11",
              123: "F12",
              144: "Numlock",
              145: "Scrolllock"
            },
            PRINTABLE_KEYS: {
              32: " ",
              48: "0",
              49: "1",
              50: "2",
              51: "3",
              52: "4",
              53: "5",
              54: "6",
              55: "7",
              56: "8",
              57: "9",
              59: ";",
              61: "=",
              65: "a",
              66: "b",
              67: "c",
              68: "d",
              69: "e",
              70: "f",
              71: "g",
              72: "h",
              73: "i",
              74: "j",
              75: "k",
              76: "l",
              77: "m",
              78: "n",
              79: "o",
              80: "p",
              81: "q",
              82: "r",
              83: "s",
              84: "t",
              85: "u",
              86: "v",
              87: "w",
              88: "x",
              89: "y",
              90: "z",
              107: "+",
              109: "-",
              110: ".",
              186: ";",
              187: "=",
              188: ",",
              189: "-",
              190: ".",
              191: "/",
              192: "`",
              219: "[",
              220: "\\",
              221: "]",
              222: "'",
              111: "/",
              106: "*"
            }
          };
          var name, i;
          for (i in ret.FUNCTION_KEYS) {
            name = ret.FUNCTION_KEYS[i].toLowerCase();
            ret[name] = parseInt(i, 10);
          }
          for (i in ret.PRINTABLE_KEYS) {
            name = ret.PRINTABLE_KEYS[i].toLowerCase();
            ret[name] = parseInt(i, 10);
          }
          oop.mixin(ret, ret.MODIFIER_KEYS);
          oop.mixin(ret, ret.PRINTABLE_KEYS);
          oop.mixin(ret, ret.FUNCTION_KEYS);
          ret.enter = ret["return"];
          ret.escape = ret.esc;
          ret.del = ret["delete"];
          ret[173] = "-";
          (function() {
            var mods = ["cmd", "ctrl", "alt", "shift"];
            for (var i2 = Math.pow(2, mods.length); i2--; ) {
              ret.KEY_MODS[i2] = mods.filter(function(x) {
                return i2 & ret.KEY_MODS[x];
              }).join("-") + "-";
            }
          })();
          ret.KEY_MODS[0] = "";
          ret.KEY_MODS[-1] = "input-";
          return ret;
        }();
        oop.mixin(exports2, Keys);
        exports2.keyCodeToString = function(keyCode) {
          var keyString = Keys[keyCode];
          if (typeof keyString != "string")
            keyString = String.fromCharCode(keyCode);
          return keyString.toLowerCase();
        };
      });
      ace.define("ace/lib/useragent", ["require", "exports", "module"], function(acequire, exports2, module2) {
        "use strict";
        exports2.OS = {
          LINUX: "LINUX",
          MAC: "MAC",
          WINDOWS: "WINDOWS"
        };
        exports2.getOS = function() {
          if (exports2.isMac) {
            return exports2.OS.MAC;
          } else if (exports2.isLinux) {
            return exports2.OS.LINUX;
          } else {
            return exports2.OS.WINDOWS;
          }
        };
        if (typeof navigator != "object")
          return;
        var os = (navigator.platform.match(/mac|win|linux/i) || ["other"])[0].toLowerCase();
        var ua = navigator.userAgent;
        exports2.isWin = os == "win";
        exports2.isMac = os == "mac";
        exports2.isLinux = os == "linux";
        exports2.isIE = navigator.appName == "Microsoft Internet Explorer" || navigator.appName.indexOf("MSAppHost") >= 0 ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]) : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]);
        exports2.isOldIE = exports2.isIE && exports2.isIE < 9;
        exports2.isGecko = exports2.isMozilla = (window.Controllers || window.controllers) && window.navigator.product === "Gecko";
        exports2.isOldGecko = exports2.isGecko && parseInt((ua.match(/rv:(\d+)/) || [])[1], 10) < 4;
        exports2.isOpera = window.opera && Object.prototype.toString.call(window.opera) == "[object Opera]";
        exports2.isWebKit = parseFloat(ua.split("WebKit/")[1]) || void 0;
        exports2.isChrome = parseFloat(ua.split(" Chrome/")[1]) || void 0;
        exports2.isAIR = ua.indexOf("AdobeAIR") >= 0;
        exports2.isIPad = ua.indexOf("iPad") >= 0;
        exports2.isChromeOS = ua.indexOf(" CrOS ") >= 0;
        exports2.isIOS = /iPad|iPhone|iPod/.test(ua) && !window.MSStream;
        if (exports2.isIOS)
          exports2.isMac = true;
      });
      ace.define("ace/lib/event", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function(acequire, exports2, module2) {
        "use strict";
        var keys = acequire("./keys");
        var useragent = acequire("./useragent");
        var pressedKeys = null;
        var ts = 0;
        exports2.addListener = function(elem, type, callback) {
          if (elem.addEventListener) {
            return elem.addEventListener(type, callback, false);
          }
          if (elem.attachEvent) {
            var wrapper = function() {
              callback.call(elem, window.event);
            };
            callback._wrapper = wrapper;
            elem.attachEvent("on" + type, wrapper);
          }
        };
        exports2.removeListener = function(elem, type, callback) {
          if (elem.removeEventListener) {
            return elem.removeEventListener(type, callback, false);
          }
          if (elem.detachEvent) {
            elem.detachEvent("on" + type, callback._wrapper || callback);
          }
        };
        exports2.stopEvent = function(e) {
          exports2.stopPropagation(e);
          exports2.preventDefault(e);
          return false;
        };
        exports2.stopPropagation = function(e) {
          if (e.stopPropagation)
            e.stopPropagation();
          else
            e.cancelBubble = true;
        };
        exports2.preventDefault = function(e) {
          if (e.preventDefault)
            e.preventDefault();
          else
            e.returnValue = false;
        };
        exports2.getButton = function(e) {
          if (e.type == "dblclick")
            return 0;
          if (e.type == "contextmenu" || useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey))
            return 2;
          if (e.preventDefault) {
            return e.button;
          } else {
            return { 1: 0, 2: 2, 4: 1 }[e.button];
          }
        };
        exports2.capture = function(el, eventHandler, releaseCaptureHandler) {
          function onMouseUp(e) {
            eventHandler && eventHandler(e);
            releaseCaptureHandler && releaseCaptureHandler(e);
            exports2.removeListener(document, "mousemove", eventHandler, true);
            exports2.removeListener(document, "mouseup", onMouseUp, true);
            exports2.removeListener(document, "dragstart", onMouseUp, true);
          }
          exports2.addListener(document, "mousemove", eventHandler, true);
          exports2.addListener(document, "mouseup", onMouseUp, true);
          exports2.addListener(document, "dragstart", onMouseUp, true);
          return onMouseUp;
        };
        exports2.addTouchMoveListener = function(el, callback) {
          var startx, starty;
          exports2.addListener(el, "touchstart", function(e) {
            var touches = e.touches;
            var touchObj = touches[0];
            startx = touchObj.clientX;
            starty = touchObj.clientY;
          });
          exports2.addListener(el, "touchmove", function(e) {
            var touches = e.touches;
            if (touches.length > 1)
              return;
            var touchObj = touches[0];
            e.wheelX = startx - touchObj.clientX;
            e.wheelY = starty - touchObj.clientY;
            startx = touchObj.clientX;
            starty = touchObj.clientY;
            callback(e);
          });
        };
        exports2.addMouseWheelListener = function(el, callback) {
          if ("onmousewheel" in el) {
            exports2.addListener(el, "mousewheel", function(e) {
              var factor = 8;
              if (e.wheelDeltaX !== void 0) {
                e.wheelX = -e.wheelDeltaX / factor;
                e.wheelY = -e.wheelDeltaY / factor;
              } else {
                e.wheelX = 0;
                e.wheelY = -e.wheelDelta / factor;
              }
              callback(e);
            });
          } else if ("onwheel" in el) {
            exports2.addListener(el, "wheel", function(e) {
              var factor = 0.35;
              switch (e.deltaMode) {
                case e.DOM_DELTA_PIXEL:
                  e.wheelX = e.deltaX * factor || 0;
                  e.wheelY = e.deltaY * factor || 0;
                  break;
                case e.DOM_DELTA_LINE:
                case e.DOM_DELTA_PAGE:
                  e.wheelX = (e.deltaX || 0) * 5;
                  e.wheelY = (e.deltaY || 0) * 5;
                  break;
              }
              callback(e);
            });
          } else {
            exports2.addListener(el, "DOMMouseScroll", function(e) {
              if (e.axis && e.axis == e.HORIZONTAL_AXIS) {
                e.wheelX = (e.detail || 0) * 5;
                e.wheelY = 0;
              } else {
                e.wheelX = 0;
                e.wheelY = (e.detail || 0) * 5;
              }
              callback(e);
            });
          }
        };
        exports2.addMultiMouseDownListener = function(elements, timeouts, eventHandler, callbackName) {
          var clicks = 0;
          var startX, startY, timer;
          var eventNames = {
            2: "dblclick",
            3: "tripleclick",
            4: "quadclick"
          };
          function onMousedown(e) {
            if (exports2.getButton(e) !== 0) {
              clicks = 0;
            } else if (e.detail > 1) {
              clicks++;
              if (clicks > 4)
                clicks = 1;
            } else {
              clicks = 1;
            }
            if (useragent.isIE) {
              var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
              if (!timer || isNewClick)
                clicks = 1;
              if (timer)
                clearTimeout(timer);
              timer = setTimeout(function() {
                timer = null;
              }, timeouts[clicks - 1] || 600);
              if (clicks == 1) {
                startX = e.clientX;
                startY = e.clientY;
              }
            }
            e._clicks = clicks;
            eventHandler[callbackName]("mousedown", e);
            if (clicks > 4)
              clicks = 0;
            else if (clicks > 1)
              return eventHandler[callbackName](eventNames[clicks], e);
          }
          function onDblclick(e) {
            clicks = 2;
            if (timer)
              clearTimeout(timer);
            timer = setTimeout(function() {
              timer = null;
            }, timeouts[clicks - 1] || 600);
            eventHandler[callbackName]("mousedown", e);
            eventHandler[callbackName](eventNames[clicks], e);
          }
          if (!Array.isArray(elements))
            elements = [elements];
          elements.forEach(function(el) {
            exports2.addListener(el, "mousedown", onMousedown);
            if (useragent.isOldIE)
              exports2.addListener(el, "dblclick", onDblclick);
          });
        };
        var getModifierHash = useragent.isMac && useragent.isOpera && !("KeyboardEvent" in window) ? function(e) {
          return 0 | (e.metaKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.ctrlKey ? 8 : 0);
        } : function(e) {
          return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
        };
        exports2.getModifierString = function(e) {
          return keys.KEY_MODS[getModifierHash(e)];
        };
        function normalizeCommandKeys(callback, e, keyCode) {
          var hashId = getModifierHash(e);
          if (!useragent.isMac && pressedKeys) {
            if (e.getModifierState && (e.getModifierState("OS") || e.getModifierState("Win")))
              hashId |= 8;
            if (pressedKeys.altGr) {
              if ((3 & hashId) != 3)
                pressedKeys.altGr = 0;
              else
                return;
            }
            if (keyCode === 18 || keyCode === 17) {
              var location = "location" in e ? e.location : e.keyLocation;
              if (keyCode === 17 && location === 1) {
                if (pressedKeys[keyCode] == 1)
                  ts = e.timeStamp;
              } else if (keyCode === 18 && hashId === 3 && location === 2) {
                var dt = e.timeStamp - ts;
                if (dt < 50)
                  pressedKeys.altGr = true;
              }
            }
          }
          if (keyCode in keys.MODIFIER_KEYS) {
            keyCode = -1;
          }
          if (hashId & 8 && (keyCode >= 91 && keyCode <= 93)) {
            keyCode = -1;
          }
          if (!hashId && keyCode === 13) {
            var location = "location" in e ? e.location : e.keyLocation;
            if (location === 3) {
              callback(e, hashId, -keyCode);
              if (e.defaultPrevented)
                return;
            }
          }
          if (useragent.isChromeOS && hashId & 8) {
            callback(e, hashId, keyCode);
            if (e.defaultPrevented)
              return;
            else
              hashId &= ~8;
          }
          if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
            return false;
          }
          return callback(e, hashId, keyCode);
        }
        exports2.addCommandKeyListener = function(el, callback) {
          var addListener = exports2.addListener;
          if (useragent.isOldGecko || useragent.isOpera && !("KeyboardEvent" in window)) {
            var lastKeyDownKeyCode = null;
            addListener(el, "keydown", function(e) {
              lastKeyDownKeyCode = e.keyCode;
            });
            addListener(el, "keypress", function(e) {
              return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
            });
          } else {
            var lastDefaultPrevented = null;
            addListener(el, "keydown", function(e) {
              pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
              var result = normalizeCommandKeys(callback, e, e.keyCode);
              lastDefaultPrevented = e.defaultPrevented;
              return result;
            });
            addListener(el, "keypress", function(e) {
              if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
                exports2.stopEvent(e);
                lastDefaultPrevented = null;
              }
            });
            addListener(el, "keyup", function(e) {
              pressedKeys[e.keyCode] = null;
            });
            if (!pressedKeys) {
              resetPressedKeys();
              addListener(window, "focus", resetPressedKeys);
            }
          }
        };
        function resetPressedKeys() {
          pressedKeys = /* @__PURE__ */ Object.create(null);
        }
        if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
          var postMessageId = 1;
          exports2.nextTick = function(callback, win) {
            win = win || window;
            var messageName = "zero-timeout-message-" + postMessageId;
            exports2.addListener(win, "message", function listener(e) {
              if (e.data == messageName) {
                exports2.stopPropagation(e);
                exports2.removeListener(win, "message", listener);
                callback();
              }
            });
            win.postMessage(messageName, "*");
          };
        }
        exports2.nextFrame = typeof window == "object" && (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame);
        if (exports2.nextFrame)
          exports2.nextFrame = exports2.nextFrame.bind(window);
        else
          exports2.nextFrame = function(callback) {
            setTimeout(callback, 17);
          };
      });
      ace.define("ace/lib/lang", ["require", "exports", "module"], function(acequire, exports2, module2) {
        "use strict";
        exports2.last = function(a) {
          return a[a.length - 1];
        };
        exports2.stringReverse = function(string) {
          return string.split("").reverse().join("");
        };
        exports2.stringRepeat = function(string, count) {
          var result = "";
          while (count > 0) {
            if (count & 1)
              result += string;
            if (count >>= 1)
              string += string;
          }
          return result;
        };
        var trimBeginRegexp = /^\s\s*/;
        var trimEndRegexp = /\s\s*$/;
        exports2.stringTrimLeft = function(string) {
          return string.replace(trimBeginRegexp, "");
        };
        exports2.stringTrimRight = function(string) {
          return string.replace(trimEndRegexp, "");
        };
        exports2.copyObject = function(obj) {
          var copy = {};
          for (var key in obj) {
            copy[key] = obj[key];
          }
          return copy;
        };
        exports2.copyArray = function(array) {
          var copy = [];
          for (var i = 0, l = array.length; i < l; i++) {
            if (array[i] && typeof array[i] == "object")
              copy[i] = this.copyObject(array[i]);
            else
              copy[i] = array[i];
          }
          return copy;
        };
        exports2.deepCopy = function deepCopy(obj) {
          if (typeof obj !== "object" || !obj)
            return obj;
          var copy;
          if (Array.isArray(obj)) {
            copy = [];
            for (var key = 0; key < obj.length; key++) {
              copy[key] = deepCopy(obj[key]);
            }
            return copy;
          }
          if (Object.prototype.toString.call(obj) !== "[object Object]")
            return obj;
          copy = {};
          for (var key in obj)
            copy[key] = deepCopy(obj[key]);
          return copy;
        };
        exports2.arrayToMap = function(arr) {
          var map = {};
          for (var i = 0; i < arr.length; i++) {
            map[arr[i]] = 1;
          }
          return map;
        };
        exports2.createMap = function(props) {
          var map = /* @__PURE__ */ Object.create(null);
          for (var i in props) {
            map[i] = props[i];
          }
          return map;
        };
        exports2.arrayRemove = function(array, value) {
          for (var i = 0; i <= array.length; i++) {
            if (value === array[i]) {
              array.splice(i, 1);
            }
          }
        };
        exports2.escapeRegExp = function(str) {
          return str.replace(/([.*+?^${}()|[\]\/\\])/g, "\\$1");
        };
        exports2.escapeHTML = function(str) {
          return str.replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
        };
        exports2.getMatchOffsets = function(string, regExp) {
          var matches = [];
          string.replace(regExp, function(str) {
            matches.push({
              offset: arguments[arguments.length - 2],
              length: str.length
            });
          });
          return matches;
        };
        exports2.deferredCall = function(fcn) {
          var timer = null;
          var callback = function() {
            timer = null;
            fcn();
          };
          var deferred = function(timeout) {
            deferred.cancel();
            timer = setTimeout(callback, timeout || 0);
            return deferred;
          };
          deferred.schedule = deferred;
          deferred.call = function() {
            this.cancel();
            fcn();
            return deferred;
          };
          deferred.cancel = function() {
            clearTimeout(timer);
            timer = null;
            return deferred;
          };
          deferred.isPending = function() {
            return timer;
          };
          return deferred;
        };
        exports2.delayedCall = function(fcn, defaultTimeout) {
          var timer = null;
          var callback = function() {
            timer = null;
            fcn();
          };
          var _self = function(timeout) {
            if (timer == null)
              timer = setTimeout(callback, timeout || defaultTimeout);
          };
          _self.delay = function(timeout) {
            timer && clearTimeout(timer);
            timer = setTimeout(callback, timeout || defaultTimeout);
          };
          _self.schedule = _self;
          _self.call = function() {
            this.cancel();
            fcn();
          };
          _self.cancel = function() {
            timer && clearTimeout(timer);
            timer = null;
          };
          _self.isPending = function() {
            return timer;
          };
          return _self;
        };
      });
      ace.define("ace/keyboard/textinput_ios", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/lib/dom", "ace/lib/lang", "ace/lib/keys"], function(acequire, exports2, module2) {
        "use strict";
        var event = acequire("../lib/event");
        var useragent = acequire("../lib/useragent");
        var dom = acequire("../lib/dom");
        var lang = acequire("../lib/lang");
        var KEYS = acequire("../lib/keys");
        var MODS = KEYS.KEY_MODS;
        var BROKEN_SETDATA = useragent.isChrome < 18;
        var USE_IE_MIME_TYPE = useragent.isIE;
        var TextInput = function(parentNode, host) {
          var self2 = this;
          var text = dom.createElement("textarea");
          text.className = useragent.isIOS ? "ace_text-input ace_text-input-ios" : "ace_text-input";
          if (useragent.isTouchPad)
            text.setAttribute("x-palm-disable-auto-cap", true);
          text.setAttribute("wrap", "off");
          text.setAttribute("autocorrect", "off");
          text.setAttribute("autocapitalize", "off");
          text.setAttribute("spellcheck", false);
          text.style.opacity = "0";
          parentNode.insertBefore(text, parentNode.firstChild);
          var PLACEHOLDER = "\n aaaa a\n";
          var copied = false;
          var cut = false;
          var pasted = false;
          var inComposition = false;
          var tempStyle = "";
          var isSelectionEmpty = true;
          try {
            var isFocused = document.activeElement === text;
          } catch (e) {
          }
          event.addListener(text, "blur", function(e) {
            host.onBlur(e);
            isFocused = false;
          });
          event.addListener(text, "focus", function(e) {
            isFocused = true;
            host.onFocus(e);
            resetSelection();
          });
          this.focus = function() {
            if (tempStyle)
              return text.focus();
            text.style.position = "fixed";
            text.focus();
          };
          this.blur = function() {
            text.blur();
          };
          this.isFocused = function() {
            return isFocused;
          };
          var syncSelection = lang.delayedCall(function() {
            isFocused && resetSelection(isSelectionEmpty);
          });
          var syncValue = lang.delayedCall(function() {
            if (!inComposition) {
              text.value = PLACEHOLDER;
              isFocused && resetSelection();
            }
          });
          function resetSelection(isEmpty) {
            if (inComposition)
              return;
            inComposition = true;
            if (inputHandler) {
              selectionStart = 0;
              selectionEnd = isEmpty ? 0 : text.value.length - 1;
            } else {
              var selectionStart = 4;
              var selectionEnd = 5;
            }
            try {
              text.setSelectionRange(selectionStart, selectionEnd);
            } catch (e) {
            }
            inComposition = false;
          }
          function resetValue() {
            if (inComposition)
              return;
            text.value = PLACEHOLDER;
            if (useragent.isWebKit)
              syncValue.schedule();
          }
          useragent.isWebKit || host.addEventListener("changeSelection", function() {
            if (host.selection.isEmpty() != isSelectionEmpty) {
              isSelectionEmpty = !isSelectionEmpty;
              syncSelection.schedule();
            }
          });
          resetValue();
          if (isFocused)
            host.onFocus();
          var isAllSelected = function(text2) {
            return text2.selectionStart === 0 && text2.selectionEnd === text2.value.length;
          };
          var onSelect = function(e) {
            if (isAllSelected(text)) {
              host.selectAll();
              resetSelection();
            } else if (inputHandler) {
              resetSelection(host.selection.isEmpty());
            }
          };
          var inputHandler = null;
          this.setInputHandler = function(cb) {
            inputHandler = cb;
          };
          this.getInputHandler = function() {
            return inputHandler;
          };
          var afterContextMenu = false;
          var sendText = function(data) {
            if (text.selectionStart === 4 && text.selectionEnd === 5) {
              return;
            }
            if (inputHandler) {
              data = inputHandler(data);
              inputHandler = null;
            }
            if (pasted) {
              resetSelection();
              if (data)
                host.onPaste(data);
              pasted = false;
            } else if (data == PLACEHOLDER.substr(0) && text.selectionStart === 4) {
              if (afterContextMenu)
                host.execCommand("del", { source: "ace" });
              else
                host.execCommand("backspace", { source: "ace" });
            } else if (!copied) {
              if (data.substring(0, 9) == PLACEHOLDER && data.length > PLACEHOLDER.length)
                data = data.substr(9);
              else if (data.substr(0, 4) == PLACEHOLDER.substr(0, 4))
                data = data.substr(4, data.length - PLACEHOLDER.length + 1);
              else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
                data = data.slice(0, -1);
              if (data == PLACEHOLDER.charAt(0)) {
              } else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
                data = data.slice(0, -1);
              if (data)
                host.onTextInput(data);
            }
            if (copied) {
              copied = false;
            }
            if (afterContextMenu)
              afterContextMenu = false;
          };
          var onInput = function(e) {
            if (inComposition)
              return;
            var data = text.value;
            sendText(data);
            resetValue();
          };
          var handleClipboardData = function(e, data, forceIEMime) {
            var clipboardData = e.clipboardData || window.clipboardData;
            if (!clipboardData || BROKEN_SETDATA)
              return;
            var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
            try {
              if (data) {
                return clipboardData.setData(mime, data) !== false;
              } else {
                return clipboardData.getData(mime);
              }
            } catch (e2) {
              if (!forceIEMime)
                return handleClipboardData(e2, data, true);
            }
          };
          var doCopy = function(e, isCut) {
            var data = host.getCopyText();
            if (!data)
              return event.preventDefault(e);
            if (handleClipboardData(e, data)) {
              if (useragent.isIOS) {
                cut = isCut;
                text.value = "\n aa" + data + "a a\n";
                text.setSelectionRange(4, 4 + data.length);
                copied = {
                  value: data
                };
              }
              isCut ? host.onCut() : host.onCopy();
              if (!useragent.isIOS)
                event.preventDefault(e);
            } else {
              copied = true;
              text.value = data;
              text.select();
              setTimeout(function() {
                copied = false;
                resetValue();
                resetSelection();
                isCut ? host.onCut() : host.onCopy();
              });
            }
          };
          var onCut = function(e) {
            doCopy(e, true);
          };
          var onCopy = function(e) {
            doCopy(e, false);
          };
          var onPaste = function(e) {
            var data = handleClipboardData(e);
            if (typeof data == "string") {
              if (data)
                host.onPaste(data, e);
              if (useragent.isIE)
                setTimeout(resetSelection);
              event.preventDefault(e);
            } else {
              text.value = "";
              pasted = true;
            }
          };
          event.addCommandKeyListener(text, host.onCommandKey.bind(host));
          event.addListener(text, "select", onSelect);
          event.addListener(text, "input", onInput);
          event.addListener(text, "cut", onCut);
          event.addListener(text, "copy", onCopy);
          event.addListener(text, "paste", onPaste);
          var onCompositionStart = function(e) {
            if (inComposition || !host.onCompositionStart || host.$readOnly)
              return;
            inComposition = {};
            inComposition.canUndo = host.session.$undoManager;
            host.onCompositionStart();
            setTimeout(onCompositionUpdate, 0);
            host.on("mousedown", onCompositionEnd);
            if (inComposition.canUndo && !host.selection.isEmpty()) {
              host.insert("");
              host.session.markUndoGroup();
              host.selection.clearSelection();
            }
            host.session.markUndoGroup();
          };
          var onCompositionUpdate = function() {
            if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
              return;
            var val = text.value.replace(/\x01/g, "");
            if (inComposition.lastValue === val)
              return;
            host.onCompositionUpdate(val);
            if (inComposition.lastValue)
              host.undo();
            if (inComposition.canUndo)
              inComposition.lastValue = val;
            if (inComposition.lastValue) {
              var r = host.selection.getRange();
              host.insert(inComposition.lastValue);
              host.session.markUndoGroup();
              inComposition.range = host.selection.getRange();
              host.selection.setRange(r);
              host.selection.clearSelection();
            }
          };
          var onCompositionEnd = function(e) {
            if (!host.onCompositionEnd || host.$readOnly)
              return;
            var c = inComposition;
            inComposition = false;
            var timer = setTimeout(function() {
              timer = null;
              var str = text.value.replace(/\x01/g, "");
              if (inComposition)
                return;
              else if (str == c.lastValue)
                resetValue();
              else if (!c.lastValue && str) {
                resetValue();
                sendText(str);
              }
            });
            inputHandler = function compositionInputHandler(str) {
              if (timer)
                clearTimeout(timer);
              str = str.replace(/\x01/g, "");
              if (str == c.lastValue)
                return "";
              if (c.lastValue && timer)
                host.undo();
              return str;
            };
            host.onCompositionEnd();
            host.removeListener("mousedown", onCompositionEnd);
            if (e.type == "compositionend" && c.range) {
              host.selection.setRange(c.range);
            }
            var needsOnInput = !!useragent.isChrome && useragent.isChrome >= 53 || !!useragent.isWebKit && useragent.isWebKit >= 603;
            if (needsOnInput) {
              onInput();
            }
          };
          var syncComposition = lang.delayedCall(onCompositionUpdate, 50);
          event.addListener(text, "compositionstart", onCompositionStart);
          if (useragent.isGecko) {
            event.addListener(text, "text", function() {
              syncComposition.schedule();
            });
          } else {
            event.addListener(text, "keyup", function() {
              syncComposition.schedule();
            });
            event.addListener(text, "keydown", function() {
              syncComposition.schedule();
            });
          }
          event.addListener(text, "compositionend", onCompositionEnd);
          this.getElement = function() {
            return text;
          };
          this.setReadOnly = function(readOnly) {
            text.readOnly = readOnly;
          };
          this.onContextMenu = function(e) {
            afterContextMenu = true;
            resetSelection(host.selection.isEmpty());
            host._emit("nativecontextmenu", { target: host, domEvent: e });
            this.moveToMouse(e, true);
          };
          this.moveToMouse = function(e, bringToFront) {
            if (!tempStyle)
              tempStyle = text.style.cssText;
            text.style.cssText = (bringToFront ? "z-index:100000;" : "") + "height:" + text.style.height + ";" + (useragent.isIE ? "opacity:0.1;" : "");
            var rect = host.container.getBoundingClientRect();
            var style = dom.computedStyle(host.container);
            var top = rect.top + (parseInt(style.borderTopWidth) || 0);
            var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
            var maxTop = rect.bottom - top - text.clientHeight - 2;
            var move = function(e2) {
              text.style.left = e2.clientX - left - 2 + "px";
              text.style.top = Math.min(e2.clientY - top - 2, maxTop) + "px";
            };
            move(e);
            if (e.type != "mousedown")
              return;
            if (host.renderer.$keepTextAreaAtCursor)
              host.renderer.$keepTextAreaAtCursor = null;
            clearTimeout(closeTimeout);
            if (useragent.isWin)
              event.capture(host.container, move, onContextMenuClose);
          };
          this.onContextMenuClose = onContextMenuClose;
          var closeTimeout;
          function onContextMenuClose() {
            clearTimeout(closeTimeout);
            closeTimeout = setTimeout(function() {
              if (tempStyle) {
                text.style.cssText = tempStyle;
                tempStyle = "";
              }
              if (host.renderer.$keepTextAreaAtCursor == null) {
                host.renderer.$keepTextAreaAtCursor = true;
                host.renderer.$moveTextAreaToCursor();
              }
            }, 0);
          }
          var onContextMenu = function(e) {
            host.textInput.onContextMenu(e);
            onContextMenuClose();
          };
          event.addListener(text, "mouseup", onContextMenu);
          event.addListener(text, "mousedown", function(e) {
            e.preventDefault();
            onContextMenuClose();
          });
          event.addListener(host.renderer.scroller, "contextmenu", onContextMenu);
          event.addListener(text, "contextmenu", onContextMenu);
          if (useragent.isIOS) {
            var typingResetTimeout = null;
            var typing = false;
            parentNode.addEventListener("keydown", function(e) {
              if (typingResetTimeout)
                clearTimeout(typingResetTimeout);
              typing = true;
            });
            parentNode.addEventListener("keyup", function(e) {
              typingResetTimeout = setTimeout(function() {
                typing = false;
              }, 100);
            });
            var detectArrowKeys = function(e) {
              if (document.activeElement !== text)
                return;
              if (typing)
                return;
              if (cut) {
                return setTimeout(function() {
                  cut = false;
                }, 100);
              }
              var selectionStart = text.selectionStart;
              var selectionEnd = text.selectionEnd;
              text.setSelectionRange(4, 5);
              if (selectionStart == selectionEnd) {
                switch (selectionStart) {
                  case 0:
                    host.onCommandKey(null, 0, KEYS.up);
                    break;
                  case 1:
                    host.onCommandKey(null, 0, KEYS.home);
                    break;
                  case 2:
                    host.onCommandKey(null, MODS.option, KEYS.left);
                    break;
                  case 4:
                    host.onCommandKey(null, 0, KEYS.left);
                    break;
                  case 5:
                    host.onCommandKey(null, 0, KEYS.right);
                    break;
                  case 7:
                    host.onCommandKey(null, MODS.option, KEYS.right);
                    break;
                  case 8:
                    host.onCommandKey(null, 0, KEYS.end);
                    break;
                  case 9:
                    host.onCommandKey(null, 0, KEYS.down);
                    break;
                }
              } else {
                switch (selectionEnd) {
                  case 6:
                    host.onCommandKey(null, MODS.shift, KEYS.right);
                    break;
                  case 7:
                    host.onCommandKey(null, MODS.shift | MODS.option, KEYS.right);
                    break;
                  case 8:
                    host.onCommandKey(null, MODS.shift, KEYS.end);
                    break;
                  case 9:
                    host.onCommandKey(null, MODS.shift, KEYS.down);
                    break;
                }
                switch (selectionStart) {
                  case 0:
                    host.onCommandKey(null, MODS.shift, KEYS.up);
                    break;
                  case 1:
                    host.onCommandKey(null, MODS.shift, KEYS.home);
                    break;
                  case 2:
                    host.onCommandKey(null, MODS.shift | MODS.option, KEYS.left);
                    break;
                  case 3:
                    host.onCommandKey(null, MODS.shift, KEYS.left);
                    break;
                }
              }
            };
            document.addEventListener("selectionchange", detectArrowKeys);
            host.on("destroy", function() {
              document.removeEventListener("selectionchange", detectArrowKeys);
            });
          }
        };
        exports2.TextInput = TextInput;
      });
      ace.define("ace/keyboard/textinput", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/lib/dom", "ace/lib/lang", "ace/keyboard/textinput_ios"], function(acequire, exports2, module2) {
        "use strict";
        var event = acequire("../lib/event");
        var useragent = acequire("../lib/useragent");
        var dom = acequire("../lib/dom");
        var lang = acequire("../lib/lang");
        var BROKEN_SETDATA = useragent.isChrome < 18;
        var USE_IE_MIME_TYPE = useragent.isIE;
        var TextInputIOS = acequire("./textinput_ios").TextInput;
        var TextInput = function(parentNode, host) {
          if (useragent.isIOS)
            return TextInputIOS.call(this, parentNode, host);
          var text = dom.createElement("textarea");
          text.className = "ace_text-input";
          text.setAttribute("wrap", "off");
          text.setAttribute("autocorrect", "off");
          text.setAttribute("autocapitalize", "off");
          text.setAttribute("spellcheck", false);
          text.style.opacity = "0";
          parentNode.insertBefore(text, parentNode.firstChild);
          var PLACEHOLDER = "\u2028\u2028";
          var copied = false;
          var pasted = false;
          var inComposition = false;
          var tempStyle = "";
          var isSelectionEmpty = true;
          try {
            var isFocused = document.activeElement === text;
          } catch (e) {
          }
          event.addListener(text, "blur", function(e) {
            host.onBlur(e);
            isFocused = false;
          });
          event.addListener(text, "focus", function(e) {
            isFocused = true;
            host.onFocus(e);
            resetSelection();
          });
          this.focus = function() {
            if (tempStyle)
              return text.focus();
            var top = text.style.top;
            text.style.position = "fixed";
            text.style.top = "0px";
            text.focus();
            setTimeout(function() {
              text.style.position = "";
              if (text.style.top == "0px")
                text.style.top = top;
            }, 0);
          };
          this.blur = function() {
            text.blur();
          };
          this.isFocused = function() {
            return isFocused;
          };
          var syncSelection = lang.delayedCall(function() {
            isFocused && resetSelection(isSelectionEmpty);
          });
          var syncValue = lang.delayedCall(function() {
            if (!inComposition) {
              text.value = PLACEHOLDER;
              isFocused && resetSelection();
            }
          });
          function resetSelection(isEmpty) {
            if (inComposition)
              return;
            inComposition = true;
            if (inputHandler) {
              var selectionStart = 0;
              var selectionEnd = isEmpty ? 0 : text.value.length - 1;
            } else {
              var selectionStart = isEmpty ? 2 : 1;
              var selectionEnd = 2;
            }
            try {
              text.setSelectionRange(selectionStart, selectionEnd);
            } catch (e) {
            }
            inComposition = false;
          }
          function resetValue() {
            if (inComposition)
              return;
            text.value = PLACEHOLDER;
            if (useragent.isWebKit)
              syncValue.schedule();
          }
          useragent.isWebKit || host.addEventListener("changeSelection", function() {
            if (host.selection.isEmpty() != isSelectionEmpty) {
              isSelectionEmpty = !isSelectionEmpty;
              syncSelection.schedule();
            }
          });
          resetValue();
          if (isFocused)
            host.onFocus();
          var isAllSelected = function(text2) {
            return text2.selectionStart === 0 && text2.selectionEnd === text2.value.length;
          };
          var onSelect = function(e) {
            if (copied) {
              copied = false;
            } else if (isAllSelected(text)) {
              host.selectAll();
              resetSelection();
            } else if (inputHandler) {
              resetSelection(host.selection.isEmpty());
            }
          };
          var inputHandler = null;
          this.setInputHandler = function(cb) {
            inputHandler = cb;
          };
          this.getInputHandler = function() {
            return inputHandler;
          };
          var afterContextMenu = false;
          var sendText = function(data) {
            if (inputHandler) {
              data = inputHandler(data);
              inputHandler = null;
            }
            if (pasted) {
              resetSelection();
              if (data)
                host.onPaste(data);
              pasted = false;
            } else if (data == PLACEHOLDER.charAt(0)) {
              if (afterContextMenu)
                host.execCommand("del", { source: "ace" });
              else
                host.execCommand("backspace", { source: "ace" });
            } else {
              if (data.substring(0, 2) == PLACEHOLDER)
                data = data.substr(2);
              else if (data.charAt(0) == PLACEHOLDER.charAt(0))
                data = data.substr(1);
              else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
                data = data.slice(0, -1);
              if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
                data = data.slice(0, -1);
              if (data)
                host.onTextInput(data);
            }
            if (afterContextMenu)
              afterContextMenu = false;
          };
          var onInput = function(e) {
            if (inComposition)
              return;
            var data = text.value;
            sendText(data);
            resetValue();
          };
          var handleClipboardData = function(e, data, forceIEMime) {
            var clipboardData = e.clipboardData || window.clipboardData;
            if (!clipboardData || BROKEN_SETDATA)
              return;
            var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
            try {
              if (data) {
                return clipboardData.setData(mime, data) !== false;
              } else {
                return clipboardData.getData(mime);
              }
            } catch (e2) {
              if (!forceIEMime)
                return handleClipboardData(e2, data, true);
            }
          };
          var doCopy = function(e, isCut) {
            var data = host.getCopyText();
            if (!data)
              return event.preventDefault(e);
            if (handleClipboardData(e, data)) {
              isCut ? host.onCut() : host.onCopy();
              event.preventDefault(e);
            } else {
              copied = true;
              text.value = data;
              text.select();
              setTimeout(function() {
                copied = false;
                resetValue();
                resetSelection();
                isCut ? host.onCut() : host.onCopy();
              });
            }
          };
          var onCut = function(e) {
            doCopy(e, true);
          };
          var onCopy = function(e) {
            doCopy(e, false);
          };
          var onPaste = function(e) {
            var data = handleClipboardData(e);
            if (typeof data == "string") {
              if (data)
                host.onPaste(data, e);
              if (useragent.isIE)
                setTimeout(resetSelection);
              event.preventDefault(e);
            } else {
              text.value = "";
              pasted = true;
            }
          };
          event.addCommandKeyListener(text, host.onCommandKey.bind(host));
          event.addListener(text, "select", onSelect);
          event.addListener(text, "input", onInput);
          event.addListener(text, "cut", onCut);
          event.addListener(text, "copy", onCopy);
          event.addListener(text, "paste", onPaste);
          if (!("oncut" in text) || !("oncopy" in text) || !("onpaste" in text)) {
            event.addListener(parentNode, "keydown", function(e) {
              if (useragent.isMac && !e.metaKey || !e.ctrlKey)
                return;
              switch (e.keyCode) {
                case 67:
                  onCopy(e);
                  break;
                case 86:
                  onPaste(e);
                  break;
                case 88:
                  onCut(e);
                  break;
              }
            });
          }
          var onCompositionStart = function(e) {
            if (inComposition || !host.onCompositionStart || host.$readOnly)
              return;
            inComposition = {};
            inComposition.canUndo = host.session.$undoManager;
            host.onCompositionStart();
            setTimeout(onCompositionUpdate, 0);
            host.on("mousedown", onCompositionEnd);
            if (inComposition.canUndo && !host.selection.isEmpty()) {
              host.insert("");
              host.session.markUndoGroup();
              host.selection.clearSelection();
            }
            host.session.markUndoGroup();
          };
          var onCompositionUpdate = function() {
            if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
              return;
            var val = text.value.replace(/\u2028/g, "");
            if (inComposition.lastValue === val)
              return;
            host.onCompositionUpdate(val);
            if (inComposition.lastValue)
              host.undo();
            if (inComposition.canUndo)
              inComposition.lastValue = val;
            if (inComposition.lastValue) {
              var r = host.selection.getRange();
              host.insert(inComposition.lastValue);
              host.session.markUndoGroup();
              inComposition.range = host.selection.getRange();
              host.selection.setRange(r);
              host.selection.clearSelection();
            }
          };
          var onCompositionEnd = function(e) {
            if (!host.onCompositionEnd || host.$readOnly)
              return;
            var c = inComposition;
            inComposition = false;
            var timer = setTimeout(function() {
              timer = null;
              var str = text.value.replace(/\u2028/g, "");
              if (inComposition)
                return;
              else if (str == c.lastValue)
                resetValue();
              else if (!c.lastValue && str) {
                resetValue();
                sendText(str);
              }
            });
            inputHandler = function compositionInputHandler(str) {
              if (timer)
                clearTimeout(timer);
              str = str.replace(/\u2028/g, "");
              if (str == c.lastValue)
                return "";
              if (c.lastValue && timer)
                host.undo();
              return str;
            };
            host.onCompositionEnd();
            host.removeListener("mousedown", onCompositionEnd);
            if (e.type == "compositionend" && c.range) {
              host.selection.setRange(c.range);
            }
            var needsOnInput = !!useragent.isChrome && useragent.isChrome >= 53 || !!useragent.isWebKit && useragent.isWebKit >= 603;
            if (needsOnInput) {
              onInput();
            }
          };
          var syncComposition = lang.delayedCall(onCompositionUpdate, 50);
          event.addListener(text, "compositionstart", onCompositionStart);
          if (useragent.isGecko) {
            event.addListener(text, "text", function() {
              syncComposition.schedule();
            });
          } else {
            event.addListener(text, "keyup", function() {
              syncComposition.schedule();
            });
            event.addListener(text, "keydown", function() {
              syncComposition.schedule();
            });
          }
          event.addListener(text, "compositionend", onCompositionEnd);
          this.getElement = function() {
            return text;
          };
          this.setReadOnly = function(readOnly) {
            text.readOnly = readOnly;
          };
          this.onContextMenu = function(e) {
            afterContextMenu = true;
            resetSelection(host.selection.isEmpty());
            host._emit("nativecontextmenu", { target: host, domEvent: e });
            this.moveToMouse(e, true);
          };
          this.moveToMouse = function(e, bringToFront) {
            if (!tempStyle)
              tempStyle = text.style.cssText;
            text.style.cssText = (bringToFront ? "z-index:100000;" : "") + "height:" + text.style.height + ";" + (useragent.isIE ? "opacity:0.1;" : "");
            var rect = host.container.getBoundingClientRect();
            var style = dom.computedStyle(host.container);
            var top = rect.top + (parseInt(style.borderTopWidth) || 0);
            var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
            var maxTop = rect.bottom - top - text.clientHeight - 2;
            var move = function(e2) {
              text.style.left = e2.clientX - left - 2 + "px";
              text.style.top = Math.min(e2.clientY - top - 2, maxTop) + "px";
            };
            move(e);
            if (e.type != "mousedown")
              return;
            if (host.renderer.$keepTextAreaAtCursor)
              host.renderer.$keepTextAreaAtCursor = null;
            clearTimeout(closeTimeout);
            if (useragent.isWin)
              event.capture(host.container, move, onContextMenuClose);
          };
          this.onContextMenuClose = onContextMenuClose;
          var closeTimeout;
          function onContextMenuClose() {
            clearTimeout(closeTimeout);
            closeTimeout = setTimeout(function() {
              if (tempStyle) {
                text.style.cssText = tempStyle;
                tempStyle = "";
              }
              if (host.renderer.$keepTextAreaAtCursor == null) {
                host.renderer.$keepTextAreaAtCursor = true;
                host.renderer.$moveTextAreaToCursor();
              }
            }, 0);
          }
          var onContextMenu = function(e) {
            host.textInput.onContextMenu(e);
            onContextMenuClose();
          };
          event.addListener(text, "mouseup", onContextMenu);
          event.addListener(text, "mousedown", function(e) {
            e.preventDefault();
            onContextMenuClose();
          });
          event.addListener(host.renderer.scroller, "contextmenu", onContextMenu);
          event.addListener(text, "contextmenu", onContextMenu);
        };
        exports2.TextInput = TextInput;
      });
      ace.define("ace/mouse/default_handlers", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/lib/useragent"], function(acequire, exports2, module2) {
        "use strict";
        var dom = acequire("../lib/dom");
        var event = acequire("../lib/event");
        var useragent = acequire("../lib/useragent");
        var DRAG_OFFSET = 0;
        var SCROLL_COOLDOWN_T = 250;
        function DefaultHandlers(mouseHandler) {
          mouseHandler.$clickSelection = null;
          var editor = mouseHandler.editor;
          editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
          editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
          editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
          editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
          editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
          editor.setDefaultHandler("touchmove", this.onTouchMove.bind(mouseHandler));
          var exports3 = [
            "select",
            "startSelect",
            "selectEnd",
            "selectAllEnd",
            "selectByWordsEnd",
            "selectByLinesEnd",
            "dragWait",
            "dragWaitEnd",
            "focusWait"
          ];
          exports3.forEach(function(x) {
            mouseHandler[x] = this[x];
          }, this);
          mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
          mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
        }
        (function() {
          this.onMouseDown = function(ev) {
            var inSelection = ev.inSelection();
            var pos = ev.getDocumentPosition();
            this.mousedownEvent = ev;
            var editor = this.editor;
            var button = ev.getButton();
            if (button !== 0) {
              var selectionRange = editor.getSelectionRange();
              var selectionEmpty = selectionRange.isEmpty();
              editor.$blockScrolling++;
              if (selectionEmpty || button == 1)
                editor.selection.moveToPosition(pos);
              editor.$blockScrolling--;
              if (button == 2) {
                editor.textInput.onContextMenu(ev.domEvent);
                if (!useragent.isMozilla)
                  ev.preventDefault();
              }
              return;
            }
            this.mousedownEvent.time = Date.now();
            if (inSelection && !editor.isFocused()) {
              editor.focus();
              if (this.$focusTimout && !this.$clickSelection && !editor.inMultiSelectMode) {
                this.setState("focusWait");
                this.captureMouse(ev);
                return;
              }
            }
            this.captureMouse(ev);
            this.startSelect(pos, ev.domEvent._clicks > 1);
            return ev.preventDefault();
          };
          this.startSelect = function(pos, waitForClickSelection) {
            pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
            var editor = this.editor;
            editor.$blockScrolling++;
            if (this.mousedownEvent.getShiftKey())
              editor.selection.selectToPosition(pos);
            else if (!waitForClickSelection)
              editor.selection.moveToPosition(pos);
            if (!waitForClickSelection)
              this.select();
            if (editor.renderer.scroller.setCapture) {
              editor.renderer.scroller.setCapture();
            }
            editor.setStyle("ace_selecting");
            this.setState("select");
            editor.$blockScrolling--;
          };
          this.select = function() {
            var anchor, editor = this.editor;
            var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
            editor.$blockScrolling++;
            if (this.$clickSelection) {
              var cmp = this.$clickSelection.comparePoint(cursor);
              if (cmp == -1) {
                anchor = this.$clickSelection.end;
              } else if (cmp == 1) {
                anchor = this.$clickSelection.start;
              } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
              }
              editor.selection.setSelectionAnchor(anchor.row, anchor.column);
            }
            editor.selection.selectToPosition(cursor);
            editor.$blockScrolling--;
            editor.renderer.scrollCursorIntoView();
          };
          this.extendSelectionBy = function(unitName) {
            var anchor, editor = this.editor;
            var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
            var range = editor.selection[unitName](cursor.row, cursor.column);
            editor.$blockScrolling++;
            if (this.$clickSelection) {
              var cmpStart = this.$clickSelection.comparePoint(range.start);
              var cmpEnd = this.$clickSelection.comparePoint(range.end);
              if (cmpStart == -1 && cmpEnd <= 0) {
                anchor = this.$clickSelection.end;
                if (range.end.row != cursor.row || range.end.column != cursor.column)
                  cursor = range.start;
              } else if (cmpEnd == 1 && cmpStart >= 0) {
                anchor = this.$clickSelection.start;
                if (range.start.row != cursor.row || range.start.column != cursor.column)
                  cursor = range.end;
              } else if (cmpStart == -1 && cmpEnd == 1) {
                cursor = range.end;
                anchor = range.start;
              } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
              }
              editor.selection.setSelectionAnchor(anchor.row, anchor.column);
            }
            editor.selection.selectToPosition(cursor);
            editor.$blockScrolling--;
            editor.renderer.scrollCursorIntoView();
          };
          this.selectEnd = this.selectAllEnd = this.selectByWordsEnd = this.selectByLinesEnd = function() {
            this.$clickSelection = null;
            this.editor.unsetStyle("ace_selecting");
            if (this.editor.renderer.scroller.releaseCapture) {
              this.editor.renderer.scroller.releaseCapture();
            }
          };
          this.focusWait = function() {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            var time = Date.now();
            if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimout)
              this.startSelect(this.mousedownEvent.getDocumentPosition());
          };
          this.onDoubleClick = function(ev) {
            var pos = ev.getDocumentPosition();
            var editor = this.editor;
            var session = editor.session;
            var range = session.getBracketRange(pos);
            if (range) {
              if (range.isEmpty()) {
                range.start.column--;
                range.end.column++;
              }
              this.setState("select");
            } else {
              range = editor.selection.getWordRange(pos.row, pos.column);
              this.setState("selectByWords");
            }
            this.$clickSelection = range;
            this.select();
          };
          this.onTripleClick = function(ev) {
            var pos = ev.getDocumentPosition();
            var editor = this.editor;
            this.setState("selectByLines");
            var range = editor.getSelectionRange();
            if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
              this.$clickSelection = editor.selection.getLineRange(range.start.row);
              this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
            } else {
              this.$clickSelection = editor.selection.getLineRange(pos.row);
            }
            this.select();
          };
          this.onQuadClick = function(ev) {
            var editor = this.editor;
            editor.selectAll();
            this.$clickSelection = editor.getSelectionRange();
            this.setState("selectAll");
          };
          this.onMouseWheel = function(ev) {
            if (ev.getAccelKey())
              return;
            if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
              ev.wheelX = ev.wheelY;
              ev.wheelY = 0;
            }
            var editor = this.editor;
            if (!this.$lastScroll)
              this.$lastScroll = { t: 0, vx: 0, vy: 0, allowed: 0 };
            var prevScroll = this.$lastScroll;
            var t = ev.domEvent.timeStamp;
            var dt = t - prevScroll.t;
            var vx = ev.wheelX / dt;
            var vy = ev.wheelY / dt;
            if (dt < SCROLL_COOLDOWN_T) {
              vx = (vx + prevScroll.vx) / 2;
              vy = (vy + prevScroll.vy) / 2;
            }
            var direction = Math.abs(vx / vy);
            var canScroll = false;
            if (direction >= 1 && editor.renderer.isScrollableBy(ev.wheelX * ev.speed, 0))
              canScroll = true;
            if (direction <= 1 && editor.renderer.isScrollableBy(0, ev.wheelY * ev.speed))
              canScroll = true;
            if (canScroll) {
              prevScroll.allowed = t;
            } else if (t - prevScroll.allowed < SCROLL_COOLDOWN_T) {
              var isSlower = Math.abs(vx) <= 1.1 * Math.abs(prevScroll.vx) && Math.abs(vy) <= 1.1 * Math.abs(prevScroll.vy);
              if (isSlower) {
                canScroll = true;
                prevScroll.allowed = t;
              } else {
                prevScroll.allowed = 0;
              }
            }
            prevScroll.t = t;
            prevScroll.vx = vx;
            prevScroll.vy = vy;
            if (canScroll) {
              editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
              return ev.stop();
            }
          };
          this.onTouchMove = function(ev) {
            this.editor._emit("mousewheel", ev);
          };
        }).call(DefaultHandlers.prototype);
        exports2.DefaultHandlers = DefaultHandlers;
        function calcDistance(ax, ay, bx, by) {
          return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
        }
        function calcRangeOrientation(range, cursor) {
          if (range.start.row == range.end.row)
            var cmp = 2 * cursor.column - range.start.column - range.end.column;
          else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
            var cmp = cursor.column - 4;
          else
            var cmp = 2 * cursor.row - range.start.row - range.end.row;
          if (cmp < 0)
            return { cursor: range.start, anchor: range.end };
          else
            return { cursor: range.end, anchor: range.start };
        }
      });
      ace.define("ace/tooltip", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("./lib/oop");
        var dom = acequire("./lib/dom");
        function Tooltip(parentNode) {
          this.isOpen = false;
          this.$element = null;
          this.$parentNode = parentNode;
        }
        (function() {
          this.$init = function() {
            this.$element = dom.createElement("div");
            this.$element.className = "ace_tooltip";
            this.$element.style.display = "none";
            this.$parentNode.appendChild(this.$element);
            return this.$element;
          };
          this.getElement = function() {
            return this.$element || this.$init();
          };
          this.setText = function(text) {
            dom.setInnerText(this.getElement(), text);
          };
          this.setHtml = function(html) {
            this.getElement().innerHTML = html;
          };
          this.setPosition = function(x, y) {
            this.getElement().style.left = x + "px";
            this.getElement().style.top = y + "px";
          };
          this.setClassName = function(className) {
            dom.addCssClass(this.getElement(), className);
          };
          this.show = function(text, x, y) {
            if (text != null)
              this.setText(text);
            if (x != null && y != null)
              this.setPosition(x, y);
            if (!this.isOpen) {
              this.getElement().style.display = "block";
              this.isOpen = true;
            }
          };
          this.hide = function() {
            if (this.isOpen) {
              this.getElement().style.display = "none";
              this.isOpen = false;
            }
          };
          this.getHeight = function() {
            return this.getElement().offsetHeight;
          };
          this.getWidth = function() {
            return this.getElement().offsetWidth;
          };
          this.destroy = function() {
            this.isOpen = false;
            if (this.$element && this.$element.parentNode) {
              this.$element.parentNode.removeChild(this.$element);
            }
          };
        }).call(Tooltip.prototype);
        exports2.Tooltip = Tooltip;
      });
      ace.define("ace/mouse/default_gutter_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/event", "ace/tooltip"], function(acequire, exports2, module2) {
        "use strict";
        var dom = acequire("../lib/dom");
        var oop = acequire("../lib/oop");
        var event = acequire("../lib/event");
        var Tooltip = acequire("../tooltip").Tooltip;
        function GutterHandler(mouseHandler) {
          var editor = mouseHandler.editor;
          var gutter = editor.renderer.$gutterLayer;
          var tooltip = new GutterTooltip(editor.container);
          mouseHandler.editor.setDefaultHandler("guttermousedown", function(e) {
            if (!editor.isFocused() || e.getButton() != 0)
              return;
            var gutterRegion = gutter.getRegion(e);
            if (gutterRegion == "foldWidgets")
              return;
            var row = e.getDocumentPosition().row;
            var selection = editor.session.selection;
            if (e.getShiftKey())
              selection.selectTo(row, 0);
            else {
              if (e.domEvent.detail == 2) {
                editor.selectAll();
                return e.preventDefault();
              }
              mouseHandler.$clickSelection = editor.selection.getLineRange(row);
            }
            mouseHandler.setState("selectByLines");
            mouseHandler.captureMouse(e);
            return e.preventDefault();
          });
          var tooltipTimeout, mouseEvent, tooltipAnnotation;
          function showTooltip() {
            var row = mouseEvent.getDocumentPosition().row;
            var annotation = gutter.$annotations[row];
            if (!annotation)
              return hideTooltip();
            var maxRow = editor.session.getLength();
            if (row == maxRow) {
              var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
              var pos = mouseEvent.$pos;
              if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))
                return hideTooltip();
            }
            if (tooltipAnnotation == annotation)
              return;
            tooltipAnnotation = annotation.text.join("<br/>");
            tooltip.setHtml(tooltipAnnotation);
            tooltip.show();
            editor._signal("showGutterTooltip", tooltip);
            editor.on("mousewheel", hideTooltip);
            if (mouseHandler.$tooltipFollowsMouse) {
              moveTooltip(mouseEvent);
            } else {
              var gutterElement = mouseEvent.domEvent.target;
              var rect = gutterElement.getBoundingClientRect();
              var style = tooltip.getElement().style;
              style.left = rect.right + "px";
              style.top = rect.bottom + "px";
            }
          }
          function hideTooltip() {
            if (tooltipTimeout)
              tooltipTimeout = clearTimeout(tooltipTimeout);
            if (tooltipAnnotation) {
              tooltip.hide();
              tooltipAnnotation = null;
              editor._signal("hideGutterTooltip", tooltip);
              editor.removeEventListener("mousewheel", hideTooltip);
            }
          }
          function moveTooltip(e) {
            tooltip.setPosition(e.x, e.y);
          }
          mouseHandler.editor.setDefaultHandler("guttermousemove", function(e) {
            var target = e.domEvent.target || e.domEvent.srcElement;
            if (dom.hasCssClass(target, "ace_fold-widget"))
              return hideTooltip();
            if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse)
              moveTooltip(e);
            mouseEvent = e;
            if (tooltipTimeout)
              return;
            tooltipTimeout = setTimeout(function() {
              tooltipTimeout = null;
              if (mouseEvent && !mouseHandler.isMousePressed)
                showTooltip();
              else
                hideTooltip();
            }, 50);
          });
          event.addListener(editor.renderer.$gutter, "mouseout", function(e) {
            mouseEvent = null;
            if (!tooltipAnnotation || tooltipTimeout)
              return;
            tooltipTimeout = setTimeout(function() {
              tooltipTimeout = null;
              hideTooltip();
            }, 50);
          });
          editor.on("changeSession", hideTooltip);
        }
        function GutterTooltip(parentNode) {
          Tooltip.call(this, parentNode);
        }
        oop.inherits(GutterTooltip, Tooltip);
        (function() {
          this.setPosition = function(x, y) {
            var windowWidth = window.innerWidth || document.documentElement.clientWidth;
            var windowHeight = window.innerHeight || document.documentElement.clientHeight;
            var width = this.getWidth();
            var height = this.getHeight();
            x += 15;
            y += 15;
            if (x + width > windowWidth) {
              x -= x + width - windowWidth;
            }
            if (y + height > windowHeight) {
              y -= 20 + height;
            }
            Tooltip.prototype.setPosition.call(this, x, y);
          };
        }).call(GutterTooltip.prototype);
        exports2.GutterHandler = GutterHandler;
      });
      ace.define("ace/mouse/mouse_event", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function(acequire, exports2, module2) {
        "use strict";
        var event = acequire("../lib/event");
        var useragent = acequire("../lib/useragent");
        var MouseEvent2 = exports2.MouseEvent = function(domEvent, editor) {
          this.domEvent = domEvent;
          this.editor = editor;
          this.x = this.clientX = domEvent.clientX;
          this.y = this.clientY = domEvent.clientY;
          this.$pos = null;
          this.$inSelection = null;
          this.propagationStopped = false;
          this.defaultPrevented = false;
        };
        (function() {
          this.stopPropagation = function() {
            event.stopPropagation(this.domEvent);
            this.propagationStopped = true;
          };
          this.preventDefault = function() {
            event.preventDefault(this.domEvent);
            this.defaultPrevented = true;
          };
          this.stop = function() {
            this.stopPropagation();
            this.preventDefault();
          };
          this.getDocumentPosition = function() {
            if (this.$pos)
              return this.$pos;
            this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
            return this.$pos;
          };
          this.inSelection = function() {
            if (this.$inSelection !== null)
              return this.$inSelection;
            var editor = this.editor;
            var selectionRange = editor.getSelectionRange();
            if (selectionRange.isEmpty())
              this.$inSelection = false;
            else {
              var pos = this.getDocumentPosition();
              this.$inSelection = selectionRange.contains(pos.row, pos.column);
            }
            return this.$inSelection;
          };
          this.getButton = function() {
            return event.getButton(this.domEvent);
          };
          this.getShiftKey = function() {
            return this.domEvent.shiftKey;
          };
          this.getAccelKey = useragent.isMac ? function() {
            return this.domEvent.metaKey;
          } : function() {
            return this.domEvent.ctrlKey;
          };
        }).call(MouseEvent2.prototype);
      });
      ace.define("ace/mouse/dragdrop_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/lib/useragent"], function(acequire, exports2, module2) {
        "use strict";
        var dom = acequire("../lib/dom");
        var event = acequire("../lib/event");
        var useragent = acequire("../lib/useragent");
        var AUTOSCROLL_DELAY = 200;
        var SCROLL_CURSOR_DELAY = 200;
        var SCROLL_CURSOR_HYSTERESIS = 5;
        function DragdropHandler(mouseHandler) {
          var editor = mouseHandler.editor;
          var blankImage = dom.createElement("img");
          blankImage.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
          if (useragent.isOpera)
            blankImage.style.cssText = "width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;";
          var exports3 = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];
          exports3.forEach(function(x2) {
            mouseHandler[x2] = this[x2];
          }, this);
          editor.addEventListener("mousedown", this.onMouseDown.bind(mouseHandler));
          var mouseTarget = editor.container;
          var dragSelectionMarker, x, y;
          var timerId, range;
          var dragCursor, counter = 0;
          var dragOperation;
          var isInternal;
          var autoScrollStartTime;
          var cursorMovedTime;
          var cursorPointOnCaretMoved;
          this.onDragStart = function(e) {
            if (this.cancelDrag || !mouseTarget.draggable) {
              var self2 = this;
              setTimeout(function() {
                self2.startSelect();
                self2.captureMouse(e);
              }, 0);
              return e.preventDefault();
            }
            range = editor.getSelectionRange();
            var dataTransfer = e.dataTransfer;
            dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
            if (useragent.isOpera) {
              editor.container.appendChild(blankImage);
              blankImage.scrollTop = 0;
            }
            dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);
            if (useragent.isOpera) {
              editor.container.removeChild(blankImage);
            }
            dataTransfer.clearData();
            dataTransfer.setData("Text", editor.session.getTextRange());
            isInternal = true;
            this.setState("drag");
          };
          this.onDragEnd = function(e) {
            mouseTarget.draggable = false;
            isInternal = false;
            this.setState(null);
            if (!editor.getReadOnly()) {
              var dropEffect = e.dataTransfer.dropEffect;
              if (!dragOperation && dropEffect == "move")
                editor.session.remove(editor.getSelectionRange());
              editor.renderer.$cursorLayer.setBlinking(true);
            }
            this.editor.unsetStyle("ace_dragging");
            this.editor.renderer.setCursorStyle("");
          };
          this.onDragEnter = function(e) {
            if (editor.getReadOnly() || !canAccept(e.dataTransfer))
              return;
            x = e.clientX;
            y = e.clientY;
            if (!dragSelectionMarker)
              addDragMarker();
            counter++;
            e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
            return event.preventDefault(e);
          };
          this.onDragOver = function(e) {
            if (editor.getReadOnly() || !canAccept(e.dataTransfer))
              return;
            x = e.clientX;
            y = e.clientY;
            if (!dragSelectionMarker) {
              addDragMarker();
              counter++;
            }
            if (onMouseMoveTimer !== null)
              onMouseMoveTimer = null;
            e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
            return event.preventDefault(e);
          };
          this.onDragLeave = function(e) {
            counter--;
            if (counter <= 0 && dragSelectionMarker) {
              clearDragMarker();
              dragOperation = null;
              return event.preventDefault(e);
            }
          };
          this.onDrop = function(e) {
            if (!dragCursor)
              return;
            var dataTransfer = e.dataTransfer;
            if (isInternal) {
              switch (dragOperation) {
                case "move":
                  if (range.contains(dragCursor.row, dragCursor.column)) {
                    range = {
                      start: dragCursor,
                      end: dragCursor
                    };
                  } else {
                    range = editor.moveText(range, dragCursor);
                  }
                  break;
                case "copy":
                  range = editor.moveText(range, dragCursor, true);
                  break;
              }
            } else {
              var dropData = dataTransfer.getData("Text");
              range = {
                start: dragCursor,
                end: editor.session.insert(dragCursor, dropData)
              };
              editor.focus();
              dragOperation = null;
            }
            clearDragMarker();
            return event.preventDefault(e);
          };
          event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler));
          event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler));
          event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler));
          event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler));
          event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler));
          event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler));
          function scrollCursorIntoView(cursor, prevCursor) {
            var now = Date.now();
            var vMovement = !prevCursor || cursor.row != prevCursor.row;
            var hMovement = !prevCursor || cursor.column != prevCursor.column;
            if (!cursorMovedTime || vMovement || hMovement) {
              editor.$blockScrolling += 1;
              editor.moveCursorToPosition(cursor);
              editor.$blockScrolling -= 1;
              cursorMovedTime = now;
              cursorPointOnCaretMoved = { x, y };
            } else {
              var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
              if (distance > SCROLL_CURSOR_HYSTERESIS) {
                cursorMovedTime = null;
              } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
                editor.renderer.scrollCursorIntoView();
                cursorMovedTime = null;
              }
            }
          }
          function autoScroll(cursor, prevCursor) {
            var now = Date.now();
            var lineHeight = editor.renderer.layerConfig.lineHeight;
            var characterWidth = editor.renderer.layerConfig.characterWidth;
            var editorRect = editor.renderer.scroller.getBoundingClientRect();
            var offsets = {
              x: {
                left: x - editorRect.left,
                right: editorRect.right - x
              },
              y: {
                top: y - editorRect.top,
                bottom: editorRect.bottom - y
              }
            };
            var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
            var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
            var scrollCursor = { row: cursor.row, column: cursor.column };
            if (nearestXOffset / characterWidth <= 2) {
              scrollCursor.column += offsets.x.left < offsets.x.right ? -3 : 2;
            }
            if (nearestYOffset / lineHeight <= 1) {
              scrollCursor.row += offsets.y.top < offsets.y.bottom ? -1 : 1;
            }
            var vScroll = cursor.row != scrollCursor.row;
            var hScroll = cursor.column != scrollCursor.column;
            var vMovement = !prevCursor || cursor.row != prevCursor.row;
            if (vScroll || hScroll && !vMovement) {
              if (!autoScrollStartTime)
                autoScrollStartTime = now;
              else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
                editor.renderer.scrollCursorIntoView(scrollCursor);
            } else {
              autoScrollStartTime = null;
            }
          }
          function onDragInterval() {
            var prevCursor = dragCursor;
            dragCursor = editor.renderer.screenToTextCoordinates(x, y);
            scrollCursorIntoView(dragCursor, prevCursor);
            autoScroll(dragCursor, prevCursor);
          }
          function addDragMarker() {
            range = editor.selection.toOrientedRange();
            dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
            editor.clearSelection();
            if (editor.isFocused())
              editor.renderer.$cursorLayer.setBlinking(false);
            clearInterval(timerId);
            onDragInterval();
            timerId = setInterval(onDragInterval, 20);
            counter = 0;
            event.addListener(document, "mousemove", onMouseMove);
          }
          function clearDragMarker() {
            clearInterval(timerId);
            editor.session.removeMarker(dragSelectionMarker);
            dragSelectionMarker = null;
            editor.$blockScrolling += 1;
            editor.selection.fromOrientedRange(range);
            editor.$blockScrolling -= 1;
            if (editor.isFocused() && !isInternal)
              editor.renderer.$cursorLayer.setBlinking(!editor.getReadOnly());
            range = null;
            dragCursor = null;
            counter = 0;
            autoScrollStartTime = null;
            cursorMovedTime = null;
            event.removeListener(document, "mousemove", onMouseMove);
          }
          var onMouseMoveTimer = null;
          function onMouseMove() {
            if (onMouseMoveTimer == null) {
              onMouseMoveTimer = setTimeout(function() {
                if (onMouseMoveTimer != null && dragSelectionMarker)
                  clearDragMarker();
              }, 20);
            }
          }
          function canAccept(dataTransfer) {
            var types = dataTransfer.types;
            return !types || Array.prototype.some.call(types, function(type) {
              return type == "text/plain" || type == "Text";
            });
          }
          function getDropEffect(e) {
            var copyAllowed = ["copy", "copymove", "all", "uninitialized"];
            var moveAllowed = ["move", "copymove", "linkmove", "all", "uninitialized"];
            var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
            var effectAllowed = "uninitialized";
            try {
              effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
            } catch (e2) {
            }
            var dropEffect = "none";
            if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
              dropEffect = "copy";
            else if (moveAllowed.indexOf(effectAllowed) >= 0)
              dropEffect = "move";
            else if (copyAllowed.indexOf(effectAllowed) >= 0)
              dropEffect = "copy";
            return dropEffect;
          }
        }
        (function() {
          this.dragWait = function() {
            var interval = Date.now() - this.mousedownEvent.time;
            if (interval > this.editor.getDragDelay())
              this.startDrag();
          };
          this.dragWaitEnd = function() {
            var target = this.editor.container;
            target.draggable = false;
            this.startSelect(this.mousedownEvent.getDocumentPosition());
            this.selectEnd();
          };
          this.dragReadyEnd = function(e) {
            this.editor.renderer.$cursorLayer.setBlinking(!this.editor.getReadOnly());
            this.editor.unsetStyle("ace_dragging");
            this.editor.renderer.setCursorStyle("");
            this.dragWaitEnd();
          };
          this.startDrag = function() {
            this.cancelDrag = false;
            var editor = this.editor;
            var target = editor.container;
            target.draggable = true;
            editor.renderer.$cursorLayer.setBlinking(false);
            editor.setStyle("ace_dragging");
            var cursorStyle = useragent.isWin ? "default" : "move";
            editor.renderer.setCursorStyle(cursorStyle);
            this.setState("dragReady");
          };
          this.onMouseDrag = function(e) {
            var target = this.editor.container;
            if (useragent.isIE && this.state == "dragReady") {
              var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
              if (distance > 3)
                target.dragDrop();
            }
            if (this.state === "dragWait") {
              var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
              if (distance > 0) {
                target.draggable = false;
                this.startSelect(this.mousedownEvent.getDocumentPosition());
              }
            }
          };
          this.onMouseDown = function(e) {
            if (!this.$dragEnabled)
              return;
            this.mousedownEvent = e;
            var editor = this.editor;
            var inSelection = e.inSelection();
            var button = e.getButton();
            var clickCount = e.domEvent.detail || 1;
            if (clickCount === 1 && button === 0 && inSelection) {
              if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))
                return;
              this.mousedownEvent.time = Date.now();
              var eventTarget = e.domEvent.target || e.domEvent.srcElement;
              if ("unselectable" in eventTarget)
                eventTarget.unselectable = "on";
              if (editor.getDragDelay()) {
                if (useragent.isWebKit) {
                  this.cancelDrag = true;
                  var mouseTarget = editor.container;
                  mouseTarget.draggable = true;
                }
                this.setState("dragWait");
              } else {
                this.startDrag();
              }
              this.captureMouse(e, this.onMouseDrag.bind(this));
              e.defaultPrevented = true;
            }
          };
        }).call(DragdropHandler.prototype);
        function calcDistance(ax, ay, bx, by) {
          return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
        }
        exports2.DragdropHandler = DragdropHandler;
      });
      ace.define("ace/lib/net", ["require", "exports", "module", "ace/lib/dom"], function(acequire, exports2, module2) {
        "use strict";
        var dom = acequire("./dom");
        exports2.get = function(url, callback) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", url, true);
          xhr.onreadystatechange = function() {
            if (xhr.readyState === 4) {
              callback(xhr.responseText);
            }
          };
          xhr.send(null);
        };
        exports2.loadScript = function(path, callback) {
          var head = dom.getDocumentHead();
          var s = document.createElement("script");
          s.src = path;
          head.appendChild(s);
          s.onload = s.onreadystatechange = function(_, isAbort) {
            if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
              s = s.onload = s.onreadystatechange = null;
              if (!isAbort)
                callback();
            }
          };
        };
        exports2.qualifyURL = function(url) {
          var a = document.createElement("a");
          a.href = url;
          return a.href;
        };
      });
      ace.define("ace/lib/event_emitter", ["require", "exports", "module"], function(acequire, exports2, module2) {
        "use strict";
        var EventEmitter = {};
        var stopPropagation = function() {
          this.propagationStopped = true;
        };
        var preventDefault = function() {
          this.defaultPrevented = true;
        };
        EventEmitter._emit = EventEmitter._dispatchEvent = function(eventName, e) {
          this._eventRegistry || (this._eventRegistry = {});
          this._defaultHandlers || (this._defaultHandlers = {});
          var listeners = this._eventRegistry[eventName] || [];
          var defaultHandler = this._defaultHandlers[eventName];
          if (!listeners.length && !defaultHandler)
            return;
          if (typeof e != "object" || !e)
            e = {};
          if (!e.type)
            e.type = eventName;
          if (!e.stopPropagation)
            e.stopPropagation = stopPropagation;
          if (!e.preventDefault)
            e.preventDefault = preventDefault;
          listeners = listeners.slice();
          for (var i = 0; i < listeners.length; i++) {
            listeners[i](e, this);
            if (e.propagationStopped)
              break;
          }
          if (defaultHandler && !e.defaultPrevented)
            return defaultHandler(e, this);
        };
        EventEmitter._signal = function(eventName, e) {
          var listeners = (this._eventRegistry || {})[eventName];
          if (!listeners)
            return;
          listeners = listeners.slice();
          for (var i = 0; i < listeners.length; i++)
            listeners[i](e, this);
        };
        EventEmitter.once = function(eventName, callback) {
          var _self = this;
          callback && this.addEventListener(eventName, function newCallback() {
            _self.removeEventListener(eventName, newCallback);
            callback.apply(null, arguments);
          });
        };
        EventEmitter.setDefaultHandler = function(eventName, callback) {
          var handlers = this._defaultHandlers;
          if (!handlers)
            handlers = this._defaultHandlers = { _disabled_: {} };
          if (handlers[eventName]) {
            var old = handlers[eventName];
            var disabled = handlers._disabled_[eventName];
            if (!disabled)
              handlers._disabled_[eventName] = disabled = [];
            disabled.push(old);
            var i = disabled.indexOf(callback);
            if (i != -1)
              disabled.splice(i, 1);
          }
          handlers[eventName] = callback;
        };
        EventEmitter.removeDefaultHandler = function(eventName, callback) {
          var handlers = this._defaultHandlers;
          if (!handlers)
            return;
          var disabled = handlers._disabled_[eventName];
          if (handlers[eventName] == callback) {
            var old = handlers[eventName];
            if (disabled)
              this.setDefaultHandler(eventName, disabled.pop());
          } else if (disabled) {
            var i = disabled.indexOf(callback);
            if (i != -1)
              disabled.splice(i, 1);
          }
        };
        EventEmitter.on = EventEmitter.addEventListener = function(eventName, callback, capturing) {
          this._eventRegistry = this._eventRegistry || {};
          var listeners = this._eventRegistry[eventName];
          if (!listeners)
            listeners = this._eventRegistry[eventName] = [];
          if (listeners.indexOf(callback) == -1)
            listeners[capturing ? "unshift" : "push"](callback);
          return callback;
        };
        EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function(eventName, callback) {
          this._eventRegistry = this._eventRegistry || {};
          var listeners = this._eventRegistry[eventName];
          if (!listeners)
            return;
          var index = listeners.indexOf(callback);
          if (index !== -1)
            listeners.splice(index, 1);
        };
        EventEmitter.removeAllListeners = function(eventName) {
          if (this._eventRegistry)
            this._eventRegistry[eventName] = [];
        };
        exports2.EventEmitter = EventEmitter;
      });
      ace.define("ace/lib/app_config", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(acequire, exports2, module2) {
        "no use strict";
        var oop = acequire("./oop");
        var EventEmitter = acequire("./event_emitter").EventEmitter;
        var optionsProvider = {
          setOptions: function(optList) {
            Object.keys(optList).forEach(function(key) {
              this.setOption(key, optList[key]);
            }, this);
          },
          getOptions: function(optionNames) {
            var result = {};
            if (!optionNames) {
              optionNames = Object.keys(this.$options);
            } else if (!Array.isArray(optionNames)) {
              result = optionNames;
              optionNames = Object.keys(result);
            }
            optionNames.forEach(function(key) {
              result[key] = this.getOption(key);
            }, this);
            return result;
          },
          setOption: function(name, value) {
            if (this["$" + name] === value)
              return;
            var opt = this.$options[name];
            if (!opt) {
              return warn('misspelled option "' + name + '"');
            }
            if (opt.forwardTo)
              return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);
            if (!opt.handlesSet)
              this["$" + name] = value;
            if (opt && opt.set)
              opt.set.call(this, value);
          },
          getOption: function(name) {
            var opt = this.$options[name];
            if (!opt) {
              return warn('misspelled option "' + name + '"');
            }
            if (opt.forwardTo)
              return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
            return opt && opt.get ? opt.get.call(this) : this["$" + name];
          }
        };
        function warn(message) {
          if (typeof console != "undefined" && console.warn)
            console.warn.apply(console, arguments);
        }
        function reportError(msg, data) {
          var e = new Error(msg);
          e.data = data;
          if (typeof console == "object" && console.error)
            console.error(e);
          setTimeout(function() {
            throw e;
          });
        }
        var AppConfig = function() {
          this.$defaultOptions = {};
        };
        (function() {
          oop.implement(this, EventEmitter);
          this.defineOptions = function(obj, path, options) {
            if (!obj.$options)
              this.$defaultOptions[path] = obj.$options = {};
            Object.keys(options).forEach(function(key) {
              var opt = options[key];
              if (typeof opt == "string")
                opt = { forwardTo: opt };
              opt.name || (opt.name = key);
              obj.$options[opt.name] = opt;
              if ("initialValue" in opt)
                obj["$" + opt.name] = opt.initialValue;
            });
            oop.implement(obj, optionsProvider);
            return this;
          };
          this.resetOptions = function(obj) {
            Object.keys(obj.$options).forEach(function(key) {
              var opt = obj.$options[key];
              if ("value" in opt)
                obj.setOption(key, opt.value);
            });
          };
          this.setDefaultValue = function(path, name, value) {
            var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
            if (opts[name]) {
              if (opts.forwardTo)
                this.setDefaultValue(opts.forwardTo, name, value);
              else
                opts[name].value = value;
            }
          };
          this.setDefaultValues = function(path, optionHash) {
            Object.keys(optionHash).forEach(function(key) {
              this.setDefaultValue(path, key, optionHash[key]);
            }, this);
          };
          this.warn = warn;
          this.reportError = reportError;
        }).call(AppConfig.prototype);
        exports2.AppConfig = AppConfig;
      });
      ace.define("ace/config", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/lib/net", "ace/lib/app_config"], function(acequire, exports2, module2) {
        "no use strict";
        var lang = acequire("./lib/lang");
        var oop = acequire("./lib/oop");
        var net = acequire("./lib/net");
        var AppConfig = acequire("./lib/app_config").AppConfig;
        module2.exports = exports2 = new AppConfig();
        var global2 = function() {
          return this || typeof window != "undefined" && window;
        }();
        var options = {
          packaged: false,
          workerPath: null,
          modePath: null,
          themePath: null,
          basePath: "",
          suffix: ".js",
          $moduleUrls: {}
        };
        exports2.get = function(key) {
          if (!options.hasOwnProperty(key))
            throw new Error("Unknown config key: " + key);
          return options[key];
        };
        exports2.set = function(key, value) {
          if (!options.hasOwnProperty(key))
            throw new Error("Unknown config key: " + key);
          options[key] = value;
        };
        exports2.all = function() {
          return lang.copyObject(options);
        };
        exports2.moduleUrl = function(name, component) {
          if (options.$moduleUrls[name])
            return options.$moduleUrls[name];
          var parts = name.split("/");
          component = component || parts[parts.length - 2] || "";
          var sep = component == "snippets" ? "/" : "-";
          var base = parts[parts.length - 1];
          if (component == "worker" && sep == "-") {
            var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
            base = base.replace(re, "");
          }
          if ((!base || base == component) && parts.length > 1)
            base = parts[parts.length - 2];
          var path = options[component + "Path"];
          if (path == null) {
            path = options.basePath;
          } else if (sep == "/") {
            component = sep = "";
          }
          if (path && path.slice(-1) != "/")
            path += "/";
          return path + component + sep + base + this.get("suffix");
        };
        exports2.setModuleUrl = function(name, subst) {
          return options.$moduleUrls[name] = subst;
        };
        exports2.$loading = {};
        exports2.loadModule = function(moduleName, onLoad) {
          var module3, moduleType;
          if (Array.isArray(moduleName)) {
            moduleType = moduleName[0];
            moduleName = moduleName[1];
          }
          try {
            module3 = acequire(moduleName);
          } catch (e) {
          }
          if (module3 && !exports2.$loading[moduleName])
            return onLoad && onLoad(module3);
          if (!exports2.$loading[moduleName])
            exports2.$loading[moduleName] = [];
          exports2.$loading[moduleName].push(onLoad);
          if (exports2.$loading[moduleName].length > 1)
            return;
          var afterLoad = function() {
            acequire([moduleName], function(module4) {
              exports2._emit("load.module", { name: moduleName, module: module4 });
              var listeners = exports2.$loading[moduleName];
              exports2.$loading[moduleName] = null;
              listeners.forEach(function(onLoad2) {
                onLoad2 && onLoad2(module4);
              });
            });
          };
          if (!exports2.get("packaged"))
            return afterLoad();
          net.loadScript(exports2.moduleUrl(moduleName, moduleType), afterLoad);
        };
        init(true);
        function init(packaged) {
          if (!global2 || !global2.document)
            return;
          options.packaged = packaged || acequire.packaged || module2.packaged || global2.define && define.packaged;
          var scriptOptions = {};
          var scriptUrl = "";
          var currentScript = document.currentScript || document._currentScript;
          var currentDocument = currentScript && currentScript.ownerDocument || document;
          var scripts = currentDocument.getElementsByTagName("script");
          for (var i = 0; i < scripts.length; i++) {
            var script = scripts[i];
            var src = script.src || script.getAttribute("src");
            if (!src)
              continue;
            var attributes = script.attributes;
            for (var j = 0, l = attributes.length; j < l; j++) {
              var attr = attributes[j];
              if (attr.name.indexOf("data-ace-") === 0) {
                scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
              }
            }
            var m = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
            if (m)
              scriptUrl = m[1];
          }
          if (scriptUrl) {
            scriptOptions.base = scriptOptions.base || scriptUrl;
            scriptOptions.packaged = true;
          }
          scriptOptions.basePath = scriptOptions.base;
          scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
          scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
          scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
          delete scriptOptions.base;
          for (var key in scriptOptions)
            if (typeof scriptOptions[key] !== "undefined")
              exports2.set(key, scriptOptions[key]);
        }
        exports2.init = init;
        function deHyphenate(str) {
          return str.replace(/-(.)/g, function(m, m1) {
            return m1.toUpperCase();
          });
        }
      });
      ace.define("ace/mouse/mouse_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/mouse/default_handlers", "ace/mouse/default_gutter_handler", "ace/mouse/mouse_event", "ace/mouse/dragdrop_handler", "ace/config"], function(acequire, exports2, module2) {
        "use strict";
        var event = acequire("../lib/event");
        var useragent = acequire("../lib/useragent");
        var DefaultHandlers = acequire("./default_handlers").DefaultHandlers;
        var DefaultGutterHandler = acequire("./default_gutter_handler").GutterHandler;
        var MouseEvent2 = acequire("./mouse_event").MouseEvent;
        var DragdropHandler = acequire("./dragdrop_handler").DragdropHandler;
        var config = acequire("../config");
        var MouseHandler = function(editor) {
          var _self = this;
          this.editor = editor;
          new DefaultHandlers(this);
          new DefaultGutterHandler(this);
          new DragdropHandler(this);
          var focusEditor = function(e) {
            var windowBlurred = !document.hasFocus || !document.hasFocus() || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());
            if (windowBlurred)
              window.focus();
            editor.focus();
          };
          var mouseTarget = editor.renderer.getMouseEventTarget();
          event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"));
          event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"));
          event.addMultiMouseDownListener([
            mouseTarget,
            editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,
            editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,
            editor.textInput && editor.textInput.getElement()
          ].filter(Boolean), [400, 300, 250], this, "onMouseEvent");
          event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"));
          event.addTouchMoveListener(editor.container, this.onTouchMove.bind(this, "touchmove"));
          var gutterEl = editor.renderer.$gutter;
          event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"));
          event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"));
          event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"));
          event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"));
          event.addListener(mouseTarget, "mousedown", focusEditor);
          event.addListener(gutterEl, "mousedown", focusEditor);
          if (useragent.isIE && editor.renderer.scrollBarV) {
            event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor);
            event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor);
          }
          editor.on("mousemove", function(e) {
            if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
              return;
            var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
            var range = editor.session.selection.getRange();
            var renderer = editor.renderer;
            if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
              renderer.setCursorStyle("default");
            } else {
              renderer.setCursorStyle("");
            }
          });
        };
        (function() {
          this.onMouseEvent = function(name, e) {
            this.editor._emit(name, new MouseEvent2(e, this.editor));
          };
          this.onMouseMove = function(name, e) {
            var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
            if (!listeners || !listeners.length)
              return;
            this.editor._emit(name, new MouseEvent2(e, this.editor));
          };
          this.onMouseWheel = function(name, e) {
            var mouseEvent = new MouseEvent2(e, this.editor);
            mouseEvent.speed = this.$scrollSpeed * 2;
            mouseEvent.wheelX = e.wheelX;
            mouseEvent.wheelY = e.wheelY;
            this.editor._emit(name, mouseEvent);
          };
          this.onTouchMove = function(name, e) {
            var mouseEvent = new MouseEvent2(e, this.editor);
            mouseEvent.speed = 1;
            mouseEvent.wheelX = e.wheelX;
            mouseEvent.wheelY = e.wheelY;
            this.editor._emit(name, mouseEvent);
          };
          this.setState = function(state) {
            this.state = state;
          };
          this.captureMouse = function(ev, mouseMoveHandler) {
            this.x = ev.x;
            this.y = ev.y;
            this.isMousePressed = true;
            var renderer = this.editor.renderer;
            if (renderer.$keepTextAreaAtCursor)
              renderer.$keepTextAreaAtCursor = null;
            var self2 = this;
            var onMouseMove = function(e) {
              if (!e)
                return;
              if (useragent.isWebKit && !e.which && self2.releaseMouse)
                return self2.releaseMouse();
              self2.x = e.clientX;
              self2.y = e.clientY;
              mouseMoveHandler && mouseMoveHandler(e);
              self2.mouseEvent = new MouseEvent2(e, self2.editor);
              self2.$mouseMoved = true;
            };
            var onCaptureEnd = function(e) {
              clearInterval(timerId);
              onCaptureInterval();
              self2[self2.state + "End"] && self2[self2.state + "End"](e);
              self2.state = "";
              if (renderer.$keepTextAreaAtCursor == null) {
                renderer.$keepTextAreaAtCursor = true;
                renderer.$moveTextAreaToCursor();
              }
              self2.isMousePressed = false;
              self2.$onCaptureMouseMove = self2.releaseMouse = null;
              e && self2.onMouseEvent("mouseup", e);
            };
            var onCaptureInterval = function() {
              self2[self2.state] && self2[self2.state]();
              self2.$mouseMoved = false;
            };
            if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
              return setTimeout(function() {
                onCaptureEnd(ev);
              });
            }
            self2.$onCaptureMouseMove = onMouseMove;
            self2.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
            var timerId = setInterval(onCaptureInterval, 20);
          };
          this.releaseMouse = null;
          this.cancelContextMenu = function() {
            var stop = function(e) {
              if (e && e.domEvent && e.domEvent.type != "contextmenu")
                return;
              this.editor.off("nativecontextmenu", stop);
              if (e && e.domEvent)
                event.stopEvent(e.domEvent);
            }.bind(this);
            setTimeout(stop, 10);
            this.editor.on("nativecontextmenu", stop);
          };
        }).call(MouseHandler.prototype);
        config.defineOptions(MouseHandler.prototype, "mouseHandler", {
          scrollSpeed: { initialValue: 2 },
          dragDelay: { initialValue: useragent.isMac ? 150 : 0 },
          dragEnabled: { initialValue: true },
          focusTimout: { initialValue: 0 },
          tooltipFollowsMouse: { initialValue: true }
        });
        exports2.MouseHandler = MouseHandler;
      });
      ace.define("ace/mouse/fold_handler", ["require", "exports", "module"], function(acequire, exports2, module2) {
        "use strict";
        function FoldHandler(editor) {
          editor.on("click", function(e) {
            var position = e.getDocumentPosition();
            var session = editor.session;
            var fold = session.getFoldAt(position.row, position.column, 1);
            if (fold) {
              if (e.getAccelKey())
                session.removeFold(fold);
              else
                session.expandFold(fold);
              e.stop();
            }
          });
          editor.on("gutterclick", function(e) {
            var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
            if (gutterRegion == "foldWidgets") {
              var row = e.getDocumentPosition().row;
              var session = editor.session;
              if (session.foldWidgets && session.foldWidgets[row])
                editor.session.onFoldWidgetClick(row, e);
              if (!editor.isFocused())
                editor.focus();
              e.stop();
            }
          });
          editor.on("gutterdblclick", function(e) {
            var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
            if (gutterRegion == "foldWidgets") {
              var row = e.getDocumentPosition().row;
              var session = editor.session;
              var data = session.getParentFoldRangeData(row, true);
              var range = data.range || data.firstRange;
              if (range) {
                row = range.start.row;
                var fold = session.getFoldAt(row, session.getLine(row).length, 1);
                if (fold) {
                  session.removeFold(fold);
                } else {
                  session.addFold("...", range);
                  editor.renderer.scrollCursorIntoView({ row: range.start.row, column: 0 });
                }
              }
              e.stop();
            }
          });
        }
        exports2.FoldHandler = FoldHandler;
      });
      ace.define("ace/keyboard/keybinding", ["require", "exports", "module", "ace/lib/keys", "ace/lib/event"], function(acequire, exports2, module2) {
        "use strict";
        var keyUtil = acequire("../lib/keys");
        var event = acequire("../lib/event");
        var KeyBinding = function(editor) {
          this.$editor = editor;
          this.$data = { editor };
          this.$handlers = [];
          this.setDefaultHandler(editor.commands);
        };
        (function() {
          this.setDefaultHandler = function(kb) {
            this.removeKeyboardHandler(this.$defaultHandler);
            this.$defaultHandler = kb;
            this.addKeyboardHandler(kb, 0);
          };
          this.setKeyboardHandler = function(kb) {
            var h = this.$handlers;
            if (h[h.length - 1] == kb)
              return;
            while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
              this.removeKeyboardHandler(h[h.length - 1]);
            this.addKeyboardHandler(kb, 1);
          };
          this.addKeyboardHandler = function(kb, pos) {
            if (!kb)
              return;
            if (typeof kb == "function" && !kb.handleKeyboard)
              kb.handleKeyboard = kb;
            var i = this.$handlers.indexOf(kb);
            if (i != -1)
              this.$handlers.splice(i, 1);
            if (pos == void 0)
              this.$handlers.push(kb);
            else
              this.$handlers.splice(pos, 0, kb);
            if (i == -1 && kb.attach)
              kb.attach(this.$editor);
          };
          this.removeKeyboardHandler = function(kb) {
            var i = this.$handlers.indexOf(kb);
            if (i == -1)
              return false;
            this.$handlers.splice(i, 1);
            kb.detach && kb.detach(this.$editor);
            return true;
          };
          this.getKeyboardHandler = function() {
            return this.$handlers[this.$handlers.length - 1];
          };
          this.getStatusText = function() {
            var data = this.$data;
            var editor = data.editor;
            return this.$handlers.map(function(h) {
              return h.getStatusText && h.getStatusText(editor, data) || "";
            }).filter(Boolean).join(" ");
          };
          this.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {
            var toExecute;
            var success = false;
            var commands = this.$editor.commands;
            for (var i = this.$handlers.length; i--; ) {
              toExecute = this.$handlers[i].handleKeyboard(
                this.$data,
                hashId,
                keyString,
                keyCode,
                e
              );
              if (!toExecute || !toExecute.command)
                continue;
              if (toExecute.command == "null") {
                success = true;
              } else {
                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
              }
              if (success && e && hashId != -1 && toExecute.passEvent != true && toExecute.command.passEvent != true) {
                event.stopEvent(e);
              }
              if (success)
                break;
            }
            if (!success && hashId == -1) {
              toExecute = { command: "insertstring" };
              success = commands.exec("insertstring", this.$editor, keyString);
            }
            if (success && this.$editor._signal)
              this.$editor._signal("keyboardActivity", toExecute);
            return success;
          };
          this.onCommandKey = function(e, hashId, keyCode) {
            var keyString = keyUtil.keyCodeToString(keyCode);
            this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
          };
          this.onTextInput = function(text) {
            this.$callKeyboardHandlers(-1, text);
          };
        }).call(KeyBinding.prototype);
        exports2.KeyBinding = KeyBinding;
      });
      ace.define("ace/lib/bidiutil", ["require", "exports", "module"], function(acequire, exports2, module2) {
        "use strict";
        var ArabicAlefBetIntervalsBegine = ["\u0621", "\u0641"];
        var ArabicAlefBetIntervalsEnd = ["\u063A", "\u064A"];
        var dir = 0, hiLevel = 0;
        var lastArabic = false, hasUBAT_AL = false, hasUBAT_B = false, hasUBAT_S = false, hasBlockSep = false, hasSegSep = false;
        var impTab_LTR = [
          [0, 3, 0, 1, 0, 0, 0],
          [0, 3, 0, 1, 2, 2, 0],
          [0, 3, 0, 17, 2, 0, 1],
          [0, 3, 5, 5, 4, 1, 0],
          [0, 3, 21, 21, 4, 0, 1],
          [0, 3, 5, 5, 4, 2, 0]
        ];
        var impTab_RTL = [
          [2, 0, 1, 1, 0, 1, 0],
          [2, 0, 1, 1, 0, 2, 0],
          [2, 0, 2, 1, 3, 2, 0],
          [2, 0, 2, 33, 3, 1, 1]
        ];
        var LTR = 0, RTL = 1;
        var L = 0;
        var R = 1;
        var EN = 2;
        var AN = 3;
        var ON = 4;
        var B = 5;
        var S = 6;
        var AL = 7;
        var WS = 8;
        var CS = 9;
        var ES = 10;
        var ET = 11;
        var NSM = 12;
        var LRE = 13;
        var RLE = 14;
        var PDF = 15;
        var LRO = 16;
        var RLO = 17;
        var BN = 18;
        var UnicodeTBL00 = [
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          S,
          B,
          S,
          WS,
          B,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          B,
          B,
          B,
          S,
          WS,
          ON,
          ON,
          ET,
          ET,
          ET,
          ON,
          ON,
          ON,
          ON,
          ON,
          ES,
          CS,
          ES,
          CS,
          CS,
          EN,
          EN,
          EN,
          EN,
          EN,
          EN,
          EN,
          EN,
          EN,
          EN,
          CS,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          L,
          ON,
          ON,
          ON,
          ON,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          B,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          BN,
          CS,
          ON,
          ET,
          ET,
          ET,
          ET,
          ON,
          ON,
          ON,
          ON,
          L,
          ON,
          ON,
          BN,
          ON,
          ON,
          ET,
          ET,
          EN,
          EN,
          ON,
          L,
          ON,
          ON,
          ON,
          EN,
          L,
          ON,
          ON,
          ON,
          ON,
          ON
        ];
        var UnicodeTBL20 = [
          WS,
          WS,
          WS,
          WS,
          WS,
          WS,
          WS,
          WS,
          WS,
          WS,
          WS,
          BN,
          BN,
          BN,
          L,
          R,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          WS,
          B,
          LRE,
          RLE,
          PDF,
          LRO,
          RLO,
          CS,
          ET,
          ET,
          ET,
          ET,
          ET,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          CS,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          ON,
          WS
        ];
        function _computeLevels(chars, levels, len, charTypes) {
          var impTab = dir ? impTab_RTL : impTab_LTR, prevState = null, newClass = null, newLevel = null, newState = 0, action = null, cond = null, condPos = -1, i = null, ix = null, classes = [];
          if (!charTypes) {
            for (i = 0, charTypes = []; i < len; i++) {
              charTypes[i] = _getCharacterType(chars[i]);
            }
          }
          hiLevel = dir;
          lastArabic = false;
          hasUBAT_AL = false;
          hasUBAT_B = false;
          hasUBAT_S = false;
          for (ix = 0; ix < len; ix++) {
            prevState = newState;
            classes[ix] = newClass = _getCharClass(chars, charTypes, classes, ix);
            newState = impTab[prevState][newClass];
            action = newState & 240;
            newState &= 15;
            levels[ix] = newLevel = impTab[newState][5];
            if (action > 0) {
              if (action == 16) {
                for (i = condPos; i < ix; i++) {
                  levels[i] = 1;
                }
                condPos = -1;
              } else {
                condPos = -1;
              }
            }
            cond = impTab[newState][6];
            if (cond) {
              if (condPos == -1) {
                condPos = ix;
              }
            } else {
              if (condPos > -1) {
                for (i = condPos; i < ix; i++) {
                  levels[i] = newLevel;
                }
                condPos = -1;
              }
            }
            if (charTypes[ix] == B) {
              levels[ix] = 0;
            }
            hiLevel |= newLevel;
          }
          if (hasUBAT_S) {
            for (i = 0; i < len; i++) {
              if (charTypes[i] == S) {
                levels[i] = dir;
                for (var j = i - 1; j >= 0; j--) {
                  if (charTypes[j] == WS) {
                    levels[j] = dir;
                  } else {
                    break;
                  }
                }
              }
            }
          }
        }
        function _invertLevel(lev, levels, _array) {
          if (hiLevel < lev) {
            return;
          }
          if (lev == 1 && dir == RTL && !hasUBAT_B) {
            _array.reverse();
            return;
          }
          var len = _array.length, start = 0, end, lo, hi, tmp;
          while (start < len) {
            if (levels[start] >= lev) {
              end = start + 1;
              while (end < len && levels[end] >= lev) {
                end++;
              }
              for (lo = start, hi = end - 1; lo < hi; lo++, hi--) {
                tmp = _array[lo];
                _array[lo] = _array[hi];
                _array[hi] = tmp;
              }
              start = end;
            }
            start++;
          }
        }
        function _getCharClass(chars, types, classes, ix) {
          var cType = types[ix], wType, nType, len, i;
          switch (cType) {
            case L:
            case R:
              lastArabic = false;
            case ON:
            case AN:
              return cType;
            case EN:
              return lastArabic ? AN : EN;
            case AL:
              lastArabic = true;
              hasUBAT_AL = true;
              return R;
            case WS:
              return ON;
            case CS:
              if (ix < 1 || ix + 1 >= types.length || (wType = classes[ix - 1]) != EN && wType != AN || (nType = types[ix + 1]) != EN && nType != AN) {
                return ON;
              }
              if (lastArabic) {
                nType = AN;
              }
              return nType == wType ? nType : ON;
            case ES:
              wType = ix > 0 ? classes[ix - 1] : B;
              if (wType == EN && ix + 1 < types.length && types[ix + 1] == EN) {
                return EN;
              }
              return ON;
            case ET:
              if (ix > 0 && classes[ix - 1] == EN) {
                return EN;
              }
              if (lastArabic) {
                return ON;
              }
              i = ix + 1;
              len = types.length;
              while (i < len && types[i] == ET) {
                i++;
              }
              if (i < len && types[i] == EN) {
                return EN;
              }
              return ON;
            case NSM:
              len = types.length;
              i = ix + 1;
              while (i < len && types[i] == NSM) {
                i++;
              }
              if (i < len) {
                var c = chars[ix], rtlCandidate = c >= 1425 && c <= 2303 || c == 64286;
                wType = types[i];
                if (rtlCandidate && (wType == R || wType == AL)) {
                  return R;
                }
              }
              if (ix < 1 || (wType = types[ix - 1]) == B) {
                return ON;
              }
              return classes[ix - 1];
            case B:
              lastArabic = false;
              hasUBAT_B = true;
              return dir;
            case S:
              hasUBAT_S = true;
              return ON;
            case LRE:
            case RLE:
            case LRO:
            case RLO:
            case PDF:
              lastArabic = false;
            case BN:
              return ON;
          }
        }
        function _getCharacterType(ch) {
          var uc = ch.charCodeAt(0), hi = uc >> 8;
          if (hi == 0) {
            return uc > 191 ? L : UnicodeTBL00[uc];
          } else if (hi == 5) {
            return /[\u0591-\u05f4]/.test(ch) ? R : L;
          } else if (hi == 6) {
            if (/[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(ch))
              return NSM;
            else if (/[\u0660-\u0669\u066b-\u066c]/.test(ch))
              return AN;
            else if (uc == 1642)
              return ET;
            else if (/[\u06f0-\u06f9]/.test(ch))
              return EN;
            else
              return AL;
          } else if (hi == 32 && uc <= 8287) {
            return UnicodeTBL20[uc & 255];
          } else if (hi == 254) {
            return uc >= 65136 ? AL : ON;
          }
          return ON;
        }
        function _isArabicDiacritics(ch) {
          return ch >= "\u064B" && ch <= "\u0655";
        }
        exports2.L = L;
        exports2.R = R;
        exports2.EN = EN;
        exports2.ON_R = 3;
        exports2.AN = 4;
        exports2.R_H = 5;
        exports2.B = 6;
        exports2.DOT = "\xB7";
        exports2.doBidiReorder = function(text, textCharTypes, isRtl) {
          if (text.length < 2)
            return {};
          var chars = text.split(""), logicalFromVisual = new Array(chars.length), bidiLevels = new Array(chars.length), levels = [];
          dir = isRtl ? RTL : LTR;
          _computeLevels(chars, levels, chars.length, textCharTypes);
          for (var i = 0; i < logicalFromVisual.length; logicalFromVisual[i] = i, i++)
            ;
          _invertLevel(2, levels, logicalFromVisual);
          _invertLevel(1, levels, logicalFromVisual);
          for (var i = 0; i < logicalFromVisual.length - 1; i++) {
            if (textCharTypes[i] === AN) {
              levels[i] = exports2.AN;
            } else if (levels[i] === R && (textCharTypes[i] > AL && textCharTypes[i] < LRE || textCharTypes[i] === ON || textCharTypes[i] === BN)) {
              levels[i] = exports2.ON_R;
            } else if (i > 0 && chars[i - 1] === "\u0644" && /\u0622|\u0623|\u0625|\u0627/.test(chars[i])) {
              levels[i - 1] = levels[i] = exports2.R_H;
              i++;
            }
          }
          if (chars[chars.length - 1] === exports2.DOT)
            levels[chars.length - 1] = exports2.B;
          for (var i = 0; i < logicalFromVisual.length; i++) {
            bidiLevels[i] = levels[logicalFromVisual[i]];
          }
          return { "logicalFromVisual": logicalFromVisual, "bidiLevels": bidiLevels };
        };
        exports2.hasBidiCharacters = function(text, textCharTypes) {
          var ret = false;
          for (var i = 0; i < text.length; i++) {
            textCharTypes[i] = _getCharacterType(text.charAt(i));
            if (!ret && (textCharTypes[i] == R || textCharTypes[i] == AL))
              ret = true;
          }
          return ret;
        };
        exports2.getVisualFromLogicalIdx = function(logIdx, rowMap) {
          for (var i = 0; i < rowMap.logicalFromVisual.length; i++) {
            if (rowMap.logicalFromVisual[i] == logIdx)
              return i;
          }
          return 0;
        };
      });
      ace.define("ace/bidihandler", ["require", "exports", "module", "ace/lib/bidiutil", "ace/lib/lang", "ace/lib/useragent"], function(acequire, exports2, module2) {
        "use strict";
        var bidiUtil = acequire("./lib/bidiutil");
        var lang = acequire("./lib/lang");
        var useragent = acequire("./lib/useragent");
        var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
        var BidiHandler = function(session) {
          this.session = session;
          this.bidiMap = {};
          this.currentRow = null;
          this.bidiUtil = bidiUtil;
          this.charWidths = [];
          this.EOL = "\xAC";
          this.showInvisibles = true;
          this.isRtlDir = false;
          this.line = "";
          this.wrapIndent = 0;
          this.isLastRow = false;
          this.EOF = "\xB6";
          this.seenBidi = false;
        };
        (function() {
          this.isBidiRow = function(screenRow, docRow, splitIndex) {
            if (!this.seenBidi)
              return false;
            if (screenRow !== this.currentRow) {
              this.currentRow = screenRow;
              this.updateRowLine(docRow, splitIndex);
              this.updateBidiMap();
            }
            return this.bidiMap.bidiLevels;
          };
          this.onChange = function(delta) {
            if (!this.seenBidi) {
              if (delta.action == "insert" && bidiRE.test(delta.lines.join("\n"))) {
                this.seenBidi = true;
                this.currentRow = null;
              }
            } else {
              this.currentRow = null;
            }
          };
          this.getDocumentRow = function() {
            var docRow = 0;
            var rowCache = this.session.$screenRowCache;
            if (rowCache.length) {
              var index = this.session.$getRowCacheIndex(rowCache, this.currentRow);
              if (index >= 0)
                docRow = this.session.$docRowCache[index];
            }
            return docRow;
          };
          this.getSplitIndex = function() {
            var splitIndex = 0;
            var rowCache = this.session.$screenRowCache;
            if (rowCache.length) {
              var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);
              while (this.currentRow - splitIndex > 0) {
                currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);
                if (currentIndex !== prevIndex)
                  break;
                prevIndex = currentIndex;
                splitIndex++;
              }
            }
            return splitIndex;
          };
          this.updateRowLine = function(docRow, splitIndex) {
            if (docRow === void 0)
              docRow = this.getDocumentRow();
            this.wrapIndent = 0;
            this.isLastRow = docRow === this.session.getLength() - 1;
            this.line = this.session.getLine(docRow);
            if (this.session.$useWrapMode) {
              var splits = this.session.$wrapData[docRow];
              if (splits) {
                if (splitIndex === void 0)
                  splitIndex = this.getSplitIndex();
                if (splitIndex > 0 && splits.length) {
                  this.wrapIndent = splits.indent;
                  this.line = splitIndex < splits.length ? this.line.substring(splits[splitIndex - 1], splits[splits.length - 1]) : this.line.substring(splits[splits.length - 1]);
                } else {
                  this.line = this.line.substring(0, splits[splitIndex]);
                }
              }
            }
            var session = this.session, shift = 0, size;
            this.line = this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g, function(ch, i) {
              if (ch === "	" || session.isFullWidth(ch.charCodeAt(0))) {
                size = ch === "	" ? session.getScreenTabSize(i + shift) : 2;
                shift += size - 1;
                return lang.stringRepeat(bidiUtil.DOT, size);
              }
              return ch;
            });
          };
          this.updateBidiMap = function() {
            var textCharTypes = [], endOfLine = this.isLastRow ? this.EOF : this.EOL;
            var line = this.line + (this.showInvisibles ? endOfLine : bidiUtil.DOT);
            if (bidiUtil.hasBidiCharacters(line, textCharTypes)) {
              this.bidiMap = bidiUtil.doBidiReorder(line, textCharTypes, this.isRtlDir);
            } else {
              this.bidiMap = {};
            }
          };
          this.markAsDirty = function() {
            this.currentRow = null;
          };
          this.updateCharacterWidths = function(fontMetrics) {
            if (!this.seenBidi)
              return;
            if (this.characterWidth === fontMetrics.$characterSize.width)
              return;
            var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;
            var bidiCharWidth = fontMetrics.$measureCharWidth("\u05D4");
            this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;
            this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;
            this.charWidths[bidiUtil.R_H] = useragent.isChrome ? bidiCharWidth : bidiCharWidth * 0.45;
            this.charWidths[bidiUtil.B] = 0;
            this.currentRow = null;
          };
          this.getShowInvisibles = function() {
            return this.showInvisibles;
          };
          this.setShowInvisibles = function(showInvisibles) {
            this.showInvisibles = showInvisibles;
            this.currentRow = null;
          };
          this.setEolChar = function(eolChar) {
            this.EOL = eolChar;
          };
          this.setTextDir = function(isRtlDir) {
            this.isRtlDir = isRtlDir;
          };
          this.getPosLeft = function(col) {
            col -= this.wrapIndent;
            var visualIdx = bidiUtil.getVisualFromLogicalIdx(col > 0 ? col - 1 : 0, this.bidiMap), levels = this.bidiMap.bidiLevels, left = 0;
            if (col === 0 && levels[visualIdx] % 2 !== 0)
              visualIdx++;
            for (var i = 0; i < visualIdx; i++) {
              left += this.charWidths[levels[i]];
            }
            if (col !== 0 && levels[visualIdx] % 2 === 0)
              left += this.charWidths[levels[visualIdx]];
            if (this.wrapIndent)
              left += this.wrapIndent * this.charWidths[bidiUtil.L];
            return left;
          };
          this.getSelections = function(startCol, endCol) {
            var map = this.bidiMap, levels = map.bidiLevels, level, offset = this.wrapIndent * this.charWidths[bidiUtil.L], selections = [], selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent, isSelected = false, isSelectedPrev = false, selectionStart = 0;
            for (var logIdx, visIdx = 0; visIdx < levels.length; visIdx++) {
              logIdx = map.logicalFromVisual[visIdx];
              level = levels[visIdx];
              isSelected = logIdx >= selColMin && logIdx < selColMax;
              if (isSelected && !isSelectedPrev) {
                selectionStart = offset;
              } else if (!isSelected && isSelectedPrev) {
                selections.push({ left: selectionStart, width: offset - selectionStart });
              }
              offset += this.charWidths[level];
              isSelectedPrev = isSelected;
            }
            if (isSelected && visIdx === levels.length) {
              selections.push({ left: selectionStart, width: offset - selectionStart });
            }
            return selections;
          };
          this.offsetToCol = function(posX) {
            var logicalIdx = 0, posX = Math.max(posX, 0), offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels, charWidth = this.charWidths[levels[visualIdx]];
            if (this.wrapIndent) {
              posX -= this.wrapIndent * this.charWidths[bidiUtil.L];
            }
            while (posX > offset + charWidth / 2) {
              offset += charWidth;
              if (visualIdx === levels.length - 1) {
                charWidth = 0;
                break;
              }
              charWidth = this.charWidths[levels[++visualIdx]];
            }
            if (visualIdx > 0 && levels[visualIdx - 1] % 2 !== 0 && levels[visualIdx] % 2 === 0) {
              if (posX < offset)
                visualIdx--;
              logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
            } else if (visualIdx > 0 && levels[visualIdx - 1] % 2 === 0 && levels[visualIdx] % 2 !== 0) {
              logicalIdx = 1 + (posX > offset ? this.bidiMap.logicalFromVisual[visualIdx] : this.bidiMap.logicalFromVisual[visualIdx - 1]);
            } else if (this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && levels[visualIdx - 1] % 2 === 0 || !this.isRtlDir && visualIdx === 0 && levels[visualIdx] % 2 !== 0) {
              logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];
            } else {
              if (visualIdx > 0 && levels[visualIdx - 1] % 2 !== 0 && charWidth !== 0)
                visualIdx--;
              logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
            }
            return logicalIdx + this.wrapIndent;
          };
        }).call(BidiHandler.prototype);
        exports2.BidiHandler = BidiHandler;
      });
      ace.define("ace/range", ["require", "exports", "module"], function(acequire, exports2, module2) {
        "use strict";
        var comparePoints = function(p1, p2) {
          return p1.row - p2.row || p1.column - p2.column;
        };
        var Range = function(startRow, startColumn, endRow, endColumn) {
          this.start = {
            row: startRow,
            column: startColumn
          };
          this.end = {
            row: endRow,
            column: endColumn
          };
        };
        (function() {
          this.isEqual = function(range) {
            return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;
          };
          this.toString = function() {
            return "Range: [" + this.start.row + "/" + this.start.column + "] -> [" + this.end.row + "/" + this.end.column + "]";
          };
          this.contains = function(row, column) {
            return this.compare(row, column) == 0;
          };
          this.compareRange = function(range) {
            var cmp, end = range.end, start = range.start;
            cmp = this.compare(end.row, end.column);
            if (cmp == 1) {
              cmp = this.compare(start.row, start.column);
              if (cmp == 1) {
                return 2;
              } else if (cmp == 0) {
                return 1;
              } else {
                return 0;
              }
            } else if (cmp == -1) {
              return -2;
            } else {
              cmp = this.compare(start.row, start.column);
              if (cmp == -1) {
                return -1;
              } else if (cmp == 1) {
                return 42;
              } else {
                return 0;
              }
            }
          };
          this.comparePoint = function(p) {
            return this.compare(p.row, p.column);
          };
          this.containsRange = function(range) {
            return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
          };
          this.intersects = function(range) {
            var cmp = this.compareRange(range);
            return cmp == -1 || cmp == 0 || cmp == 1;
          };
          this.isEnd = function(row, column) {
            return this.end.row == row && this.end.column == column;
          };
          this.isStart = function(row, column) {
            return this.start.row == row && this.start.column == column;
          };
          this.setStart = function(row, column) {
            if (typeof row == "object") {
              this.start.column = row.column;
              this.start.row = row.row;
            } else {
              this.start.row = row;
              this.start.column = column;
            }
          };
          this.setEnd = function(row, column) {
            if (typeof row == "object") {
              this.end.column = row.column;
              this.end.row = row.row;
            } else {
              this.end.row = row;
              this.end.column = column;
            }
          };
          this.inside = function(row, column) {
            if (this.compare(row, column) == 0) {
              if (this.isEnd(row, column) || this.isStart(row, column)) {
                return false;
              } else {
                return true;
              }
            }
            return false;
          };
          this.insideStart = function(row, column) {
            if (this.compare(row, column) == 0) {
              if (this.isEnd(row, column)) {
                return false;
              } else {
                return true;
              }
            }
            return false;
          };
          this.insideEnd = function(row, column) {
            if (this.compare(row, column) == 0) {
              if (this.isStart(row, column)) {
                return false;
              } else {
                return true;
              }
            }
            return false;
          };
          this.compare = function(row, column) {
            if (!this.isMultiLine()) {
              if (row === this.start.row) {
                return column < this.start.column ? -1 : column > this.end.column ? 1 : 0;
              }
            }
            if (row < this.start.row)
              return -1;
            if (row > this.end.row)
              return 1;
            if (this.start.row === row)
              return column >= this.start.column ? 0 : -1;
            if (this.end.row === row)
              return column <= this.end.column ? 0 : 1;
            return 0;
          };
          this.compareStart = function(row, column) {
            if (this.start.row == row && this.start.column == column) {
              return -1;
            } else {
              return this.compare(row, column);
            }
          };
          this.compareEnd = function(row, column) {
            if (this.end.row == row && this.end.column == column) {
              return 1;
            } else {
              return this.compare(row, column);
            }
          };
          this.compareInside = function(row, column) {
            if (this.end.row == row && this.end.column == column) {
              return 1;
            } else if (this.start.row == row && this.start.column == column) {
              return -1;
            } else {
              return this.compare(row, column);
            }
          };
          this.clipRows = function(firstRow, lastRow) {
            if (this.end.row > lastRow)
              var end = { row: lastRow + 1, column: 0 };
            else if (this.end.row < firstRow)
              var end = { row: firstRow, column: 0 };
            if (this.start.row > lastRow)
              var start = { row: lastRow + 1, column: 0 };
            else if (this.start.row < firstRow)
              var start = { row: firstRow, column: 0 };
            return Range.fromPoints(start || this.start, end || this.end);
          };
          this.extend = function(row, column) {
            var cmp = this.compare(row, column);
            if (cmp == 0)
              return this;
            else if (cmp == -1)
              var start = { row, column };
            else
              var end = { row, column };
            return Range.fromPoints(start || this.start, end || this.end);
          };
          this.isEmpty = function() {
            return this.start.row === this.end.row && this.start.column === this.end.column;
          };
          this.isMultiLine = function() {
            return this.start.row !== this.end.row;
          };
          this.clone = function() {
            return Range.fromPoints(this.start, this.end);
          };
          this.collapseRows = function() {
            if (this.end.column == 0)
              return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);
            else
              return new Range(this.start.row, 0, this.end.row, 0);
          };
          this.toScreenRange = function(session) {
            var screenPosStart = session.documentToScreenPosition(this.start);
            var screenPosEnd = session.documentToScreenPosition(this.end);
            return new Range(
              screenPosStart.row,
              screenPosStart.column,
              screenPosEnd.row,
              screenPosEnd.column
            );
          };
          this.moveBy = function(row, column) {
            this.start.row += row;
            this.start.column += column;
            this.end.row += row;
            this.end.column += column;
          };
        }).call(Range.prototype);
        Range.fromPoints = function(start, end) {
          return new Range(start.row, start.column, end.row, end.column);
        };
        Range.comparePoints = comparePoints;
        Range.comparePoints = function(p1, p2) {
          return p1.row - p2.row || p1.column - p2.column;
        };
        exports2.Range = Range;
      });
      ace.define("ace/selection", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/range"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("./lib/oop");
        var lang = acequire("./lib/lang");
        var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
        var Range = acequire("./range").Range;
        var Selection = function(session) {
          this.session = session;
          this.doc = session.getDocument();
          this.clearSelection();
          this.lead = this.selectionLead = this.doc.createAnchor(0, 0);
          this.anchor = this.selectionAnchor = this.doc.createAnchor(0, 0);
          var self2 = this;
          this.lead.on("change", function(e) {
            self2._emit("changeCursor");
            if (!self2.$isEmpty)
              self2._emit("changeSelection");
            if (!self2.$keepDesiredColumnOnChange && e.old.column != e.value.column)
              self2.$desiredColumn = null;
          });
          this.selectionAnchor.on("change", function() {
            if (!self2.$isEmpty)
              self2._emit("changeSelection");
          });
        };
        (function() {
          oop.implement(this, EventEmitter);
          this.isEmpty = function() {
            return this.$isEmpty || this.anchor.row == this.lead.row && this.anchor.column == this.lead.column;
          };
          this.isMultiLine = function() {
            if (this.isEmpty()) {
              return false;
            }
            return this.getRange().isMultiLine();
          };
          this.getCursor = function() {
            return this.lead.getPosition();
          };
          this.setSelectionAnchor = function(row, column) {
            this.anchor.setPosition(row, column);
            if (this.$isEmpty) {
              this.$isEmpty = false;
              this._emit("changeSelection");
            }
          };
          this.getSelectionAnchor = function() {
            if (this.$isEmpty)
              return this.getSelectionLead();
            else
              return this.anchor.getPosition();
          };
          this.getSelectionLead = function() {
            return this.lead.getPosition();
          };
          this.shiftSelection = function(columns) {
            if (this.$isEmpty) {
              this.moveCursorTo(this.lead.row, this.lead.column + columns);
              return;
            }
            var anchor = this.getSelectionAnchor();
            var lead = this.getSelectionLead();
            var isBackwards = this.isBackwards();
            if (!isBackwards || anchor.column !== 0)
              this.setSelectionAnchor(anchor.row, anchor.column + columns);
            if (isBackwards || lead.column !== 0) {
              this.$moveSelection(function() {
                this.moveCursorTo(lead.row, lead.column + columns);
              });
            }
          };
          this.isBackwards = function() {
            var anchor = this.anchor;
            var lead = this.lead;
            return anchor.row > lead.row || anchor.row == lead.row && anchor.column > lead.column;
          };
          this.getRange = function() {
            var anchor = this.anchor;
            var lead = this.lead;
            if (this.isEmpty())
              return Range.fromPoints(lead, lead);
            if (this.isBackwards()) {
              return Range.fromPoints(lead, anchor);
            } else {
              return Range.fromPoints(anchor, lead);
            }
          };
          this.clearSelection = function() {
            if (!this.$isEmpty) {
              this.$isEmpty = true;
              this._emit("changeSelection");
            }
          };
          this.selectAll = function() {
            var lastRow = this.doc.getLength() - 1;
            this.setSelectionAnchor(0, 0);
            this.moveCursorTo(lastRow, this.doc.getLine(lastRow).length);
          };
          this.setRange = this.setSelectionRange = function(range, reverse) {
            if (reverse) {
              this.setSelectionAnchor(range.end.row, range.end.column);
              this.selectTo(range.start.row, range.start.column);
            } else {
              this.setSelectionAnchor(range.start.row, range.start.column);
              this.selectTo(range.end.row, range.end.column);
            }
            if (this.getRange().isEmpty())
              this.$isEmpty = true;
            this.$desiredColumn = null;
          };
          this.$moveSelection = function(mover) {
            var lead = this.lead;
            if (this.$isEmpty)
              this.setSelectionAnchor(lead.row, lead.column);
            mover.call(this);
          };
          this.selectTo = function(row, column) {
            this.$moveSelection(function() {
              this.moveCursorTo(row, column);
            });
          };
          this.selectToPosition = function(pos) {
            this.$moveSelection(function() {
              this.moveCursorToPosition(pos);
            });
          };
          this.moveTo = function(row, column) {
            this.clearSelection();
            this.moveCursorTo(row, column);
          };
          this.moveToPosition = function(pos) {
            this.clearSelection();
            this.moveCursorToPosition(pos);
          };
          this.selectUp = function() {
            this.$moveSelection(this.moveCursorUp);
          };
          this.selectDown = function() {
            this.$moveSelection(this.moveCursorDown);
          };
          this.selectRight = function() {
            this.$moveSelection(this.moveCursorRight);
          };
          this.selectLeft = function() {
            this.$moveSelection(this.moveCursorLeft);
          };
          this.selectLineStart = function() {
            this.$moveSelection(this.moveCursorLineStart);
          };
          this.selectLineEnd = function() {
            this.$moveSelection(this.moveCursorLineEnd);
          };
          this.selectFileEnd = function() {
            this.$moveSelection(this.moveCursorFileEnd);
          };
          this.selectFileStart = function() {
            this.$moveSelection(this.moveCursorFileStart);
          };
          this.selectWordRight = function() {
            this.$moveSelection(this.moveCursorWordRight);
          };
          this.selectWordLeft = function() {
            this.$moveSelection(this.moveCursorWordLeft);
          };
          this.getWordRange = function(row, column) {
            if (typeof column == "undefined") {
              var cursor = row || this.lead;
              row = cursor.row;
              column = cursor.column;
            }
            return this.session.getWordRange(row, column);
          };
          this.selectWord = function() {
            this.setSelectionRange(this.getWordRange());
          };
          this.selectAWord = function() {
            var cursor = this.getCursor();
            var range = this.session.getAWordRange(cursor.row, cursor.column);
            this.setSelectionRange(range);
          };
          this.getLineRange = function(row, excludeLastChar) {
            var rowStart = typeof row == "number" ? row : this.lead.row;
            var rowEnd;
            var foldLine = this.session.getFoldLine(rowStart);
            if (foldLine) {
              rowStart = foldLine.start.row;
              rowEnd = foldLine.end.row;
            } else {
              rowEnd = rowStart;
            }
            if (excludeLastChar === true)
              return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
            else
              return new Range(rowStart, 0, rowEnd + 1, 0);
          };
          this.selectLine = function() {
            this.setSelectionRange(this.getLineRange());
          };
          this.moveCursorUp = function() {
            this.moveCursorBy(-1, 0);
          };
          this.moveCursorDown = function() {
            this.moveCursorBy(1, 0);
          };
          this.wouldMoveIntoSoftTab = function(cursor, tabSize, direction) {
            var start = cursor.column;
            var end = cursor.column + tabSize;
            if (direction < 0) {
              start = cursor.column - tabSize;
              end = cursor.column;
            }
            return this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(start, end).split(" ").length - 1 == tabSize;
          };
          this.moveCursorLeft = function() {
            var cursor = this.lead.getPosition(), fold;
            if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
              this.moveCursorTo(fold.start.row, fold.start.column);
            } else if (cursor.column === 0) {
              if (cursor.row > 0) {
                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
              }
            } else {
              var tabSize = this.session.getTabSize();
              if (this.wouldMoveIntoSoftTab(cursor, tabSize, -1) && !this.session.getNavigateWithinSoftTabs()) {
                this.moveCursorBy(0, -tabSize);
              } else {
                this.moveCursorBy(0, -1);
              }
            }
          };
          this.moveCursorRight = function() {
            var cursor = this.lead.getPosition(), fold;
            if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
              this.moveCursorTo(fold.end.row, fold.end.column);
            } else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
              if (this.lead.row < this.doc.getLength() - 1) {
                this.moveCursorTo(this.lead.row + 1, 0);
              }
            } else {
              var tabSize = this.session.getTabSize();
              var cursor = this.lead;
              if (this.wouldMoveIntoSoftTab(cursor, tabSize, 1) && !this.session.getNavigateWithinSoftTabs()) {
                this.moveCursorBy(0, tabSize);
              } else {
                this.moveCursorBy(0, 1);
              }
            }
          };
          this.moveCursorLineStart = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var screenRow = this.session.documentToScreenRow(row, column);
            var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
            var beforeCursor = this.session.getDisplayLine(
              row,
              null,
              firstColumnPosition.row,
              firstColumnPosition.column
            );
            var leadingSpace = beforeCursor.match(/^\s*/);
            if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
              firstColumnPosition.column += leadingSpace[0].length;
            this.moveCursorToPosition(firstColumnPosition);
          };
          this.moveCursorLineEnd = function() {
            var lead = this.lead;
            var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
            if (this.lead.column == lineEnd.column) {
              var line = this.session.getLine(lineEnd.row);
              if (lineEnd.column == line.length) {
                var textEnd = line.search(/\s+$/);
                if (textEnd > 0)
                  lineEnd.column = textEnd;
              }
            }
            this.moveCursorTo(lineEnd.row, lineEnd.column);
          };
          this.moveCursorFileEnd = function() {
            var row = this.doc.getLength() - 1;
            var column = this.doc.getLine(row).length;
            this.moveCursorTo(row, column);
          };
          this.moveCursorFileStart = function() {
            this.moveCursorTo(0, 0);
          };
          this.moveCursorLongWordRight = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var line = this.doc.getLine(row);
            var rightOfCursor = line.substring(column);
            var match;
            this.session.nonTokenRe.lastIndex = 0;
            this.session.tokenRe.lastIndex = 0;
            var fold = this.session.getFoldAt(row, column, 1);
            if (fold) {
              this.moveCursorTo(fold.end.row, fold.end.column);
              return;
            }
            if (match = this.session.nonTokenRe.exec(rightOfCursor)) {
              column += this.session.nonTokenRe.lastIndex;
              this.session.nonTokenRe.lastIndex = 0;
              rightOfCursor = line.substring(column);
            }
            if (column >= line.length) {
              this.moveCursorTo(row, line.length);
              this.moveCursorRight();
              if (row < this.doc.getLength() - 1)
                this.moveCursorWordRight();
              return;
            }
            if (match = this.session.tokenRe.exec(rightOfCursor)) {
              column += this.session.tokenRe.lastIndex;
              this.session.tokenRe.lastIndex = 0;
            }
            this.moveCursorTo(row, column);
          };
          this.moveCursorLongWordLeft = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var fold;
            if (fold = this.session.getFoldAt(row, column, -1)) {
              this.moveCursorTo(fold.start.row, fold.start.column);
              return;
            }
            var str = this.session.getFoldStringAt(row, column, -1);
            if (str == null) {
              str = this.doc.getLine(row).substring(0, column);
            }
            var leftOfCursor = lang.stringReverse(str);
            var match;
            this.session.nonTokenRe.lastIndex = 0;
            this.session.tokenRe.lastIndex = 0;
            if (match = this.session.nonTokenRe.exec(leftOfCursor)) {
              column -= this.session.nonTokenRe.lastIndex;
              leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
              this.session.nonTokenRe.lastIndex = 0;
            }
            if (column <= 0) {
              this.moveCursorTo(row, 0);
              this.moveCursorLeft();
              if (row > 0)
                this.moveCursorWordLeft();
              return;
            }
            if (match = this.session.tokenRe.exec(leftOfCursor)) {
              column -= this.session.tokenRe.lastIndex;
              this.session.tokenRe.lastIndex = 0;
            }
            this.moveCursorTo(row, column);
          };
          this.$shortWordEndIndex = function(rightOfCursor) {
            var match, index = 0, ch;
            var whitespaceRe = /\s/;
            var tokenRe = this.session.tokenRe;
            tokenRe.lastIndex = 0;
            if (match = this.session.tokenRe.exec(rightOfCursor)) {
              index = this.session.tokenRe.lastIndex;
            } else {
              while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                index++;
              if (index < 1) {
                tokenRe.lastIndex = 0;
                while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
                  tokenRe.lastIndex = 0;
                  index++;
                  if (whitespaceRe.test(ch)) {
                    if (index > 2) {
                      index--;
                      break;
                    } else {
                      while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                        index++;
                      if (index > 2)
                        break;
                    }
                  }
                }
              }
            }
            tokenRe.lastIndex = 0;
            return index;
          };
          this.moveCursorShortWordRight = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var line = this.doc.getLine(row);
            var rightOfCursor = line.substring(column);
            var fold = this.session.getFoldAt(row, column, 1);
            if (fold)
              return this.moveCursorTo(fold.end.row, fold.end.column);
            if (column == line.length) {
              var l = this.doc.getLength();
              do {
                row++;
                rightOfCursor = this.doc.getLine(row);
              } while (row < l && /^\s*$/.test(rightOfCursor));
              if (!/^\s+/.test(rightOfCursor))
                rightOfCursor = "";
              column = 0;
            }
            var index = this.$shortWordEndIndex(rightOfCursor);
            this.moveCursorTo(row, column + index);
          };
          this.moveCursorShortWordLeft = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var fold;
            if (fold = this.session.getFoldAt(row, column, -1))
              return this.moveCursorTo(fold.start.row, fold.start.column);
            var line = this.session.getLine(row).substring(0, column);
            if (column === 0) {
              do {
                row--;
                line = this.doc.getLine(row);
              } while (row > 0 && /^\s*$/.test(line));
              column = line.length;
              if (!/\s+$/.test(line))
                line = "";
            }
            var leftOfCursor = lang.stringReverse(line);
            var index = this.$shortWordEndIndex(leftOfCursor);
            return this.moveCursorTo(row, column - index);
          };
          this.moveCursorWordRight = function() {
            if (this.session.$selectLongWords)
              this.moveCursorLongWordRight();
            else
              this.moveCursorShortWordRight();
          };
          this.moveCursorWordLeft = function() {
            if (this.session.$selectLongWords)
              this.moveCursorLongWordLeft();
            else
              this.moveCursorShortWordLeft();
          };
          this.moveCursorBy = function(rows, chars) {
            var screenPos = this.session.documentToScreenPosition(
              this.lead.row,
              this.lead.column
            );
            var offsetX;
            if (chars === 0) {
              if (rows !== 0) {
                if (this.session.$bidiHandler.isBidiRow(screenPos.row, this.lead.row)) {
                  offsetX = this.session.$bidiHandler.getPosLeft(screenPos.column);
                  screenPos.column = Math.round(offsetX / this.session.$bidiHandler.charWidths[0]);
                } else {
                  offsetX = screenPos.column * this.session.$bidiHandler.charWidths[0];
                }
              }
              if (this.$desiredColumn)
                screenPos.column = this.$desiredColumn;
              else
                this.$desiredColumn = screenPos.column;
            }
            var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column, offsetX);
            if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {
              if (this.session.lineWidgets && this.session.lineWidgets[docPos.row]) {
                if (docPos.row > 0 || rows > 0)
                  docPos.row++;
              }
            }
            this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
          };
          this.moveCursorToPosition = function(position) {
            this.moveCursorTo(position.row, position.column);
          };
          this.moveCursorTo = function(row, column, keepDesiredColumn) {
            var fold = this.session.getFoldAt(row, column, 1);
            if (fold) {
              row = fold.start.row;
              column = fold.start.column;
            }
            this.$keepDesiredColumnOnChange = true;
            var line = this.session.getLine(row);
            if (/[\uDC00-\uDFFF]/.test(line.charAt(column)) && line.charAt(column - 1)) {
              if (this.lead.row == row && this.lead.column == column + 1)
                column = column - 1;
              else
                column = column + 1;
            }
            this.lead.setPosition(row, column);
            this.$keepDesiredColumnOnChange = false;
            if (!keepDesiredColumn)
              this.$desiredColumn = null;
          };
          this.moveCursorToScreen = function(row, column, keepDesiredColumn) {
            var pos = this.session.screenToDocumentPosition(row, column);
            this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
          };
          this.detach = function() {
            this.lead.detach();
            this.anchor.detach();
            this.session = this.doc = null;
          };
          this.fromOrientedRange = function(range) {
            this.setSelectionRange(range, range.cursor == range.start);
            this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
          };
          this.toOrientedRange = function(range) {
            var r = this.getRange();
            if (range) {
              range.start.column = r.start.column;
              range.start.row = r.start.row;
              range.end.column = r.end.column;
              range.end.row = r.end.row;
            } else {
              range = r;
            }
            range.cursor = this.isBackwards() ? range.start : range.end;
            range.desiredColumn = this.$desiredColumn;
            return range;
          };
          this.getRangeOfMovements = function(func) {
            var start = this.getCursor();
            try {
              func(this);
              var end = this.getCursor();
              return Range.fromPoints(start, end);
            } catch (e) {
              return Range.fromPoints(start, start);
            } finally {
              this.moveCursorToPosition(start);
            }
          };
          this.toJSON = function() {
            if (this.rangeCount) {
              var data = this.ranges.map(function(r) {
                var r1 = r.clone();
                r1.isBackwards = r.cursor == r.start;
                return r1;
              });
            } else {
              var data = this.getRange();
              data.isBackwards = this.isBackwards();
            }
            return data;
          };
          this.fromJSON = function(data) {
            if (data.start == void 0) {
              if (this.rangeList) {
                this.toSingleRange(data[0]);
                for (var i = data.length; i--; ) {
                  var r = Range.fromPoints(data[i].start, data[i].end);
                  if (data[i].isBackwards)
                    r.cursor = r.start;
                  this.addRange(r, true);
                }
                return;
              } else
                data = data[0];
            }
            if (this.rangeList)
              this.toSingleRange(data);
            this.setSelectionRange(data, data.isBackwards);
          };
          this.isEqual = function(data) {
            if ((data.length || this.rangeCount) && data.length != this.rangeCount)
              return false;
            if (!data.length || !this.ranges)
              return this.getRange().isEqual(data);
            for (var i = this.ranges.length; i--; ) {
              if (!this.ranges[i].isEqual(data[i]))
                return false;
            }
            return true;
          };
        }).call(Selection.prototype);
        exports2.Selection = Selection;
      });
      ace.define("ace/tokenizer", ["require", "exports", "module", "ace/config"], function(acequire, exports2, module2) {
        "use strict";
        var config = acequire("./config");
        var MAX_TOKEN_COUNT = 2e3;
        var Tokenizer = function(rules) {
          this.states = rules;
          this.regExps = {};
          this.matchMappings = {};
          for (var key in this.states) {
            var state = this.states[key];
            var ruleRegExps = [];
            var matchTotal = 0;
            var mapping = this.matchMappings[key] = { defaultToken: "text" };
            var flag = "g";
            var splitterRurles = [];
            for (var i = 0; i < state.length; i++) {
              var rule = state[i];
              if (rule.defaultToken)
                mapping.defaultToken = rule.defaultToken;
              if (rule.caseInsensitive)
                flag = "gi";
              if (rule.regex == null)
                continue;
              if (rule.regex instanceof RegExp)
                rule.regex = rule.regex.toString().slice(1, -1);
              var adjustedregex = rule.regex;
              var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
              if (Array.isArray(rule.token)) {
                if (rule.token.length == 1 || matchcount == 1) {
                  rule.token = rule.token[0];
                } else if (matchcount - 1 != rule.token.length) {
                  this.reportError("number of classes and regexp groups doesn't match", {
                    rule,
                    groupCount: matchcount - 1
                  });
                  rule.token = rule.token[0];
                } else {
                  rule.tokenArray = rule.token;
                  rule.token = null;
                  rule.onMatch = this.$arrayTokens;
                }
              } else if (typeof rule.token == "function" && !rule.onMatch) {
                if (matchcount > 1)
                  rule.onMatch = this.$applyToken;
                else
                  rule.onMatch = rule.token;
              }
              if (matchcount > 1) {
                if (/\\\d/.test(rule.regex)) {
                  adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
                    return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                  });
                } else {
                  matchcount = 1;
                  adjustedregex = this.removeCapturingGroups(rule.regex);
                }
                if (!rule.splitRegex && typeof rule.token != "string")
                  splitterRurles.push(rule);
              }
              mapping[matchTotal] = i;
              matchTotal += matchcount;
              ruleRegExps.push(adjustedregex);
              if (!rule.onMatch)
                rule.onMatch = null;
            }
            if (!ruleRegExps.length) {
              mapping[0] = 0;
              ruleRegExps.push("$");
            }
            splitterRurles.forEach(function(rule2) {
              rule2.splitRegex = this.createSplitterRegexp(rule2.regex, flag);
            }, this);
            this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
          }
        };
        (function() {
          this.$setMaxTokenCount = function(m) {
            MAX_TOKEN_COUNT = m | 0;
          };
          this.$applyToken = function(str) {
            var values = this.splitRegex.exec(str).slice(1);
            var types = this.token.apply(this, values);
            if (typeof types === "string")
              return [{ type: types, value: str }];
            var tokens = [];
            for (var i = 0, l = types.length; i < l; i++) {
              if (values[i])
                tokens[tokens.length] = {
                  type: types[i],
                  value: values[i]
                };
            }
            return tokens;
          };
          this.$arrayTokens = function(str) {
            if (!str)
              return [];
            var values = this.splitRegex.exec(str);
            if (!values)
              return "text";
            var tokens = [];
            var types = this.tokenArray;
            for (var i = 0, l = types.length; i < l; i++) {
              if (values[i + 1])
                tokens[tokens.length] = {
                  type: types[i],
                  value: values[i + 1]
                };
            }
            return tokens;
          };
          this.removeCapturingGroups = function(src) {
            var r = src.replace(
              /\[(?:\\.|[^\]])*?\]|\\.|\(\?[:=!]|(\()/g,
              function(x, y) {
                return y ? "(?:" : x;
              }
            );
            return r;
          };
          this.createSplitterRegexp = function(src, flag) {
            if (src.indexOf("(?=") != -1) {
              var stack = 0;
              var inChClass = false;
              var lastCapture = {};
              src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(m, esc, parenOpen, parenClose, square, index) {
                if (inChClass) {
                  inChClass = square != "]";
                } else if (square) {
                  inChClass = true;
                } else if (parenClose) {
                  if (stack == lastCapture.stack) {
                    lastCapture.end = index + 1;
                    lastCapture.stack = -1;
                  }
                  stack--;
                } else if (parenOpen) {
                  stack++;
                  if (parenOpen.length != 1) {
                    lastCapture.stack = stack;
                    lastCapture.start = index;
                  }
                }
                return m;
              });
              if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
                src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
            }
            if (src.charAt(0) != "^")
              src = "^" + src;
            if (src.charAt(src.length - 1) != "$")
              src += "$";
            return new RegExp(src, (flag || "").replace("g", ""));
          };
          this.getLineTokens = function(line, startState) {
            if (startState && typeof startState != "string") {
              var stack = startState.slice(0);
              startState = stack[0];
              if (startState === "#tmp") {
                stack.shift();
                startState = stack.shift();
              }
            } else
              var stack = [];
            var currentState = startState || "start";
            var state = this.states[currentState];
            if (!state) {
              currentState = "start";
              state = this.states[currentState];
            }
            var mapping = this.matchMappings[currentState];
            var re = this.regExps[currentState];
            re.lastIndex = 0;
            var match, tokens = [];
            var lastIndex = 0;
            var matchAttempts = 0;
            var token = { type: null, value: "" };
            while (match = re.exec(line)) {
              var type = mapping.defaultToken;
              var rule = null;
              var value = match[0];
              var index = re.lastIndex;
              if (index - value.length > lastIndex) {
                var skipped = line.substring(lastIndex, index - value.length);
                if (token.type == type) {
                  token.value += skipped;
                } else {
                  if (token.type)
                    tokens.push(token);
                  token = { type, value: skipped };
                }
              }
              for (var i = 0; i < match.length - 2; i++) {
                if (match[i + 1] === void 0)
                  continue;
                rule = state[mapping[i]];
                if (rule.onMatch)
                  type = rule.onMatch(value, currentState, stack, line);
                else
                  type = rule.token;
                if (rule.next) {
                  if (typeof rule.next == "string") {
                    currentState = rule.next;
                  } else {
                    currentState = rule.next(currentState, stack);
                  }
                  state = this.states[currentState];
                  if (!state) {
                    this.reportError("state doesn't exist", currentState);
                    currentState = "start";
                    state = this.states[currentState];
                  }
                  mapping = this.matchMappings[currentState];
                  lastIndex = index;
                  re = this.regExps[currentState];
                  re.lastIndex = index;
                }
                if (rule.consumeLineEnd)
                  lastIndex = index;
                break;
              }
              if (value) {
                if (typeof type === "string") {
                  if ((!rule || rule.merge !== false) && token.type === type) {
                    token.value += value;
                  } else {
                    if (token.type)
                      tokens.push(token);
                    token = { type, value };
                  }
                } else if (type) {
                  if (token.type)
                    tokens.push(token);
                  token = { type: null, value: "" };
                  for (var i = 0; i < type.length; i++)
                    tokens.push(type[i]);
                }
              }
              if (lastIndex == line.length)
                break;
              lastIndex = index;
              if (matchAttempts++ > MAX_TOKEN_COUNT) {
                if (matchAttempts > 2 * line.length) {
                  this.reportError("infinite loop with in ace tokenizer", {
                    startState,
                    line
                  });
                }
                while (lastIndex < line.length) {
                  if (token.type)
                    tokens.push(token);
                  token = {
                    value: line.substring(lastIndex, lastIndex += 2e3),
                    type: "overflow"
                  };
                }
                currentState = "start";
                stack = [];
                break;
              }
            }
            if (token.type)
              tokens.push(token);
            if (stack.length > 1) {
              if (stack[0] !== currentState)
                stack.unshift("#tmp", currentState);
            }
            return {
              tokens,
              state: stack.length ? stack : currentState
            };
          };
          this.reportError = config.reportError;
        }).call(Tokenizer.prototype);
        exports2.Tokenizer = Tokenizer;
      });
      ace.define("ace/mode/text_highlight_rules", ["require", "exports", "module", "ace/lib/lang"], function(acequire, exports2, module2) {
        "use strict";
        var lang = acequire("../lib/lang");
        var TextHighlightRules = function() {
          this.$rules = {
            "start": [{
              token: "empty_line",
              regex: "^$"
            }, {
              defaultToken: "text"
            }]
          };
        };
        (function() {
          this.addRules = function(rules, prefix) {
            if (!prefix) {
              for (var key in rules)
                this.$rules[key] = rules[key];
              return;
            }
            for (var key in rules) {
              var state = rules[key];
              for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                if (rule.next || rule.onMatch) {
                  if (typeof rule.next == "string") {
                    if (rule.next.indexOf(prefix) !== 0)
                      rule.next = prefix + rule.next;
                  }
                  if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
                    rule.nextState = prefix + rule.nextState;
                }
              }
              this.$rules[prefix + key] = state;
            }
          };
          this.getRules = function() {
            return this.$rules;
          };
          this.embedRules = function(HighlightRules, prefix, escapeRules, states, append) {
            var embedRules = typeof HighlightRules == "function" ? new HighlightRules().getRules() : HighlightRules;
            if (states) {
              for (var i = 0; i < states.length; i++)
                states[i] = prefix + states[i];
            } else {
              states = [];
              for (var key in embedRules)
                states.push(prefix + key);
            }
            this.addRules(embedRules, prefix);
            if (escapeRules) {
              var addRules = Array.prototype[append ? "push" : "unshift"];
              for (var i = 0; i < states.length; i++)
                addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
            }
            if (!this.$embeds)
              this.$embeds = [];
            this.$embeds.push(prefix);
          };
          this.getEmbeds = function() {
            return this.$embeds;
          };
          var pushState = function(currentState, stack) {
            if (currentState != "start" || stack.length)
              stack.unshift(this.nextState, currentState);
            return this.nextState;
          };
          var popState = function(currentState, stack) {
            stack.shift();
            return stack.shift() || "start";
          };
          this.normalizeRules = function() {
            var id = 0;
            var rules = this.$rules;
            function processState(key) {
              var state = rules[key];
              state.processed = true;
              for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                var toInsert = null;
                if (Array.isArray(rule)) {
                  toInsert = rule;
                  rule = {};
                }
                if (!rule.regex && rule.start) {
                  rule.regex = rule.start;
                  if (!rule.next)
                    rule.next = [];
                  rule.next.push({
                    defaultToken: rule.token
                  }, {
                    token: rule.token + ".end",
                    regex: rule.end || rule.start,
                    next: "pop"
                  });
                  rule.token = rule.token + ".start";
                  rule.push = true;
                }
                var next = rule.next || rule.push;
                if (next && Array.isArray(next)) {
                  var stateName = rule.stateName;
                  if (!stateName) {
                    stateName = rule.token;
                    if (typeof stateName != "string")
                      stateName = stateName[0] || "";
                    if (rules[stateName])
                      stateName += id++;
                  }
                  rules[stateName] = next;
                  rule.next = stateName;
                  processState(stateName);
                } else if (next == "pop") {
                  rule.next = popState;
                }
                if (rule.push) {
                  rule.nextState = rule.next || rule.push;
                  rule.next = pushState;
                  delete rule.push;
                }
                if (rule.rules) {
                  for (var r in rule.rules) {
                    if (rules[r]) {
                      if (rules[r].push)
                        rules[r].push.apply(rules[r], rule.rules[r]);
                    } else {
                      rules[r] = rule.rules[r];
                    }
                  }
                }
                var includeName = typeof rule == "string" ? rule : rule.include;
                if (includeName) {
                  if (Array.isArray(includeName))
                    toInsert = includeName.map(function(x) {
                      return rules[x];
                    });
                  else
                    toInsert = rules[includeName];
                }
                if (toInsert) {
                  var args = [i, 1].concat(toInsert);
                  if (rule.noEscape)
                    args = args.filter(function(x) {
                      return !x.next;
                    });
                  state.splice.apply(state, args);
                  i--;
                }
                if (rule.keywordMap) {
                  rule.token = this.createKeywordMapper(
                    rule.keywordMap,
                    rule.defaultToken || "text",
                    rule.caseInsensitive
                  );
                  delete rule.defaultToken;
                }
              }
            }
            Object.keys(rules).forEach(processState, this);
          };
          this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
            var keywords = /* @__PURE__ */ Object.create(null);
            Object.keys(map).forEach(function(className) {
              var a = map[className];
              if (ignoreCase)
                a = a.toLowerCase();
              var list = a.split(splitChar || "|");
              for (var i = list.length; i--; )
                keywords[list[i]] = className;
            });
            if (Object.getPrototypeOf(keywords)) {
              keywords.__proto__ = null;
            }
            this.$keywordList = Object.keys(keywords);
            map = null;
            return ignoreCase ? function(value) {
              return keywords[value.toLowerCase()] || defaultToken;
            } : function(value) {
              return keywords[value] || defaultToken;
            };
          };
          this.getKeywords = function() {
            return this.$keywords;
          };
        }).call(TextHighlightRules.prototype);
        exports2.TextHighlightRules = TextHighlightRules;
      });
      ace.define("ace/mode/behaviour", ["require", "exports", "module"], function(acequire, exports2, module2) {
        "use strict";
        var Behaviour = function() {
          this.$behaviours = {};
        };
        (function() {
          this.add = function(name, action, callback) {
            switch (void 0) {
              case this.$behaviours:
                this.$behaviours = {};
              case this.$behaviours[name]:
                this.$behaviours[name] = {};
            }
            this.$behaviours[name][action] = callback;
          };
          this.addBehaviours = function(behaviours) {
            for (var key in behaviours) {
              for (var action in behaviours[key]) {
                this.add(key, action, behaviours[key][action]);
              }
            }
          };
          this.remove = function(name) {
            if (this.$behaviours && this.$behaviours[name]) {
              delete this.$behaviours[name];
            }
          };
          this.inherit = function(mode, filter) {
            if (typeof mode === "function") {
              var behaviours = new mode().getBehaviours(filter);
            } else {
              var behaviours = mode.getBehaviours(filter);
            }
            this.addBehaviours(behaviours);
          };
          this.getBehaviours = function(filter) {
            if (!filter) {
              return this.$behaviours;
            } else {
              var ret = {};
              for (var i = 0; i < filter.length; i++) {
                if (this.$behaviours[filter[i]]) {
                  ret[filter[i]] = this.$behaviours[filter[i]];
                }
              }
              return ret;
            }
          };
        }).call(Behaviour.prototype);
        exports2.Behaviour = Behaviour;
      });
      ace.define("ace/token_iterator", ["require", "exports", "module", "ace/range"], function(acequire, exports2, module2) {
        "use strict";
        var Range = acequire("./range").Range;
        var TokenIterator = function(session, initialRow, initialColumn) {
          this.$session = session;
          this.$row = initialRow;
          this.$rowTokens = session.getTokens(initialRow);
          var token = session.getTokenAt(initialRow, initialColumn);
          this.$tokenIndex = token ? token.index : -1;
        };
        (function() {
          this.stepBackward = function() {
            this.$tokenIndex -= 1;
            while (this.$tokenIndex < 0) {
              this.$row -= 1;
              if (this.$row < 0) {
                this.$row = 0;
                return null;
              }
              this.$rowTokens = this.$session.getTokens(this.$row);
              this.$tokenIndex = this.$rowTokens.length - 1;
            }
            return this.$rowTokens[this.$tokenIndex];
          };
          this.stepForward = function() {
            this.$tokenIndex += 1;
            var rowCount;
            while (this.$tokenIndex >= this.$rowTokens.length) {
              this.$row += 1;
              if (!rowCount)
                rowCount = this.$session.getLength();
              if (this.$row >= rowCount) {
                this.$row = rowCount - 1;
                return null;
              }
              this.$rowTokens = this.$session.getTokens(this.$row);
              this.$tokenIndex = 0;
            }
            return this.$rowTokens[this.$tokenIndex];
          };
          this.getCurrentToken = function() {
            return this.$rowTokens[this.$tokenIndex];
          };
          this.getCurrentTokenRow = function() {
            return this.$row;
          };
          this.getCurrentTokenColumn = function() {
            var rowTokens = this.$rowTokens;
            var tokenIndex = this.$tokenIndex;
            var column = rowTokens[tokenIndex].start;
            if (column !== void 0)
              return column;
            column = 0;
            while (tokenIndex > 0) {
              tokenIndex -= 1;
              column += rowTokens[tokenIndex].value.length;
            }
            return column;
          };
          this.getCurrentTokenPosition = function() {
            return { row: this.$row, column: this.getCurrentTokenColumn() };
          };
          this.getCurrentTokenRange = function() {
            var token = this.$rowTokens[this.$tokenIndex];
            var column = this.getCurrentTokenColumn();
            return new Range(this.$row, column, this.$row, column + token.value.length);
          };
        }).call(TokenIterator.prototype);
        exports2.TokenIterator = TokenIterator;
      });
      ace.define("ace/mode/behaviour/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/token_iterator", "ace/lib/lang"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("../../lib/oop");
        var Behaviour = acequire("../behaviour").Behaviour;
        var TokenIterator = acequire("../../token_iterator").TokenIterator;
        var lang = acequire("../../lib/lang");
        var SAFE_INSERT_IN_TOKENS = ["text", "paren.rparen", "punctuation.operator"];
        var SAFE_INSERT_BEFORE_TOKENS = ["text", "paren.rparen", "punctuation.operator", "comment"];
        var context;
        var contextCache = {};
        var defaultQuotes = { '"': '"', "'": "'" };
        var initContext = function(editor) {
          var id = -1;
          if (editor.multiSelect) {
            id = editor.selection.index;
            if (contextCache.rangeCount != editor.multiSelect.rangeCount)
              contextCache = { rangeCount: editor.multiSelect.rangeCount };
          }
          if (contextCache[id])
            return context = contextCache[id];
          context = contextCache[id] = {
            autoInsertedBrackets: 0,
            autoInsertedRow: -1,
            autoInsertedLineEnd: "",
            maybeInsertedBrackets: 0,
            maybeInsertedRow: -1,
            maybeInsertedLineStart: "",
            maybeInsertedLineEnd: ""
          };
        };
        var getWrapped = function(selection, selected, opening, closing) {
          var rowDiff = selection.end.row - selection.start.row;
          return {
            text: opening + selected + closing,
            selection: [
              0,
              selection.start.column + 1,
              rowDiff,
              selection.end.column + (rowDiff ? 0 : 1)
            ]
          };
        };
        var CstyleBehaviour = function(options) {
          this.add("braces", "insertion", function(state, action, editor, session, text) {
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            if (text == "{") {
              initContext(editor);
              var selection = editor.getSelectionRange();
              var selected = session.doc.getTextRange(selection);
              if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, "{", "}");
              } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode || options && options.braces) {
                  CstyleBehaviour.recordAutoInsert(editor, session, "}");
                  return {
                    text: "{}",
                    selection: [1, 1]
                  };
                } else {
                  CstyleBehaviour.recordMaybeInsert(editor, session, "{");
                  return {
                    text: "{",
                    selection: [1, 1]
                  };
                }
              }
            } else if (text == "}") {
              initContext(editor);
              var rightChar = line.substring(cursor.column, cursor.column + 1);
              if (rightChar == "}") {
                var matching = session.$findOpeningBracket("}", { column: cursor.column + 1, row: cursor.row });
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                  CstyleBehaviour.popAutoInsertedClosing();
                  return {
                    text: "",
                    selection: [1, 1]
                  };
                }
              }
            } else if (text == "\n" || text == "\r\n") {
              initContext(editor);
              var closing = "";
              if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
                closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
                CstyleBehaviour.clearMaybeInsertedClosing();
              }
              var rightChar = line.substring(cursor.column, cursor.column + 1);
              if (rightChar === "}") {
                var openBracePos = session.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 }, "}");
                if (!openBracePos)
                  return null;
                var next_indent = this.$getIndent(session.getLine(openBracePos.row));
              } else if (closing) {
                var next_indent = this.$getIndent(line);
              } else {
                CstyleBehaviour.clearMaybeInsertedClosing();
                return;
              }
              var indent = next_indent + session.getTabString();
              return {
                text: "\n" + indent + "\n" + next_indent + closing,
                selection: [1, indent.length, 1, indent.length]
              };
            } else {
              CstyleBehaviour.clearMaybeInsertedClosing();
            }
          });
          this.add("braces", "deletion", function(state, action, editor, session, range) {
            var selected = session.doc.getTextRange(range);
            if (!range.isMultiLine() && selected == "{") {
              initContext(editor);
              var line = session.doc.getLine(range.start.row);
              var rightChar = line.substring(range.end.column, range.end.column + 1);
              if (rightChar == "}") {
                range.end.column++;
                return range;
              } else {
                context.maybeInsertedBrackets--;
              }
            }
          });
          this.add("parens", "insertion", function(state, action, editor, session, text) {
            if (text == "(") {
              initContext(editor);
              var selection = editor.getSelectionRange();
              var selected = session.doc.getTextRange(selection);
              if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, "(", ")");
              } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                CstyleBehaviour.recordAutoInsert(editor, session, ")");
                return {
                  text: "()",
                  selection: [1, 1]
                };
              }
            } else if (text == ")") {
              initContext(editor);
              var cursor = editor.getCursorPosition();
              var line = session.doc.getLine(cursor.row);
              var rightChar = line.substring(cursor.column, cursor.column + 1);
              if (rightChar == ")") {
                var matching = session.$findOpeningBracket(")", { column: cursor.column + 1, row: cursor.row });
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                  CstyleBehaviour.popAutoInsertedClosing();
                  return {
                    text: "",
                    selection: [1, 1]
                  };
                }
              }
            }
          });
          this.add("parens", "deletion", function(state, action, editor, session, range) {
            var selected = session.doc.getTextRange(range);
            if (!range.isMultiLine() && selected == "(") {
              initContext(editor);
              var line = session.doc.getLine(range.start.row);
              var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
              if (rightChar == ")") {
                range.end.column++;
                return range;
              }
            }
          });
          this.add("brackets", "insertion", function(state, action, editor, session, text) {
            if (text == "[") {
              initContext(editor);
              var selection = editor.getSelectionRange();
              var selected = session.doc.getTextRange(selection);
              if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, "[", "]");
              } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                CstyleBehaviour.recordAutoInsert(editor, session, "]");
                return {
                  text: "[]",
                  selection: [1, 1]
                };
              }
            } else if (text == "]") {
              initContext(editor);
              var cursor = editor.getCursorPosition();
              var line = session.doc.getLine(cursor.row);
              var rightChar = line.substring(cursor.column, cursor.column + 1);
              if (rightChar == "]") {
                var matching = session.$findOpeningBracket("]", { column: cursor.column + 1, row: cursor.row });
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                  CstyleBehaviour.popAutoInsertedClosing();
                  return {
                    text: "",
                    selection: [1, 1]
                  };
                }
              }
            }
          });
          this.add("brackets", "deletion", function(state, action, editor, session, range) {
            var selected = session.doc.getTextRange(range);
            if (!range.isMultiLine() && selected == "[") {
              initContext(editor);
              var line = session.doc.getLine(range.start.row);
              var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
              if (rightChar == "]") {
                range.end.column++;
                return range;
              }
            }
          });
          this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
            var quotes = session.$mode.$quotes || defaultQuotes;
            if (text.length == 1 && quotes[text]) {
              if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1)
                return;
              initContext(editor);
              var quote = text;
              var selection = editor.getSelectionRange();
              var selected = session.doc.getTextRange(selection);
              if (selected !== "" && (selected.length != 1 || !quotes[selected]) && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, quote, quote);
              } else if (!selected) {
                var cursor = editor.getCursorPosition();
                var line = session.doc.getLine(cursor.row);
                var leftChar = line.substring(cursor.column - 1, cursor.column);
                var rightChar = line.substring(cursor.column, cursor.column + 1);
                var token = session.getTokenAt(cursor.row, cursor.column);
                var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
                if (leftChar == "\\" && token && /escape/.test(token.type))
                  return null;
                var stringBefore = token && /string|escape/.test(token.type);
                var stringAfter = !rightToken || /string|escape/.test(rightToken.type);
                var pair;
                if (rightChar == quote) {
                  pair = stringBefore !== stringAfter;
                  if (pair && /string\.end/.test(rightToken.type))
                    pair = false;
                } else {
                  if (stringBefore && !stringAfter)
                    return null;
                  if (stringBefore && stringAfter)
                    return null;
                  var wordRe = session.$mode.tokenRe;
                  wordRe.lastIndex = 0;
                  var isWordBefore = wordRe.test(leftChar);
                  wordRe.lastIndex = 0;
                  var isWordAfter = wordRe.test(leftChar);
                  if (isWordBefore || isWordAfter)
                    return null;
                  if (rightChar && !/[\s;,.})\]\\]/.test(rightChar))
                    return null;
                  pair = true;
                }
                return {
                  text: pair ? quote + quote : "",
                  selection: [1, 1]
                };
              }
            }
          });
          this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
            var selected = session.doc.getTextRange(range);
            if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
              initContext(editor);
              var line = session.doc.getLine(range.start.row);
              var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
              if (rightChar == selected) {
                range.end.column++;
                return range;
              }
            }
          });
        };
        CstyleBehaviour.isSaneInsertion = function(editor, session) {
          var cursor = editor.getCursorPosition();
          var iterator = new TokenIterator(session, cursor.row, cursor.column);
          if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
            var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
            if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
              return false;
          }
          iterator.stepForward();
          return iterator.getCurrentTokenRow() !== cursor.row || this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
        };
        CstyleBehaviour.$matchTokenType = function(token, types) {
          return types.indexOf(token.type || token) > -1;
        };
        CstyleBehaviour.recordAutoInsert = function(editor, session, bracket) {
          var cursor = editor.getCursorPosition();
          var line = session.doc.getLine(cursor.row);
          if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0]))
            context.autoInsertedBrackets = 0;
          context.autoInsertedRow = cursor.row;
          context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
          context.autoInsertedBrackets++;
        };
        CstyleBehaviour.recordMaybeInsert = function(editor, session, bracket) {
          var cursor = editor.getCursorPosition();
          var line = session.doc.getLine(cursor.row);
          if (!this.isMaybeInsertedClosing(cursor, line))
            context.maybeInsertedBrackets = 0;
          context.maybeInsertedRow = cursor.row;
          context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
          context.maybeInsertedLineEnd = line.substr(cursor.column);
          context.maybeInsertedBrackets++;
        };
        CstyleBehaviour.isAutoInsertedClosing = function(cursor, line, bracket) {
          return context.autoInsertedBrackets > 0 && cursor.row === context.autoInsertedRow && bracket === context.autoInsertedLineEnd[0] && line.substr(cursor.column) === context.autoInsertedLineEnd;
        };
        CstyleBehaviour.isMaybeInsertedClosing = function(cursor, line) {
          return context.maybeInsertedBrackets > 0 && cursor.row === context.maybeInsertedRow && line.substr(cursor.column) === context.maybeInsertedLineEnd && line.substr(0, cursor.column) == context.maybeInsertedLineStart;
        };
        CstyleBehaviour.popAutoInsertedClosing = function() {
          context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
          context.autoInsertedBrackets--;
        };
        CstyleBehaviour.clearMaybeInsertedClosing = function() {
          if (context) {
            context.maybeInsertedBrackets = 0;
            context.maybeInsertedRow = -1;
          }
        };
        oop.inherits(CstyleBehaviour, Behaviour);
        exports2.CstyleBehaviour = CstyleBehaviour;
      });
      ace.define("ace/unicode", ["require", "exports", "module"], function(acequire, exports2, module2) {
        "use strict";
        exports2.packages = {};
        addUnicodePackage({
          L: "0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
          Ll: "0061-007A00AA00B500BA00DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F0521052305250561-05871D00-1D2B1D62-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7C2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2D00-2D25A641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CFB00-FB06FB13-FB17FF41-FF5A",
          Lu: "0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E0520052205240531-055610A0-10C51E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CEDA640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BFF21-FF3A",
          Lt: "01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC",
          Lm: "02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D611D781D9B-1DBF2071207F2090-20942C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A9CFAA70AADDFF70FF9EFF9F",
          Lo: "01BB01C0-01C3029405D0-05EA05F0-05F20621-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150904-0939093D09500958-096109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF12135-21382D30-2D652D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
          M: "0300-036F0483-04890591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DE-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0903093C093E-094E0951-0955096209630981-098309BC09BE-09C409C709C809CB-09CD09D709E209E30A01-0A030A3C0A3E-0A420A470A480A4B-0A4D0A510A700A710A750A81-0A830ABC0ABE-0AC50AC7-0AC90ACB-0ACD0AE20AE30B01-0B030B3C0B3E-0B440B470B480B4B-0B4D0B560B570B620B630B820BBE-0BC20BC6-0BC80BCA-0BCD0BD70C01-0C030C3E-0C440C46-0C480C4A-0C4D0C550C560C620C630C820C830CBC0CBE-0CC40CC6-0CC80CCA-0CCD0CD50CD60CE20CE30D020D030D3E-0D440D46-0D480D4A-0D4D0D570D620D630D820D830DCA0DCF-0DD40DD60DD8-0DDF0DF20DF30E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F3E0F3F0F71-0F840F860F870F90-0F970F99-0FBC0FC6102B-103E1056-1059105E-10601062-10641067-106D1071-10741082-108D108F109A-109D135F1712-17141732-1734175217531772177317B6-17D317DD180B-180D18A91920-192B1930-193B19B0-19C019C819C91A17-1A1B1A55-1A5E1A60-1A7C1A7F1B00-1B041B34-1B441B6B-1B731B80-1B821BA1-1BAA1C24-1C371CD0-1CD21CD4-1CE81CED1CF21DC0-1DE61DFD-1DFF20D0-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66F-A672A67CA67DA6F0A6F1A802A806A80BA823-A827A880A881A8B4-A8C4A8E0-A8F1A926-A92DA947-A953A980-A983A9B3-A9C0AA29-AA36AA43AA4CAA4DAA7BAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE3-ABEAABECABEDFB1EFE00-FE0FFE20-FE26",
          Mn: "0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0902093C0941-0948094D0951-095509620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F90-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135F1712-17141732-1734175217531772177317B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1DC0-1DE61DFD-1DFF20D0-20DC20E120E5-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66FA67CA67DA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26",
          Mc: "0903093E-09400949-094C094E0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1C24-1C2B1C341C351CE11CF2A823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BABE3ABE4ABE6ABE7ABE9ABEAABEC",
          Me: "0488048906DE20DD-20E020E2-20E4A670-A672",
          N: "0030-003900B200B300B900BC-00BE0660-066906F0-06F907C0-07C90966-096F09E6-09EF09F4-09F90A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BF20C66-0C6F0C78-0C7E0CE6-0CEF0D66-0D750E50-0E590ED0-0ED90F20-0F331040-10491090-10991369-137C16EE-16F017E0-17E917F0-17F91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C5920702074-20792080-20892150-21822185-21892460-249B24EA-24FF2776-27932CFD30073021-30293038-303A3192-31953220-32293251-325F3280-328932B1-32BFA620-A629A6E6-A6EFA830-A835A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
          Nd: "0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
          Nl: "16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF",
          No: "00B200B300B900BC-00BE09F4-09F90BF0-0BF20C78-0C7E0D70-0D750F2A-0F331369-137C17F0-17F920702074-20792080-20892150-215F21892460-249B24EA-24FF2776-27932CFD3192-31953220-32293251-325F3280-328932B1-32BFA830-A835",
          P: "0021-00230025-002A002C-002F003A003B003F0040005B-005D005F007B007D00A100AB00B700BB00BF037E0387055A-055F0589058A05BE05C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F3A-0F3D0F850FD0-0FD4104A-104F10FB1361-13681400166D166E169B169C16EB-16ED1735173617D4-17D617D8-17DA1800-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD32010-20272030-20432045-20512053-205E207D207E208D208E2329232A2768-277527C527C627E6-27EF2983-299829D8-29DB29FC29FD2CF9-2CFC2CFE2CFF2E00-2E2E2E302E313001-30033008-30113014-301F3030303D30A030FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFD3EFD3FFE10-FE19FE30-FE52FE54-FE61FE63FE68FE6AFE6BFF01-FF03FF05-FF0AFF0C-FF0FFF1AFF1BFF1FFF20FF3B-FF3DFF3FFF5BFF5DFF5F-FF65",
          Pd: "002D058A05BE140018062010-20152E172E1A301C303030A0FE31FE32FE58FE63FF0D",
          Ps: "0028005B007B0F3A0F3C169B201A201E2045207D208D23292768276A276C276E27702772277427C527E627E827EA27EC27EE2983298529872989298B298D298F299129932995299729D829DA29FC2E222E242E262E283008300A300C300E3010301430163018301A301DFD3EFE17FE35FE37FE39FE3BFE3DFE3FFE41FE43FE47FE59FE5BFE5DFF08FF3BFF5BFF5FFF62",
          Pe: "0029005D007D0F3B0F3D169C2046207E208E232A2769276B276D276F27712773277527C627E727E927EB27ED27EF298429862988298A298C298E2990299229942996299829D929DB29FD2E232E252E272E293009300B300D300F3011301530173019301B301E301FFD3FFE18FE36FE38FE3AFE3CFE3EFE40FE42FE44FE48FE5AFE5CFE5EFF09FF3DFF5DFF60FF63",
          Pi: "00AB2018201B201C201F20392E022E042E092E0C2E1C2E20",
          Pf: "00BB2019201D203A2E032E052E0A2E0D2E1D2E21",
          Pc: "005F203F20402054FE33FE34FE4D-FE4FFF3F",
          Po: "0021-00230025-0027002A002C002E002F003A003B003F0040005C00A100B700BF037E0387055A-055F058905C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F850FD0-0FD4104A-104F10FB1361-1368166D166E16EB-16ED1735173617D4-17D617D8-17DA1800-18051807-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD3201620172020-20272030-2038203B-203E2041-20432047-205120532055-205E2CF9-2CFC2CFE2CFF2E002E012E06-2E082E0B2E0E-2E162E182E192E1B2E1E2E1F2E2A-2E2E2E302E313001-3003303D30FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFE10-FE16FE19FE30FE45FE46FE49-FE4CFE50-FE52FE54-FE57FE5F-FE61FE68FE6AFE6BFF01-FF03FF05-FF07FF0AFF0CFF0EFF0FFF1AFF1BFF1FFF20FF3CFF61FF64FF65",
          S: "0024002B003C-003E005E0060007C007E00A2-00A900AC00AE-00B100B400B600B800D700F702C2-02C502D2-02DF02E5-02EB02ED02EF-02FF03750384038503F604820606-0608060B060E060F06E906FD06FE07F609F209F309FA09FB0AF10B700BF3-0BFA0C7F0CF10CF20D790E3F0F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-139917DB194019E0-19FF1B61-1B6A1B74-1B7C1FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE20442052207A-207C208A-208C20A0-20B8210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B2140-2144214A-214D214F2190-2328232B-23E82400-24262440-244A249C-24E92500-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE27C0-27C427C7-27CA27CC27D0-27E527F0-29822999-29D729DC-29FB29FE-2B4C2B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F309B309C319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A700-A716A720A721A789A78AA828-A82BA836-A839AA77-AA79FB29FDFCFDFDFE62FE64-FE66FE69FF04FF0BFF1C-FF1EFF3EFF40FF5CFF5EFFE0-FFE6FFE8-FFEEFFFCFFFD",
          Sm: "002B003C-003E007C007E00AC00B100D700F703F60606-060820442052207A-207C208A-208C2140-2144214B2190-2194219A219B21A021A321A621AE21CE21CF21D221D421F4-22FF2308-230B23202321237C239B-23B323DC-23E125B725C125F8-25FF266F27C0-27C427C7-27CA27CC27D0-27E527F0-27FF2900-29822999-29D729DC-29FB29FE-2AFF2B30-2B442B47-2B4CFB29FE62FE64-FE66FF0BFF1C-FF1EFF5CFF5EFFE2FFE9-FFEC",
          Sc: "002400A2-00A5060B09F209F309FB0AF10BF90E3F17DB20A0-20B8A838FDFCFE69FF04FFE0FFE1FFE5FFE6",
          Sk: "005E006000A800AF00B400B802C2-02C502D2-02DF02E5-02EB02ED02EF-02FF0375038403851FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE309B309CA700-A716A720A721A789A78AFF3EFF40FFE3",
          So: "00A600A700A900AE00B000B60482060E060F06E906FD06FE07F609FA0B700BF3-0BF80BFA0C7F0CF10CF20D790F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-1399194019E0-19FF1B61-1B6A1B74-1B7C210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B214A214C214D214F2195-2199219C-219F21A121A221A421A521A7-21AD21AF-21CD21D021D121D321D5-21F32300-2307230C-231F2322-2328232B-237B237D-239A23B4-23DB23E2-23E82400-24262440-244A249C-24E92500-25B625B8-25C025C2-25F72600-266E2670-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE2800-28FF2B00-2B2F2B452B462B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A828-A82BA836A837A839AA77-AA79FDFDFFE4FFE8FFEDFFEEFFFCFFFD",
          Z: "002000A01680180E2000-200A20282029202F205F3000",
          Zs: "002000A01680180E2000-200A202F205F3000",
          Zl: "2028",
          Zp: "2029",
          C: "0000-001F007F-009F00AD03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-0605061C061D0620065F06DD070E070F074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17B417B517DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF200B-200F202A-202E2060-206F20722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-F8FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFD-FF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFFBFFFEFFFF",
          Cc: "0000-001F007F-009F",
          Cf: "00AD0600-060306DD070F17B417B5200B-200F202A-202E2060-2064206A-206FFEFFFFF9-FFFB",
          Co: "E000-F8FF",
          Cs: "D800-DFFF",
          Cn: "03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-05FF06040605061C061D0620065F070E074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF2065-206920722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-D7FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFDFEFEFF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFF8FFFEFFFF"
        });
        function addUnicodePackage(pack) {
          var codePoint = /\w{4}/g;
          for (var name in pack)
            exports2.packages[name] = pack[name].replace(codePoint, "\\u$&");
        }
      });
      ace.define("ace/mode/text", ["require", "exports", "module", "ace/tokenizer", "ace/mode/text_highlight_rules", "ace/mode/behaviour/cstyle", "ace/unicode", "ace/lib/lang", "ace/token_iterator", "ace/range"], function(acequire, exports2, module2) {
        "use strict";
        var Tokenizer = acequire("../tokenizer").Tokenizer;
        var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;
        var CstyleBehaviour = acequire("./behaviour/cstyle").CstyleBehaviour;
        var unicode = acequire("../unicode");
        var lang = acequire("../lib/lang");
        var TokenIterator = acequire("../token_iterator").TokenIterator;
        var Range = acequire("../range").Range;
        var Mode = function() {
          this.HighlightRules = TextHighlightRules;
        };
        (function() {
          this.$defaultBehaviour = new CstyleBehaviour();
          this.tokenRe = new RegExp(
            "^[" + unicode.packages.L + unicode.packages.Mn + unicode.packages.Mc + unicode.packages.Nd + unicode.packages.Pc + "\\$_]+",
            "g"
          );
          this.nonTokenRe = new RegExp(
            "^(?:[^" + unicode.packages.L + unicode.packages.Mn + unicode.packages.Mc + unicode.packages.Nd + unicode.packages.Pc + "\\$_]|\\s])+",
            "g"
          );
          this.getTokenizer = function() {
            if (!this.$tokenizer) {
              this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
              this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
            }
            return this.$tokenizer;
          };
          this.lineCommentStart = "";
          this.blockComment = "";
          this.toggleCommentLines = function(state, session, startRow, endRow) {
            var doc = session.doc;
            var ignoreBlankLines = true;
            var shouldRemove = true;
            var minIndent = Infinity;
            var tabSize = session.getTabSize();
            var insertAtTabStop = false;
            if (!this.lineCommentStart) {
              if (!this.blockComment)
                return false;
              var lineCommentStart = this.blockComment.start;
              var lineCommentEnd = this.blockComment.end;
              var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
              var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");
              var comment = function(line, i) {
                if (testRemove(line, i))
                  return;
                if (!ignoreBlankLines || /\S/.test(line)) {
                  doc.insertInLine({ row: i, column: line.length }, lineCommentEnd);
                  doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);
                }
              };
              var uncomment = function(line, i) {
                var m;
                if (m = line.match(regexpEnd))
                  doc.removeInLine(i, line.length - m[0].length, line.length);
                if (m = line.match(regexpStart))
                  doc.removeInLine(i, m[1].length, m[0].length);
              };
              var testRemove = function(line, row) {
                if (regexpStart.test(line))
                  return true;
                var tokens = session.getTokens(row);
                for (var i = 0; i < tokens.length; i++) {
                  if (tokens[i].type === "comment")
                    return true;
                }
              };
            } else {
              if (Array.isArray(this.lineCommentStart)) {
                var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
                var lineCommentStart = this.lineCommentStart[0];
              } else {
                var regexpStart = lang.escapeRegExp(this.lineCommentStart);
                var lineCommentStart = this.lineCommentStart;
              }
              regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
              insertAtTabStop = session.getUseSoftTabs();
              var uncomment = function(line, i) {
                var m = line.match(regexpStart);
                if (!m)
                  return;
                var start = m[1].length, end = m[0].length;
                if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ")
                  end--;
                doc.removeInLine(i, start, end);
              };
              var commentWithSpace = lineCommentStart + " ";
              var comment = function(line, i) {
                if (!ignoreBlankLines || /\S/.test(line)) {
                  if (shouldInsertSpace(line, minIndent, minIndent))
                    doc.insertInLine({ row: i, column: minIndent }, commentWithSpace);
                  else
                    doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);
                }
              };
              var testRemove = function(line, i) {
                return regexpStart.test(line);
              };
              var shouldInsertSpace = function(line, before, after) {
                var spaces = 0;
                while (before-- && line.charAt(before) == " ")
                  spaces++;
                if (spaces % tabSize != 0)
                  return false;
                var spaces = 0;
                while (line.charAt(after++) == " ")
                  spaces++;
                if (tabSize > 2)
                  return spaces % tabSize != tabSize - 1;
                else
                  return spaces % tabSize == 0;
                return true;
              };
            }
            function iter(fun) {
              for (var i = startRow; i <= endRow; i++)
                fun(doc.getLine(i), i);
            }
            var minEmptyLength = Infinity;
            iter(function(line, i) {
              var indent = line.search(/\S/);
              if (indent !== -1) {
                if (indent < minIndent)
                  minIndent = indent;
                if (shouldRemove && !testRemove(line, i))
                  shouldRemove = false;
              } else if (minEmptyLength > line.length) {
                minEmptyLength = line.length;
              }
            });
            if (minIndent == Infinity) {
              minIndent = minEmptyLength;
              ignoreBlankLines = false;
              shouldRemove = false;
            }
            if (insertAtTabStop && minIndent % tabSize != 0)
              minIndent = Math.floor(minIndent / tabSize) * tabSize;
            iter(shouldRemove ? uncomment : comment);
          };
          this.toggleBlockComment = function(state, session, range, cursor) {
            var comment = this.blockComment;
            if (!comment)
              return;
            if (!comment.start && comment[0])
              comment = comment[0];
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            var sel = session.selection;
            var initialRange = session.selection.toOrientedRange();
            var startRow, colDiff;
            if (token && /comment/.test(token.type)) {
              var startRange, endRange;
              while (token && /comment/.test(token.type)) {
                var i = token.value.indexOf(comment.start);
                if (i != -1) {
                  var row = iterator.getCurrentTokenRow();
                  var column = iterator.getCurrentTokenColumn() + i;
                  startRange = new Range(row, column, row, column + comment.start.length);
                  break;
                }
                token = iterator.stepBackward();
              }
              var iterator = new TokenIterator(session, cursor.row, cursor.column);
              var token = iterator.getCurrentToken();
              while (token && /comment/.test(token.type)) {
                var i = token.value.indexOf(comment.end);
                if (i != -1) {
                  var row = iterator.getCurrentTokenRow();
                  var column = iterator.getCurrentTokenColumn() + i;
                  endRange = new Range(row, column, row, column + comment.end.length);
                  break;
                }
                token = iterator.stepForward();
              }
              if (endRange)
                session.remove(endRange);
              if (startRange) {
                session.remove(startRange);
                startRow = startRange.start.row;
                colDiff = -comment.start.length;
              }
            } else {
              colDiff = comment.start.length;
              startRow = range.start.row;
              session.insert(range.end, comment.end);
              session.insert(range.start, comment.start);
            }
            if (initialRange.start.row == startRow)
              initialRange.start.column += colDiff;
            if (initialRange.end.row == startRow)
              initialRange.end.column += colDiff;
            session.selection.fromOrientedRange(initialRange);
          };
          this.getNextLineIndent = function(state, line, tab) {
            return this.$getIndent(line);
          };
          this.checkOutdent = function(state, line, input) {
            return false;
          };
          this.autoOutdent = function(state, doc, row) {
          };
          this.$getIndent = function(line) {
            return line.match(/^\s*/)[0];
          };
          this.createWorker = function(session) {
            return null;
          };
          this.createModeDelegates = function(mapping) {
            this.$embeds = [];
            this.$modes = {};
            for (var i in mapping) {
              if (mapping[i]) {
                this.$embeds.push(i);
                this.$modes[i] = new mapping[i]();
              }
            }
            var delegations = [
              "toggleBlockComment",
              "toggleCommentLines",
              "getNextLineIndent",
              "checkOutdent",
              "autoOutdent",
              "transformAction",
              "getCompletions"
            ];
            for (var i = 0; i < delegations.length; i++) {
              (function(scope) {
                var functionName = delegations[i];
                var defaultHandler = scope[functionName];
                scope[delegations[i]] = function() {
                  return this.$delegator(functionName, arguments, defaultHandler);
                };
              })(this);
            }
          };
          this.$delegator = function(method, args, defaultHandler) {
            var state = args[0];
            if (typeof state != "string")
              state = state[0];
            for (var i = 0; i < this.$embeds.length; i++) {
              if (!this.$modes[this.$embeds[i]])
                continue;
              var split = state.split(this.$embeds[i]);
              if (!split[0] && split[1]) {
                args[0] = split[1];
                var mode = this.$modes[this.$embeds[i]];
                return mode[method].apply(mode, args);
              }
            }
            var ret = defaultHandler.apply(this, args);
            return defaultHandler ? ret : void 0;
          };
          this.transformAction = function(state, action, editor, session, param) {
            if (this.$behaviour) {
              var behaviours = this.$behaviour.getBehaviours();
              for (var key in behaviours) {
                if (behaviours[key][action]) {
                  var ret = behaviours[key][action].apply(this, arguments);
                  if (ret) {
                    return ret;
                  }
                }
              }
            }
          };
          this.getKeywords = function(append) {
            if (!this.completionKeywords) {
              var rules = this.$tokenizer.rules;
              var completionKeywords = [];
              for (var rule in rules) {
                var ruleItr = rules[rule];
                for (var r = 0, l = ruleItr.length; r < l; r++) {
                  if (typeof ruleItr[r].token === "string") {
                    if (/keyword|support|storage/.test(ruleItr[r].token))
                      completionKeywords.push(ruleItr[r].regex);
                  } else if (typeof ruleItr[r].token === "object") {
                    for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {
                      if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                        var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                        completionKeywords.push(rule.substr(1, rule.length - 2));
                      }
                    }
                  }
                }
              }
              this.completionKeywords = completionKeywords;
            }
            if (!append)
              return this.$keywordList;
            return completionKeywords.concat(this.$keywordList || []);
          };
          this.$createKeywordList = function() {
            if (!this.$highlightRules)
              this.getTokenizer();
            return this.$keywordList = this.$highlightRules.$keywordList || [];
          };
          this.getCompletions = function(state, session, pos, prefix) {
            var keywords = this.$keywordList || this.$createKeywordList();
            return keywords.map(function(word) {
              return {
                name: word,
                value: word,
                score: 0,
                meta: "keyword"
              };
            });
          };
          this.$id = "ace/mode/text";
        }).call(Mode.prototype);
        exports2.Mode = Mode;
      });
      ace.define("ace/apply_delta", ["require", "exports", "module"], function(acequire, exports2, module2) {
        "use strict";
        function throwDeltaError(delta, errorText) {
          console.log("Invalid Delta:", delta);
          throw "Invalid Delta: " + errorText;
        }
        function positionInDocument(docLines, position) {
          return position.row >= 0 && position.row < docLines.length && position.column >= 0 && position.column <= docLines[position.row].length;
        }
        function validateDelta(docLines, delta) {
          if (delta.action != "insert" && delta.action != "remove")
            throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
          if (!(delta.lines instanceof Array))
            throwDeltaError(delta, "delta.lines must be an Array");
          if (!delta.start || !delta.end)
            throwDeltaError(delta, "delta.start/end must be an present");
          var start = delta.start;
          if (!positionInDocument(docLines, delta.start))
            throwDeltaError(delta, "delta.start must be contained in document");
          var end = delta.end;
          if (delta.action == "remove" && !positionInDocument(docLines, end))
            throwDeltaError(delta, "delta.end must contained in document for 'remove' actions");
          var numRangeRows = end.row - start.row;
          var numRangeLastLineChars = end.column - (numRangeRows == 0 ? start.column : 0);
          if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)
            throwDeltaError(delta, "delta.range must match delta lines");
        }
        exports2.applyDelta = function(docLines, delta, doNotValidate) {
          var row = delta.start.row;
          var startColumn = delta.start.column;
          var line = docLines[row] || "";
          switch (delta.action) {
            case "insert":
              var lines = delta.lines;
              if (lines.length === 1) {
                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
              } else {
                var args = [row, 1].concat(delta.lines);
                docLines.splice.apply(docLines, args);
                docLines[row] = line.substring(0, startColumn) + docLines[row];
                docLines[row + delta.lines.length - 1] += line.substring(startColumn);
              }
              break;
            case "remove":
              var endColumn = delta.end.column;
              var endRow = delta.end.row;
              if (row === endRow) {
                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
              } else {
                docLines.splice(
                  row,
                  endRow - row + 1,
                  line.substring(0, startColumn) + docLines[endRow].substring(endColumn)
                );
              }
              break;
          }
        };
      });
      ace.define("ace/anchor", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("./lib/oop");
        var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
        var Anchor = exports2.Anchor = function(doc, row, column) {
          this.$onChange = this.onChange.bind(this);
          this.attach(doc);
          if (typeof column == "undefined")
            this.setPosition(row.row, row.column);
          else
            this.setPosition(row, column);
        };
        (function() {
          oop.implement(this, EventEmitter);
          this.getPosition = function() {
            return this.$clipPositionToDocument(this.row, this.column);
          };
          this.getDocument = function() {
            return this.document;
          };
          this.$insertRight = false;
          this.onChange = function(delta) {
            if (delta.start.row == delta.end.row && delta.start.row != this.row)
              return;
            if (delta.start.row > this.row)
              return;
            var point = $getTransformedPoint(delta, { row: this.row, column: this.column }, this.$insertRight);
            this.setPosition(point.row, point.column, true);
          };
          function $pointsInOrder(point1, point2, equalPointsInOrder) {
            var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
            return point1.row < point2.row || point1.row == point2.row && bColIsAfter;
          }
          function $getTransformedPoint(delta, point, moveIfEqual) {
            var deltaIsInsert = delta.action == "insert";
            var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);
            var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
            var deltaStart = delta.start;
            var deltaEnd = deltaIsInsert ? deltaStart : delta.end;
            if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
              return {
                row: point.row,
                column: point.column
              };
            }
            if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
              return {
                row: point.row + deltaRowShift,
                column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
              };
            }
            return {
              row: deltaStart.row,
              column: deltaStart.column
            };
          }
          this.setPosition = function(row, column, noClip) {
            var pos;
            if (noClip) {
              pos = {
                row,
                column
              };
            } else {
              pos = this.$clipPositionToDocument(row, column);
            }
            if (this.row == pos.row && this.column == pos.column)
              return;
            var old = {
              row: this.row,
              column: this.column
            };
            this.row = pos.row;
            this.column = pos.column;
            this._signal("change", {
              old,
              value: pos
            });
          };
          this.detach = function() {
            this.document.removeEventListener("change", this.$onChange);
          };
          this.attach = function(doc) {
            this.document = doc || this.document;
            this.document.on("change", this.$onChange);
          };
          this.$clipPositionToDocument = function(row, column) {
            var pos = {};
            if (row >= this.document.getLength()) {
              pos.row = Math.max(0, this.document.getLength() - 1);
              pos.column = this.document.getLine(pos.row).length;
            } else if (row < 0) {
              pos.row = 0;
              pos.column = 0;
            } else {
              pos.row = row;
              pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
            }
            if (column < 0)
              pos.column = 0;
            return pos;
          };
        }).call(Anchor.prototype);
      });
      ace.define("ace/document", ["require", "exports", "module", "ace/lib/oop", "ace/apply_delta", "ace/lib/event_emitter", "ace/range", "ace/anchor"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("./lib/oop");
        var applyDelta = acequire("./apply_delta").applyDelta;
        var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
        var Range = acequire("./range").Range;
        var Anchor = acequire("./anchor").Anchor;
        var Document = function(textOrLines) {
          this.$lines = [""];
          if (textOrLines.length === 0) {
            this.$lines = [""];
          } else if (Array.isArray(textOrLines)) {
            this.insertMergedLines({ row: 0, column: 0 }, textOrLines);
          } else {
            this.insert({ row: 0, column: 0 }, textOrLines);
          }
        };
        (function() {
          oop.implement(this, EventEmitter);
          this.setValue = function(text) {
            var len = this.getLength() - 1;
            this.remove(new Range(0, 0, len, this.getLine(len).length));
            this.insert({ row: 0, column: 0 }, text);
          };
          this.getValue = function() {
            return this.getAllLines().join(this.getNewLineCharacter());
          };
          this.createAnchor = function(row, column) {
            return new Anchor(this, row, column);
          };
          if ("aaa".split(/a/).length === 0) {
            this.$split = function(text) {
              return text.replace(/\r\n|\r/g, "\n").split("\n");
            };
          } else {
            this.$split = function(text) {
              return text.split(/\r\n|\r|\n/);
            };
          }
          this.$detectNewLine = function(text) {
            var match = text.match(/^.*?(\r\n|\r|\n)/m);
            this.$autoNewLine = match ? match[1] : "\n";
            this._signal("changeNewLineMode");
          };
          this.getNewLineCharacter = function() {
            switch (this.$newLineMode) {
              case "windows":
                return "\r\n";
              case "unix":
                return "\n";
              default:
                return this.$autoNewLine || "\n";
            }
          };
          this.$autoNewLine = "";
          this.$newLineMode = "auto";
          this.setNewLineMode = function(newLineMode) {
            if (this.$newLineMode === newLineMode)
              return;
            this.$newLineMode = newLineMode;
            this._signal("changeNewLineMode");
          };
          this.getNewLineMode = function() {
            return this.$newLineMode;
          };
          this.isNewLine = function(text) {
            return text == "\r\n" || text == "\r" || text == "\n";
          };
          this.getLine = function(row) {
            return this.$lines[row] || "";
          };
          this.getLines = function(firstRow, lastRow) {
            return this.$lines.slice(firstRow, lastRow + 1);
          };
          this.getAllLines = function() {
            return this.getLines(0, this.getLength());
          };
          this.getLength = function() {
            return this.$lines.length;
          };
          this.getTextRange = function(range) {
            return this.getLinesForRange(range).join(this.getNewLineCharacter());
          };
          this.getLinesForRange = function(range) {
            var lines;
            if (range.start.row === range.end.row) {
              lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
            } else {
              lines = this.getLines(range.start.row, range.end.row);
              lines[0] = (lines[0] || "").substring(range.start.column);
              var l = lines.length - 1;
              if (range.end.row - range.start.row == l)
                lines[l] = lines[l].substring(0, range.end.column);
            }
            return lines;
          };
          this.insertLines = function(row, lines) {
            console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
            return this.insertFullLines(row, lines);
          };
          this.removeLines = function(firstRow, lastRow) {
            console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
            return this.removeFullLines(firstRow, lastRow);
          };
          this.insertNewLine = function(position) {
            console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
            return this.insertMergedLines(position, ["", ""]);
          };
          this.insert = function(position, text) {
            if (this.getLength() <= 1)
              this.$detectNewLine(text);
            return this.insertMergedLines(position, this.$split(text));
          };
          this.insertInLine = function(position, text) {
            var start = this.clippedPos(position.row, position.column);
            var end = this.pos(position.row, position.column + text.length);
            this.applyDelta({
              start,
              end,
              action: "insert",
              lines: [text]
            }, true);
            return this.clonePos(end);
          };
          this.clippedPos = function(row, column) {
            var length = this.getLength();
            if (row === void 0) {
              row = length;
            } else if (row < 0) {
              row = 0;
            } else if (row >= length) {
              row = length - 1;
              column = void 0;
            }
            var line = this.getLine(row);
            if (column == void 0)
              column = line.length;
            column = Math.min(Math.max(column, 0), line.length);
            return { row, column };
          };
          this.clonePos = function(pos) {
            return { row: pos.row, column: pos.column };
          };
          this.pos = function(row, column) {
            return { row, column };
          };
          this.$clipPosition = function(position) {
            var length = this.getLength();
            if (position.row >= length) {
              position.row = Math.max(0, length - 1);
              position.column = this.getLine(length - 1).length;
            } else {
              position.row = Math.max(0, position.row);
              position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
            }
            return position;
          };
          this.insertFullLines = function(row, lines) {
            row = Math.min(Math.max(row, 0), this.getLength());
            var column = 0;
            if (row < this.getLength()) {
              lines = lines.concat([""]);
              column = 0;
            } else {
              lines = [""].concat(lines);
              row--;
              column = this.$lines[row].length;
            }
            this.insertMergedLines({ row, column }, lines);
          };
          this.insertMergedLines = function(position, lines) {
            var start = this.clippedPos(position.row, position.column);
            var end = {
              row: start.row + lines.length - 1,
              column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
            };
            this.applyDelta({
              start,
              end,
              action: "insert",
              lines
            });
            return this.clonePos(end);
          };
          this.remove = function(range) {
            var start = this.clippedPos(range.start.row, range.start.column);
            var end = this.clippedPos(range.end.row, range.end.column);
            this.applyDelta({
              start,
              end,
              action: "remove",
              lines: this.getLinesForRange({ start, end })
            });
            return this.clonePos(start);
          };
          this.removeInLine = function(row, startColumn, endColumn) {
            var start = this.clippedPos(row, startColumn);
            var end = this.clippedPos(row, endColumn);
            this.applyDelta({
              start,
              end,
              action: "remove",
              lines: this.getLinesForRange({ start, end })
            }, true);
            return this.clonePos(start);
          };
          this.removeFullLines = function(firstRow, lastRow) {
            firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
            lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);
            var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
            var deleteLastNewLine = lastRow < this.getLength() - 1;
            var startRow = deleteFirstNewLine ? firstRow - 1 : firstRow;
            var startCol = deleteFirstNewLine ? this.getLine(startRow).length : 0;
            var endRow = deleteLastNewLine ? lastRow + 1 : lastRow;
            var endCol = deleteLastNewLine ? 0 : this.getLine(endRow).length;
            var range = new Range(startRow, startCol, endRow, endCol);
            var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
            this.applyDelta({
              start: range.start,
              end: range.end,
              action: "remove",
              lines: this.getLinesForRange(range)
            });
            return deletedLines;
          };
          this.removeNewLine = function(row) {
            if (row < this.getLength() - 1 && row >= 0) {
              this.applyDelta({
                start: this.pos(row, this.getLine(row).length),
                end: this.pos(row + 1, 0),
                action: "remove",
                lines: ["", ""]
              });
            }
          };
          this.replace = function(range, text) {
            if (!(range instanceof Range))
              range = Range.fromPoints(range.start, range.end);
            if (text.length === 0 && range.isEmpty())
              return range.start;
            if (text == this.getTextRange(range))
              return range.end;
            this.remove(range);
            var end;
            if (text) {
              end = this.insert(range.start, text);
            } else {
              end = range.start;
            }
            return end;
          };
          this.applyDeltas = function(deltas) {
            for (var i = 0; i < deltas.length; i++) {
              this.applyDelta(deltas[i]);
            }
          };
          this.revertDeltas = function(deltas) {
            for (var i = deltas.length - 1; i >= 0; i--) {
              this.revertDelta(deltas[i]);
            }
          };
          this.applyDelta = function(delta, doNotValidate) {
            var isInsert = delta.action == "insert";
            if (isInsert ? delta.lines.length <= 1 && !delta.lines[0] : !Range.comparePoints(delta.start, delta.end)) {
              return;
            }
            if (isInsert && delta.lines.length > 2e4)
              this.$splitAndapplyLargeDelta(delta, 2e4);
            applyDelta(this.$lines, delta, doNotValidate);
            this._signal("change", delta);
          };
          this.$splitAndapplyLargeDelta = function(delta, MAX) {
            var lines = delta.lines;
            var l = lines.length;
            var row = delta.start.row;
            var column = delta.start.column;
            var from = 0, to = 0;
            do {
              from = to;
              to += MAX - 1;
              var chunk = lines.slice(from, to);
              if (to > l) {
                delta.lines = chunk;
                delta.start.row = row + from;
                delta.start.column = column;
                break;
              }
              chunk.push("");
              this.applyDelta({
                start: this.pos(row + from, column),
                end: this.pos(row + to, column = 0),
                action: delta.action,
                lines: chunk
              }, true);
            } while (true);
          };
          this.revertDelta = function(delta) {
            this.applyDelta({
              start: this.clonePos(delta.start),
              end: this.clonePos(delta.end),
              action: delta.action == "insert" ? "remove" : "insert",
              lines: delta.lines.slice()
            });
          };
          this.indexToPosition = function(index, startRow) {
            var lines = this.$lines || this.getAllLines();
            var newlineLength = this.getNewLineCharacter().length;
            for (var i = startRow || 0, l = lines.length; i < l; i++) {
              index -= lines[i].length + newlineLength;
              if (index < 0)
                return { row: i, column: index + lines[i].length + newlineLength };
            }
            return { row: l - 1, column: lines[l - 1].length };
          };
          this.positionToIndex = function(pos, startRow) {
            var lines = this.$lines || this.getAllLines();
            var newlineLength = this.getNewLineCharacter().length;
            var index = 0;
            var row = Math.min(pos.row, lines.length);
            for (var i = startRow || 0; i < row; ++i)
              index += lines[i].length + newlineLength;
            return index + pos.column;
          };
        }).call(Document.prototype);
        exports2.Document = Document;
      });
      ace.define("ace/background_tokenizer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("./lib/oop");
        var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
        var BackgroundTokenizer = function(tokenizer, editor) {
          this.running = false;
          this.lines = [];
          this.states = [];
          this.currentLine = 0;
          this.tokenizer = tokenizer;
          var self2 = this;
          this.$worker = function() {
            if (!self2.running) {
              return;
            }
            var workerStart = /* @__PURE__ */ new Date();
            var currentLine = self2.currentLine;
            var endLine = -1;
            var doc = self2.doc;
            var startLine = currentLine;
            while (self2.lines[currentLine])
              currentLine++;
            var len = doc.getLength();
            var processedLines = 0;
            self2.running = false;
            while (currentLine < len) {
              self2.$tokenizeRow(currentLine);
              endLine = currentLine;
              do {
                currentLine++;
              } while (self2.lines[currentLine]);
              processedLines++;
              if (processedLines % 5 === 0 && /* @__PURE__ */ new Date() - workerStart > 20) {
                self2.running = setTimeout(self2.$worker, 20);
                break;
              }
            }
            self2.currentLine = currentLine;
            if (endLine == -1)
              endLine = currentLine;
            if (startLine <= endLine)
              self2.fireUpdateEvent(startLine, endLine);
          };
        };
        (function() {
          oop.implement(this, EventEmitter);
          this.setTokenizer = function(tokenizer) {
            this.tokenizer = tokenizer;
            this.lines = [];
            this.states = [];
            this.start(0);
          };
          this.setDocument = function(doc) {
            this.doc = doc;
            this.lines = [];
            this.states = [];
            this.stop();
          };
          this.fireUpdateEvent = function(firstRow, lastRow) {
            var data = {
              first: firstRow,
              last: lastRow
            };
            this._signal("update", { data });
          };
          this.start = function(startRow) {
            this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
            this.lines.splice(this.currentLine, this.lines.length);
            this.states.splice(this.currentLine, this.states.length);
            this.stop();
            this.running = setTimeout(this.$worker, 700);
          };
          this.scheduleStart = function() {
            if (!this.running)
              this.running = setTimeout(this.$worker, 700);
          };
          this.$updateOnChange = function(delta) {
            var startRow = delta.start.row;
            var len = delta.end.row - startRow;
            if (len === 0) {
              this.lines[startRow] = null;
            } else if (delta.action == "remove") {
              this.lines.splice(startRow, len + 1, null);
              this.states.splice(startRow, len + 1, null);
            } else {
              var args = Array(len + 1);
              args.unshift(startRow, 1);
              this.lines.splice.apply(this.lines, args);
              this.states.splice.apply(this.states, args);
            }
            this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());
            this.stop();
          };
          this.stop = function() {
            if (this.running)
              clearTimeout(this.running);
            this.running = false;
          };
          this.getTokens = function(row) {
            return this.lines[row] || this.$tokenizeRow(row);
          };
          this.getState = function(row) {
            if (this.currentLine == row)
              this.$tokenizeRow(row);
            return this.states[row] || "start";
          };
          this.$tokenizeRow = function(row) {
            var line = this.doc.getLine(row);
            var state = this.states[row - 1];
            var data = this.tokenizer.getLineTokens(line, state, row);
            if (this.states[row] + "" !== data.state + "") {
              this.states[row] = data.state;
              this.lines[row + 1] = null;
              if (this.currentLine > row + 1)
                this.currentLine = row + 1;
            } else if (this.currentLine == row) {
              this.currentLine = row + 1;
            }
            return this.lines[row] = data.tokens;
          };
        }).call(BackgroundTokenizer.prototype);
        exports2.BackgroundTokenizer = BackgroundTokenizer;
      });
      ace.define("ace/search_highlight", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function(acequire, exports2, module2) {
        "use strict";
        var lang = acequire("./lib/lang");
        var oop = acequire("./lib/oop");
        var Range = acequire("./range").Range;
        var SearchHighlight = function(regExp, clazz, type) {
          this.setRegexp(regExp);
          this.clazz = clazz;
          this.type = type || "text";
        };
        (function() {
          this.MAX_RANGES = 500;
          this.setRegexp = function(regExp) {
            if (this.regExp + "" == regExp + "")
              return;
            this.regExp = regExp;
            this.cache = [];
          };
          this.update = function(html, markerLayer, session, config) {
            if (!this.regExp)
              return;
            var start = config.firstRow, end = config.lastRow;
            for (var i = start; i <= end; i++) {
              var ranges = this.cache[i];
              if (ranges == null) {
                ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
                if (ranges.length > this.MAX_RANGES)
                  ranges = ranges.slice(0, this.MAX_RANGES);
                ranges = ranges.map(function(match) {
                  return new Range(i, match.offset, i, match.offset + match.length);
                });
                this.cache[i] = ranges.length ? ranges : "";
              }
              for (var j = ranges.length; j--; ) {
                markerLayer.drawSingleLineMarker(
                  html,
                  ranges[j].toScreenRange(session),
                  this.clazz,
                  config
                );
              }
            }
          };
        }).call(SearchHighlight.prototype);
        exports2.SearchHighlight = SearchHighlight;
      });
      ace.define("ace/edit_session/fold_line", ["require", "exports", "module", "ace/range"], function(acequire, exports2, module2) {
        "use strict";
        var Range = acequire("../range").Range;
        function FoldLine(foldData, folds) {
          this.foldData = foldData;
          if (Array.isArray(folds)) {
            this.folds = folds;
          } else {
            folds = this.folds = [folds];
          }
          var last = folds[folds.length - 1];
          this.range = new Range(
            folds[0].start.row,
            folds[0].start.column,
            last.end.row,
            last.end.column
          );
          this.start = this.range.start;
          this.end = this.range.end;
          this.folds.forEach(function(fold) {
            fold.setFoldLine(this);
          }, this);
        }
        (function() {
          this.shiftRow = function(shift) {
            this.start.row += shift;
            this.end.row += shift;
            this.folds.forEach(function(fold) {
              fold.start.row += shift;
              fold.end.row += shift;
            });
          };
          this.addFold = function(fold) {
            if (fold.sameRow) {
              if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
                throw new Error("Can't add a fold to this FoldLine as it has no connection");
              }
              this.folds.push(fold);
              this.folds.sort(function(a, b) {
                return -a.range.compareEnd(b.start.row, b.start.column);
              });
              if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
                this.end.row = fold.end.row;
                this.end.column = fold.end.column;
              } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
                this.start.row = fold.start.row;
                this.start.column = fold.start.column;
              }
            } else if (fold.start.row == this.end.row) {
              this.folds.push(fold);
              this.end.row = fold.end.row;
              this.end.column = fold.end.column;
            } else if (fold.end.row == this.start.row) {
              this.folds.unshift(fold);
              this.start.row = fold.start.row;
              this.start.column = fold.start.column;
            } else {
              throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
            }
            fold.foldLine = this;
          };
          this.containsRow = function(row) {
            return row >= this.start.row && row <= this.end.row;
          };
          this.walk = function(callback, endRow, endColumn) {
            var lastEnd = 0, folds = this.folds, fold, cmp, stop, isNewRow = true;
            if (endRow == null) {
              endRow = this.end.row;
              endColumn = this.end.column;
            }
            for (var i = 0; i < folds.length; i++) {
              fold = folds[i];
              cmp = fold.range.compareStart(endRow, endColumn);
              if (cmp == -1) {
                callback(null, endRow, endColumn, lastEnd, isNewRow);
                return;
              }
              stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
              stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
              if (stop || cmp === 0) {
                return;
              }
              isNewRow = !fold.sameRow;
              lastEnd = fold.end.column;
            }
            callback(null, endRow, endColumn, lastEnd, isNewRow);
          };
          this.getNextFoldTo = function(row, column) {
            var fold, cmp;
            for (var i = 0; i < this.folds.length; i++) {
              fold = this.folds[i];
              cmp = fold.range.compareEnd(row, column);
              if (cmp == -1) {
                return {
                  fold,
                  kind: "after"
                };
              } else if (cmp === 0) {
                return {
                  fold,
                  kind: "inside"
                };
              }
            }
            return null;
          };
          this.addRemoveChars = function(row, column, len) {
            var ret = this.getNextFoldTo(row, column), fold, folds;
            if (ret) {
              fold = ret.fold;
              if (ret.kind == "inside" && fold.start.column != column && fold.start.row != row) {
                window.console && window.console.log(row, column, fold);
              } else if (fold.start.row == row) {
                folds = this.folds;
                var i = folds.indexOf(fold);
                if (i === 0) {
                  this.start.column += len;
                }
                for (i; i < folds.length; i++) {
                  fold = folds[i];
                  fold.start.column += len;
                  if (!fold.sameRow) {
                    return;
                  }
                  fold.end.column += len;
                }
                this.end.column += len;
              }
            }
          };
          this.split = function(row, column) {
            var pos = this.getNextFoldTo(row, column);
            if (!pos || pos.kind == "inside")
              return null;
            var fold = pos.fold;
            var folds = this.folds;
            var foldData = this.foldData;
            var i = folds.indexOf(fold);
            var foldBefore = folds[i - 1];
            this.end.row = foldBefore.end.row;
            this.end.column = foldBefore.end.column;
            folds = folds.splice(i, folds.length - i);
            var newFoldLine = new FoldLine(foldData, folds);
            foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
            return newFoldLine;
          };
          this.merge = function(foldLineNext) {
            var folds = foldLineNext.folds;
            for (var i = 0; i < folds.length; i++) {
              this.addFold(folds[i]);
            }
            var foldData = this.foldData;
            foldData.splice(foldData.indexOf(foldLineNext), 1);
          };
          this.toString = function() {
            var ret = [this.range.toString() + ": ["];
            this.folds.forEach(function(fold) {
              ret.push("  " + fold.toString());
            });
            ret.push("]");
            return ret.join("\n");
          };
          this.idxToPosition = function(idx) {
            var lastFoldEndColumn = 0;
            for (var i = 0; i < this.folds.length; i++) {
              var fold = this.folds[i];
              idx -= fold.start.column - lastFoldEndColumn;
              if (idx < 0) {
                return {
                  row: fold.start.row,
                  column: fold.start.column + idx
                };
              }
              idx -= fold.placeholder.length;
              if (idx < 0) {
                return fold.start;
              }
              lastFoldEndColumn = fold.end.column;
            }
            return {
              row: this.end.row,
              column: this.end.column + idx
            };
          };
        }).call(FoldLine.prototype);
        exports2.FoldLine = FoldLine;
      });
      ace.define("ace/range_list", ["require", "exports", "module", "ace/range"], function(acequire, exports2, module2) {
        "use strict";
        var Range = acequire("./range").Range;
        var comparePoints = Range.comparePoints;
        var RangeList = function() {
          this.ranges = [];
        };
        (function() {
          this.comparePoints = comparePoints;
          this.pointIndex = function(pos, excludeEdges, startIndex) {
            var list = this.ranges;
            for (var i = startIndex || 0; i < list.length; i++) {
              var range = list[i];
              var cmpEnd = comparePoints(pos, range.end);
              if (cmpEnd > 0)
                continue;
              var cmpStart = comparePoints(pos, range.start);
              if (cmpEnd === 0)
                return excludeEdges && cmpStart !== 0 ? -i - 2 : i;
              if (cmpStart > 0 || cmpStart === 0 && !excludeEdges)
                return i;
              return -i - 1;
            }
            return -i - 1;
          };
          this.add = function(range) {
            var excludeEdges = !range.isEmpty();
            var startIndex = this.pointIndex(range.start, excludeEdges);
            if (startIndex < 0)
              startIndex = -startIndex - 1;
            var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);
            if (endIndex < 0)
              endIndex = -endIndex - 1;
            else
              endIndex++;
            return this.ranges.splice(startIndex, endIndex - startIndex, range);
          };
          this.addList = function(list) {
            var removed = [];
            for (var i = list.length; i--; ) {
              removed.push.apply(removed, this.add(list[i]));
            }
            return removed;
          };
          this.substractPoint = function(pos) {
            var i = this.pointIndex(pos);
            if (i >= 0)
              return this.ranges.splice(i, 1);
          };
          this.merge = function() {
            var removed = [];
            var list = this.ranges;
            list = list.sort(function(a, b) {
              return comparePoints(a.start, b.start);
            });
            var next = list[0], range;
            for (var i = 1; i < list.length; i++) {
              range = next;
              next = list[i];
              var cmp = comparePoints(range.end, next.start);
              if (cmp < 0)
                continue;
              if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
                continue;
              if (comparePoints(range.end, next.end) < 0) {
                range.end.row = next.end.row;
                range.end.column = next.end.column;
              }
              list.splice(i, 1);
              removed.push(next);
              next = range;
              i--;
            }
            this.ranges = list;
            return removed;
          };
          this.contains = function(row, column) {
            return this.pointIndex({ row, column }) >= 0;
          };
          this.containsPoint = function(pos) {
            return this.pointIndex(pos) >= 0;
          };
          this.rangeAtPoint = function(pos) {
            var i = this.pointIndex(pos);
            if (i >= 0)
              return this.ranges[i];
          };
          this.clipRows = function(startRow, endRow) {
            var list = this.ranges;
            if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
              return [];
            var startIndex = this.pointIndex({ row: startRow, column: 0 });
            if (startIndex < 0)
              startIndex = -startIndex - 1;
            var endIndex = this.pointIndex({ row: endRow, column: 0 }, startIndex);
            if (endIndex < 0)
              endIndex = -endIndex - 1;
            var clipped = [];
            for (var i = startIndex; i < endIndex; i++) {
              clipped.push(list[i]);
            }
            return clipped;
          };
          this.removeAll = function() {
            return this.ranges.splice(0, this.ranges.length);
          };
          this.attach = function(session) {
            if (this.session)
              this.detach();
            this.session = session;
            this.onChange = this.$onChange.bind(this);
            this.session.on("change", this.onChange);
          };
          this.detach = function() {
            if (!this.session)
              return;
            this.session.removeListener("change", this.onChange);
            this.session = null;
          };
          this.$onChange = function(delta) {
            if (delta.action == "insert") {
              var start = delta.start;
              var end = delta.end;
            } else {
              var end = delta.start;
              var start = delta.end;
            }
            var startRow = start.row;
            var endRow = end.row;
            var lineDif = endRow - startRow;
            var colDiff = -start.column + end.column;
            var ranges = this.ranges;
            for (var i = 0, n = ranges.length; i < n; i++) {
              var r = ranges[i];
              if (r.end.row < startRow)
                continue;
              if (r.start.row > startRow)
                break;
              if (r.start.row == startRow && r.start.column >= start.column) {
                if (r.start.column == start.column && this.$insertRight) {
                } else {
                  r.start.column += colDiff;
                  r.start.row += lineDif;
                }
              }
              if (r.end.row == startRow && r.end.column >= start.column) {
                if (r.end.column == start.column && this.$insertRight) {
                  continue;
                }
                if (r.end.column == start.column && colDiff > 0 && i < n - 1) {
                  if (r.end.column > r.start.column && r.end.column == ranges[i + 1].start.column)
                    r.end.column -= colDiff;
                }
                r.end.column += colDiff;
                r.end.row += lineDif;
              }
            }
            if (lineDif != 0 && i < n) {
              for (; i < n; i++) {
                var r = ranges[i];
                r.start.row += lineDif;
                r.end.row += lineDif;
              }
            }
          };
        }).call(RangeList.prototype);
        exports2.RangeList = RangeList;
      });
      ace.define("ace/edit_session/fold", ["require", "exports", "module", "ace/range", "ace/range_list", "ace/lib/oop"], function(acequire, exports2, module2) {
        "use strict";
        var Range = acequire("../range").Range;
        var RangeList = acequire("../range_list").RangeList;
        var oop = acequire("../lib/oop");
        var Fold = exports2.Fold = function(range, placeholder) {
          this.foldLine = null;
          this.placeholder = placeholder;
          this.range = range;
          this.start = range.start;
          this.end = range.end;
          this.sameRow = range.start.row == range.end.row;
          this.subFolds = this.ranges = [];
        };
        oop.inherits(Fold, RangeList);
        (function() {
          this.toString = function() {
            return '"' + this.placeholder + '" ' + this.range.toString();
          };
          this.setFoldLine = function(foldLine) {
            this.foldLine = foldLine;
            this.subFolds.forEach(function(fold) {
              fold.setFoldLine(foldLine);
            });
          };
          this.clone = function() {
            var range = this.range.clone();
            var fold = new Fold(range, this.placeholder);
            this.subFolds.forEach(function(subFold) {
              fold.subFolds.push(subFold.clone());
            });
            fold.collapseChildren = this.collapseChildren;
            return fold;
          };
          this.addSubFold = function(fold) {
            if (this.range.isEqual(fold))
              return;
            if (!this.range.containsRange(fold))
              throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
            consumeRange(fold, this.start);
            var row = fold.start.row, column = fold.start.column;
            for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
              cmp = this.subFolds[i].range.compare(row, column);
              if (cmp != 1)
                break;
            }
            var afterStart = this.subFolds[i];
            if (cmp == 0)
              return afterStart.addSubFold(fold);
            var row = fold.range.end.row, column = fold.range.end.column;
            for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
              cmp = this.subFolds[j].range.compare(row, column);
              if (cmp != 1)
                break;
            }
            var afterEnd = this.subFolds[j];
            if (cmp == 0)
              throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
            var consumedFolds = this.subFolds.splice(i, j - i, fold);
            fold.setFoldLine(this.foldLine);
            return fold;
          };
          this.restoreRange = function(range) {
            return restoreRange(range, this.start);
          };
        }).call(Fold.prototype);
        function consumePoint(point, anchor) {
          point.row -= anchor.row;
          if (point.row == 0)
            point.column -= anchor.column;
        }
        function consumeRange(range, anchor) {
          consumePoint(range.start, anchor);
          consumePoint(range.end, anchor);
        }
        function restorePoint(point, anchor) {
          if (point.row == 0)
            point.column += anchor.column;
          point.row += anchor.row;
        }
        function restoreRange(range, anchor) {
          restorePoint(range.start, anchor);
          restorePoint(range.end, anchor);
        }
      });
      ace.define("ace/edit_session/folding", ["require", "exports", "module", "ace/range", "ace/edit_session/fold_line", "ace/edit_session/fold", "ace/token_iterator"], function(acequire, exports2, module2) {
        "use strict";
        var Range = acequire("../range").Range;
        var FoldLine = acequire("./fold_line").FoldLine;
        var Fold = acequire("./fold").Fold;
        var TokenIterator = acequire("../token_iterator").TokenIterator;
        function Folding() {
          this.getFoldAt = function(row, column, side) {
            var foldLine = this.getFoldLine(row);
            if (!foldLine)
              return null;
            var folds = foldLine.folds;
            for (var i = 0; i < folds.length; i++) {
              var fold = folds[i];
              if (fold.range.contains(row, column)) {
                if (side == 1 && fold.range.isEnd(row, column)) {
                  continue;
                } else if (side == -1 && fold.range.isStart(row, column)) {
                  continue;
                }
                return fold;
              }
            }
          };
          this.getFoldsInRange = function(range) {
            var start = range.start;
            var end = range.end;
            var foldLines = this.$foldData;
            var foundFolds = [];
            start.column += 1;
            end.column -= 1;
            for (var i = 0; i < foldLines.length; i++) {
              var cmp = foldLines[i].range.compareRange(range);
              if (cmp == 2) {
                continue;
              } else if (cmp == -2) {
                break;
              }
              var folds = foldLines[i].folds;
              for (var j = 0; j < folds.length; j++) {
                var fold = folds[j];
                cmp = fold.range.compareRange(range);
                if (cmp == -2) {
                  break;
                } else if (cmp == 2) {
                  continue;
                } else if (cmp == 42) {
                  break;
                }
                foundFolds.push(fold);
              }
            }
            start.column -= 1;
            end.column += 1;
            return foundFolds;
          };
          this.getFoldsInRangeList = function(ranges) {
            if (Array.isArray(ranges)) {
              var folds = [];
              ranges.forEach(function(range) {
                folds = folds.concat(this.getFoldsInRange(range));
              }, this);
            } else {
              var folds = this.getFoldsInRange(ranges);
            }
            return folds;
          };
          this.getAllFolds = function() {
            var folds = [];
            var foldLines = this.$foldData;
            for (var i = 0; i < foldLines.length; i++)
              for (var j = 0; j < foldLines[i].folds.length; j++)
                folds.push(foldLines[i].folds[j]);
            return folds;
          };
          this.getFoldStringAt = function(row, column, trim, foldLine) {
            foldLine = foldLine || this.getFoldLine(row);
            if (!foldLine)
              return null;
            var lastFold = {
              end: { column: 0 }
            };
            var str, fold;
            for (var i = 0; i < foldLine.folds.length; i++) {
              fold = foldLine.folds[i];
              var cmp = fold.range.compareEnd(row, column);
              if (cmp == -1) {
                str = this.getLine(fold.start.row).substring(lastFold.end.column, fold.start.column);
                break;
              } else if (cmp === 0) {
                return null;
              }
              lastFold = fold;
            }
            if (!str)
              str = this.getLine(fold.start.row).substring(lastFold.end.column);
            if (trim == -1)
              return str.substring(0, column - lastFold.end.column);
            else if (trim == 1)
              return str.substring(column - lastFold.end.column);
            else
              return str;
          };
          this.getFoldLine = function(docRow, startFoldLine) {
            var foldData = this.$foldData;
            var i = 0;
            if (startFoldLine)
              i = foldData.indexOf(startFoldLine);
            if (i == -1)
              i = 0;
            for (i; i < foldData.length; i++) {
              var foldLine = foldData[i];
              if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
                return foldLine;
              } else if (foldLine.end.row > docRow) {
                return null;
              }
            }
            return null;
          };
          this.getNextFoldLine = function(docRow, startFoldLine) {
            var foldData = this.$foldData;
            var i = 0;
            if (startFoldLine)
              i = foldData.indexOf(startFoldLine);
            if (i == -1)
              i = 0;
            for (i; i < foldData.length; i++) {
              var foldLine = foldData[i];
              if (foldLine.end.row >= docRow) {
                return foldLine;
              }
            }
            return null;
          };
          this.getFoldedRowCount = function(first, last) {
            var foldData = this.$foldData, rowCount = last - first + 1;
            for (var i = 0; i < foldData.length; i++) {
              var foldLine = foldData[i], end = foldLine.end.row, start = foldLine.start.row;
              if (end >= last) {
                if (start < last) {
                  if (start >= first)
                    rowCount -= last - start;
                  else
                    rowCount = 0;
                }
                break;
              } else if (end >= first) {
                if (start >= first)
                  rowCount -= end - start;
                else
                  rowCount -= end - first + 1;
              }
            }
            return rowCount;
          };
          this.$addFoldLine = function(foldLine) {
            this.$foldData.push(foldLine);
            this.$foldData.sort(function(a, b) {
              return a.start.row - b.start.row;
            });
            return foldLine;
          };
          this.addFold = function(placeholder, range) {
            var foldData = this.$foldData;
            var added = false;
            var fold;
            if (placeholder instanceof Fold)
              fold = placeholder;
            else {
              fold = new Fold(range, placeholder);
              fold.collapseChildren = range.collapseChildren;
            }
            this.$clipRangeToDocument(fold.range);
            var startRow = fold.start.row;
            var startColumn = fold.start.column;
            var endRow = fold.end.row;
            var endColumn = fold.end.column;
            if (!(startRow < endRow || startRow == endRow && startColumn <= endColumn - 2))
              throw new Error("The range has to be at least 2 characters width");
            var startFold = this.getFoldAt(startRow, startColumn, 1);
            var endFold = this.getFoldAt(endRow, endColumn, -1);
            if (startFold && endFold == startFold)
              return startFold.addSubFold(fold);
            if (startFold && !startFold.range.isStart(startRow, startColumn))
              this.removeFold(startFold);
            if (endFold && !endFold.range.isEnd(endRow, endColumn))
              this.removeFold(endFold);
            var folds = this.getFoldsInRange(fold.range);
            if (folds.length > 0) {
              this.removeFolds(folds);
              folds.forEach(function(subFold) {
                fold.addSubFold(subFold);
              });
            }
            for (var i = 0; i < foldData.length; i++) {
              var foldLine = foldData[i];
              if (endRow == foldLine.start.row) {
                foldLine.addFold(fold);
                added = true;
                break;
              } else if (startRow == foldLine.end.row) {
                foldLine.addFold(fold);
                added = true;
                if (!fold.sameRow) {
                  var foldLineNext = foldData[i + 1];
                  if (foldLineNext && foldLineNext.start.row == endRow) {
                    foldLine.merge(foldLineNext);
                    break;
                  }
                }
                break;
              } else if (endRow <= foldLine.start.row) {
                break;
              }
            }
            if (!added)
              foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));
            if (this.$useWrapMode)
              this.$updateWrapData(foldLine.start.row, foldLine.start.row);
            else
              this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
            this.$modified = true;
            this._signal("changeFold", { data: fold, action: "add" });
            return fold;
          };
          this.addFolds = function(folds) {
            folds.forEach(function(fold) {
              this.addFold(fold);
            }, this);
          };
          this.removeFold = function(fold) {
            var foldLine = fold.foldLine;
            var startRow = foldLine.start.row;
            var endRow = foldLine.end.row;
            var foldLines = this.$foldData;
            var folds = foldLine.folds;
            if (folds.length == 1) {
              foldLines.splice(foldLines.indexOf(foldLine), 1);
            } else if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
              folds.pop();
              foldLine.end.row = folds[folds.length - 1].end.row;
              foldLine.end.column = folds[folds.length - 1].end.column;
            } else if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
              folds.shift();
              foldLine.start.row = folds[0].start.row;
              foldLine.start.column = folds[0].start.column;
            } else if (fold.sameRow) {
              folds.splice(folds.indexOf(fold), 1);
            } else {
              var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
              folds = newFoldLine.folds;
              folds.shift();
              newFoldLine.start.row = folds[0].start.row;
              newFoldLine.start.column = folds[0].start.column;
            }
            if (!this.$updating) {
              if (this.$useWrapMode)
                this.$updateWrapData(startRow, endRow);
              else
                this.$updateRowLengthCache(startRow, endRow);
            }
            this.$modified = true;
            this._signal("changeFold", { data: fold, action: "remove" });
          };
          this.removeFolds = function(folds) {
            var cloneFolds = [];
            for (var i = 0; i < folds.length; i++) {
              cloneFolds.push(folds[i]);
            }
            cloneFolds.forEach(function(fold) {
              this.removeFold(fold);
            }, this);
            this.$modified = true;
          };
          this.expandFold = function(fold) {
            this.removeFold(fold);
            fold.subFolds.forEach(function(subFold) {
              fold.restoreRange(subFold);
              this.addFold(subFold);
            }, this);
            if (fold.collapseChildren > 0) {
              this.foldAll(fold.start.row + 1, fold.end.row, fold.collapseChildren - 1);
            }
            fold.subFolds = [];
          };
          this.expandFolds = function(folds) {
            folds.forEach(function(fold) {
              this.expandFold(fold);
            }, this);
          };
          this.unfold = function(location, expandInner) {
            var range, folds;
            if (location == null) {
              range = new Range(0, 0, this.getLength(), 0);
              expandInner = true;
            } else if (typeof location == "number")
              range = new Range(location, 0, location, this.getLine(location).length);
            else if ("row" in location)
              range = Range.fromPoints(location, location);
            else
              range = location;
            folds = this.getFoldsInRangeList(range);
            if (expandInner) {
              this.removeFolds(folds);
            } else {
              var subFolds = folds;
              while (subFolds.length) {
                this.expandFolds(subFolds);
                subFolds = this.getFoldsInRangeList(range);
              }
            }
            if (folds.length)
              return folds;
          };
          this.isRowFolded = function(docRow, startFoldRow) {
            return !!this.getFoldLine(docRow, startFoldRow);
          };
          this.getRowFoldEnd = function(docRow, startFoldRow) {
            var foldLine = this.getFoldLine(docRow, startFoldRow);
            return foldLine ? foldLine.end.row : docRow;
          };
          this.getRowFoldStart = function(docRow, startFoldRow) {
            var foldLine = this.getFoldLine(docRow, startFoldRow);
            return foldLine ? foldLine.start.row : docRow;
          };
          this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
            if (startRow == null)
              startRow = foldLine.start.row;
            if (startColumn == null)
              startColumn = 0;
            if (endRow == null)
              endRow = foldLine.end.row;
            if (endColumn == null)
              endColumn = this.getLine(endRow).length;
            var doc = this.doc;
            var textLine = "";
            foldLine.walk(function(placeholder, row, column, lastColumn) {
              if (row < startRow)
                return;
              if (row == startRow) {
                if (column < startColumn)
                  return;
                lastColumn = Math.max(startColumn, lastColumn);
              }
              if (placeholder != null) {
                textLine += placeholder;
              } else {
                textLine += doc.getLine(row).substring(lastColumn, column);
              }
            }, endRow, endColumn);
            return textLine;
          };
          this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
            var foldLine = this.getFoldLine(row);
            if (!foldLine) {
              var line;
              line = this.doc.getLine(row);
              return line.substring(startColumn || 0, endColumn || line.length);
            } else {
              return this.getFoldDisplayLine(
                foldLine,
                row,
                endColumn,
                startRow,
                startColumn
              );
            }
          };
          this.$cloneFoldData = function() {
            var fd = [];
            fd = this.$foldData.map(function(foldLine) {
              var folds = foldLine.folds.map(function(fold) {
                return fold.clone();
              });
              return new FoldLine(fd, folds);
            });
            return fd;
          };
          this.toggleFold = function(tryToUnfold) {
            var selection = this.selection;
            var range = selection.getRange();
            var fold;
            var bracketPos;
            if (range.isEmpty()) {
              var cursor = range.start;
              fold = this.getFoldAt(cursor.row, cursor.column);
              if (fold) {
                this.expandFold(fold);
                return;
              } else if (bracketPos = this.findMatchingBracket(cursor)) {
                if (range.comparePoint(bracketPos) == 1) {
                  range.end = bracketPos;
                } else {
                  range.start = bracketPos;
                  range.start.column++;
                  range.end.column--;
                }
              } else if (bracketPos = this.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 })) {
                if (range.comparePoint(bracketPos) == 1)
                  range.end = bracketPos;
                else
                  range.start = bracketPos;
                range.start.column++;
              } else {
                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
              }
            } else {
              var folds = this.getFoldsInRange(range);
              if (tryToUnfold && folds.length) {
                this.expandFolds(folds);
                return;
              } else if (folds.length == 1) {
                fold = folds[0];
              }
            }
            if (!fold)
              fold = this.getFoldAt(range.start.row, range.start.column);
            if (fold && fold.range.toString() == range.toString()) {
              this.expandFold(fold);
              return;
            }
            var placeholder = "...";
            if (!range.isMultiLine()) {
              placeholder = this.getTextRange(range);
              if (placeholder.length < 4)
                return;
              placeholder = placeholder.trim().substring(0, 2) + "..";
            }
            this.addFold(placeholder, range);
          };
          this.getCommentFoldRange = function(row, column, dir) {
            var iterator = new TokenIterator(this, row, column);
            var token = iterator.getCurrentToken();
            var type = token.type;
            if (token && /^comment|string/.test(type)) {
              type = type.match(/comment|string/)[0];
              if (type == "comment")
                type += "|doc-start";
              var re = new RegExp(type);
              var range = new Range();
              if (dir != 1) {
                do {
                  token = iterator.stepBackward();
                } while (token && re.test(token.type));
                iterator.stepForward();
              }
              range.start.row = iterator.getCurrentTokenRow();
              range.start.column = iterator.getCurrentTokenColumn() + 2;
              iterator = new TokenIterator(this, row, column);
              if (dir != -1) {
                var lastRow = -1;
                do {
                  token = iterator.stepForward();
                  if (lastRow == -1) {
                    var state = this.getState(iterator.$row);
                    if (!re.test(state))
                      lastRow = iterator.$row;
                  } else if (iterator.$row > lastRow) {
                    break;
                  }
                } while (token && re.test(token.type));
                token = iterator.stepBackward();
              } else
                token = iterator.getCurrentToken();
              range.end.row = iterator.getCurrentTokenRow();
              range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
              return range;
            }
          };
          this.foldAll = function(startRow, endRow, depth) {
            if (depth == void 0)
              depth = 1e5;
            var foldWidgets = this.foldWidgets;
            if (!foldWidgets)
              return;
            endRow = endRow || this.getLength();
            startRow = startRow || 0;
            for (var row = startRow; row < endRow; row++) {
              if (foldWidgets[row] == null)
                foldWidgets[row] = this.getFoldWidget(row);
              if (foldWidgets[row] != "start")
                continue;
              var range = this.getFoldWidgetRange(row);
              if (range && range.isMultiLine() && range.end.row <= endRow && range.start.row >= startRow) {
                row = range.end.row;
                try {
                  var fold = this.addFold("...", range);
                  if (fold)
                    fold.collapseChildren = depth;
                } catch (e) {
                }
              }
            }
          };
          this.$foldStyles = {
            "manual": 1,
            "markbegin": 1,
            "markbeginend": 1
          };
          this.$foldStyle = "markbegin";
          this.setFoldStyle = function(style) {
            if (!this.$foldStyles[style])
              throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
            if (this.$foldStyle == style)
              return;
            this.$foldStyle = style;
            if (style == "manual")
              this.unfold();
            var mode = this.$foldMode;
            this.$setFolding(null);
            this.$setFolding(mode);
          };
          this.$setFolding = function(foldMode) {
            if (this.$foldMode == foldMode)
              return;
            this.$foldMode = foldMode;
            this.off("change", this.$updateFoldWidgets);
            this.off("tokenizerUpdate", this.$tokenizerUpdateFoldWidgets);
            this._signal("changeAnnotation");
            if (!foldMode || this.$foldStyle == "manual") {
              this.foldWidgets = null;
              return;
            }
            this.foldWidgets = [];
            this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
            this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
            this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
            this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
            this.on("change", this.$updateFoldWidgets);
            this.on("tokenizerUpdate", this.$tokenizerUpdateFoldWidgets);
          };
          this.getParentFoldRangeData = function(row, ignoreCurrent) {
            var fw = this.foldWidgets;
            if (!fw || ignoreCurrent && fw[row])
              return {};
            var i = row - 1, firstRange;
            while (i >= 0) {
              var c = fw[i];
              if (c == null)
                c = fw[i] = this.getFoldWidget(i);
              if (c == "start") {
                var range = this.getFoldWidgetRange(i);
                if (!firstRange)
                  firstRange = range;
                if (range && range.end.row >= row)
                  break;
              }
              i--;
            }
            return {
              range: i !== -1 && range,
              firstRange
            };
          };
          this.onFoldWidgetClick = function(row, e) {
            e = e.domEvent;
            var options = {
              children: e.shiftKey,
              all: e.ctrlKey || e.metaKey,
              siblings: e.altKey
            };
            var range = this.$toggleFoldWidget(row, options);
            if (!range) {
              var el = e.target || e.srcElement;
              if (el && /ace_fold-widget/.test(el.className))
                el.className += " ace_invalid";
            }
          };
          this.$toggleFoldWidget = function(row, options) {
            if (!this.getFoldWidget)
              return;
            var type = this.getFoldWidget(row);
            var line = this.getLine(row);
            var dir = type === "end" ? -1 : 1;
            var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);
            if (fold) {
              if (options.children || options.all)
                this.removeFold(fold);
              else
                this.expandFold(fold);
              return fold;
            }
            var range = this.getFoldWidgetRange(row, true);
            if (range && !range.isMultiLine()) {
              fold = this.getFoldAt(range.start.row, range.start.column, 1);
              if (fold && range.isEqual(fold.range)) {
                this.removeFold(fold);
                return fold;
              }
            }
            if (options.siblings) {
              var data = this.getParentFoldRangeData(row);
              if (data.range) {
                var startRow = data.range.start.row + 1;
                var endRow = data.range.end.row;
              }
              this.foldAll(startRow, endRow, options.all ? 1e4 : 0);
            } else if (options.children) {
              endRow = range ? range.end.row : this.getLength();
              this.foldAll(row + 1, endRow, options.all ? 1e4 : 0);
            } else if (range) {
              if (options.all)
                range.collapseChildren = 1e4;
              this.addFold("...", range);
            }
            return range;
          };
          this.toggleFoldWidget = function(toggleParent) {
            var row = this.selection.getCursor().row;
            row = this.getRowFoldStart(row);
            var range = this.$toggleFoldWidget(row, {});
            if (range)
              return;
            var data = this.getParentFoldRangeData(row, true);
            range = data.range || data.firstRange;
            if (range) {
              row = range.start.row;
              var fold = this.getFoldAt(row, this.getLine(row).length, 1);
              if (fold) {
                this.removeFold(fold);
              } else {
                this.addFold("...", range);
              }
            }
          };
          this.updateFoldWidgets = function(delta) {
            var firstRow = delta.start.row;
            var len = delta.end.row - firstRow;
            if (len === 0) {
              this.foldWidgets[firstRow] = null;
            } else if (delta.action == "remove") {
              this.foldWidgets.splice(firstRow, len + 1, null);
            } else {
              var args = Array(len + 1);
              args.unshift(firstRow, 1);
              this.foldWidgets.splice.apply(this.foldWidgets, args);
            }
          };
          this.tokenizerUpdateFoldWidgets = function(e) {
            var rows = e.data;
            if (rows.first != rows.last) {
              if (this.foldWidgets.length > rows.first)
                this.foldWidgets.splice(rows.first, this.foldWidgets.length);
            }
          };
        }
        exports2.Folding = Folding;
      });
      ace.define("ace/edit_session/bracket_match", ["require", "exports", "module", "ace/token_iterator", "ace/range"], function(acequire, exports2, module2) {
        "use strict";
        var TokenIterator = acequire("../token_iterator").TokenIterator;
        var Range = acequire("../range").Range;
        function BracketMatch() {
          this.findMatchingBracket = function(position, chr) {
            if (position.column == 0)
              return null;
            var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column - 1);
            if (charBeforeCursor == "")
              return null;
            var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
            if (!match)
              return null;
            if (match[1])
              return this.$findClosingBracket(match[1], position);
            else
              return this.$findOpeningBracket(match[2], position);
          };
          this.getBracketRange = function(pos) {
            var line = this.getLine(pos.row);
            var before = true, range;
            var chr = line.charAt(pos.column - 1);
            var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
            if (!match) {
              chr = line.charAt(pos.column);
              pos = { row: pos.row, column: pos.column + 1 };
              match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
              before = false;
            }
            if (!match)
              return null;
            if (match[1]) {
              var bracketPos = this.$findClosingBracket(match[1], pos);
              if (!bracketPos)
                return null;
              range = Range.fromPoints(pos, bracketPos);
              if (!before) {
                range.end.column++;
                range.start.column--;
              }
              range.cursor = range.end;
            } else {
              var bracketPos = this.$findOpeningBracket(match[2], pos);
              if (!bracketPos)
                return null;
              range = Range.fromPoints(bracketPos, pos);
              if (!before) {
                range.start.column++;
                range.end.column--;
              }
              range.cursor = range.start;
            }
            return range;
          };
          this.$brackets = {
            ")": "(",
            "(": ")",
            "]": "[",
            "[": "]",
            "{": "}",
            "}": "{"
          };
          this.$findOpeningBracket = function(bracket, position, typeRe) {
            var openBracket = this.$brackets[bracket];
            var depth = 1;
            var iterator = new TokenIterator(this, position.row, position.column);
            var token = iterator.getCurrentToken();
            if (!token)
              token = iterator.stepForward();
            if (!token)
              return;
            if (!typeRe) {
              typeRe = new RegExp(
                "(\\.?" + token.type.replace(".", "\\.").replace("rparen", ".paren").replace(/\b(?:end)\b/, "(?:start|begin|end)") + ")+"
              );
            }
            var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
            var value = token.value;
            while (true) {
              while (valueIndex >= 0) {
                var chr = value.charAt(valueIndex);
                if (chr == openBracket) {
                  depth -= 1;
                  if (depth == 0) {
                    return {
                      row: iterator.getCurrentTokenRow(),
                      column: valueIndex + iterator.getCurrentTokenColumn()
                    };
                  }
                } else if (chr == bracket) {
                  depth += 1;
                }
                valueIndex -= 1;
              }
              do {
                token = iterator.stepBackward();
              } while (token && !typeRe.test(token.type));
              if (token == null)
                break;
              value = token.value;
              valueIndex = value.length - 1;
            }
            return null;
          };
          this.$findClosingBracket = function(bracket, position, typeRe) {
            var closingBracket = this.$brackets[bracket];
            var depth = 1;
            var iterator = new TokenIterator(this, position.row, position.column);
            var token = iterator.getCurrentToken();
            if (!token)
              token = iterator.stepForward();
            if (!token)
              return;
            if (!typeRe) {
              typeRe = new RegExp(
                "(\\.?" + token.type.replace(".", "\\.").replace("lparen", ".paren").replace(/\b(?:start|begin)\b/, "(?:start|begin|end)") + ")+"
              );
            }
            var valueIndex = position.column - iterator.getCurrentTokenColumn();
            while (true) {
              var value = token.value;
              var valueLength = value.length;
              while (valueIndex < valueLength) {
                var chr = value.charAt(valueIndex);
                if (chr == closingBracket) {
                  depth -= 1;
                  if (depth == 0) {
                    return {
                      row: iterator.getCurrentTokenRow(),
                      column: valueIndex + iterator.getCurrentTokenColumn()
                    };
                  }
                } else if (chr == bracket) {
                  depth += 1;
                }
                valueIndex += 1;
              }
              do {
                token = iterator.stepForward();
              } while (token && !typeRe.test(token.type));
              if (token == null)
                break;
              valueIndex = 0;
            }
            return null;
          };
        }
        exports2.BracketMatch = BracketMatch;
      });
      ace.define("ace/edit_session", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/bidihandler", "ace/config", "ace/lib/event_emitter", "ace/selection", "ace/mode/text", "ace/range", "ace/document", "ace/background_tokenizer", "ace/search_highlight", "ace/edit_session/folding", "ace/edit_session/bracket_match"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("./lib/oop");
        var lang = acequire("./lib/lang");
        var BidiHandler = acequire("./bidihandler").BidiHandler;
        var config = acequire("./config");
        var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
        var Selection = acequire("./selection").Selection;
        var TextMode = acequire("./mode/text").Mode;
        var Range = acequire("./range").Range;
        var Document = acequire("./document").Document;
        var BackgroundTokenizer = acequire("./background_tokenizer").BackgroundTokenizer;
        var SearchHighlight = acequire("./search_highlight").SearchHighlight;
        var EditSession = function(text, mode) {
          this.$breakpoints = [];
          this.$decorations = [];
          this.$frontMarkers = {};
          this.$backMarkers = {};
          this.$markerId = 1;
          this.$undoSelect = true;
          this.$foldData = [];
          this.id = "session" + ++EditSession.$uid;
          this.$foldData.toString = function() {
            return this.join("\n");
          };
          this.on("changeFold", this.onChangeFold.bind(this));
          this.$onChange = this.onChange.bind(this);
          if (typeof text != "object" || !text.getLine)
            text = new Document(text);
          this.$bidiHandler = new BidiHandler(this);
          this.setDocument(text);
          this.selection = new Selection(this);
          config.resetOptions(this);
          this.setMode(mode);
          config._signal("session", this);
        };
        EditSession.$uid = 0;
        (function() {
          oop.implement(this, EventEmitter);
          this.setDocument = function(doc) {
            if (this.doc)
              this.doc.removeListener("change", this.$onChange);
            this.doc = doc;
            doc.on("change", this.$onChange);
            if (this.bgTokenizer)
              this.bgTokenizer.setDocument(this.getDocument());
            this.resetCaches();
          };
          this.getDocument = function() {
            return this.doc;
          };
          this.$resetRowCache = function(docRow) {
            if (!docRow) {
              this.$docRowCache = [];
              this.$screenRowCache = [];
              return;
            }
            var l = this.$docRowCache.length;
            var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
            if (l > i) {
              this.$docRowCache.splice(i, l);
              this.$screenRowCache.splice(i, l);
            }
          };
          this.$getRowCacheIndex = function(cacheArray, val) {
            var low = 0;
            var hi = cacheArray.length - 1;
            while (low <= hi) {
              var mid = low + hi >> 1;
              var c = cacheArray[mid];
              if (val > c)
                low = mid + 1;
              else if (val < c)
                hi = mid - 1;
              else
                return mid;
            }
            return low - 1;
          };
          this.resetCaches = function() {
            this.$modified = true;
            this.$wrapData = [];
            this.$rowLengthCache = [];
            this.$resetRowCache(0);
            if (this.bgTokenizer)
              this.bgTokenizer.start(0);
          };
          this.onChangeFold = function(e) {
            var fold = e.data;
            this.$resetRowCache(fold.start.row);
          };
          this.onChange = function(delta) {
            this.$modified = true;
            this.$bidiHandler.onChange(delta);
            this.$resetRowCache(delta.start.row);
            var removedFolds = this.$updateInternalDataOnChange(delta);
            if (!this.$fromUndo && this.$undoManager && !delta.ignore) {
              this.$deltasDoc.push(delta);
              if (removedFolds && removedFolds.length != 0) {
                this.$deltasFold.push({
                  action: "removeFolds",
                  folds: removedFolds
                });
              }
              this.$informUndoManager.schedule();
            }
            this.bgTokenizer && this.bgTokenizer.$updateOnChange(delta);
            this._signal("change", delta);
          };
          this.setValue = function(text) {
            this.doc.setValue(text);
            this.selection.moveTo(0, 0);
            this.$resetRowCache(0);
            this.$deltas = [];
            this.$deltasDoc = [];
            this.$deltasFold = [];
            this.setUndoManager(this.$undoManager);
            this.getUndoManager().reset();
          };
          this.getValue = this.toString = function() {
            return this.doc.getValue();
          };
          this.getSelection = function() {
            return this.selection;
          };
          this.getState = function(row) {
            return this.bgTokenizer.getState(row);
          };
          this.getTokens = function(row) {
            return this.bgTokenizer.getTokens(row);
          };
          this.getTokenAt = function(row, column) {
            var tokens = this.bgTokenizer.getTokens(row);
            var token, c = 0;
            if (column == null) {
              var i = tokens.length - 1;
              c = this.getLine(row).length;
            } else {
              for (var i = 0; i < tokens.length; i++) {
                c += tokens[i].value.length;
                if (c >= column)
                  break;
              }
            }
            token = tokens[i];
            if (!token)
              return null;
            token.index = i;
            token.start = c - token.value.length;
            return token;
          };
          this.setUndoManager = function(undoManager) {
            this.$undoManager = undoManager;
            this.$deltas = [];
            this.$deltasDoc = [];
            this.$deltasFold = [];
            if (this.$informUndoManager)
              this.$informUndoManager.cancel();
            if (undoManager) {
              var self2 = this;
              this.$syncInformUndoManager = function() {
                self2.$informUndoManager.cancel();
                if (self2.$deltasFold.length) {
                  self2.$deltas.push({
                    group: "fold",
                    deltas: self2.$deltasFold
                  });
                  self2.$deltasFold = [];
                }
                if (self2.$deltasDoc.length) {
                  self2.$deltas.push({
                    group: "doc",
                    deltas: self2.$deltasDoc
                  });
                  self2.$deltasDoc = [];
                }
                if (self2.$deltas.length > 0) {
                  undoManager.execute({
                    action: "aceupdate",
                    args: [self2.$deltas, self2],
                    merge: self2.mergeUndoDeltas
                  });
                }
                self2.mergeUndoDeltas = false;
                self2.$deltas = [];
              };
              this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
            }
          };
          this.markUndoGroup = function() {
            if (this.$syncInformUndoManager)
              this.$syncInformUndoManager();
          };
          this.$defaultUndoManager = {
            undo: function() {
            },
            redo: function() {
            },
            reset: function() {
            }
          };
          this.getUndoManager = function() {
            return this.$undoManager || this.$defaultUndoManager;
          };
          this.getTabString = function() {
            if (this.getUseSoftTabs()) {
              return lang.stringRepeat(" ", this.getTabSize());
            } else {
              return "	";
            }
          };
          this.setUseSoftTabs = function(val) {
            this.setOption("useSoftTabs", val);
          };
          this.getUseSoftTabs = function() {
            return this.$useSoftTabs && !this.$mode.$indentWithTabs;
          };
          this.setTabSize = function(tabSize) {
            this.setOption("tabSize", tabSize);
          };
          this.getTabSize = function() {
            return this.$tabSize;
          };
          this.isTabStop = function(position) {
            return this.$useSoftTabs && position.column % this.$tabSize === 0;
          };
          this.setNavigateWithinSoftTabs = function(navigateWithinSoftTabs) {
            this.setOption("navigateWithinSoftTabs", navigateWithinSoftTabs);
          };
          this.getNavigateWithinSoftTabs = function() {
            return this.$navigateWithinSoftTabs;
          };
          this.$overwrite = false;
          this.setOverwrite = function(overwrite) {
            this.setOption("overwrite", overwrite);
          };
          this.getOverwrite = function() {
            return this.$overwrite;
          };
          this.toggleOverwrite = function() {
            this.setOverwrite(!this.$overwrite);
          };
          this.addGutterDecoration = function(row, className) {
            if (!this.$decorations[row])
              this.$decorations[row] = "";
            this.$decorations[row] += " " + className;
            this._signal("changeBreakpoint", {});
          };
          this.removeGutterDecoration = function(row, className) {
            this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
            this._signal("changeBreakpoint", {});
          };
          this.getBreakpoints = function() {
            return this.$breakpoints;
          };
          this.setBreakpoints = function(rows) {
            this.$breakpoints = [];
            for (var i = 0; i < rows.length; i++) {
              this.$breakpoints[rows[i]] = "ace_breakpoint";
            }
            this._signal("changeBreakpoint", {});
          };
          this.clearBreakpoints = function() {
            this.$breakpoints = [];
            this._signal("changeBreakpoint", {});
          };
          this.setBreakpoint = function(row, className) {
            if (className === void 0)
              className = "ace_breakpoint";
            if (className)
              this.$breakpoints[row] = className;
            else
              delete this.$breakpoints[row];
            this._signal("changeBreakpoint", {});
          };
          this.clearBreakpoint = function(row) {
            delete this.$breakpoints[row];
            this._signal("changeBreakpoint", {});
          };
          this.addMarker = function(range, clazz, type, inFront) {
            var id = this.$markerId++;
            var marker = {
              range,
              type: type || "line",
              renderer: typeof type == "function" ? type : null,
              clazz,
              inFront: !!inFront,
              id
            };
            if (inFront) {
              this.$frontMarkers[id] = marker;
              this._signal("changeFrontMarker");
            } else {
              this.$backMarkers[id] = marker;
              this._signal("changeBackMarker");
            }
            return id;
          };
          this.addDynamicMarker = function(marker, inFront) {
            if (!marker.update)
              return;
            var id = this.$markerId++;
            marker.id = id;
            marker.inFront = !!inFront;
            if (inFront) {
              this.$frontMarkers[id] = marker;
              this._signal("changeFrontMarker");
            } else {
              this.$backMarkers[id] = marker;
              this._signal("changeBackMarker");
            }
            return marker;
          };
          this.removeMarker = function(markerId) {
            var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
            if (!marker)
              return;
            var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
            if (marker) {
              delete markers[markerId];
              this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
            }
          };
          this.getMarkers = function(inFront) {
            return inFront ? this.$frontMarkers : this.$backMarkers;
          };
          this.highlight = function(re) {
            if (!this.$searchHighlight) {
              var highlight = new SearchHighlight(null, "ace_selected-word", "text");
              this.$searchHighlight = this.addDynamicMarker(highlight);
            }
            this.$searchHighlight.setRegexp(re);
          };
          this.highlightLines = function(startRow, endRow, clazz, inFront) {
            if (typeof endRow != "number") {
              clazz = endRow;
              endRow = startRow;
            }
            if (!clazz)
              clazz = "ace_step";
            var range = new Range(startRow, 0, endRow, Infinity);
            range.id = this.addMarker(range, clazz, "fullLine", inFront);
            return range;
          };
          this.setAnnotations = function(annotations) {
            this.$annotations = annotations;
            this._signal("changeAnnotation", {});
          };
          this.getAnnotations = function() {
            return this.$annotations || [];
          };
          this.clearAnnotations = function() {
            this.setAnnotations([]);
          };
          this.$detectNewLine = function(text) {
            var match = text.match(/^.*?(\r?\n)/m);
            if (match) {
              this.$autoNewLine = match[1];
            } else {
              this.$autoNewLine = "\n";
            }
          };
          this.getWordRange = function(row, column) {
            var line = this.getLine(row);
            var inToken = false;
            if (column > 0)
              inToken = !!line.charAt(column - 1).match(this.tokenRe);
            if (!inToken)
              inToken = !!line.charAt(column).match(this.tokenRe);
            if (inToken)
              var re = this.tokenRe;
            else if (/^\s+$/.test(line.slice(column - 1, column + 1)))
              var re = /\s/;
            else
              var re = this.nonTokenRe;
            var start = column;
            if (start > 0) {
              do {
                start--;
              } while (start >= 0 && line.charAt(start).match(re));
              start++;
            }
            var end = column;
            while (end < line.length && line.charAt(end).match(re)) {
              end++;
            }
            return new Range(row, start, row, end);
          };
          this.getAWordRange = function(row, column) {
            var wordRange = this.getWordRange(row, column);
            var line = this.getLine(wordRange.end.row);
            while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
              wordRange.end.column += 1;
            }
            return wordRange;
          };
          this.setNewLineMode = function(newLineMode) {
            this.doc.setNewLineMode(newLineMode);
          };
          this.getNewLineMode = function() {
            return this.doc.getNewLineMode();
          };
          this.setUseWorker = function(useWorker) {
            this.setOption("useWorker", useWorker);
          };
          this.getUseWorker = function() {
            return this.$useWorker;
          };
          this.onReloadTokenizer = function(e) {
            var rows = e.data;
            this.bgTokenizer.start(rows.first);
            this._signal("tokenizerUpdate", e);
          };
          this.$modes = {};
          this.$mode = null;
          this.$modeId = null;
          this.setMode = function(mode, cb) {
            if (mode && typeof mode === "object") {
              if (mode.getTokenizer)
                return this.$onChangeMode(mode);
              var options = mode;
              var path = options.path;
            } else {
              path = mode || "ace/mode/text";
            }
            if (!this.$modes["ace/mode/text"])
              this.$modes["ace/mode/text"] = new TextMode();
            if (this.$modes[path] && !options) {
              this.$onChangeMode(this.$modes[path]);
              cb && cb();
              return;
            }
            this.$modeId = path;
            config.loadModule(["mode", path], function(m) {
              if (this.$modeId !== path)
                return cb && cb();
              if (this.$modes[path] && !options) {
                this.$onChangeMode(this.$modes[path]);
              } else if (m && m.Mode) {
                m = new m.Mode(options);
                if (!options) {
                  this.$modes[path] = m;
                  m.$id = path;
                }
                this.$onChangeMode(m);
              }
              cb && cb();
            }.bind(this));
            if (!this.$mode)
              this.$onChangeMode(this.$modes["ace/mode/text"], true);
          };
          this.$onChangeMode = function(mode, $isPlaceholder) {
            if (!$isPlaceholder)
              this.$modeId = mode.$id;
            if (this.$mode === mode)
              return;
            this.$mode = mode;
            this.$stopWorker();
            if (this.$useWorker)
              this.$startWorker();
            var tokenizer = mode.getTokenizer();
            if (tokenizer.addEventListener !== void 0) {
              var onReloadTokenizer = this.onReloadTokenizer.bind(this);
              tokenizer.addEventListener("update", onReloadTokenizer);
            }
            if (!this.bgTokenizer) {
              this.bgTokenizer = new BackgroundTokenizer(tokenizer);
              var _self = this;
              this.bgTokenizer.addEventListener("update", function(e) {
                _self._signal("tokenizerUpdate", e);
              });
            } else {
              this.bgTokenizer.setTokenizer(tokenizer);
            }
            this.bgTokenizer.setDocument(this.getDocument());
            this.tokenRe = mode.tokenRe;
            this.nonTokenRe = mode.nonTokenRe;
            if (!$isPlaceholder) {
              if (mode.attachToSession)
                mode.attachToSession(this);
              this.$options.wrapMethod.set.call(this, this.$wrapMethod);
              this.$setFolding(mode.foldingRules);
              this.bgTokenizer.start(0);
              this._emit("changeMode");
            }
          };
          this.$stopWorker = function() {
            if (this.$worker) {
              this.$worker.terminate();
              this.$worker = null;
            }
          };
          this.$startWorker = function() {
            try {
              this.$worker = this.$mode.createWorker(this);
            } catch (e) {
              config.warn("Could not load worker", e);
              this.$worker = null;
            }
          };
          this.getMode = function() {
            return this.$mode;
          };
          this.$scrollTop = 0;
          this.setScrollTop = function(scrollTop) {
            if (this.$scrollTop === scrollTop || isNaN(scrollTop))
              return;
            this.$scrollTop = scrollTop;
            this._signal("changeScrollTop", scrollTop);
          };
          this.getScrollTop = function() {
            return this.$scrollTop;
          };
          this.$scrollLeft = 0;
          this.setScrollLeft = function(scrollLeft) {
            if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
              return;
            this.$scrollLeft = scrollLeft;
            this._signal("changeScrollLeft", scrollLeft);
          };
          this.getScrollLeft = function() {
            return this.$scrollLeft;
          };
          this.getScreenWidth = function() {
            this.$computeWidth();
            if (this.lineWidgets)
              return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
            return this.screenWidth;
          };
          this.getLineWidgetMaxWidth = function() {
            if (this.lineWidgetsWidth != null)
              return this.lineWidgetsWidth;
            var width = 0;
            this.lineWidgets.forEach(function(w) {
              if (w && w.screenWidth > width)
                width = w.screenWidth;
            });
            return this.lineWidgetWidth = width;
          };
          this.$computeWidth = function(force) {
            if (this.$modified || force) {
              this.$modified = false;
              if (this.$useWrapMode)
                return this.screenWidth = this.$wrapLimit;
              var lines = this.doc.getAllLines();
              var cache = this.$rowLengthCache;
              var longestScreenLine = 0;
              var foldIndex = 0;
              var foldLine = this.$foldData[foldIndex];
              var foldStart = foldLine ? foldLine.start.row : Infinity;
              var len = lines.length;
              for (var i = 0; i < len; i++) {
                if (i > foldStart) {
                  i = foldLine.end.row + 1;
                  if (i >= len)
                    break;
                  foldLine = this.$foldData[foldIndex++];
                  foldStart = foldLine ? foldLine.start.row : Infinity;
                }
                if (cache[i] == null)
                  cache[i] = this.$getStringScreenWidth(lines[i])[0];
                if (cache[i] > longestScreenLine)
                  longestScreenLine = cache[i];
              }
              this.screenWidth = longestScreenLine;
            }
          };
          this.getLine = function(row) {
            return this.doc.getLine(row);
          };
          this.getLines = function(firstRow, lastRow) {
            return this.doc.getLines(firstRow, lastRow);
          };
          this.getLength = function() {
            return this.doc.getLength();
          };
          this.getTextRange = function(range) {
            return this.doc.getTextRange(range || this.selection.getRange());
          };
          this.insert = function(position, text) {
            return this.doc.insert(position, text);
          };
          this.remove = function(range) {
            return this.doc.remove(range);
          };
          this.removeFullLines = function(firstRow, lastRow) {
            return this.doc.removeFullLines(firstRow, lastRow);
          };
          this.undoChanges = function(deltas, dontSelect) {
            if (!deltas.length)
              return;
            this.$fromUndo = true;
            var lastUndoRange = null;
            for (var i = deltas.length - 1; i != -1; i--) {
              var delta = deltas[i];
              if (delta.group == "doc") {
                this.doc.revertDeltas(delta.deltas);
                lastUndoRange = this.$getUndoSelection(delta.deltas, true, lastUndoRange);
              } else {
                delta.deltas.forEach(function(foldDelta) {
                  this.addFolds(foldDelta.folds);
                }, this);
              }
            }
            this.$fromUndo = false;
            lastUndoRange && this.$undoSelect && !dontSelect && this.selection.setSelectionRange(lastUndoRange);
            return lastUndoRange;
          };
          this.redoChanges = function(deltas, dontSelect) {
            if (!deltas.length)
              return;
            this.$fromUndo = true;
            var lastUndoRange = null;
            for (var i = 0; i < deltas.length; i++) {
              var delta = deltas[i];
              if (delta.group == "doc") {
                this.doc.applyDeltas(delta.deltas);
                lastUndoRange = this.$getUndoSelection(delta.deltas, false, lastUndoRange);
              }
            }
            this.$fromUndo = false;
            lastUndoRange && this.$undoSelect && !dontSelect && this.selection.setSelectionRange(lastUndoRange);
            return lastUndoRange;
          };
          this.setUndoSelect = function(enable) {
            this.$undoSelect = enable;
          };
          this.$getUndoSelection = function(deltas, isUndo, lastUndoRange) {
            function isInsert(delta2) {
              return isUndo ? delta2.action !== "insert" : delta2.action === "insert";
            }
            var delta = deltas[0];
            var range, point;
            var lastDeltaIsInsert = false;
            if (isInsert(delta)) {
              range = Range.fromPoints(delta.start, delta.end);
              lastDeltaIsInsert = true;
            } else {
              range = Range.fromPoints(delta.start, delta.start);
              lastDeltaIsInsert = false;
            }
            for (var i = 1; i < deltas.length; i++) {
              delta = deltas[i];
              if (isInsert(delta)) {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                  range.setStart(point);
                }
                point = delta.end;
                if (range.compare(point.row, point.column) == 1) {
                  range.setEnd(point);
                }
                lastDeltaIsInsert = true;
              } else {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                  range = Range.fromPoints(delta.start, delta.start);
                }
                lastDeltaIsInsert = false;
              }
            }
            if (lastUndoRange != null) {
              if (Range.comparePoints(lastUndoRange.start, range.start) === 0) {
                lastUndoRange.start.column += range.end.column - range.start.column;
                lastUndoRange.end.column += range.end.column - range.start.column;
              }
              var cmp = lastUndoRange.compareRange(range);
              if (cmp == 1) {
                range.setStart(lastUndoRange.start);
              } else if (cmp == -1) {
                range.setEnd(lastUndoRange.end);
              }
            }
            return range;
          };
          this.replace = function(range, text) {
            return this.doc.replace(range, text);
          };
          this.moveText = function(fromRange, toPosition, copy) {
            var text = this.getTextRange(fromRange);
            var folds = this.getFoldsInRange(fromRange);
            var toRange = Range.fromPoints(toPosition, toPosition);
            if (!copy) {
              this.remove(fromRange);
              var rowDiff = fromRange.start.row - fromRange.end.row;
              var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
              if (collDiff) {
                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
                  toRange.start.column += collDiff;
                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
                  toRange.end.column += collDiff;
              }
              if (rowDiff && toRange.start.row >= fromRange.end.row) {
                toRange.start.row += rowDiff;
                toRange.end.row += rowDiff;
              }
            }
            toRange.end = this.insert(toRange.start, text);
            if (folds.length) {
              var oldStart = fromRange.start;
              var newStart = toRange.start;
              var rowDiff = newStart.row - oldStart.row;
              var collDiff = newStart.column - oldStart.column;
              this.addFolds(folds.map(function(x) {
                x = x.clone();
                if (x.start.row == oldStart.row)
                  x.start.column += collDiff;
                if (x.end.row == oldStart.row)
                  x.end.column += collDiff;
                x.start.row += rowDiff;
                x.end.row += rowDiff;
                return x;
              }));
            }
            return toRange;
          };
          this.indentRows = function(startRow, endRow, indentString) {
            indentString = indentString.replace(/\t/g, this.getTabString());
            for (var row = startRow; row <= endRow; row++)
              this.doc.insertInLine({ row, column: 0 }, indentString);
          };
          this.outdentRows = function(range) {
            var rowRange = range.collapseRows();
            var deleteRange = new Range(0, 0, 0, 0);
            var size = this.getTabSize();
            for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
              var line = this.getLine(i);
              deleteRange.start.row = i;
              deleteRange.end.row = i;
              for (var j = 0; j < size; ++j)
                if (line.charAt(j) != " ")
                  break;
              if (j < size && line.charAt(j) == "	") {
                deleteRange.start.column = j;
                deleteRange.end.column = j + 1;
              } else {
                deleteRange.start.column = 0;
                deleteRange.end.column = j;
              }
              this.remove(deleteRange);
            }
          };
          this.$moveLines = function(firstRow, lastRow, dir) {
            firstRow = this.getRowFoldStart(firstRow);
            lastRow = this.getRowFoldEnd(lastRow);
            if (dir < 0) {
              var row = this.getRowFoldStart(firstRow + dir);
              if (row < 0)
                return 0;
              var diff = row - firstRow;
            } else if (dir > 0) {
              var row = this.getRowFoldEnd(lastRow + dir);
              if (row > this.doc.getLength() - 1)
                return 0;
              var diff = row - lastRow;
            } else {
              firstRow = this.$clipRowToDocument(firstRow);
              lastRow = this.$clipRowToDocument(lastRow);
              var diff = lastRow - firstRow + 1;
            }
            var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
            var folds = this.getFoldsInRange(range).map(function(x) {
              x = x.clone();
              x.start.row += diff;
              x.end.row += diff;
              return x;
            });
            var lines = dir == 0 ? this.doc.getLines(firstRow, lastRow) : this.doc.removeFullLines(firstRow, lastRow);
            this.doc.insertFullLines(firstRow + diff, lines);
            folds.length && this.addFolds(folds);
            return diff;
          };
          this.moveLinesUp = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, -1);
          };
          this.moveLinesDown = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, 1);
          };
          this.duplicateLines = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, 0);
          };
          this.$clipRowToDocument = function(row) {
            return Math.max(0, Math.min(row, this.doc.getLength() - 1));
          };
          this.$clipColumnToRow = function(row, column) {
            if (column < 0)
              return 0;
            return Math.min(this.doc.getLine(row).length, column);
          };
          this.$clipPositionToDocument = function(row, column) {
            column = Math.max(0, column);
            if (row < 0) {
              row = 0;
              column = 0;
            } else {
              var len = this.doc.getLength();
              if (row >= len) {
                row = len - 1;
                column = this.doc.getLine(len - 1).length;
              } else {
                column = Math.min(this.doc.getLine(row).length, column);
              }
            }
            return {
              row,
              column
            };
          };
          this.$clipRangeToDocument = function(range) {
            if (range.start.row < 0) {
              range.start.row = 0;
              range.start.column = 0;
            } else {
              range.start.column = this.$clipColumnToRow(
                range.start.row,
                range.start.column
              );
            }
            var len = this.doc.getLength() - 1;
            if (range.end.row > len) {
              range.end.row = len;
              range.end.column = this.doc.getLine(len).length;
            } else {
              range.end.column = this.$clipColumnToRow(
                range.end.row,
                range.end.column
              );
            }
            return range;
          };
          this.$wrapLimit = 80;
          this.$useWrapMode = false;
          this.$wrapLimitRange = {
            min: null,
            max: null
          };
          this.setUseWrapMode = function(useWrapMode) {
            if (useWrapMode != this.$useWrapMode) {
              this.$useWrapMode = useWrapMode;
              this.$modified = true;
              this.$resetRowCache(0);
              if (useWrapMode) {
                var len = this.getLength();
                this.$wrapData = Array(len);
                this.$updateWrapData(0, len - 1);
              }
              this._signal("changeWrapMode");
            }
          };
          this.getUseWrapMode = function() {
            return this.$useWrapMode;
          };
          this.setWrapLimitRange = function(min, max) {
            if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
              this.$wrapLimitRange = { min, max };
              this.$modified = true;
              this.$bidiHandler.markAsDirty();
              if (this.$useWrapMode)
                this._signal("changeWrapMode");
            }
          };
          this.adjustWrapLimit = function(desiredLimit, $printMargin) {
            var limits = this.$wrapLimitRange;
            if (limits.max < 0)
              limits = { min: $printMargin, max: $printMargin };
            var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
            if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
              this.$wrapLimit = wrapLimit;
              this.$modified = true;
              if (this.$useWrapMode) {
                this.$updateWrapData(0, this.getLength() - 1);
                this.$resetRowCache(0);
                this._signal("changeWrapLimit");
              }
              return true;
            }
            return false;
          };
          this.$constrainWrapLimit = function(wrapLimit, min, max) {
            if (min)
              wrapLimit = Math.max(min, wrapLimit);
            if (max)
              wrapLimit = Math.min(max, wrapLimit);
            return wrapLimit;
          };
          this.getWrapLimit = function() {
            return this.$wrapLimit;
          };
          this.setWrapLimit = function(limit) {
            this.setWrapLimitRange(limit, limit);
          };
          this.getWrapLimitRange = function() {
            return {
              min: this.$wrapLimitRange.min,
              max: this.$wrapLimitRange.max
            };
          };
          this.$updateInternalDataOnChange = function(delta) {
            var useWrapMode = this.$useWrapMode;
            var action = delta.action;
            var start = delta.start;
            var end = delta.end;
            var firstRow = start.row;
            var lastRow = end.row;
            var len = lastRow - firstRow;
            var removedFolds = null;
            this.$updating = true;
            if (len != 0) {
              if (action === "remove") {
                this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);
                var foldLines = this.$foldData;
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);
                var foldLine = this.getFoldLine(end.row);
                var idx = 0;
                if (foldLine) {
                  foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                  foldLine.shiftRow(-len);
                  var foldLineBefore = this.getFoldLine(firstRow);
                  if (foldLineBefore && foldLineBefore !== foldLine) {
                    foldLineBefore.merge(foldLine);
                    foldLine = foldLineBefore;
                  }
                  idx = foldLines.indexOf(foldLine) + 1;
                }
                for (idx; idx < foldLines.length; idx++) {
                  var foldLine = foldLines[idx];
                  if (foldLine.start.row >= end.row) {
                    foldLine.shiftRow(-len);
                  }
                }
                lastRow = firstRow;
              } else {
                var args = Array(len);
                args.unshift(firstRow, 0);
                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
                arr.splice.apply(arr, args);
                var foldLines = this.$foldData;
                var foldLine = this.getFoldLine(firstRow);
                var idx = 0;
                if (foldLine) {
                  var cmp = foldLine.range.compareInside(start.row, start.column);
                  if (cmp == 0) {
                    foldLine = foldLine.split(start.row, start.column);
                    if (foldLine) {
                      foldLine.shiftRow(len);
                      foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                    }
                  } else if (cmp == -1) {
                    foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                    foldLine.shiftRow(len);
                  }
                  idx = foldLines.indexOf(foldLine) + 1;
                }
                for (idx; idx < foldLines.length; idx++) {
                  var foldLine = foldLines[idx];
                  if (foldLine.start.row >= firstRow) {
                    foldLine.shiftRow(len);
                  }
                }
              }
            } else {
              len = Math.abs(delta.start.column - delta.end.column);
              if (action === "remove") {
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);
                len = -len;
              }
              var foldLine = this.getFoldLine(firstRow);
              if (foldLine) {
                foldLine.addRemoveChars(firstRow, start.column, len);
              }
            }
            if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
              console.error("doc.getLength() and $wrapData.length have to be the same!");
            }
            this.$updating = false;
            if (useWrapMode)
              this.$updateWrapData(firstRow, lastRow);
            else
              this.$updateRowLengthCache(firstRow, lastRow);
            return removedFolds;
          };
          this.$updateRowLengthCache = function(firstRow, lastRow, b) {
            this.$rowLengthCache[firstRow] = null;
            this.$rowLengthCache[lastRow] = null;
          };
          this.$updateWrapData = function(firstRow, lastRow) {
            var lines = this.doc.getAllLines();
            var tabSize = this.getTabSize();
            var wrapData = this.$wrapData;
            var wrapLimit = this.$wrapLimit;
            var tokens;
            var foldLine;
            var row = firstRow;
            lastRow = Math.min(lastRow, lines.length - 1);
            while (row <= lastRow) {
              foldLine = this.getFoldLine(row, foldLine);
              if (!foldLine) {
                tokens = this.$getDisplayTokens(lines[row]);
                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row++;
              } else {
                tokens = [];
                foldLine.walk(
                  function(placeholder, row2, column, lastColumn) {
                    var walkTokens;
                    if (placeholder != null) {
                      walkTokens = this.$getDisplayTokens(
                        placeholder,
                        tokens.length
                      );
                      walkTokens[0] = PLACEHOLDER_START;
                      for (var i = 1; i < walkTokens.length; i++) {
                        walkTokens[i] = PLACEHOLDER_BODY;
                      }
                    } else {
                      walkTokens = this.$getDisplayTokens(
                        lines[row2].substring(lastColumn, column),
                        tokens.length
                      );
                    }
                    tokens = tokens.concat(walkTokens);
                  }.bind(this),
                  foldLine.end.row,
                  lines[foldLine.end.row].length + 1
                );
                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row = foldLine.end.row + 1;
              }
            }
          };
          var CHAR = 1, CHAR_EXT = 2, PLACEHOLDER_START = 3, PLACEHOLDER_BODY = 4, PUNCTUATION = 9, SPACE = 10, TAB = 11, TAB_SPACE = 12;
          this.$computeWrapSplits = function(tokens, wrapLimit, tabSize) {
            if (tokens.length == 0) {
              return [];
            }
            var splits = [];
            var displayLength = tokens.length;
            var lastSplit = 0, lastDocSplit = 0;
            var isCode = this.$wrapAsCode;
            var indentedSoftWrap = this.$indentedSoftWrap;
            var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8) || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);
            function getWrapIndent() {
              var indentation = 0;
              if (maxIndent === 0)
                return indentation;
              if (indentedSoftWrap) {
                for (var i = 0; i < tokens.length; i++) {
                  var token = tokens[i];
                  if (token == SPACE)
                    indentation += 1;
                  else if (token == TAB)
                    indentation += tabSize;
                  else if (token == TAB_SPACE)
                    continue;
                  else
                    break;
                }
              }
              if (isCode && indentedSoftWrap !== false)
                indentation += tabSize;
              return Math.min(indentation, maxIndent);
            }
            function addSplit(screenPos) {
              var displayed = tokens.slice(lastSplit, screenPos);
              var len = displayed.length;
              displayed.join("").replace(/12/g, function() {
                len -= 1;
              }).replace(/2/g, function() {
                len -= 1;
              });
              if (!splits.length) {
                indent = getWrapIndent();
                splits.indent = indent;
              }
              lastDocSplit += len;
              splits.push(lastDocSplit);
              lastSplit = screenPos;
            }
            var indent = 0;
            while (displayLength - lastSplit > wrapLimit - indent) {
              var split = lastSplit + wrapLimit - indent;
              if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
                addSplit(split);
                continue;
              }
              if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
                for (split; split != lastSplit - 1; split--) {
                  if (tokens[split] == PLACEHOLDER_START) {
                    break;
                  }
                }
                if (split > lastSplit) {
                  addSplit(split);
                  continue;
                }
                split = lastSplit + wrapLimit;
                for (split; split < tokens.length; split++) {
                  if (tokens[split] != PLACEHOLDER_BODY) {
                    break;
                  }
                }
                if (split == tokens.length) {
                  break;
                }
                addSplit(split);
                continue;
              }
              var minSplit = Math.max(split - (wrapLimit - (wrapLimit >> 2)), lastSplit - 1);
              while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                split--;
              }
              if (isCode) {
                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                  split--;
                }
                while (split > minSplit && tokens[split] == PUNCTUATION) {
                  split--;
                }
              } else {
                while (split > minSplit && tokens[split] < SPACE) {
                  split--;
                }
              }
              if (split > minSplit) {
                addSplit(++split);
                continue;
              }
              split = lastSplit + wrapLimit;
              if (tokens[split] == CHAR_EXT)
                split--;
              addSplit(split - indent);
            }
            return splits;
          };
          this.$getDisplayTokens = function(str, offset) {
            var arr = [];
            var tabSize;
            offset = offset || 0;
            for (var i = 0; i < str.length; i++) {
              var c = str.charCodeAt(i);
              if (c == 9) {
                tabSize = this.getScreenTabSize(arr.length + offset);
                arr.push(TAB);
                for (var n = 1; n < tabSize; n++) {
                  arr.push(TAB_SPACE);
                }
              } else if (c == 32) {
                arr.push(SPACE);
              } else if (c > 39 && c < 48 || c > 57 && c < 64) {
                arr.push(PUNCTUATION);
              } else if (c >= 4352 && isFullWidth(c)) {
                arr.push(CHAR, CHAR_EXT);
              } else {
                arr.push(CHAR);
              }
            }
            return arr;
          };
          this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
            if (maxScreenColumn == 0)
              return [0, 0];
            if (maxScreenColumn == null)
              maxScreenColumn = Infinity;
            screenColumn = screenColumn || 0;
            var c, column;
            for (column = 0; column < str.length; column++) {
              c = str.charCodeAt(column);
              if (c == 9) {
                screenColumn += this.getScreenTabSize(screenColumn);
              } else if (c >= 4352 && isFullWidth(c)) {
                screenColumn += 2;
              } else {
                screenColumn += 1;
              }
              if (screenColumn > maxScreenColumn) {
                break;
              }
            }
            return [screenColumn, column];
          };
          this.lineWidgets = null;
          this.getRowLength = function(row) {
            if (this.lineWidgets)
              var h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
            else
              h = 0;
            if (!this.$useWrapMode || !this.$wrapData[row]) {
              return 1 + h;
            } else {
              return this.$wrapData[row].length + 1 + h;
            }
          };
          this.getRowLineCount = function(row) {
            if (!this.$useWrapMode || !this.$wrapData[row]) {
              return 1;
            } else {
              return this.$wrapData[row].length + 1;
            }
          };
          this.getRowWrapIndent = function(screenRow) {
            if (this.$useWrapMode) {
              var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
              var splits = this.$wrapData[pos.row];
              return splits.length && splits[0] < pos.column ? splits.indent : 0;
            } else {
              return 0;
            }
          };
          this.getScreenLastRowColumn = function(screenRow) {
            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
            return this.documentToScreenColumn(pos.row, pos.column);
          };
          this.getDocumentLastRowColumn = function(docRow, docColumn) {
            var screenRow = this.documentToScreenRow(docRow, docColumn);
            return this.getScreenLastRowColumn(screenRow);
          };
          this.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
            var screenRow = this.documentToScreenRow(docRow, docColumn);
            return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
          };
          this.getRowSplitData = function(row) {
            if (!this.$useWrapMode) {
              return void 0;
            } else {
              return this.$wrapData[row];
            }
          };
          this.getScreenTabSize = function(screenColumn) {
            return this.$tabSize - screenColumn % this.$tabSize;
          };
          this.screenToDocumentRow = function(screenRow, screenColumn) {
            return this.screenToDocumentPosition(screenRow, screenColumn).row;
          };
          this.screenToDocumentColumn = function(screenRow, screenColumn) {
            return this.screenToDocumentPosition(screenRow, screenColumn).column;
          };
          this.screenToDocumentPosition = function(screenRow, screenColumn, offsetX) {
            if (screenRow < 0)
              return { row: 0, column: 0 };
            var line;
            var docRow = 0;
            var docColumn = 0;
            var column;
            var row = 0;
            var rowLength = 0;
            var rowCache = this.$screenRowCache;
            var i = this.$getRowCacheIndex(rowCache, screenRow);
            var l = rowCache.length;
            if (l && i >= 0) {
              var row = rowCache[i];
              var docRow = this.$docRowCache[i];
              var doCache = screenRow > rowCache[l - 1];
            } else {
              var doCache = !l;
            }
            var maxRow = this.getLength() - 1;
            var foldLine = this.getNextFoldLine(docRow);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (row <= screenRow) {
              rowLength = this.getRowLength(docRow);
              if (row + rowLength > screenRow || docRow >= maxRow) {
                break;
              } else {
                row += rowLength;
                docRow++;
                if (docRow > foldStart) {
                  docRow = foldLine.end.row + 1;
                  foldLine = this.getNextFoldLine(docRow, foldLine);
                  foldStart = foldLine ? foldLine.start.row : Infinity;
                }
              }
              if (doCache) {
                this.$docRowCache.push(docRow);
                this.$screenRowCache.push(row);
              }
            }
            if (foldLine && foldLine.start.row <= docRow) {
              line = this.getFoldDisplayLine(foldLine);
              docRow = foldLine.start.row;
            } else if (row + rowLength <= screenRow || docRow > maxRow) {
              return {
                row: maxRow,
                column: this.getLine(maxRow).length
              };
            } else {
              line = this.getLine(docRow);
              foldLine = null;
            }
            var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);
            if (this.$useWrapMode) {
              var splits = this.$wrapData[docRow];
              if (splits) {
                column = splits[splitIndex];
                if (splitIndex > 0 && splits.length) {
                  wrapIndent = splits.indent;
                  docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                  line = line.substring(docColumn);
                }
              }
            }
            if (offsetX !== void 0 && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex))
              screenColumn = this.$bidiHandler.offsetToCol(offsetX);
            docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
            if (this.$useWrapMode && docColumn >= column)
              docColumn = column - 1;
            if (foldLine)
              return foldLine.idxToPosition(docColumn);
            return { row: docRow, column: docColumn };
          };
          this.documentToScreenPosition = function(docRow, docColumn) {
            if (typeof docColumn === "undefined")
              var pos = this.$clipPositionToDocument(docRow.row, docRow.column);
            else
              pos = this.$clipPositionToDocument(docRow, docColumn);
            docRow = pos.row;
            docColumn = pos.column;
            var screenRow = 0;
            var foldStartRow = null;
            var fold = null;
            fold = this.getFoldAt(docRow, docColumn, 1);
            if (fold) {
              docRow = fold.start.row;
              docColumn = fold.start.column;
            }
            var rowEnd, row = 0;
            var rowCache = this.$docRowCache;
            var i = this.$getRowCacheIndex(rowCache, docRow);
            var l = rowCache.length;
            if (l && i >= 0) {
              var row = rowCache[i];
              var screenRow = this.$screenRowCache[i];
              var doCache = docRow > rowCache[l - 1];
            } else {
              var doCache = !l;
            }
            var foldLine = this.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (row < docRow) {
              if (row >= foldStart) {
                rowEnd = foldLine.end.row + 1;
                if (rowEnd > docRow)
                  break;
                foldLine = this.getNextFoldLine(rowEnd, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              } else {
                rowEnd = row + 1;
              }
              screenRow += this.getRowLength(row);
              row = rowEnd;
              if (doCache) {
                this.$docRowCache.push(row);
                this.$screenRowCache.push(screenRow);
              }
            }
            var textLine = "";
            if (foldLine && row >= foldStart) {
              textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
              foldStartRow = foldLine.start.row;
            } else {
              textLine = this.getLine(docRow).substring(0, docColumn);
              foldStartRow = docRow;
            }
            var wrapIndent = 0;
            if (this.$useWrapMode) {
              var wrapRow = this.$wrapData[foldStartRow];
              if (wrapRow) {
                var screenRowOffset = 0;
                while (textLine.length >= wrapRow[screenRowOffset]) {
                  screenRow++;
                  screenRowOffset++;
                }
                textLine = textLine.substring(
                  wrapRow[screenRowOffset - 1] || 0,
                  textLine.length
                );
                wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
              }
            }
            return {
              row: screenRow,
              column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
            };
          };
          this.documentToScreenColumn = function(row, docColumn) {
            return this.documentToScreenPosition(row, docColumn).column;
          };
          this.documentToScreenRow = function(docRow, docColumn) {
            return this.documentToScreenPosition(docRow, docColumn).row;
          };
          this.getScreenLength = function() {
            var screenRows = 0;
            var fold = null;
            if (!this.$useWrapMode) {
              screenRows = this.getLength();
              var foldData = this.$foldData;
              for (var i = 0; i < foldData.length; i++) {
                fold = foldData[i];
                screenRows -= fold.end.row - fold.start.row;
              }
            } else {
              var lastRow = this.$wrapData.length;
              var row = 0, i = 0;
              var fold = this.$foldData[i++];
              var foldStart = fold ? fold.start.row : Infinity;
              while (row < lastRow) {
                var splits = this.$wrapData[row];
                screenRows += splits ? splits.length + 1 : 1;
                row++;
                if (row > foldStart) {
                  row = fold.end.row + 1;
                  fold = this.$foldData[i++];
                  foldStart = fold ? fold.start.row : Infinity;
                }
              }
            }
            if (this.lineWidgets)
              screenRows += this.$getWidgetScreenLength();
            return screenRows;
          };
          this.$setFontMetrics = function(fm) {
            if (!this.$enableVarChar)
              return;
            this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
              if (maxScreenColumn === 0)
                return [0, 0];
              if (!maxScreenColumn)
                maxScreenColumn = Infinity;
              screenColumn = screenColumn || 0;
              var c, column;
              for (column = 0; column < str.length; column++) {
                c = str.charAt(column);
                if (c === "	") {
                  screenColumn += this.getScreenTabSize(screenColumn);
                } else {
                  screenColumn += fm.getCharacterWidth(c);
                }
                if (screenColumn > maxScreenColumn) {
                  break;
                }
              }
              return [screenColumn, column];
            };
          };
          this.destroy = function() {
            if (this.bgTokenizer) {
              this.bgTokenizer.setDocument(null);
              this.bgTokenizer = null;
            }
            this.$stopWorker();
          };
          this.isFullWidth = isFullWidth;
          function isFullWidth(c) {
            if (c < 4352)
              return false;
            return c >= 4352 && c <= 4447 || c >= 4515 && c <= 4519 || c >= 4602 && c <= 4607 || c >= 9001 && c <= 9002 || c >= 11904 && c <= 11929 || c >= 11931 && c <= 12019 || c >= 12032 && c <= 12245 || c >= 12272 && c <= 12283 || c >= 12288 && c <= 12350 || c >= 12353 && c <= 12438 || c >= 12441 && c <= 12543 || c >= 12549 && c <= 12589 || c >= 12593 && c <= 12686 || c >= 12688 && c <= 12730 || c >= 12736 && c <= 12771 || c >= 12784 && c <= 12830 || c >= 12832 && c <= 12871 || c >= 12880 && c <= 13054 || c >= 13056 && c <= 19903 || c >= 19968 && c <= 42124 || c >= 42128 && c <= 42182 || c >= 43360 && c <= 43388 || c >= 44032 && c <= 55203 || c >= 55216 && c <= 55238 || c >= 55243 && c <= 55291 || c >= 63744 && c <= 64255 || c >= 65040 && c <= 65049 || c >= 65072 && c <= 65106 || c >= 65108 && c <= 65126 || c >= 65128 && c <= 65131 || c >= 65281 && c <= 65376 || c >= 65504 && c <= 65510;
          }
        }).call(EditSession.prototype);
        acequire("./edit_session/folding").Folding.call(EditSession.prototype);
        acequire("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);
        config.defineOptions(EditSession.prototype, "session", {
          wrap: {
            set: function(value) {
              if (!value || value == "off")
                value = false;
              else if (value == "free")
                value = true;
              else if (value == "printMargin")
                value = -1;
              else if (typeof value == "string")
                value = parseInt(value, 10) || false;
              if (this.$wrap == value)
                return;
              this.$wrap = value;
              if (!value) {
                this.setUseWrapMode(false);
              } else {
                var col = typeof value == "number" ? value : null;
                this.setWrapLimitRange(col, col);
                this.setUseWrapMode(true);
              }
            },
            get: function() {
              if (this.getUseWrapMode()) {
                if (this.$wrap == -1)
                  return "printMargin";
                if (!this.getWrapLimitRange().min)
                  return "free";
                return this.$wrap;
              }
              return "off";
            },
            handlesSet: true
          },
          wrapMethod: {
            set: function(val) {
              val = val == "auto" ? this.$mode.type != "text" : val != "text";
              if (val != this.$wrapAsCode) {
                this.$wrapAsCode = val;
                if (this.$useWrapMode) {
                  this.$modified = true;
                  this.$resetRowCache(0);
                  this.$updateWrapData(0, this.getLength() - 1);
                }
              }
            },
            initialValue: "auto"
          },
          indentedSoftWrap: { initialValue: true },
          firstLineNumber: {
            set: function() {
              this._signal("changeBreakpoint");
            },
            initialValue: 1
          },
          useWorker: {
            set: function(useWorker) {
              this.$useWorker = useWorker;
              this.$stopWorker();
              if (useWorker)
                this.$startWorker();
            },
            initialValue: true
          },
          useSoftTabs: { initialValue: true },
          tabSize: {
            set: function(tabSize) {
              if (isNaN(tabSize) || this.$tabSize === tabSize)
                return;
              this.$modified = true;
              this.$rowLengthCache = [];
              this.$tabSize = tabSize;
              this._signal("changeTabSize");
            },
            initialValue: 4,
            handlesSet: true
          },
          navigateWithinSoftTabs: { initialValue: false },
          overwrite: {
            set: function(val) {
              this._signal("changeOverwrite");
            },
            initialValue: false
          },
          newLineMode: {
            set: function(val) {
              this.doc.setNewLineMode(val);
            },
            get: function() {
              return this.doc.getNewLineMode();
            },
            handlesSet: true
          },
          mode: {
            set: function(val) {
              this.setMode(val);
            },
            get: function() {
              return this.$modeId;
            }
          }
        });
        exports2.EditSession = EditSession;
      });
      ace.define("ace/search", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function(acequire, exports2, module2) {
        "use strict";
        var lang = acequire("./lib/lang");
        var oop = acequire("./lib/oop");
        var Range = acequire("./range").Range;
        var Search = function() {
          this.$options = {};
        };
        (function() {
          this.set = function(options) {
            oop.mixin(this.$options, options);
            return this;
          };
          this.getOptions = function() {
            return lang.copyObject(this.$options);
          };
          this.setOptions = function(options) {
            this.$options = options;
          };
          this.find = function(session) {
            var options = this.$options;
            var iterator = this.$matchIterator(session, options);
            if (!iterator)
              return false;
            var firstRange = null;
            iterator.forEach(function(sr, sc, er, ec) {
              firstRange = new Range(sr, sc, er, ec);
              if (sc == ec && options.start && options.start.start && options.skipCurrent != false && firstRange.isEqual(options.start)) {
                firstRange = null;
                return false;
              }
              return true;
            });
            return firstRange;
          };
          this.findAll = function(session) {
            var options = this.$options;
            if (!options.needle)
              return [];
            this.$assembleRegExp(options);
            var range = options.range;
            var lines = range ? session.getLines(range.start.row, range.end.row) : session.doc.getAllLines();
            var ranges = [];
            var re = options.re;
            if (options.$isMultiLine) {
              var len = re.length;
              var maxRow = lines.length - len;
              var prevRange;
              outer:
                for (var row = re.offset || 0; row <= maxRow; row++) {
                  for (var j = 0; j < len; j++)
                    if (lines[row + j].search(re[j]) == -1)
                      continue outer;
                  var startLine = lines[row];
                  var line = lines[row + len - 1];
                  var startIndex = startLine.length - startLine.match(re[0])[0].length;
                  var endIndex = line.match(re[len - 1])[0].length;
                  if (prevRange && prevRange.end.row === row && prevRange.end.column > startIndex) {
                    continue;
                  }
                  ranges.push(prevRange = new Range(
                    row,
                    startIndex,
                    row + len - 1,
                    endIndex
                  ));
                  if (len > 2)
                    row = row + len - 2;
                }
            } else {
              for (var i = 0; i < lines.length; i++) {
                var matches = lang.getMatchOffsets(lines[i], re);
                for (var j = 0; j < matches.length; j++) {
                  var match = matches[j];
                  ranges.push(new Range(i, match.offset, i, match.offset + match.length));
                }
              }
            }
            if (range) {
              var startColumn = range.start.column;
              var endColumn = range.start.column;
              var i = 0, j = ranges.length - 1;
              while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row)
                i++;
              while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row)
                j--;
              ranges = ranges.slice(i, j + 1);
              for (i = 0, j = ranges.length; i < j; i++) {
                ranges[i].start.row += range.start.row;
                ranges[i].end.row += range.start.row;
              }
            }
            return ranges;
          };
          this.replace = function(input, replacement) {
            var options = this.$options;
            var re = this.$assembleRegExp(options);
            if (options.$isMultiLine)
              return replacement;
            if (!re)
              return;
            var match = re.exec(input);
            if (!match || match[0].length != input.length)
              return null;
            replacement = input.replace(re, replacement);
            if (options.preserveCase) {
              replacement = replacement.split("");
              for (var i = Math.min(input.length, input.length); i--; ) {
                var ch = input[i];
                if (ch && ch.toLowerCase() != ch)
                  replacement[i] = replacement[i].toUpperCase();
                else
                  replacement[i] = replacement[i].toLowerCase();
              }
              replacement = replacement.join("");
            }
            return replacement;
          };
          this.$assembleRegExp = function(options, $disableFakeMultiline) {
            if (options.needle instanceof RegExp)
              return options.re = options.needle;
            var needle = options.needle;
            if (!options.needle)
              return options.re = false;
            if (!options.regExp)
              needle = lang.escapeRegExp(needle);
            if (options.wholeWord)
              needle = addWordBoundary(needle, options);
            var modifier = options.caseSensitive ? "gm" : "gmi";
            options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
            if (options.$isMultiLine)
              return options.re = this.$assembleMultilineRegExp(needle, modifier);
            try {
              var re = new RegExp(needle, modifier);
            } catch (e) {
              re = false;
            }
            return options.re = re;
          };
          this.$assembleMultilineRegExp = function(needle, modifier) {
            var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
            var re = [];
            for (var i = 0; i < parts.length; i++)
              try {
                re.push(new RegExp(parts[i], modifier));
              } catch (e) {
                return false;
              }
            return re;
          };
          this.$matchIterator = function(session, options) {
            var re = this.$assembleRegExp(options);
            if (!re)
              return false;
            var backwards = options.backwards == true;
            var skipCurrent = options.skipCurrent != false;
            var range = options.range;
            var start = options.start;
            if (!start)
              start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
            if (start.start)
              start = start[skipCurrent != backwards ? "end" : "start"];
            var firstRow = range ? range.start.row : 0;
            var lastRow = range ? range.end.row : session.getLength() - 1;
            if (backwards) {
              var forEach = function(callback) {
                var row = start.row;
                if (forEachInLine(row, start.column, callback))
                  return;
                for (row--; row >= firstRow; row--)
                  if (forEachInLine(row, Number.MAX_VALUE, callback))
                    return;
                if (options.wrap == false)
                  return;
                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
                  if (forEachInLine(row, Number.MAX_VALUE, callback))
                    return;
              };
            } else {
              var forEach = function(callback) {
                var row = start.row;
                if (forEachInLine(row, start.column, callback))
                  return;
                for (row = row + 1; row <= lastRow; row++)
                  if (forEachInLine(row, 0, callback))
                    return;
                if (options.wrap == false)
                  return;
                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
                  if (forEachInLine(row, 0, callback))
                    return;
              };
            }
            if (options.$isMultiLine) {
              var len = re.length;
              var forEachInLine = function(row, offset, callback) {
                var startRow = backwards ? row - len + 1 : row;
                if (startRow < 0)
                  return;
                var line = session.getLine(startRow);
                var startIndex = line.search(re[0]);
                if (!backwards && startIndex < offset || startIndex === -1)
                  return;
                for (var i = 1; i < len; i++) {
                  line = session.getLine(startRow + i);
                  if (line.search(re[i]) == -1)
                    return;
                }
                var endIndex = line.match(re[len - 1])[0].length;
                if (backwards && endIndex > offset)
                  return;
                if (callback(startRow, startIndex, startRow + len - 1, endIndex))
                  return true;
              };
            } else if (backwards) {
              var forEachInLine = function(row, endIndex, callback) {
                var line = session.getLine(row);
                var matches = [];
                var m, last = 0;
                re.lastIndex = 0;
                while (m = re.exec(line)) {
                  var length = m[0].length;
                  last = m.index;
                  if (!length) {
                    if (last >= line.length)
                      break;
                    re.lastIndex = last += 1;
                  }
                  if (m.index + length > endIndex)
                    break;
                  matches.push(m.index, length);
                }
                for (var i = matches.length - 1; i >= 0; i -= 2) {
                  var column = matches[i - 1];
                  var length = matches[i];
                  if (callback(row, column, row, column + length))
                    return true;
                }
              };
            } else {
              var forEachInLine = function(row, startIndex, callback) {
                var line = session.getLine(row);
                var m;
                var last = startIndex;
                re.lastIndex = startIndex;
                while (m = re.exec(line)) {
                  var length = m[0].length;
                  last = m.index;
                  if (callback(row, last, row, last + length))
                    return true;
                  if (!length) {
                    re.lastIndex = last += 1;
                    if (last >= line.length)
                      return false;
                  }
                }
              };
            }
            return { forEach };
          };
        }).call(Search.prototype);
        function addWordBoundary(needle, options) {
          function wordBoundary(c) {
            if (/\w/.test(c) || options.regExp)
              return "\\b";
            return "";
          }
          return wordBoundary(needle[0]) + needle + wordBoundary(needle[needle.length - 1]);
        }
        exports2.Search = Search;
      });
      ace.define("ace/keyboard/hash_handler", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function(acequire, exports2, module2) {
        "use strict";
        var keyUtil = acequire("../lib/keys");
        var useragent = acequire("../lib/useragent");
        var KEY_MODS = keyUtil.KEY_MODS;
        function HashHandler(config, platform) {
          this.platform = platform || (useragent.isMac ? "mac" : "win");
          this.commands = {};
          this.commandKeyBinding = {};
          this.addCommands(config);
          this.$singleCommand = true;
        }
        function MultiHashHandler(config, platform) {
          HashHandler.call(this, config, platform);
          this.$singleCommand = false;
        }
        MultiHashHandler.prototype = HashHandler.prototype;
        (function() {
          this.addCommand = function(command) {
            if (this.commands[command.name])
              this.removeCommand(command);
            this.commands[command.name] = command;
            if (command.bindKey)
              this._buildKeyHash(command);
          };
          this.removeCommand = function(command, keepCommand) {
            var name = command && (typeof command === "string" ? command : command.name);
            command = this.commands[name];
            if (!keepCommand)
              delete this.commands[name];
            var ckb = this.commandKeyBinding;
            for (var keyId in ckb) {
              var cmdGroup = ckb[keyId];
              if (cmdGroup == command) {
                delete ckb[keyId];
              } else if (Array.isArray(cmdGroup)) {
                var i = cmdGroup.indexOf(command);
                if (i != -1) {
                  cmdGroup.splice(i, 1);
                  if (cmdGroup.length == 1)
                    ckb[keyId] = cmdGroup[0];
                }
              }
            }
          };
          this.bindKey = function(key, command, position) {
            if (typeof key == "object" && key) {
              if (position == void 0)
                position = key.position;
              key = key[this.platform];
            }
            if (!key)
              return;
            if (typeof command == "function")
              return this.addCommand({ exec: command, bindKey: key, name: command.name || key });
            key.split("|").forEach(function(keyPart) {
              var chain = "";
              if (keyPart.indexOf(" ") != -1) {
                var parts = keyPart.split(/\s+/);
                keyPart = parts.pop();
                parts.forEach(function(keyPart2) {
                  var binding2 = this.parseKeys(keyPart2);
                  var id2 = KEY_MODS[binding2.hashId] + binding2.key;
                  chain += (chain ? " " : "") + id2;
                  this._addCommandToBinding(chain, "chainKeys");
                }, this);
                chain += " ";
              }
              var binding = this.parseKeys(keyPart);
              var id = KEY_MODS[binding.hashId] + binding.key;
              this._addCommandToBinding(chain + id, command, position);
            }, this);
          };
          function getPosition(command) {
            return typeof command == "object" && command.bindKey && command.bindKey.position || (command.isDefault ? -100 : 0);
          }
          this._addCommandToBinding = function(keyId, command, position) {
            var ckb = this.commandKeyBinding, i;
            if (!command) {
              delete ckb[keyId];
            } else if (!ckb[keyId] || this.$singleCommand) {
              ckb[keyId] = command;
            } else {
              if (!Array.isArray(ckb[keyId])) {
                ckb[keyId] = [ckb[keyId]];
              } else if ((i = ckb[keyId].indexOf(command)) != -1) {
                ckb[keyId].splice(i, 1);
              }
              if (typeof position != "number") {
                position = getPosition(command);
              }
              var commands = ckb[keyId];
              for (i = 0; i < commands.length; i++) {
                var other = commands[i];
                var otherPos = getPosition(other);
                if (otherPos > position)
                  break;
              }
              commands.splice(i, 0, command);
            }
          };
          this.addCommands = function(commands) {
            commands && Object.keys(commands).forEach(function(name) {
              var command = commands[name];
              if (!command)
                return;
              if (typeof command === "string")
                return this.bindKey(command, name);
              if (typeof command === "function")
                command = { exec: command };
              if (typeof command !== "object")
                return;
              if (!command.name)
                command.name = name;
              this.addCommand(command);
            }, this);
          };
          this.removeCommands = function(commands) {
            Object.keys(commands).forEach(function(name) {
              this.removeCommand(commands[name]);
            }, this);
          };
          this.bindKeys = function(keyList) {
            Object.keys(keyList).forEach(function(key) {
              this.bindKey(key, keyList[key]);
            }, this);
          };
          this._buildKeyHash = function(command) {
            this.bindKey(command.bindKey, command);
          };
          this.parseKeys = function(keys) {
            var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x) {
              return x;
            });
            var key = parts.pop();
            var keyCode = keyUtil[key];
            if (keyUtil.FUNCTION_KEYS[keyCode])
              key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
            else if (!parts.length)
              return { key, hashId: -1 };
            else if (parts.length == 1 && parts[0] == "shift")
              return { key: key.toUpperCase(), hashId: -1 };
            var hashId = 0;
            for (var i = parts.length; i--; ) {
              var modifier = keyUtil.KEY_MODS[parts[i]];
              if (modifier == null) {
                if (typeof console != "undefined")
                  console.error("invalid modifier " + parts[i] + " in " + keys);
                return false;
              }
              hashId |= modifier;
            }
            return { key, hashId };
          };
          this.findKeyCommand = function findKeyCommand(hashId, keyString) {
            var key = KEY_MODS[hashId] + keyString;
            return this.commandKeyBinding[key];
          };
          this.handleKeyboard = function(data, hashId, keyString, keyCode) {
            if (keyCode < 0)
              return;
            var key = KEY_MODS[hashId] + keyString;
            var command = this.commandKeyBinding[key];
            if (data.$keyChain) {
              data.$keyChain += " " + key;
              command = this.commandKeyBinding[data.$keyChain] || command;
            }
            if (command) {
              if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
                data.$keyChain = data.$keyChain || key;
                return { command: "null" };
              }
            }
            if (data.$keyChain) {
              if ((!hashId || hashId == 4) && keyString.length == 1)
                data.$keyChain = data.$keyChain.slice(0, -key.length - 1);
              else if (hashId == -1 || keyCode > 0)
                data.$keyChain = "";
            }
            return { command };
          };
          this.getStatusText = function(editor, data) {
            return data.$keyChain || "";
          };
        }).call(HashHandler.prototype);
        exports2.HashHandler = HashHandler;
        exports2.MultiHashHandler = MultiHashHandler;
      });
      ace.define("ace/commands/command_manager", ["require", "exports", "module", "ace/lib/oop", "ace/keyboard/hash_handler", "ace/lib/event_emitter"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("../lib/oop");
        var MultiHashHandler = acequire("../keyboard/hash_handler").MultiHashHandler;
        var EventEmitter = acequire("../lib/event_emitter").EventEmitter;
        var CommandManager = function(platform, commands) {
          MultiHashHandler.call(this, commands, platform);
          this.byName = this.commands;
          this.setDefaultHandler("exec", function(e) {
            return e.command.exec(e.editor, e.args || {});
          });
        };
        oop.inherits(CommandManager, MultiHashHandler);
        (function() {
          oop.implement(this, EventEmitter);
          this.exec = function(command, editor, args) {
            if (Array.isArray(command)) {
              for (var i = command.length; i--; ) {
                if (this.exec(command[i], editor, args))
                  return true;
              }
              return false;
            }
            if (typeof command === "string")
              command = this.commands[command];
            if (!command)
              return false;
            if (editor && editor.$readOnly && !command.readOnly)
              return false;
            if (command.isAvailable && !command.isAvailable(editor))
              return false;
            var e = { editor, command, args };
            e.returnValue = this._emit("exec", e);
            this._signal("afterExec", e);
            return e.returnValue === false ? false : true;
          };
          this.toggleRecording = function(editor) {
            if (this.$inReplay)
              return;
            editor && editor._emit("changeStatus");
            if (this.recording) {
              this.macro.pop();
              this.removeEventListener("exec", this.$addCommandToMacro);
              if (!this.macro.length)
                this.macro = this.oldMacro;
              return this.recording = false;
            }
            if (!this.$addCommandToMacro) {
              this.$addCommandToMacro = function(e) {
                this.macro.push([e.command, e.args]);
              }.bind(this);
            }
            this.oldMacro = this.macro;
            this.macro = [];
            this.on("exec", this.$addCommandToMacro);
            return this.recording = true;
          };
          this.replay = function(editor) {
            if (this.$inReplay || !this.macro)
              return;
            if (this.recording)
              return this.toggleRecording(editor);
            try {
              this.$inReplay = true;
              this.macro.forEach(function(x) {
                if (typeof x == "string")
                  this.exec(x, editor);
                else
                  this.exec(x[0], editor, x[1]);
              }, this);
            } finally {
              this.$inReplay = false;
            }
          };
          this.trimMacro = function(m) {
            return m.map(function(x) {
              if (typeof x[0] != "string")
                x[0] = x[0].name;
              if (!x[1])
                x = x[0];
              return x;
            });
          };
        }).call(CommandManager.prototype);
        exports2.CommandManager = CommandManager;
      });
      ace.define("ace/commands/default_commands", ["require", "exports", "module", "ace/lib/lang", "ace/config", "ace/range"], function(acequire, exports2, module2) {
        "use strict";
        var lang = acequire("../lib/lang");
        var config = acequire("../config");
        var Range = acequire("../range").Range;
        function bindKey(win, mac) {
          return { win, mac };
        }
        exports2.commands = [
          {
            name: "showSettingsMenu",
            bindKey: bindKey("Ctrl-,", "Command-,"),
            exec: function(editor) {
              config.loadModule("ace/ext/settings_menu", function(module3) {
                module3.init(editor);
                editor.showSettingsMenu();
              });
            },
            readOnly: true
          },
          {
            name: "goToNextError",
            bindKey: bindKey("Alt-E", "F4"),
            exec: function(editor) {
              config.loadModule("ace/ext/error_marker", function(module3) {
                module3.showErrorMarker(editor, 1);
              });
            },
            scrollIntoView: "animate",
            readOnly: true
          },
          {
            name: "goToPreviousError",
            bindKey: bindKey("Alt-Shift-E", "Shift-F4"),
            exec: function(editor) {
              config.loadModule("ace/ext/error_marker", function(module3) {
                module3.showErrorMarker(editor, -1);
              });
            },
            scrollIntoView: "animate",
            readOnly: true
          },
          {
            name: "selectall",
            bindKey: bindKey("Ctrl-A", "Command-A"),
            exec: function(editor) {
              editor.selectAll();
            },
            readOnly: true
          },
          {
            name: "centerselection",
            bindKey: bindKey(null, "Ctrl-L"),
            exec: function(editor) {
              editor.centerSelection();
            },
            readOnly: true
          },
          {
            name: "gotoline",
            bindKey: bindKey("Ctrl-L", "Command-L"),
            exec: function(editor) {
              var line = parseInt(prompt("Enter line number:"), 10);
              if (!isNaN(line)) {
                editor.gotoLine(line);
              }
            },
            readOnly: true
          },
          {
            name: "fold",
            bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
            exec: function(editor) {
              editor.session.toggleFold(false);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "center",
            readOnly: true
          },
          {
            name: "unfold",
            bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
            exec: function(editor) {
              editor.session.toggleFold(true);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "center",
            readOnly: true
          },
          {
            name: "toggleFoldWidget",
            bindKey: bindKey("F2", "F2"),
            exec: function(editor) {
              editor.session.toggleFoldWidget();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "center",
            readOnly: true
          },
          {
            name: "toggleParentFoldWidget",
            bindKey: bindKey("Alt-F2", "Alt-F2"),
            exec: function(editor) {
              editor.session.toggleFoldWidget(true);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "center",
            readOnly: true
          },
          {
            name: "foldall",
            bindKey: bindKey(null, "Ctrl-Command-Option-0"),
            exec: function(editor) {
              editor.session.foldAll();
            },
            scrollIntoView: "center",
            readOnly: true
          },
          {
            name: "foldOther",
            bindKey: bindKey("Alt-0", "Command-Option-0"),
            exec: function(editor) {
              editor.session.foldAll();
              editor.session.unfold(editor.selection.getAllRanges());
            },
            scrollIntoView: "center",
            readOnly: true
          },
          {
            name: "unfoldall",
            bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
            exec: function(editor) {
              editor.session.unfold();
            },
            scrollIntoView: "center",
            readOnly: true
          },
          {
            name: "findnext",
            bindKey: bindKey("Ctrl-K", "Command-G"),
            exec: function(editor) {
              editor.findNext();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "center",
            readOnly: true
          },
          {
            name: "findprevious",
            bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
            exec: function(editor) {
              editor.findPrevious();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "center",
            readOnly: true
          },
          {
            name: "selectOrFindNext",
            bindKey: bindKey("Alt-K", "Ctrl-G"),
            exec: function(editor) {
              if (editor.selection.isEmpty())
                editor.selection.selectWord();
              else
                editor.findNext();
            },
            readOnly: true
          },
          {
            name: "selectOrFindPrevious",
            bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
            exec: function(editor) {
              if (editor.selection.isEmpty())
                editor.selection.selectWord();
              else
                editor.findPrevious();
            },
            readOnly: true
          },
          {
            name: "find",
            bindKey: bindKey("Ctrl-F", "Command-F"),
            exec: function(editor) {
              config.loadModule("ace/ext/searchbox", function(e) {
                e.Search(editor);
              });
            },
            readOnly: true
          },
          {
            name: "overwrite",
            bindKey: "Insert",
            exec: function(editor) {
              editor.toggleOverwrite();
            },
            readOnly: true
          },
          {
            name: "selecttostart",
            bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Home|Command-Shift-Up"),
            exec: function(editor) {
              editor.getSelection().selectFileStart();
            },
            multiSelectAction: "forEach",
            readOnly: true,
            scrollIntoView: "animate",
            aceCommandGroup: "fileJump"
          },
          {
            name: "gotostart",
            bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
            exec: function(editor) {
              editor.navigateFileStart();
            },
            multiSelectAction: "forEach",
            readOnly: true,
            scrollIntoView: "animate",
            aceCommandGroup: "fileJump"
          },
          {
            name: "selectup",
            bindKey: bindKey("Shift-Up", "Shift-Up|Ctrl-Shift-P"),
            exec: function(editor) {
              editor.getSelection().selectUp();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
          },
          {
            name: "golineup",
            bindKey: bindKey("Up", "Up|Ctrl-P"),
            exec: function(editor, args) {
              editor.navigateUp(args.times);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
          },
          {
            name: "selecttoend",
            bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-End|Command-Shift-Down"),
            exec: function(editor) {
              editor.getSelection().selectFileEnd();
            },
            multiSelectAction: "forEach",
            readOnly: true,
            scrollIntoView: "animate",
            aceCommandGroup: "fileJump"
          },
          {
            name: "gotoend",
            bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
            exec: function(editor) {
              editor.navigateFileEnd();
            },
            multiSelectAction: "forEach",
            readOnly: true,
            scrollIntoView: "animate",
            aceCommandGroup: "fileJump"
          },
          {
            name: "selectdown",
            bindKey: bindKey("Shift-Down", "Shift-Down|Ctrl-Shift-N"),
            exec: function(editor) {
              editor.getSelection().selectDown();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
          },
          {
            name: "golinedown",
            bindKey: bindKey("Down", "Down|Ctrl-N"),
            exec: function(editor, args) {
              editor.navigateDown(args.times);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
          },
          {
            name: "selectwordleft",
            bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
            exec: function(editor) {
              editor.getSelection().selectWordLeft();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
          },
          {
            name: "gotowordleft",
            bindKey: bindKey("Ctrl-Left", "Option-Left"),
            exec: function(editor) {
              editor.navigateWordLeft();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
          },
          {
            name: "selecttolinestart",
            bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left|Ctrl-Shift-A"),
            exec: function(editor) {
              editor.getSelection().selectLineStart();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
          },
          {
            name: "gotolinestart",
            bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
            exec: function(editor) {
              editor.navigateLineStart();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
          },
          {
            name: "selectleft",
            bindKey: bindKey("Shift-Left", "Shift-Left|Ctrl-Shift-B"),
            exec: function(editor) {
              editor.getSelection().selectLeft();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
          },
          {
            name: "gotoleft",
            bindKey: bindKey("Left", "Left|Ctrl-B"),
            exec: function(editor, args) {
              editor.navigateLeft(args.times);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
          },
          {
            name: "selectwordright",
            bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
            exec: function(editor) {
              editor.getSelection().selectWordRight();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
          },
          {
            name: "gotowordright",
            bindKey: bindKey("Ctrl-Right", "Option-Right"),
            exec: function(editor) {
              editor.navigateWordRight();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
          },
          {
            name: "selecttolineend",
            bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right|Shift-End|Ctrl-Shift-E"),
            exec: function(editor) {
              editor.getSelection().selectLineEnd();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
          },
          {
            name: "gotolineend",
            bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
            exec: function(editor) {
              editor.navigateLineEnd();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
          },
          {
            name: "selectright",
            bindKey: bindKey("Shift-Right", "Shift-Right"),
            exec: function(editor) {
              editor.getSelection().selectRight();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
          },
          {
            name: "gotoright",
            bindKey: bindKey("Right", "Right|Ctrl-F"),
            exec: function(editor, args) {
              editor.navigateRight(args.times);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
          },
          {
            name: "selectpagedown",
            bindKey: "Shift-PageDown",
            exec: function(editor) {
              editor.selectPageDown();
            },
            readOnly: true
          },
          {
            name: "pagedown",
            bindKey: bindKey(null, "Option-PageDown"),
            exec: function(editor) {
              editor.scrollPageDown();
            },
            readOnly: true
          },
          {
            name: "gotopagedown",
            bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
            exec: function(editor) {
              editor.gotoPageDown();
            },
            readOnly: true
          },
          {
            name: "selectpageup",
            bindKey: "Shift-PageUp",
            exec: function(editor) {
              editor.selectPageUp();
            },
            readOnly: true
          },
          {
            name: "pageup",
            bindKey: bindKey(null, "Option-PageUp"),
            exec: function(editor) {
              editor.scrollPageUp();
            },
            readOnly: true
          },
          {
            name: "gotopageup",
            bindKey: "PageUp",
            exec: function(editor) {
              editor.gotoPageUp();
            },
            readOnly: true
          },
          {
            name: "scrollup",
            bindKey: bindKey("Ctrl-Up", null),
            exec: function(e) {
              e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight);
            },
            readOnly: true
          },
          {
            name: "scrolldown",
            bindKey: bindKey("Ctrl-Down", null),
            exec: function(e) {
              e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight);
            },
            readOnly: true
          },
          {
            name: "selectlinestart",
            bindKey: "Shift-Home",
            exec: function(editor) {
              editor.getSelection().selectLineStart();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
          },
          {
            name: "selectlineend",
            bindKey: "Shift-End",
            exec: function(editor) {
              editor.getSelection().selectLineEnd();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
          },
          {
            name: "togglerecording",
            bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
            exec: function(editor) {
              editor.commands.toggleRecording(editor);
            },
            readOnly: true
          },
          {
            name: "replaymacro",
            bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
            exec: function(editor) {
              editor.commands.replay(editor);
            },
            readOnly: true
          },
          {
            name: "jumptomatching",
            bindKey: bindKey("Ctrl-P", "Ctrl-P"),
            exec: function(editor) {
              editor.jumpToMatching();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "animate",
            readOnly: true
          },
          {
            name: "selecttomatching",
            bindKey: bindKey("Ctrl-Shift-P", "Ctrl-Shift-P"),
            exec: function(editor) {
              editor.jumpToMatching(true);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "animate",
            readOnly: true
          },
          {
            name: "expandToMatching",
            bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
            exec: function(editor) {
              editor.jumpToMatching(true, true);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "animate",
            readOnly: true
          },
          {
            name: "passKeysToBrowser",
            bindKey: bindKey(null, null),
            exec: function() {
            },
            passEvent: true,
            readOnly: true
          },
          {
            name: "copy",
            exec: function(editor) {
            },
            readOnly: true
          },
          {
            name: "cut",
            exec: function(editor) {
              var range = editor.getSelectionRange();
              editor._emit("cut", range);
              if (!editor.selection.isEmpty()) {
                editor.session.remove(range);
                editor.clearSelection();
              }
            },
            scrollIntoView: "cursor",
            multiSelectAction: "forEach"
          },
          {
            name: "paste",
            exec: function(editor, args) {
              editor.$handlePaste(args);
            },
            scrollIntoView: "cursor"
          },
          {
            name: "removeline",
            bindKey: bindKey("Ctrl-D", "Command-D"),
            exec: function(editor) {
              editor.removeLines();
            },
            scrollIntoView: "cursor",
            multiSelectAction: "forEachLine"
          },
          {
            name: "duplicateSelection",
            bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
            exec: function(editor) {
              editor.duplicateSelection();
            },
            scrollIntoView: "cursor",
            multiSelectAction: "forEach"
          },
          {
            name: "sortlines",
            bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
            exec: function(editor) {
              editor.sortLines();
            },
            scrollIntoView: "selection",
            multiSelectAction: "forEachLine"
          },
          {
            name: "togglecomment",
            bindKey: bindKey("Ctrl-/", "Command-/"),
            exec: function(editor) {
              editor.toggleCommentLines();
            },
            multiSelectAction: "forEachLine",
            scrollIntoView: "selectionPart"
          },
          {
            name: "toggleBlockComment",
            bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
            exec: function(editor) {
              editor.toggleBlockComment();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "selectionPart"
          },
          {
            name: "modifyNumberUp",
            bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
            exec: function(editor) {
              editor.modifyNumber(1);
            },
            scrollIntoView: "cursor",
            multiSelectAction: "forEach"
          },
          {
            name: "modifyNumberDown",
            bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
            exec: function(editor) {
              editor.modifyNumber(-1);
            },
            scrollIntoView: "cursor",
            multiSelectAction: "forEach"
          },
          {
            name: "replace",
            bindKey: bindKey("Ctrl-H", "Command-Option-F"),
            exec: function(editor) {
              config.loadModule("ace/ext/searchbox", function(e) {
                e.Search(editor, true);
              });
            }
          },
          {
            name: "undo",
            bindKey: bindKey("Ctrl-Z", "Command-Z"),
            exec: function(editor) {
              editor.undo();
            }
          },
          {
            name: "redo",
            bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
            exec: function(editor) {
              editor.redo();
            }
          },
          {
            name: "copylinesup",
            bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
            exec: function(editor) {
              editor.copyLinesUp();
            },
            scrollIntoView: "cursor"
          },
          {
            name: "movelinesup",
            bindKey: bindKey("Alt-Up", "Option-Up"),
            exec: function(editor) {
              editor.moveLinesUp();
            },
            scrollIntoView: "cursor"
          },
          {
            name: "copylinesdown",
            bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
            exec: function(editor) {
              editor.copyLinesDown();
            },
            scrollIntoView: "cursor"
          },
          {
            name: "movelinesdown",
            bindKey: bindKey("Alt-Down", "Option-Down"),
            exec: function(editor) {
              editor.moveLinesDown();
            },
            scrollIntoView: "cursor"
          },
          {
            name: "del",
            bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
            exec: function(editor) {
              editor.remove("right");
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
          },
          {
            name: "backspace",
            bindKey: bindKey(
              "Shift-Backspace|Backspace",
              "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"
            ),
            exec: function(editor) {
              editor.remove("left");
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
          },
          {
            name: "cut_or_delete",
            bindKey: bindKey("Shift-Delete", null),
            exec: function(editor) {
              if (editor.selection.isEmpty()) {
                editor.remove("left");
              } else {
                return false;
              }
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
          },
          {
            name: "removetolinestart",
            bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
            exec: function(editor) {
              editor.removeToLineStart();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
          },
          {
            name: "removetolineend",
            bindKey: bindKey("Alt-Delete", "Ctrl-K|Command-Delete"),
            exec: function(editor) {
              editor.removeToLineEnd();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
          },
          {
            name: "removetolinestarthard",
            bindKey: bindKey("Ctrl-Shift-Backspace", null),
            exec: function(editor) {
              var range = editor.selection.getRange();
              range.start.column = 0;
              editor.session.remove(range);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
          },
          {
            name: "removetolineendhard",
            bindKey: bindKey("Ctrl-Shift-Delete", null),
            exec: function(editor) {
              var range = editor.selection.getRange();
              range.end.column = Number.MAX_VALUE;
              editor.session.remove(range);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
          },
          {
            name: "removewordleft",
            bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
            exec: function(editor) {
              editor.removeWordLeft();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
          },
          {
            name: "removewordright",
            bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
            exec: function(editor) {
              editor.removeWordRight();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
          },
          {
            name: "outdent",
            bindKey: bindKey("Shift-Tab", "Shift-Tab"),
            exec: function(editor) {
              editor.blockOutdent();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "selectionPart"
          },
          {
            name: "indent",
            bindKey: bindKey("Tab", "Tab"),
            exec: function(editor) {
              editor.indent();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "selectionPart"
          },
          {
            name: "blockoutdent",
            bindKey: bindKey("Ctrl-[", "Ctrl-["),
            exec: function(editor) {
              editor.blockOutdent();
            },
            multiSelectAction: "forEachLine",
            scrollIntoView: "selectionPart"
          },
          {
            name: "blockindent",
            bindKey: bindKey("Ctrl-]", "Ctrl-]"),
            exec: function(editor) {
              editor.blockIndent();
            },
            multiSelectAction: "forEachLine",
            scrollIntoView: "selectionPart"
          },
          {
            name: "insertstring",
            exec: function(editor, str) {
              editor.insert(str);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
          },
          {
            name: "inserttext",
            exec: function(editor, args) {
              editor.insert(lang.stringRepeat(args.text || "", args.times || 1));
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
          },
          {
            name: "splitline",
            bindKey: bindKey(null, "Ctrl-O"),
            exec: function(editor) {
              editor.splitLine();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
          },
          {
            name: "transposeletters",
            bindKey: bindKey("Alt-Shift-X", "Ctrl-T"),
            exec: function(editor) {
              editor.transposeLetters();
            },
            multiSelectAction: function(editor) {
              editor.transposeSelections(1);
            },
            scrollIntoView: "cursor"
          },
          {
            name: "touppercase",
            bindKey: bindKey("Ctrl-U", "Ctrl-U"),
            exec: function(editor) {
              editor.toUpperCase();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
          },
          {
            name: "tolowercase",
            bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
            exec: function(editor) {
              editor.toLowerCase();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
          },
          {
            name: "expandtoline",
            bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
            exec: function(editor) {
              var range = editor.selection.getRange();
              range.start.column = range.end.column = 0;
              range.end.row++;
              editor.selection.setRange(range, false);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
          },
          {
            name: "joinlines",
            bindKey: bindKey(null, null),
            exec: function(editor) {
              var isBackwards = editor.selection.isBackwards();
              var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
              var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
              var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
              var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
              var selectedCount = selectedText.replace(/\n\s*/, " ").length;
              var insertLine = editor.session.doc.getLine(selectionStart.row);
              for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {
                var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
                if (curLine.length !== 0) {
                  curLine = " " + curLine;
                }
                insertLine += curLine;
              }
              if (selectionEnd.row + 1 < editor.session.doc.getLength() - 1) {
                insertLine += editor.session.doc.getNewLineCharacter();
              }
              editor.clearSelection();
              editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);
              if (selectedCount > 0) {
                editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
                editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
              } else {
                firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? firstLineEndCol + 1 : firstLineEndCol;
                editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
              }
            },
            multiSelectAction: "forEach",
            readOnly: true
          },
          {
            name: "invertSelection",
            bindKey: bindKey(null, null),
            exec: function(editor) {
              var endRow = editor.session.doc.getLength() - 1;
              var endCol = editor.session.doc.getLine(endRow).length;
              var ranges = editor.selection.rangeList.ranges;
              var newRanges = [];
              if (ranges.length < 1) {
                ranges = [editor.selection.getRange()];
              }
              for (var i = 0; i < ranges.length; i++) {
                if (i == ranges.length - 1) {
                  if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
                    newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
                  }
                }
                if (i === 0) {
                  if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
                    newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
                  }
                } else {
                  newRanges.push(new Range(ranges[i - 1].end.row, ranges[i - 1].end.column, ranges[i].start.row, ranges[i].start.column));
                }
              }
              editor.exitMultiSelectMode();
              editor.clearSelection();
              for (var i = 0; i < newRanges.length; i++) {
                editor.selection.addRange(newRanges[i], false);
              }
            },
            readOnly: true,
            scrollIntoView: "none"
          }
        ];
      });
      ace.define("ace/editor", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/keyboard/textinput", "ace/mouse/mouse_handler", "ace/mouse/fold_handler", "ace/keyboard/keybinding", "ace/edit_session", "ace/search", "ace/range", "ace/lib/event_emitter", "ace/commands/command_manager", "ace/commands/default_commands", "ace/config", "ace/token_iterator"], function(acequire, exports2, module2) {
        "use strict";
        acequire("./lib/fixoldbrowsers");
        var oop = acequire("./lib/oop");
        var dom = acequire("./lib/dom");
        var lang = acequire("./lib/lang");
        var useragent = acequire("./lib/useragent");
        var TextInput = acequire("./keyboard/textinput").TextInput;
        var MouseHandler = acequire("./mouse/mouse_handler").MouseHandler;
        var FoldHandler = acequire("./mouse/fold_handler").FoldHandler;
        var KeyBinding = acequire("./keyboard/keybinding").KeyBinding;
        var EditSession = acequire("./edit_session").EditSession;
        var Search = acequire("./search").Search;
        var Range = acequire("./range").Range;
        var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
        var CommandManager = acequire("./commands/command_manager").CommandManager;
        var defaultCommands = acequire("./commands/default_commands").commands;
        var config = acequire("./config");
        var TokenIterator = acequire("./token_iterator").TokenIterator;
        var Editor = function(renderer, session) {
          var container = renderer.getContainerElement();
          this.container = container;
          this.renderer = renderer;
          this.id = "editor" + ++Editor.$uid;
          this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
          if (typeof document == "object") {
            this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
            this.renderer.textarea = this.textInput.getElement();
            this.$mouseHandler = new MouseHandler(this);
            new FoldHandler(this);
          }
          this.keyBinding = new KeyBinding(this);
          this.$blockScrolling = 0;
          this.$search = new Search().set({
            wrap: true
          });
          this.$historyTracker = this.$historyTracker.bind(this);
          this.commands.on("exec", this.$historyTracker);
          this.$initOperationListeners();
          this._$emitInputEvent = lang.delayedCall(function() {
            this._signal("input", {});
            if (this.session && this.session.bgTokenizer)
              this.session.bgTokenizer.scheduleStart();
          }.bind(this));
          this.on("change", function(_, _self) {
            _self._$emitInputEvent.schedule(31);
          });
          this.setSession(session || new EditSession(""));
          config.resetOptions(this);
          config._signal("editor", this);
        };
        Editor.$uid = 0;
        (function() {
          oop.implement(this, EventEmitter);
          this.$initOperationListeners = function() {
            function last(a) {
              return a[a.length - 1];
            }
            this.selections = [];
            this.commands.on("exec", this.startOperation.bind(this), true);
            this.commands.on("afterExec", this.endOperation.bind(this), true);
            this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this));
            this.on("change", function() {
              this.curOp || this.startOperation();
              this.curOp.docChanged = true;
            }.bind(this), true);
            this.on("changeSelection", function() {
              this.curOp || this.startOperation();
              this.curOp.selectionChanged = true;
            }.bind(this), true);
          };
          this.curOp = null;
          this.prevOp = {};
          this.startOperation = function(commadEvent) {
            if (this.curOp) {
              if (!commadEvent || this.curOp.command)
                return;
              this.prevOp = this.curOp;
            }
            if (!commadEvent) {
              this.previousCommand = null;
              commadEvent = {};
            }
            this.$opResetTimer.schedule();
            this.curOp = {
              command: commadEvent.command || {},
              args: commadEvent.args,
              scrollTop: this.renderer.scrollTop
            };
            if (this.curOp.command.name && this.curOp.command.scrollIntoView !== void 0)
              this.$blockScrolling++;
          };
          this.endOperation = function(e) {
            if (this.curOp) {
              if (e && e.returnValue === false)
                return this.curOp = null;
              this._signal("beforeEndOperation");
              var command = this.curOp.command;
              if (command.name && this.$blockScrolling > 0)
                this.$blockScrolling--;
              var scrollIntoView = command && command.scrollIntoView;
              if (scrollIntoView) {
                switch (scrollIntoView) {
                  case "center-animate":
                    scrollIntoView = "animate";
                  case "center":
                    this.renderer.scrollCursorIntoView(null, 0.5);
                    break;
                  case "animate":
                  case "cursor":
                    this.renderer.scrollCursorIntoView();
                    break;
                  case "selectionPart":
                    var range = this.selection.getRange();
                    var config2 = this.renderer.layerConfig;
                    if (range.start.row >= config2.lastRow || range.end.row <= config2.firstRow) {
                      this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                    }
                    break;
                  default:
                    break;
                }
                if (scrollIntoView == "animate")
                  this.renderer.animateScrolling(this.curOp.scrollTop);
              }
              this.prevOp = this.curOp;
              this.curOp = null;
            }
          };
          this.$mergeableCommands = ["backspace", "del", "insertstring"];
          this.$historyTracker = function(e) {
            if (!this.$mergeUndoDeltas)
              return;
            var prev = this.prevOp;
            var mergeableCommands = this.$mergeableCommands;
            var shouldMerge = prev.command && e.command.name == prev.command.name;
            if (e.command.name == "insertstring") {
              var text = e.args;
              if (this.mergeNextCommand === void 0)
                this.mergeNextCommand = true;
              shouldMerge = shouldMerge && this.mergeNextCommand && (!/\s/.test(text) || /\s/.test(prev.args));
              this.mergeNextCommand = true;
            } else {
              shouldMerge = shouldMerge && mergeableCommands.indexOf(e.command.name) !== -1;
            }
            if (this.$mergeUndoDeltas != "always" && Date.now() - this.sequenceStartTime > 2e3) {
              shouldMerge = false;
            }
            if (shouldMerge)
              this.session.mergeUndoDeltas = true;
            else if (mergeableCommands.indexOf(e.command.name) !== -1)
              this.sequenceStartTime = Date.now();
          };
          this.setKeyboardHandler = function(keyboardHandler, cb) {
            if (keyboardHandler && typeof keyboardHandler === "string") {
              this.$keybindingId = keyboardHandler;
              var _self = this;
              config.loadModule(["keybinding", keyboardHandler], function(module3) {
                if (_self.$keybindingId == keyboardHandler)
                  _self.keyBinding.setKeyboardHandler(module3 && module3.handler);
                cb && cb();
              });
            } else {
              this.$keybindingId = null;
              this.keyBinding.setKeyboardHandler(keyboardHandler);
              cb && cb();
            }
          };
          this.getKeyboardHandler = function() {
            return this.keyBinding.getKeyboardHandler();
          };
          this.setSession = function(session) {
            if (this.session == session)
              return;
            if (this.curOp)
              this.endOperation();
            this.curOp = {};
            var oldSession = this.session;
            if (oldSession) {
              this.session.off("change", this.$onDocumentChange);
              this.session.off("changeMode", this.$onChangeMode);
              this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
              this.session.off("changeTabSize", this.$onChangeTabSize);
              this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
              this.session.off("changeWrapMode", this.$onChangeWrapMode);
              this.session.off("changeFold", this.$onChangeFold);
              this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
              this.session.off("changeBackMarker", this.$onChangeBackMarker);
              this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
              this.session.off("changeAnnotation", this.$onChangeAnnotation);
              this.session.off("changeOverwrite", this.$onCursorChange);
              this.session.off("changeScrollTop", this.$onScrollTopChange);
              this.session.off("changeScrollLeft", this.$onScrollLeftChange);
              var selection = this.session.getSelection();
              selection.off("changeCursor", this.$onCursorChange);
              selection.off("changeSelection", this.$onSelectionChange);
            }
            this.session = session;
            if (session) {
              this.$onDocumentChange = this.onDocumentChange.bind(this);
              session.on("change", this.$onDocumentChange);
              this.renderer.setSession(session);
              this.$onChangeMode = this.onChangeMode.bind(this);
              session.on("changeMode", this.$onChangeMode);
              this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
              session.on("tokenizerUpdate", this.$onTokenizerUpdate);
              this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
              session.on("changeTabSize", this.$onChangeTabSize);
              this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
              session.on("changeWrapLimit", this.$onChangeWrapLimit);
              this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
              session.on("changeWrapMode", this.$onChangeWrapMode);
              this.$onChangeFold = this.onChangeFold.bind(this);
              session.on("changeFold", this.$onChangeFold);
              this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
              this.session.on("changeFrontMarker", this.$onChangeFrontMarker);
              this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
              this.session.on("changeBackMarker", this.$onChangeBackMarker);
              this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
              this.session.on("changeBreakpoint", this.$onChangeBreakpoint);
              this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
              this.session.on("changeAnnotation", this.$onChangeAnnotation);
              this.$onCursorChange = this.onCursorChange.bind(this);
              this.session.on("changeOverwrite", this.$onCursorChange);
              this.$onScrollTopChange = this.onScrollTopChange.bind(this);
              this.session.on("changeScrollTop", this.$onScrollTopChange);
              this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
              this.session.on("changeScrollLeft", this.$onScrollLeftChange);
              this.selection = session.getSelection();
              this.selection.on("changeCursor", this.$onCursorChange);
              this.$onSelectionChange = this.onSelectionChange.bind(this);
              this.selection.on("changeSelection", this.$onSelectionChange);
              this.onChangeMode();
              this.$blockScrolling += 1;
              this.onCursorChange();
              this.$blockScrolling -= 1;
              this.onScrollTopChange();
              this.onScrollLeftChange();
              this.onSelectionChange();
              this.onChangeFrontMarker();
              this.onChangeBackMarker();
              this.onChangeBreakpoint();
              this.onChangeAnnotation();
              this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
              this.renderer.updateFull();
            } else {
              this.selection = null;
              this.renderer.setSession(session);
            }
            this._signal("changeSession", {
              session,
              oldSession
            });
            this.curOp = null;
            oldSession && oldSession._signal("changeEditor", { oldEditor: this });
            session && session._signal("changeEditor", { editor: this });
            if (session && session.bgTokenizer)
              session.bgTokenizer.scheduleStart();
          };
          this.getSession = function() {
            return this.session;
          };
          this.setValue = function(val, cursorPos) {
            this.session.doc.setValue(val);
            if (!cursorPos)
              this.selectAll();
            else if (cursorPos == 1)
              this.navigateFileEnd();
            else if (cursorPos == -1)
              this.navigateFileStart();
            return val;
          };
          this.getValue = function() {
            return this.session.getValue();
          };
          this.getSelection = function() {
            return this.selection;
          };
          this.resize = function(force) {
            this.renderer.onResize(force);
          };
          this.setTheme = function(theme, cb) {
            this.renderer.setTheme(theme, cb);
          };
          this.getTheme = function() {
            return this.renderer.getTheme();
          };
          this.setStyle = function(style) {
            this.renderer.setStyle(style);
          };
          this.unsetStyle = function(style) {
            this.renderer.unsetStyle(style);
          };
          this.getFontSize = function() {
            return this.getOption("fontSize") || dom.computedStyle(this.container, "fontSize");
          };
          this.setFontSize = function(size) {
            this.setOption("fontSize", size);
          };
          this.$highlightBrackets = function() {
            if (this.session.$bracketHighlight) {
              this.session.removeMarker(this.session.$bracketHighlight);
              this.session.$bracketHighlight = null;
            }
            if (this.$highlightPending) {
              return;
            }
            var self2 = this;
            this.$highlightPending = true;
            setTimeout(function() {
              self2.$highlightPending = false;
              var session = self2.session;
              if (!session || !session.bgTokenizer)
                return;
              var pos = session.findMatchingBracket(self2.getCursorPosition());
              if (pos) {
                var range = new Range(pos.row, pos.column, pos.row, pos.column + 1);
              } else if (session.$mode.getMatching) {
                var range = session.$mode.getMatching(self2.session);
              }
              if (range)
                session.$bracketHighlight = session.addMarker(range, "ace_bracket", "text");
            }, 50);
          };
          this.$highlightTags = function() {
            if (this.$highlightTagPending)
              return;
            var self2 = this;
            this.$highlightTagPending = true;
            setTimeout(function() {
              self2.$highlightTagPending = false;
              var session = self2.session;
              if (!session || !session.bgTokenizer)
                return;
              var pos = self2.getCursorPosition();
              var iterator = new TokenIterator(self2.session, pos.row, pos.column);
              var token = iterator.getCurrentToken();
              if (!token || !/\b(?:tag-open|tag-name)/.test(token.type)) {
                session.removeMarker(session.$tagHighlight);
                session.$tagHighlight = null;
                return;
              }
              if (token.type.indexOf("tag-open") != -1) {
                token = iterator.stepForward();
                if (!token)
                  return;
              }
              var tag = token.value;
              var depth = 0;
              var prevToken = iterator.stepBackward();
              if (prevToken.value == "<") {
                do {
                  prevToken = token;
                  token = iterator.stepForward();
                  if (token && token.value === tag && token.type.indexOf("tag-name") !== -1) {
                    if (prevToken.value === "<") {
                      depth++;
                    } else if (prevToken.value === "</") {
                      depth--;
                    }
                  }
                } while (token && depth >= 0);
              } else {
                do {
                  token = prevToken;
                  prevToken = iterator.stepBackward();
                  if (token && token.value === tag && token.type.indexOf("tag-name") !== -1) {
                    if (prevToken.value === "<") {
                      depth++;
                    } else if (prevToken.value === "</") {
                      depth--;
                    }
                  }
                } while (prevToken && depth <= 0);
                iterator.stepForward();
              }
              if (!token) {
                session.removeMarker(session.$tagHighlight);
                session.$tagHighlight = null;
                return;
              }
              var row = iterator.getCurrentTokenRow();
              var column = iterator.getCurrentTokenColumn();
              var range = new Range(row, column, row, column + token.value.length);
              var sbm = session.$backMarkers[session.$tagHighlight];
              if (session.$tagHighlight && sbm != void 0 && range.compareRange(sbm.range) !== 0) {
                session.removeMarker(session.$tagHighlight);
                session.$tagHighlight = null;
              }
              if (range && !session.$tagHighlight)
                session.$tagHighlight = session.addMarker(range, "ace_bracket", "text");
            }, 50);
          };
          this.focus = function() {
            var _self = this;
            setTimeout(function() {
              _self.textInput.focus();
            });
            this.textInput.focus();
          };
          this.isFocused = function() {
            return this.textInput.isFocused();
          };
          this.blur = function() {
            this.textInput.blur();
          };
          this.onFocus = function(e) {
            if (this.$isFocused)
              return;
            this.$isFocused = true;
            this.renderer.showCursor();
            this.renderer.visualizeFocus();
            this._emit("focus", e);
          };
          this.onBlur = function(e) {
            if (!this.$isFocused)
              return;
            this.$isFocused = false;
            this.renderer.hideCursor();
            this.renderer.visualizeBlur();
            this._emit("blur", e);
          };
          this.$cursorChange = function() {
            this.renderer.updateCursor();
          };
          this.onDocumentChange = function(delta) {
            var wrap = this.session.$useWrapMode;
            var lastRow = delta.start.row == delta.end.row ? delta.end.row : Infinity;
            this.renderer.updateLines(delta.start.row, lastRow, wrap);
            this._signal("change", delta);
            this.$cursorChange();
            this.$updateHighlightActiveLine();
          };
          this.onTokenizerUpdate = function(e) {
            var rows = e.data;
            this.renderer.updateLines(rows.first, rows.last);
          };
          this.onScrollTopChange = function() {
            this.renderer.scrollToY(this.session.getScrollTop());
          };
          this.onScrollLeftChange = function() {
            this.renderer.scrollToX(this.session.getScrollLeft());
          };
          this.onCursorChange = function() {
            this.$cursorChange();
            if (!this.$blockScrolling) {
              config.warn(
                "Automatically scrolling cursor into view after selection change",
                "this will be disabled in the next version",
                "set editor.$blockScrolling = Infinity to disable this message"
              );
              this.renderer.scrollCursorIntoView();
            }
            this.$highlightBrackets();
            this.$highlightTags();
            this.$updateHighlightActiveLine();
            this._signal("changeSelection");
          };
          this.$updateHighlightActiveLine = function() {
            var session = this.getSession();
            var highlight;
            if (this.$highlightActiveLine) {
              if (this.$selectionStyle != "line" || !this.selection.isMultiLine())
                highlight = this.getCursorPosition();
              if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
                highlight = false;
            }
            if (session.$highlightLineMarker && !highlight) {
              session.removeMarker(session.$highlightLineMarker.id);
              session.$highlightLineMarker = null;
            } else if (!session.$highlightLineMarker && highlight) {
              var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
              range.id = session.addMarker(range, "ace_active-line", "screenLine");
              session.$highlightLineMarker = range;
            } else if (highlight) {
              session.$highlightLineMarker.start.row = highlight.row;
              session.$highlightLineMarker.end.row = highlight.row;
              session.$highlightLineMarker.start.column = highlight.column;
              session._signal("changeBackMarker");
            }
          };
          this.onSelectionChange = function(e) {
            var session = this.session;
            if (session.$selectionMarker) {
              session.removeMarker(session.$selectionMarker);
            }
            session.$selectionMarker = null;
            if (!this.selection.isEmpty()) {
              var range = this.selection.getRange();
              var style = this.getSelectionStyle();
              session.$selectionMarker = session.addMarker(range, "ace_selection", style);
            } else {
              this.$updateHighlightActiveLine();
            }
            var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
            this.session.highlight(re);
            this._signal("changeSelection");
          };
          this.$getSelectionHighLightRegexp = function() {
            var session = this.session;
            var selection = this.getSelectionRange();
            if (selection.isEmpty() || selection.isMultiLine())
              return;
            var startOuter = selection.start.column - 1;
            var endOuter = selection.end.column + 1;
            var line = session.getLine(selection.start.row);
            var lineCols = line.length;
            var needle = line.substring(
              Math.max(startOuter, 0),
              Math.min(endOuter, lineCols)
            );
            if (startOuter >= 0 && /^[\w\d]/.test(needle) || endOuter <= lineCols && /[\w\d]$/.test(needle))
              return;
            needle = line.substring(selection.start.column, selection.end.column);
            if (!/^[\w\d]+$/.test(needle))
              return;
            var re = this.$search.$assembleRegExp({
              wholeWord: true,
              caseSensitive: true,
              needle
            });
            return re;
          };
          this.onChangeFrontMarker = function() {
            this.renderer.updateFrontMarkers();
          };
          this.onChangeBackMarker = function() {
            this.renderer.updateBackMarkers();
          };
          this.onChangeBreakpoint = function() {
            this.renderer.updateBreakpoints();
          };
          this.onChangeAnnotation = function() {
            this.renderer.setAnnotations(this.session.getAnnotations());
          };
          this.onChangeMode = function(e) {
            this.renderer.updateText();
            this._emit("changeMode", e);
          };
          this.onChangeWrapLimit = function() {
            this.renderer.updateFull();
          };
          this.onChangeWrapMode = function() {
            this.renderer.onResize(true);
          };
          this.onChangeFold = function() {
            this.$updateHighlightActiveLine();
            this.renderer.updateFull();
          };
          this.getSelectedText = function() {
            return this.session.getTextRange(this.getSelectionRange());
          };
          this.getCopyText = function() {
            var text = this.getSelectedText();
            this._signal("copy", text);
            return text;
          };
          this.onCopy = function() {
            this.commands.exec("copy", this);
          };
          this.onCut = function() {
            this.commands.exec("cut", this);
          };
          this.onPaste = function(text, event) {
            var e = { text, event };
            this.commands.exec("paste", this, e);
          };
          this.$handlePaste = function(e) {
            if (typeof e == "string")
              e = { text: e };
            this._signal("paste", e);
            var text = e.text;
            if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
              this.insert(text);
            } else {
              var lines = text.split(/\r\n|\r|\n/);
              var ranges = this.selection.rangeList.ranges;
              if (lines.length > ranges.length || lines.length < 2 || !lines[1])
                return this.commands.exec("insertstring", this, text);
              for (var i = ranges.length; i--; ) {
                var range = ranges[i];
                if (!range.isEmpty())
                  this.session.remove(range);
                this.session.insert(range.start, lines[i]);
              }
            }
          };
          this.execCommand = function(command, args) {
            return this.commands.exec(command, this, args);
          };
          this.insert = function(text, pasted) {
            var session = this.session;
            var mode = session.getMode();
            var cursor = this.getCursorPosition();
            if (this.getBehavioursEnabled() && !pasted) {
              var transform = mode.transformAction(session.getState(cursor.row), "insertion", this, session, text);
              if (transform) {
                if (text !== transform.text) {
                  this.session.mergeUndoDeltas = false;
                  this.$mergeNextCommand = false;
                }
                text = transform.text;
              }
            }
            if (text == "	")
              text = this.session.getTabString();
            if (!this.selection.isEmpty()) {
              var range = this.getSelectionRange();
              cursor = this.session.remove(range);
              this.clearSelection();
            } else if (this.session.getOverwrite() && text.indexOf("\n") == -1) {
              var range = new Range.fromPoints(cursor, cursor);
              range.end.column += text.length;
              this.session.remove(range);
            }
            if (text == "\n" || text == "\r\n") {
              var line = session.getLine(cursor.row);
              if (cursor.column > line.search(/\S|$/)) {
                var d = line.substr(cursor.column).search(/\S|$/);
                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
              }
            }
            this.clearSelection();
            var start = cursor.column;
            var lineState = session.getState(cursor.row);
            var line = session.getLine(cursor.row);
            var shouldOutdent = mode.checkOutdent(lineState, line, text);
            var end = session.insert(cursor, text);
            if (transform && transform.selection) {
              if (transform.selection.length == 2) {
                this.selection.setSelectionRange(
                  new Range(
                    cursor.row,
                    start + transform.selection[0],
                    cursor.row,
                    start + transform.selection[1]
                  )
                );
              } else {
                this.selection.setSelectionRange(
                  new Range(
                    cursor.row + transform.selection[0],
                    transform.selection[1],
                    cursor.row + transform.selection[2],
                    transform.selection[3]
                  )
                );
              }
            }
            if (session.getDocument().isNewLine(text)) {
              var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());
              session.insert({ row: cursor.row + 1, column: 0 }, lineIndent);
            }
            if (shouldOutdent)
              mode.autoOutdent(lineState, session, cursor.row);
          };
          this.onTextInput = function(text) {
            this.keyBinding.onTextInput(text);
          };
          this.onCommandKey = function(e, hashId, keyCode) {
            this.keyBinding.onCommandKey(e, hashId, keyCode);
          };
          this.setOverwrite = function(overwrite) {
            this.session.setOverwrite(overwrite);
          };
          this.getOverwrite = function() {
            return this.session.getOverwrite();
          };
          this.toggleOverwrite = function() {
            this.session.toggleOverwrite();
          };
          this.setScrollSpeed = function(speed) {
            this.setOption("scrollSpeed", speed);
          };
          this.getScrollSpeed = function() {
            return this.getOption("scrollSpeed");
          };
          this.setDragDelay = function(dragDelay) {
            this.setOption("dragDelay", dragDelay);
          };
          this.getDragDelay = function() {
            return this.getOption("dragDelay");
          };
          this.setSelectionStyle = function(val) {
            this.setOption("selectionStyle", val);
          };
          this.getSelectionStyle = function() {
            return this.getOption("selectionStyle");
          };
          this.setHighlightActiveLine = function(shouldHighlight) {
            this.setOption("highlightActiveLine", shouldHighlight);
          };
          this.getHighlightActiveLine = function() {
            return this.getOption("highlightActiveLine");
          };
          this.setHighlightGutterLine = function(shouldHighlight) {
            this.setOption("highlightGutterLine", shouldHighlight);
          };
          this.getHighlightGutterLine = function() {
            return this.getOption("highlightGutterLine");
          };
          this.setHighlightSelectedWord = function(shouldHighlight) {
            this.setOption("highlightSelectedWord", shouldHighlight);
          };
          this.getHighlightSelectedWord = function() {
            return this.$highlightSelectedWord;
          };
          this.setAnimatedScroll = function(shouldAnimate) {
            this.renderer.setAnimatedScroll(shouldAnimate);
          };
          this.getAnimatedScroll = function() {
            return this.renderer.getAnimatedScroll();
          };
          this.setShowInvisibles = function(showInvisibles) {
            this.renderer.setShowInvisibles(showInvisibles);
          };
          this.getShowInvisibles = function() {
            return this.renderer.getShowInvisibles();
          };
          this.setDisplayIndentGuides = function(display) {
            this.renderer.setDisplayIndentGuides(display);
          };
          this.getDisplayIndentGuides = function() {
            return this.renderer.getDisplayIndentGuides();
          };
          this.setShowPrintMargin = function(showPrintMargin) {
            this.renderer.setShowPrintMargin(showPrintMargin);
          };
          this.getShowPrintMargin = function() {
            return this.renderer.getShowPrintMargin();
          };
          this.setPrintMarginColumn = function(showPrintMargin) {
            this.renderer.setPrintMarginColumn(showPrintMargin);
          };
          this.getPrintMarginColumn = function() {
            return this.renderer.getPrintMarginColumn();
          };
          this.setReadOnly = function(readOnly) {
            this.setOption("readOnly", readOnly);
          };
          this.getReadOnly = function() {
            return this.getOption("readOnly");
          };
          this.setBehavioursEnabled = function(enabled) {
            this.setOption("behavioursEnabled", enabled);
          };
          this.getBehavioursEnabled = function() {
            return this.getOption("behavioursEnabled");
          };
          this.setWrapBehavioursEnabled = function(enabled) {
            this.setOption("wrapBehavioursEnabled", enabled);
          };
          this.getWrapBehavioursEnabled = function() {
            return this.getOption("wrapBehavioursEnabled");
          };
          this.setShowFoldWidgets = function(show) {
            this.setOption("showFoldWidgets", show);
          };
          this.getShowFoldWidgets = function() {
            return this.getOption("showFoldWidgets");
          };
          this.setFadeFoldWidgets = function(fade) {
            this.setOption("fadeFoldWidgets", fade);
          };
          this.getFadeFoldWidgets = function() {
            return this.getOption("fadeFoldWidgets");
          };
          this.remove = function(dir) {
            if (this.selection.isEmpty()) {
              if (dir == "left")
                this.selection.selectLeft();
              else
                this.selection.selectRight();
            }
            var range = this.getSelectionRange();
            if (this.getBehavioursEnabled()) {
              var session = this.session;
              var state = session.getState(range.start.row);
              var new_range = session.getMode().transformAction(state, "deletion", this, session, range);
              if (range.end.column === 0) {
                var text = session.getTextRange(range);
                if (text[text.length - 1] == "\n") {
                  var line = session.getLine(range.end.row);
                  if (/^\s+$/.test(line)) {
                    range.end.column = line.length;
                  }
                }
              }
              if (new_range)
                range = new_range;
            }
            this.session.remove(range);
            this.clearSelection();
          };
          this.removeWordRight = function() {
            if (this.selection.isEmpty())
              this.selection.selectWordRight();
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
          };
          this.removeWordLeft = function() {
            if (this.selection.isEmpty())
              this.selection.selectWordLeft();
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
          };
          this.removeToLineStart = function() {
            if (this.selection.isEmpty())
              this.selection.selectLineStart();
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
          };
          this.removeToLineEnd = function() {
            if (this.selection.isEmpty())
              this.selection.selectLineEnd();
            var range = this.getSelectionRange();
            if (range.start.column == range.end.column && range.start.row == range.end.row) {
              range.end.column = 0;
              range.end.row++;
            }
            this.session.remove(range);
            this.clearSelection();
          };
          this.splitLine = function() {
            if (!this.selection.isEmpty()) {
              this.session.remove(this.getSelectionRange());
              this.clearSelection();
            }
            var cursor = this.getCursorPosition();
            this.insert("\n");
            this.moveCursorToPosition(cursor);
          };
          this.transposeLetters = function() {
            if (!this.selection.isEmpty()) {
              return;
            }
            var cursor = this.getCursorPosition();
            var column = cursor.column;
            if (column === 0)
              return;
            var line = this.session.getLine(cursor.row);
            var swap, range;
            if (column < line.length) {
              swap = line.charAt(column) + line.charAt(column - 1);
              range = new Range(cursor.row, column - 1, cursor.row, column + 1);
            } else {
              swap = line.charAt(column - 1) + line.charAt(column - 2);
              range = new Range(cursor.row, column - 2, cursor.row, column);
            }
            this.session.replace(range, swap);
            this.session.selection.moveToPosition(range.end);
          };
          this.toLowerCase = function() {
            var originalRange = this.getSelectionRange();
            if (this.selection.isEmpty()) {
              this.selection.selectWord();
            }
            var range = this.getSelectionRange();
            var text = this.session.getTextRange(range);
            this.session.replace(range, text.toLowerCase());
            this.selection.setSelectionRange(originalRange);
          };
          this.toUpperCase = function() {
            var originalRange = this.getSelectionRange();
            if (this.selection.isEmpty()) {
              this.selection.selectWord();
            }
            var range = this.getSelectionRange();
            var text = this.session.getTextRange(range);
            this.session.replace(range, text.toUpperCase());
            this.selection.setSelectionRange(originalRange);
          };
          this.indent = function() {
            var session = this.session;
            var range = this.getSelectionRange();
            if (range.start.row < range.end.row) {
              var rows = this.$getSelectedRows();
              session.indentRows(rows.first, rows.last, "	");
              return;
            } else if (range.start.column < range.end.column) {
              var text = session.getTextRange(range);
              if (!/^\s+$/.test(text)) {
                var rows = this.$getSelectedRows();
                session.indentRows(rows.first, rows.last, "	");
                return;
              }
            }
            var line = session.getLine(range.start.row);
            var position = range.start;
            var size = session.getTabSize();
            var column = session.documentToScreenColumn(position.row, position.column);
            if (this.session.getUseSoftTabs()) {
              var count = size - column % size;
              var indentString = lang.stringRepeat(" ", count);
            } else {
              var count = column % size;
              while (line[range.start.column - 1] == " " && count) {
                range.start.column--;
                count--;
              }
              this.selection.setSelectionRange(range);
              indentString = "	";
            }
            return this.insert(indentString);
          };
          this.blockIndent = function() {
            var rows = this.$getSelectedRows();
            this.session.indentRows(rows.first, rows.last, "	");
          };
          this.blockOutdent = function() {
            var selection = this.session.getSelection();
            this.session.outdentRows(selection.getRange());
          };
          this.sortLines = function() {
            var rows = this.$getSelectedRows();
            var session = this.session;
            var lines = [];
            for (var i = rows.first; i <= rows.last; i++)
              lines.push(session.getLine(i));
            lines.sort(function(a, b) {
              if (a.toLowerCase() < b.toLowerCase())
                return -1;
              if (a.toLowerCase() > b.toLowerCase())
                return 1;
              return 0;
            });
            var deleteRange = new Range(0, 0, 0, 0);
            for (var i = rows.first; i <= rows.last; i++) {
              var line = session.getLine(i);
              deleteRange.start.row = i;
              deleteRange.end.row = i;
              deleteRange.end.column = line.length;
              session.replace(deleteRange, lines[i - rows.first]);
            }
          };
          this.toggleCommentLines = function() {
            var state = this.session.getState(this.getCursorPosition().row);
            var rows = this.$getSelectedRows();
            this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
          };
          this.toggleBlockComment = function() {
            var cursor = this.getCursorPosition();
            var state = this.session.getState(cursor.row);
            var range = this.getSelectionRange();
            this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
          };
          this.getNumberAt = function(row, column) {
            var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
            _numberRx.lastIndex = 0;
            var s = this.session.getLine(row);
            while (_numberRx.lastIndex < column) {
              var m = _numberRx.exec(s);
              if (m.index <= column && m.index + m[0].length >= column) {
                var number = {
                  value: m[0],
                  start: m.index,
                  end: m.index + m[0].length
                };
                return number;
              }
            }
            return null;
          };
          this.modifyNumber = function(amount) {
            var row = this.selection.getCursor().row;
            var column = this.selection.getCursor().column;
            var charRange = new Range(row, column - 1, row, column);
            var c = this.session.getTextRange(charRange);
            if (!isNaN(parseFloat(c)) && isFinite(c)) {
              var nr = this.getNumberAt(row, column);
              if (nr) {
                var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
                var decimals = nr.start + nr.value.length - fp;
                var t = parseFloat(nr.value);
                t *= Math.pow(10, decimals);
                if (fp !== nr.end && column < fp) {
                  amount *= Math.pow(10, nr.end - column - 1);
                } else {
                  amount *= Math.pow(10, nr.end - column);
                }
                t += amount;
                t /= Math.pow(10, decimals);
                var nnr = t.toFixed(decimals);
                var replaceRange = new Range(row, nr.start, row, nr.end);
                this.session.replace(replaceRange, nnr);
                this.moveCursorTo(row, Math.max(nr.start + 1, column + nnr.length - nr.value.length));
              }
            }
          };
          this.removeLines = function() {
            var rows = this.$getSelectedRows();
            this.session.removeFullLines(rows.first, rows.last);
            this.clearSelection();
          };
          this.duplicateSelection = function() {
            var sel = this.selection;
            var doc = this.session;
            var range = sel.getRange();
            var reverse = sel.isBackwards();
            if (range.isEmpty()) {
              var row = range.start.row;
              doc.duplicateLines(row, row);
            } else {
              var point = reverse ? range.start : range.end;
              var endPoint = doc.insert(point, doc.getTextRange(range), false);
              range.start = point;
              range.end = endPoint;
              sel.setSelectionRange(range, reverse);
            }
          };
          this.moveLinesDown = function() {
            this.$moveLines(1, false);
          };
          this.moveLinesUp = function() {
            this.$moveLines(-1, false);
          };
          this.moveText = function(range, toPosition, copy) {
            return this.session.moveText(range, toPosition, copy);
          };
          this.copyLinesUp = function() {
            this.$moveLines(-1, true);
          };
          this.copyLinesDown = function() {
            this.$moveLines(1, true);
          };
          this.$moveLines = function(dir, copy) {
            var rows, moved;
            var selection = this.selection;
            if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
              var range = selection.toOrientedRange();
              rows = this.$getSelectedRows(range);
              moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
              if (copy && dir == -1)
                moved = 0;
              range.moveBy(moved, 0);
              selection.fromOrientedRange(range);
            } else {
              var ranges = selection.rangeList.ranges;
              selection.rangeList.detach(this.session);
              this.inVirtualSelectionMode = true;
              var diff = 0;
              var totalDiff = 0;
              var l = ranges.length;
              for (var i = 0; i < l; i++) {
                var rangeIndex = i;
                ranges[i].moveBy(diff, 0);
                rows = this.$getSelectedRows(ranges[i]);
                var first = rows.first;
                var last = rows.last;
                while (++i < l) {
                  if (totalDiff)
                    ranges[i].moveBy(totalDiff, 0);
                  var subRows = this.$getSelectedRows(ranges[i]);
                  if (copy && subRows.first != last)
                    break;
                  else if (!copy && subRows.first > last + 1)
                    break;
                  last = subRows.last;
                }
                i--;
                diff = this.session.$moveLines(first, last, copy ? 0 : dir);
                if (copy && dir == -1)
                  rangeIndex = i + 1;
                while (rangeIndex <= i) {
                  ranges[rangeIndex].moveBy(diff, 0);
                  rangeIndex++;
                }
                if (!copy)
                  diff = 0;
                totalDiff += diff;
              }
              selection.fromOrientedRange(selection.ranges[0]);
              selection.rangeList.attach(this.session);
              this.inVirtualSelectionMode = false;
            }
          };
          this.$getSelectedRows = function(range) {
            range = (range || this.getSelectionRange()).collapseRows();
            return {
              first: this.session.getRowFoldStart(range.start.row),
              last: this.session.getRowFoldEnd(range.end.row)
            };
          };
          this.onCompositionStart = function(text) {
            this.renderer.showComposition(this.getCursorPosition());
          };
          this.onCompositionUpdate = function(text) {
            this.renderer.setCompositionText(text);
          };
          this.onCompositionEnd = function() {
            this.renderer.hideComposition();
          };
          this.getFirstVisibleRow = function() {
            return this.renderer.getFirstVisibleRow();
          };
          this.getLastVisibleRow = function() {
            return this.renderer.getLastVisibleRow();
          };
          this.isRowVisible = function(row) {
            return row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow();
          };
          this.isRowFullyVisible = function(row) {
            return row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow();
          };
          this.$getVisibleRowCount = function() {
            return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
          };
          this.$moveByPage = function(dir, select) {
            var renderer = this.renderer;
            var config2 = this.renderer.layerConfig;
            var rows = dir * Math.floor(config2.height / config2.lineHeight);
            this.$blockScrolling++;
            if (select === true) {
              this.selection.$moveSelection(function() {
                this.moveCursorBy(rows, 0);
              });
            } else if (select === false) {
              this.selection.moveCursorBy(rows, 0);
              this.selection.clearSelection();
            }
            this.$blockScrolling--;
            var scrollTop = renderer.scrollTop;
            renderer.scrollBy(0, rows * config2.lineHeight);
            if (select != null)
              renderer.scrollCursorIntoView(null, 0.5);
            renderer.animateScrolling(scrollTop);
          };
          this.selectPageDown = function() {
            this.$moveByPage(1, true);
          };
          this.selectPageUp = function() {
            this.$moveByPage(-1, true);
          };
          this.gotoPageDown = function() {
            this.$moveByPage(1, false);
          };
          this.gotoPageUp = function() {
            this.$moveByPage(-1, false);
          };
          this.scrollPageDown = function() {
            this.$moveByPage(1);
          };
          this.scrollPageUp = function() {
            this.$moveByPage(-1);
          };
          this.scrollToRow = function(row) {
            this.renderer.scrollToRow(row);
          };
          this.scrollToLine = function(line, center, animate, callback) {
            this.renderer.scrollToLine(line, center, animate, callback);
          };
          this.centerSelection = function() {
            var range = this.getSelectionRange();
            var pos = {
              row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
              column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
            };
            this.renderer.alignCursor(pos, 0.5);
          };
          this.getCursorPosition = function() {
            return this.selection.getCursor();
          };
          this.getCursorPositionScreen = function() {
            return this.session.documentToScreenPosition(this.getCursorPosition());
          };
          this.getSelectionRange = function() {
            return this.selection.getRange();
          };
          this.selectAll = function() {
            this.$blockScrolling += 1;
            this.selection.selectAll();
            this.$blockScrolling -= 1;
          };
          this.clearSelection = function() {
            this.selection.clearSelection();
          };
          this.moveCursorTo = function(row, column) {
            this.selection.moveCursorTo(row, column);
          };
          this.moveCursorToPosition = function(pos) {
            this.selection.moveCursorToPosition(pos);
          };
          this.jumpToMatching = function(select, expand) {
            var cursor = this.getCursorPosition();
            var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
            var prevToken = iterator.getCurrentToken();
            var token = prevToken || iterator.stepForward();
            if (!token)
              return;
            var matchType;
            var found = false;
            var depth = {};
            var i = cursor.column - token.start;
            var bracketType;
            var brackets = {
              ")": "(",
              "(": "(",
              "]": "[",
              "[": "[",
              "{": "{",
              "}": "{"
            };
            do {
              if (token.value.match(/[{}()\[\]]/g)) {
                for (; i < token.value.length && !found; i++) {
                  if (!brackets[token.value[i]]) {
                    continue;
                  }
                  bracketType = brackets[token.value[i]] + "." + token.type.replace("rparen", "lparen");
                  if (isNaN(depth[bracketType])) {
                    depth[bracketType] = 0;
                  }
                  switch (token.value[i]) {
                    case "(":
                    case "[":
                    case "{":
                      depth[bracketType]++;
                      break;
                    case ")":
                    case "]":
                    case "}":
                      depth[bracketType]--;
                      if (depth[bracketType] === -1) {
                        matchType = "bracket";
                        found = true;
                      }
                      break;
                  }
                }
              } else if (token && token.type.indexOf("tag-name") !== -1) {
                if (isNaN(depth[token.value])) {
                  depth[token.value] = 0;
                }
                if (prevToken.value === "<") {
                  depth[token.value]++;
                } else if (prevToken.value === "</") {
                  depth[token.value]--;
                }
                if (depth[token.value] === -1) {
                  matchType = "tag";
                  found = true;
                }
              }
              if (!found) {
                prevToken = token;
                token = iterator.stepForward();
                i = 0;
              }
            } while (token && !found);
            if (!matchType)
              return;
            var range, pos;
            if (matchType === "bracket") {
              range = this.session.getBracketRange(cursor);
              if (!range) {
                range = new Range(
                  iterator.getCurrentTokenRow(),
                  iterator.getCurrentTokenColumn() + i - 1,
                  iterator.getCurrentTokenRow(),
                  iterator.getCurrentTokenColumn() + i - 1
                );
                pos = range.start;
                if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)
                  range = this.session.getBracketRange(pos);
              }
            } else if (matchType === "tag") {
              if (token && token.type.indexOf("tag-name") !== -1)
                var tag = token.value;
              else
                return;
              range = new Range(
                iterator.getCurrentTokenRow(),
                iterator.getCurrentTokenColumn() - 2,
                iterator.getCurrentTokenRow(),
                iterator.getCurrentTokenColumn() - 2
              );
              if (range.compare(cursor.row, cursor.column) === 0) {
                found = false;
                do {
                  token = prevToken;
                  prevToken = iterator.stepBackward();
                  if (prevToken) {
                    if (prevToken.type.indexOf("tag-close") !== -1) {
                      range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                    }
                    if (token.value === tag && token.type.indexOf("tag-name") !== -1) {
                      if (prevToken.value === "<") {
                        depth[tag]++;
                      } else if (prevToken.value === "</") {
                        depth[tag]--;
                      }
                      if (depth[tag] === 0)
                        found = true;
                    }
                  }
                } while (prevToken && !found);
              }
              if (token && token.type.indexOf("tag-name")) {
                pos = range.start;
                if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2)
                  pos = range.end;
              }
            }
            pos = range && range.cursor || pos;
            if (pos) {
              if (select) {
                if (range && expand) {
                  this.selection.setRange(range);
                } else if (range && range.isEqual(this.getSelectionRange())) {
                  this.clearSelection();
                } else {
                  this.selection.selectTo(pos.row, pos.column);
                }
              } else {
                this.selection.moveTo(pos.row, pos.column);
              }
            }
          };
          this.gotoLine = function(lineNumber, column, animate) {
            this.selection.clearSelection();
            this.session.unfold({ row: lineNumber - 1, column: column || 0 });
            this.$blockScrolling += 1;
            this.exitMultiSelectMode && this.exitMultiSelectMode();
            this.moveCursorTo(lineNumber - 1, column || 0);
            this.$blockScrolling -= 1;
            if (!this.isRowFullyVisible(lineNumber - 1))
              this.scrollToLine(lineNumber - 1, true, animate);
          };
          this.navigateTo = function(row, column) {
            this.selection.moveTo(row, column);
          };
          this.navigateUp = function(times) {
            if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
              var selectionStart = this.selection.anchor.getPosition();
              return this.moveCursorToPosition(selectionStart);
            }
            this.selection.clearSelection();
            this.selection.moveCursorBy(-times || -1, 0);
          };
          this.navigateDown = function(times) {
            if (this.selection.isMultiLine() && this.selection.isBackwards()) {
              var selectionEnd = this.selection.anchor.getPosition();
              return this.moveCursorToPosition(selectionEnd);
            }
            this.selection.clearSelection();
            this.selection.moveCursorBy(times || 1, 0);
          };
          this.navigateLeft = function(times) {
            if (!this.selection.isEmpty()) {
              var selectionStart = this.getSelectionRange().start;
              this.moveCursorToPosition(selectionStart);
            } else {
              times = times || 1;
              while (times--) {
                this.selection.moveCursorLeft();
              }
            }
            this.clearSelection();
          };
          this.navigateRight = function(times) {
            if (!this.selection.isEmpty()) {
              var selectionEnd = this.getSelectionRange().end;
              this.moveCursorToPosition(selectionEnd);
            } else {
              times = times || 1;
              while (times--) {
                this.selection.moveCursorRight();
              }
            }
            this.clearSelection();
          };
          this.navigateLineStart = function() {
            this.selection.moveCursorLineStart();
            this.clearSelection();
          };
          this.navigateLineEnd = function() {
            this.selection.moveCursorLineEnd();
            this.clearSelection();
          };
          this.navigateFileEnd = function() {
            this.selection.moveCursorFileEnd();
            this.clearSelection();
          };
          this.navigateFileStart = function() {
            this.selection.moveCursorFileStart();
            this.clearSelection();
          };
          this.navigateWordRight = function() {
            this.selection.moveCursorWordRight();
            this.clearSelection();
          };
          this.navigateWordLeft = function() {
            this.selection.moveCursorWordLeft();
            this.clearSelection();
          };
          this.replace = function(replacement, options) {
            if (options)
              this.$search.set(options);
            var range = this.$search.find(this.session);
            var replaced = 0;
            if (!range)
              return replaced;
            if (this.$tryReplace(range, replacement)) {
              replaced = 1;
            }
            if (range !== null) {
              this.selection.setSelectionRange(range);
              this.renderer.scrollSelectionIntoView(range.start, range.end);
            }
            return replaced;
          };
          this.replaceAll = function(replacement, options) {
            if (options) {
              this.$search.set(options);
            }
            var ranges = this.$search.findAll(this.session);
            var replaced = 0;
            if (!ranges.length)
              return replaced;
            this.$blockScrolling += 1;
            var selection = this.getSelectionRange();
            this.selection.moveTo(0, 0);
            for (var i = ranges.length - 1; i >= 0; --i) {
              if (this.$tryReplace(ranges[i], replacement)) {
                replaced++;
              }
            }
            this.selection.setSelectionRange(selection);
            this.$blockScrolling -= 1;
            return replaced;
          };
          this.$tryReplace = function(range, replacement) {
            var input = this.session.getTextRange(range);
            replacement = this.$search.replace(input, replacement);
            if (replacement !== null) {
              range.end = this.session.replace(range, replacement);
              return range;
            } else {
              return null;
            }
          };
          this.getLastSearchOptions = function() {
            return this.$search.getOptions();
          };
          this.find = function(needle, options, animate) {
            if (!options)
              options = {};
            if (typeof needle == "string" || needle instanceof RegExp)
              options.needle = needle;
            else if (typeof needle == "object")
              oop.mixin(options, needle);
            var range = this.selection.getRange();
            if (options.needle == null) {
              needle = this.session.getTextRange(range) || this.$search.$options.needle;
              if (!needle) {
                range = this.session.getWordRange(range.start.row, range.start.column);
                needle = this.session.getTextRange(range);
              }
              this.$search.set({ needle });
            }
            this.$search.set(options);
            if (!options.start)
              this.$search.set({ start: range });
            var newRange = this.$search.find(this.session);
            if (options.preventScroll)
              return newRange;
            if (newRange) {
              this.revealRange(newRange, animate);
              return newRange;
            }
            if (options.backwards)
              range.start = range.end;
            else
              range.end = range.start;
            this.selection.setRange(range);
          };
          this.findNext = function(options, animate) {
            this.find({ skipCurrent: true, backwards: false }, options, animate);
          };
          this.findPrevious = function(options, animate) {
            this.find(options, { skipCurrent: true, backwards: true }, animate);
          };
          this.revealRange = function(range, animate) {
            this.$blockScrolling += 1;
            this.session.unfold(range);
            this.selection.setSelectionRange(range);
            this.$blockScrolling -= 1;
            var scrollTop = this.renderer.scrollTop;
            this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
            if (animate !== false)
              this.renderer.animateScrolling(scrollTop);
          };
          this.undo = function() {
            this.$blockScrolling++;
            this.session.getUndoManager().undo();
            this.$blockScrolling--;
            this.renderer.scrollCursorIntoView(null, 0.5);
          };
          this.redo = function() {
            this.$blockScrolling++;
            this.session.getUndoManager().redo();
            this.$blockScrolling--;
            this.renderer.scrollCursorIntoView(null, 0.5);
          };
          this.destroy = function() {
            this.renderer.destroy();
            this._signal("destroy", this);
            if (this.session) {
              this.session.destroy();
            }
          };
          this.setAutoScrollEditorIntoView = function(enable) {
            if (!enable)
              return;
            var rect;
            var self2 = this;
            var shouldScroll = false;
            if (!this.$scrollAnchor)
              this.$scrollAnchor = document.createElement("div");
            var scrollAnchor = this.$scrollAnchor;
            scrollAnchor.style.cssText = "position:absolute";
            this.container.insertBefore(scrollAnchor, this.container.firstChild);
            var onChangeSelection = this.on("changeSelection", function() {
              shouldScroll = true;
            });
            var onBeforeRender = this.renderer.on("beforeRender", function() {
              if (shouldScroll)
                rect = self2.renderer.container.getBoundingClientRect();
            });
            var onAfterRender = this.renderer.on("afterRender", function() {
              if (shouldScroll && rect && (self2.isFocused() || self2.searchBox && self2.searchBox.isFocused())) {
                var renderer = self2.renderer;
                var pos = renderer.$cursorLayer.$pixelPos;
                var config2 = renderer.layerConfig;
                var top = pos.top - config2.offset;
                if (pos.top >= 0 && top + rect.top < 0) {
                  shouldScroll = true;
                } else if (pos.top < config2.height && pos.top + rect.top + config2.lineHeight > window.innerHeight) {
                  shouldScroll = false;
                } else {
                  shouldScroll = null;
                }
                if (shouldScroll != null) {
                  scrollAnchor.style.top = top + "px";
                  scrollAnchor.style.left = pos.left + "px";
                  scrollAnchor.style.height = config2.lineHeight + "px";
                  scrollAnchor.scrollIntoView(shouldScroll);
                }
                shouldScroll = rect = null;
              }
            });
            this.setAutoScrollEditorIntoView = function(enable2) {
              if (enable2)
                return;
              delete this.setAutoScrollEditorIntoView;
              this.off("changeSelection", onChangeSelection);
              this.renderer.off("afterRender", onAfterRender);
              this.renderer.off("beforeRender", onBeforeRender);
            };
          };
          this.$resetCursorStyle = function() {
            var style = this.$cursorStyle || "ace";
            var cursorLayer = this.renderer.$cursorLayer;
            if (!cursorLayer)
              return;
            cursorLayer.setSmoothBlinking(/smooth/.test(style));
            cursorLayer.isBlinking = !this.$readOnly && style != "wide";
            dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
          };
        }).call(Editor.prototype);
        config.defineOptions(Editor.prototype, "editor", {
          selectionStyle: {
            set: function(style) {
              this.onSelectionChange();
              this._signal("changeSelectionStyle", { data: style });
            },
            initialValue: "line"
          },
          highlightActiveLine: {
            set: function() {
              this.$updateHighlightActiveLine();
            },
            initialValue: true
          },
          highlightSelectedWord: {
            set: function(shouldHighlight) {
              this.$onSelectionChange();
            },
            initialValue: true
          },
          readOnly: {
            set: function(readOnly) {
              this.$resetCursorStyle();
            },
            initialValue: false
          },
          cursorStyle: {
            set: function(val) {
              this.$resetCursorStyle();
            },
            values: ["ace", "slim", "smooth", "wide"],
            initialValue: "ace"
          },
          mergeUndoDeltas: {
            values: [false, true, "always"],
            initialValue: true
          },
          behavioursEnabled: { initialValue: true },
          wrapBehavioursEnabled: { initialValue: true },
          autoScrollEditorIntoView: {
            set: function(val) {
              this.setAutoScrollEditorIntoView(val);
            }
          },
          keyboardHandler: {
            set: function(val) {
              this.setKeyboardHandler(val);
            },
            get: function() {
              return this.keybindingId;
            },
            handlesSet: true
          },
          hScrollBarAlwaysVisible: "renderer",
          vScrollBarAlwaysVisible: "renderer",
          highlightGutterLine: "renderer",
          animatedScroll: "renderer",
          showInvisibles: "renderer",
          showPrintMargin: "renderer",
          printMarginColumn: "renderer",
          printMargin: "renderer",
          fadeFoldWidgets: "renderer",
          showFoldWidgets: "renderer",
          showLineNumbers: "renderer",
          showGutter: "renderer",
          displayIndentGuides: "renderer",
          fontSize: "renderer",
          fontFamily: "renderer",
          maxLines: "renderer",
          minLines: "renderer",
          scrollPastEnd: "renderer",
          fixedWidthGutter: "renderer",
          theme: "renderer",
          scrollSpeed: "$mouseHandler",
          dragDelay: "$mouseHandler",
          dragEnabled: "$mouseHandler",
          focusTimout: "$mouseHandler",
          tooltipFollowsMouse: "$mouseHandler",
          firstLineNumber: "session",
          overwrite: "session",
          newLineMode: "session",
          useWorker: "session",
          useSoftTabs: "session",
          tabSize: "session",
          wrap: "session",
          indentedSoftWrap: "session",
          foldStyle: "session",
          mode: "session"
        });
        exports2.Editor = Editor;
      });
      ace.define("ace/undomanager", ["require", "exports", "module"], function(acequire, exports2, module2) {
        "use strict";
        var UndoManager = function() {
          this.reset();
        };
        (function() {
          this.execute = function(options) {
            var deltaSets = options.args[0];
            this.$doc = options.args[1];
            if (options.merge && this.hasUndo()) {
              this.dirtyCounter--;
              deltaSets = this.$undoStack.pop().concat(deltaSets);
            }
            this.$undoStack.push(deltaSets);
            this.$redoStack = [];
            if (this.dirtyCounter < 0) {
              this.dirtyCounter = NaN;
            }
            this.dirtyCounter++;
          };
          this.undo = function(dontSelect) {
            var deltaSets = this.$undoStack.pop();
            var undoSelectionRange = null;
            if (deltaSets) {
              undoSelectionRange = this.$doc.undoChanges(deltaSets, dontSelect);
              this.$redoStack.push(deltaSets);
              this.dirtyCounter--;
            }
            return undoSelectionRange;
          };
          this.redo = function(dontSelect) {
            var deltaSets = this.$redoStack.pop();
            var redoSelectionRange = null;
            if (deltaSets) {
              redoSelectionRange = this.$doc.redoChanges(this.$deserializeDeltas(deltaSets), dontSelect);
              this.$undoStack.push(deltaSets);
              this.dirtyCounter++;
            }
            return redoSelectionRange;
          };
          this.reset = function() {
            this.$undoStack = [];
            this.$redoStack = [];
            this.dirtyCounter = 0;
          };
          this.hasUndo = function() {
            return this.$undoStack.length > 0;
          };
          this.hasRedo = function() {
            return this.$redoStack.length > 0;
          };
          this.markClean = function() {
            this.dirtyCounter = 0;
          };
          this.isClean = function() {
            return this.dirtyCounter === 0;
          };
          this.$serializeDeltas = function(deltaSets) {
            return cloneDeltaSetsObj(deltaSets, $serializeDelta);
          };
          this.$deserializeDeltas = function(deltaSets) {
            return cloneDeltaSetsObj(deltaSets, $deserializeDelta);
          };
          function $serializeDelta(delta) {
            return {
              action: delta.action,
              start: delta.start,
              end: delta.end,
              lines: delta.lines.length == 1 ? null : delta.lines,
              text: delta.lines.length == 1 ? delta.lines[0] : null
            };
          }
          function $deserializeDelta(delta) {
            return {
              action: delta.action,
              start: delta.start,
              end: delta.end,
              lines: delta.lines || [delta.text]
            };
          }
          function cloneDeltaSetsObj(deltaSets_old, fnGetModifiedDelta) {
            var deltaSets_new = new Array(deltaSets_old.length);
            for (var i = 0; i < deltaSets_old.length; i++) {
              var deltaSet_old = deltaSets_old[i];
              var deltaSet_new = { group: deltaSet_old.group, deltas: new Array(deltaSet_old.length) };
              for (var j = 0; j < deltaSet_old.deltas.length; j++) {
                var delta_old = deltaSet_old.deltas[j];
                deltaSet_new.deltas[j] = fnGetModifiedDelta(delta_old);
              }
              deltaSets_new[i] = deltaSet_new;
            }
            return deltaSets_new;
          }
        }).call(UndoManager.prototype);
        exports2.UndoManager = UndoManager;
      });
      ace.define("ace/layer/gutter", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter"], function(acequire, exports2, module2) {
        "use strict";
        var dom = acequire("../lib/dom");
        var oop = acequire("../lib/oop");
        var lang = acequire("../lib/lang");
        var EventEmitter = acequire("../lib/event_emitter").EventEmitter;
        var Gutter = function(parentEl) {
          this.element = dom.createElement("div");
          this.element.className = "ace_layer ace_gutter-layer";
          parentEl.appendChild(this.element);
          this.setShowFoldWidgets(this.$showFoldWidgets);
          this.gutterWidth = 0;
          this.$annotations = [];
          this.$updateAnnotations = this.$updateAnnotations.bind(this);
          this.$cells = [];
        };
        (function() {
          oop.implement(this, EventEmitter);
          this.setSession = function(session) {
            if (this.session)
              this.session.removeEventListener("change", this.$updateAnnotations);
            this.session = session;
            if (session)
              session.on("change", this.$updateAnnotations);
          };
          this.addGutterDecoration = function(row, className) {
            if (window.console)
              console.warn && console.warn("deprecated use session.addGutterDecoration");
            this.session.addGutterDecoration(row, className);
          };
          this.removeGutterDecoration = function(row, className) {
            if (window.console)
              console.warn && console.warn("deprecated use session.removeGutterDecoration");
            this.session.removeGutterDecoration(row, className);
          };
          this.setAnnotations = function(annotations) {
            this.$annotations = [];
            for (var i = 0; i < annotations.length; i++) {
              var annotation = annotations[i];
              var row = annotation.row;
              var rowInfo = this.$annotations[row];
              if (!rowInfo)
                rowInfo = this.$annotations[row] = { text: [] };
              var annoText = annotation.text;
              annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";
              if (rowInfo.text.indexOf(annoText) === -1)
                rowInfo.text.push(annoText);
              var type = annotation.type;
              if (type == "error")
                rowInfo.className = " ace_error";
              else if (type == "warning" && rowInfo.className != " ace_error")
                rowInfo.className = " ace_warning";
              else if (type == "info" && !rowInfo.className)
                rowInfo.className = " ace_info";
            }
          };
          this.$updateAnnotations = function(delta) {
            if (!this.$annotations.length)
              return;
            var firstRow = delta.start.row;
            var len = delta.end.row - firstRow;
            if (len === 0) {
            } else if (delta.action == "remove") {
              this.$annotations.splice(firstRow, len + 1, null);
            } else {
              var args = new Array(len + 1);
              args.unshift(firstRow, 1);
              this.$annotations.splice.apply(this.$annotations, args);
            }
          };
          this.update = function(config) {
            var session = this.session;
            var firstRow = config.firstRow;
            var lastRow = Math.min(
              config.lastRow + config.gutterOffset,
              // needed to compensate for hor scollbar
              session.getLength() - 1
            );
            var fold = session.getNextFoldLine(firstRow);
            var foldStart = fold ? fold.start.row : Infinity;
            var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
            var breakpoints = session.$breakpoints;
            var decorations = session.$decorations;
            var firstLineNumber = session.$firstLineNumber;
            var lastLineNumber = 0;
            var gutterRenderer = session.gutterRenderer || this.$renderer;
            var cell = null;
            var index = -1;
            var row = firstRow;
            while (true) {
              if (row > foldStart) {
                row = fold.end.row + 1;
                fold = session.getNextFoldLine(row, fold);
                foldStart = fold ? fold.start.row : Infinity;
              }
              if (row > lastRow) {
                while (this.$cells.length > index + 1) {
                  cell = this.$cells.pop();
                  this.element.removeChild(cell.element);
                }
                break;
              }
              cell = this.$cells[++index];
              if (!cell) {
                cell = { element: null, textNode: null, foldWidget: null };
                cell.element = dom.createElement("div");
                cell.textNode = document.createTextNode("");
                cell.element.appendChild(cell.textNode);
                this.element.appendChild(cell.element);
                this.$cells[index] = cell;
              }
              var className = "ace_gutter-cell ";
              if (breakpoints[row])
                className += breakpoints[row];
              if (decorations[row])
                className += decorations[row];
              if (this.$annotations[row])
                className += this.$annotations[row].className;
              if (cell.element.className != className)
                cell.element.className = className;
              var height = session.getRowLength(row) * config.lineHeight + "px";
              if (height != cell.element.style.height)
                cell.element.style.height = height;
              if (foldWidgets) {
                var c = foldWidgets[row];
                if (c == null)
                  c = foldWidgets[row] = session.getFoldWidget(row);
              }
              if (c) {
                if (!cell.foldWidget) {
                  cell.foldWidget = dom.createElement("span");
                  cell.element.appendChild(cell.foldWidget);
                }
                var className = "ace_fold-widget ace_" + c;
                if (c == "start" && row == foldStart && row < fold.end.row)
                  className += " ace_closed";
                else
                  className += " ace_open";
                if (cell.foldWidget.className != className)
                  cell.foldWidget.className = className;
                var height = config.lineHeight + "px";
                if (cell.foldWidget.style.height != height)
                  cell.foldWidget.style.height = height;
              } else {
                if (cell.foldWidget) {
                  cell.element.removeChild(cell.foldWidget);
                  cell.foldWidget = null;
                }
              }
              var text = lastLineNumber = gutterRenderer ? gutterRenderer.getText(session, row) : row + firstLineNumber;
              if (text !== cell.textNode.data)
                cell.textNode.data = text;
              row++;
            }
            this.element.style.height = config.minHeight + "px";
            if (this.$fixedWidth || session.$useWrapMode)
              lastLineNumber = session.getLength() + firstLineNumber;
            var gutterWidth = gutterRenderer ? gutterRenderer.getWidth(session, lastLineNumber, config) : lastLineNumber.toString().length * config.characterWidth;
            var padding = this.$padding || this.$computePadding();
            gutterWidth += padding.left + padding.right;
            if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
              this.gutterWidth = gutterWidth;
              this.element.style.width = Math.ceil(this.gutterWidth) + "px";
              this._emit("changeGutterWidth", gutterWidth);
            }
          };
          this.$fixedWidth = false;
          this.$showLineNumbers = true;
          this.$renderer = "";
          this.setShowLineNumbers = function(show) {
            this.$renderer = !show && {
              getWidth: function() {
                return "";
              },
              getText: function() {
                return "";
              }
            };
          };
          this.getShowLineNumbers = function() {
            return this.$showLineNumbers;
          };
          this.$showFoldWidgets = true;
          this.setShowFoldWidgets = function(show) {
            if (show)
              dom.addCssClass(this.element, "ace_folding-enabled");
            else
              dom.removeCssClass(this.element, "ace_folding-enabled");
            this.$showFoldWidgets = show;
            this.$padding = null;
          };
          this.getShowFoldWidgets = function() {
            return this.$showFoldWidgets;
          };
          this.$computePadding = function() {
            if (!this.element.firstChild)
              return { left: 0, right: 0 };
            var style = dom.computedStyle(this.element.firstChild);
            this.$padding = {};
            this.$padding.left = parseInt(style.paddingLeft) + 1 || 0;
            this.$padding.right = parseInt(style.paddingRight) || 0;
            return this.$padding;
          };
          this.getRegion = function(point) {
            var padding = this.$padding || this.$computePadding();
            var rect = this.element.getBoundingClientRect();
            if (point.x < padding.left + rect.left)
              return "markers";
            if (this.$showFoldWidgets && point.x > rect.right - padding.right)
              return "foldWidgets";
          };
        }).call(Gutter.prototype);
        exports2.Gutter = Gutter;
      });
      ace.define("ace/layer/marker", ["require", "exports", "module", "ace/range", "ace/lib/dom"], function(acequire, exports2, module2) {
        "use strict";
        var Range = acequire("../range").Range;
        var dom = acequire("../lib/dom");
        var Marker = function(parentEl) {
          this.element = dom.createElement("div");
          this.element.className = "ace_layer ace_marker-layer";
          parentEl.appendChild(this.element);
        };
        (function() {
          this.$padding = 0;
          this.setPadding = function(padding) {
            this.$padding = padding;
          };
          this.setSession = function(session) {
            this.session = session;
          };
          this.setMarkers = function(markers) {
            this.markers = markers;
          };
          this.update = function(config) {
            if (!config)
              return;
            this.config = config;
            var html = [];
            for (var key in this.markers) {
              var marker = this.markers[key];
              if (!marker.range) {
                marker.update(html, this, this.session, config);
                continue;
              }
              var range = marker.range.clipRows(config.firstRow, config.lastRow);
              if (range.isEmpty())
                continue;
              range = range.toScreenRange(this.session);
              if (marker.renderer) {
                var top = this.$getTop(range.start.row, config);
                var left = this.$padding + (this.session.$bidiHandler.isBidiRow(range.start.row) ? this.session.$bidiHandler.getPosLeft(range.start.column) : range.start.column * config.characterWidth);
                marker.renderer(html, range, left, top, config);
              } else if (marker.type == "fullLine") {
                this.drawFullLineMarker(html, range, marker.clazz, config);
              } else if (marker.type == "screenLine") {
                this.drawScreenLineMarker(html, range, marker.clazz, config);
              } else if (range.isMultiLine()) {
                if (marker.type == "text")
                  this.drawTextMarker(html, range, marker.clazz, config);
                else
                  this.drawMultiLineMarker(html, range, marker.clazz, config);
              } else {
                if (this.session.$bidiHandler.isBidiRow(range.start.row)) {
                  this.drawBidiSingleLineMarker(html, range, marker.clazz + " ace_start ace_br15", config);
                } else {
                  this.drawSingleLineMarker(html, range, marker.clazz + " ace_start ace_br15", config);
                }
              }
            }
            this.element.innerHTML = html.join("");
          };
          this.$getTop = function(row, layerConfig) {
            return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
          };
          function getBorderClass(tl, tr, br, bl) {
            return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
          }
          this.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {
            var session = this.session;
            var start = range.start.row;
            var end = range.end.row;
            var row = start;
            var prev = 0;
            var curr = 0;
            var next = session.getScreenLastRowColumn(row);
            var clazzModified = null;
            var lineRange = new Range(row, range.start.column, row, curr);
            for (; row <= end; row++) {
              lineRange.start.row = lineRange.end.row = row;
              lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
              lineRange.end.column = next;
              prev = curr;
              curr = next;
              next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
              clazzModified = clazz + (row == start ? " ace_start" : "") + " ace_br" + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end);
              if (this.session.$bidiHandler.isBidiRow(row)) {
                this.drawBidiSingleLineMarker(
                  stringBuilder,
                  lineRange,
                  clazzModified,
                  layerConfig,
                  row == end ? 0 : 1,
                  extraStyle
                );
              } else {
                this.drawSingleLineMarker(
                  stringBuilder,
                  lineRange,
                  clazzModified,
                  layerConfig,
                  row == end ? 0 : 1,
                  extraStyle
                );
              }
            }
          };
          this.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
            var padding = this.$padding;
            var height, top, left;
            extraStyle = extraStyle || "";
            if (this.session.$bidiHandler.isBidiRow(range.start.row)) {
              var range1 = range.clone();
              range1.end.row = range1.start.row;
              range1.end.column = this.session.getLine(range1.start.row).length;
              this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br1 ace_start", config, null, extraStyle);
            } else {
              height = config.lineHeight;
              top = this.$getTop(range.start.row, config);
              left = padding + range.start.column * config.characterWidth;
              stringBuilder.push(
                "<div class='",
                clazz,
                " ace_br1 ace_start' style='",
                "height:",
                height,
                "px;",
                "right:0;",
                "top:",
                top,
                "px;",
                "left:",
                left,
                "px;",
                extraStyle,
                "'></div>"
              );
            }
            if (this.session.$bidiHandler.isBidiRow(range.end.row)) {
              var range1 = range.clone();
              range1.start.row = range1.end.row;
              range1.start.column = 0;
              this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br12", config, null, extraStyle);
            } else {
              var width = range.end.column * config.characterWidth;
              height = config.lineHeight;
              top = this.$getTop(range.end.row, config);
              stringBuilder.push(
                "<div class='",
                clazz,
                " ace_br12' style='",
                "height:",
                height,
                "px;",
                "width:",
                width,
                "px;",
                "top:",
                top,
                "px;",
                "left:",
                padding,
                "px;",
                extraStyle,
                "'></div>"
              );
            }
            height = (range.end.row - range.start.row - 1) * config.lineHeight;
            if (height <= 0)
              return;
            top = this.$getTop(range.start.row + 1, config);
            var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);
            stringBuilder.push(
              "<div class='",
              clazz,
              radiusClass ? " ace_br" + radiusClass : "",
              "' style='",
              "height:",
              height,
              "px;",
              "right:0;",
              "top:",
              top,
              "px;",
              "left:",
              padding,
              "px;",
              extraStyle,
              "'></div>"
            );
          };
          this.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
            var height = config.lineHeight;
            var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;
            var top = this.$getTop(range.start.row, config);
            var left = this.$padding + range.start.column * config.characterWidth;
            stringBuilder.push(
              "<div class='",
              clazz,
              "' style='",
              "height:",
              height,
              "px;",
              "width:",
              width,
              "px;",
              "top:",
              top,
              "px;",
              "left:",
              left,
              "px;",
              extraStyle || "",
              "'></div>"
            );
          };
          this.drawBidiSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
            var height = config.lineHeight, top = this.$getTop(range.start.row, config), padding = this.$padding;
            var selections = this.session.$bidiHandler.getSelections(range.start.column, range.end.column);
            selections.forEach(function(selection) {
              stringBuilder.push(
                "<div class='",
                clazz,
                "' style='",
                "height:",
                height,
                "px;",
                "width:",
                selection.width + (extraLength || 0),
                "px;",
                "top:",
                top,
                "px;",
                "left:",
                padding + selection.left,
                "px;",
                extraStyle || "",
                "'></div>"
              );
            });
          };
          this.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
            var top = this.$getTop(range.start.row, config);
            var height = config.lineHeight;
            if (range.start.row != range.end.row)
              height += this.$getTop(range.end.row, config) - top;
            stringBuilder.push(
              "<div class='",
              clazz,
              "' style='",
              "height:",
              height,
              "px;",
              "top:",
              top,
              "px;",
              "left:0;right:0;",
              extraStyle || "",
              "'></div>"
            );
          };
          this.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
            var top = this.$getTop(range.start.row, config);
            var height = config.lineHeight;
            stringBuilder.push(
              "<div class='",
              clazz,
              "' style='",
              "height:",
              height,
              "px;",
              "top:",
              top,
              "px;",
              "left:0;right:0;",
              extraStyle || "",
              "'></div>"
            );
          };
        }).call(Marker.prototype);
        exports2.Marker = Marker;
      });
      ace.define("ace/layer/text", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/lib/event_emitter"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("../lib/oop");
        var dom = acequire("../lib/dom");
        var lang = acequire("../lib/lang");
        var useragent = acequire("../lib/useragent");
        var EventEmitter = acequire("../lib/event_emitter").EventEmitter;
        var Text = function(parentEl) {
          this.element = dom.createElement("div");
          this.element.className = "ace_layer ace_text-layer";
          parentEl.appendChild(this.element);
          this.$updateEolChar = this.$updateEolChar.bind(this);
        };
        (function() {
          oop.implement(this, EventEmitter);
          this.EOF_CHAR = "\xB6";
          this.EOL_CHAR_LF = "\xAC";
          this.EOL_CHAR_CRLF = "\xA4";
          this.EOL_CHAR = this.EOL_CHAR_LF;
          this.TAB_CHAR = "\u2014";
          this.SPACE_CHAR = "\xB7";
          this.$padding = 0;
          this.$updateEolChar = function() {
            var EOL_CHAR = this.session.doc.getNewLineCharacter() == "\n" ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
            if (this.EOL_CHAR != EOL_CHAR) {
              this.EOL_CHAR = EOL_CHAR;
              return true;
            }
          };
          this.setPadding = function(padding) {
            this.$padding = padding;
            this.element.style.padding = "0 " + padding + "px";
          };
          this.getLineHeight = function() {
            return this.$fontMetrics.$characterSize.height || 0;
          };
          this.getCharacterWidth = function() {
            return this.$fontMetrics.$characterSize.width || 0;
          };
          this.$setFontMetrics = function(measure) {
            this.$fontMetrics = measure;
            this.$fontMetrics.on("changeCharacterSize", function(e) {
              this._signal("changeCharacterSize", e);
            }.bind(this));
            this.$pollSizeChanges();
          };
          this.checkForSizeChanges = function() {
            this.$fontMetrics.checkForSizeChanges();
          };
          this.$pollSizeChanges = function() {
            return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
          };
          this.setSession = function(session) {
            this.session = session;
            if (session)
              this.$computeTabString();
          };
          this.showInvisibles = false;
          this.setShowInvisibles = function(showInvisibles) {
            if (this.showInvisibles == showInvisibles)
              return false;
            this.showInvisibles = showInvisibles;
            this.$computeTabString();
            return true;
          };
          this.displayIndentGuides = true;
          this.setDisplayIndentGuides = function(display) {
            if (this.displayIndentGuides == display)
              return false;
            this.displayIndentGuides = display;
            this.$computeTabString();
            return true;
          };
          this.$tabStrings = [];
          this.onChangeTabSize = this.$computeTabString = function() {
            var tabSize = this.session.getTabSize();
            this.tabSize = tabSize;
            var tabStr = this.$tabStrings = [0];
            for (var i = 1; i < tabSize + 1; i++) {
              if (this.showInvisibles) {
                tabStr.push("<span class='ace_invisible ace_invisible_tab'>" + lang.stringRepeat(this.TAB_CHAR, i) + "</span>");
              } else {
                tabStr.push(lang.stringRepeat(" ", i));
              }
            }
            if (this.displayIndentGuides) {
              this.$indentGuideRe = /\s\S| \t|\t |\s$/;
              var className = "ace_indent-guide";
              var spaceClass = "";
              var tabClass = "";
              if (this.showInvisibles) {
                className += " ace_invisible";
                spaceClass = " ace_invisible_space";
                tabClass = " ace_invisible_tab";
                var spaceContent = lang.stringRepeat(this.SPACE_CHAR, this.tabSize);
                var tabContent = lang.stringRepeat(this.TAB_CHAR, this.tabSize);
              } else {
                var spaceContent = lang.stringRepeat(" ", this.tabSize);
                var tabContent = spaceContent;
              }
              this.$tabStrings[" "] = "<span class='" + className + spaceClass + "'>" + spaceContent + "</span>";
              this.$tabStrings["	"] = "<span class='" + className + tabClass + "'>" + tabContent + "</span>";
            }
          };
          this.updateLines = function(config, firstRow, lastRow) {
            if (this.config.lastRow != config.lastRow || this.config.firstRow != config.firstRow) {
              this.scrollLines(config);
            }
            this.config = config;
            var first = Math.max(firstRow, config.firstRow);
            var last = Math.min(lastRow, config.lastRow);
            var lineElements = this.element.childNodes;
            var lineElementsIdx = 0;
            for (var row = config.firstRow; row < first; row++) {
              var foldLine = this.session.getFoldLine(row);
              if (foldLine) {
                if (foldLine.containsRow(first)) {
                  first = foldLine.start.row;
                  break;
                } else {
                  row = foldLine.end.row;
                }
              }
              lineElementsIdx++;
            }
            var row = first;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (true) {
              if (row > foldStart) {
                row = foldLine.end.row + 1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              }
              if (row > last)
                break;
              var lineElement = lineElements[lineElementsIdx++];
              if (lineElement) {
                var html = [];
                this.$renderLine(
                  html,
                  row,
                  !this.$useLineGroups(),
                  row == foldStart ? foldLine : false
                );
                lineElement.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
                lineElement.innerHTML = html.join("");
              }
              row++;
            }
          };
          this.scrollLines = function(config) {
            var oldConfig = this.config;
            this.config = config;
            if (!oldConfig || oldConfig.lastRow < config.firstRow)
              return this.update(config);
            if (config.lastRow < oldConfig.firstRow)
              return this.update(config);
            var el = this.element;
            if (oldConfig.firstRow < config.firstRow)
              for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)
                el.removeChild(el.firstChild);
            if (oldConfig.lastRow > config.lastRow)
              for (var row = this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row > 0; row--)
                el.removeChild(el.lastChild);
            if (config.firstRow < oldConfig.firstRow) {
              var fragment = this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1);
              if (el.firstChild)
                el.insertBefore(fragment, el.firstChild);
              else
                el.appendChild(fragment);
            }
            if (config.lastRow > oldConfig.lastRow) {
              var fragment = this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow);
              el.appendChild(fragment);
            }
          };
          this.$renderLinesFragment = function(config, firstRow, lastRow) {
            var fragment = this.element.ownerDocument.createDocumentFragment();
            var row = firstRow;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (true) {
              if (row > foldStart) {
                row = foldLine.end.row + 1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              }
              if (row > lastRow)
                break;
              var container = dom.createElement("div");
              var html = [];
              this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
              container.innerHTML = html.join("");
              if (this.$useLineGroups()) {
                container.className = "ace_line_group";
                fragment.appendChild(container);
                container.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
              } else {
                while (container.firstChild)
                  fragment.appendChild(container.firstChild);
              }
              row++;
            }
            return fragment;
          };
          this.update = function(config) {
            this.config = config;
            var html = [];
            var firstRow = config.firstRow, lastRow = config.lastRow;
            var row = firstRow;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (true) {
              if (row > foldStart) {
                row = foldLine.end.row + 1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              }
              if (row > lastRow)
                break;
              if (this.$useLineGroups())
                html.push("<div class='ace_line_group' style='height:", config.lineHeight * this.session.getRowLength(row), "px'>");
              this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
              if (this.$useLineGroups())
                html.push("</div>");
              row++;
            }
            this.element.innerHTML = html.join("");
          };
          this.$textToken = {
            "text": true,
            "rparen": true,
            "lparen": true
          };
          this.$renderToken = function(stringBuilder, screenColumn, token, value) {
            var self2 = this;
            var replaceReg = /\t|&|<|>|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\u3000\uFEFF\uFFF9-\uFFFC])|[\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3000-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
            var replaceFunc = function(c, a, b, tabIdx, idx4) {
              if (a) {
                return self2.showInvisibles ? "<span class='ace_invisible ace_invisible_space'>" + lang.stringRepeat(self2.SPACE_CHAR, c.length) + "</span>" : c;
              } else if (c == "&") {
                return "&#38;";
              } else if (c == "<") {
                return "&#60;";
              } else if (c == ">") {
                return "&#62;";
              } else if (c == "	") {
                var tabSize = self2.session.getScreenTabSize(screenColumn + tabIdx);
                screenColumn += tabSize - 1;
                return self2.$tabStrings[tabSize];
              } else if (c == "\u3000") {
                var classToUse = self2.showInvisibles ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
                var space = self2.showInvisibles ? self2.SPACE_CHAR : "";
                screenColumn += 1;
                return "<span class='" + classToUse + "' style='width:" + self2.config.characterWidth * 2 + "px'>" + space + "</span>";
              } else if (b) {
                return "<span class='ace_invisible ace_invisible_space ace_invalid'>" + self2.SPACE_CHAR + "</span>";
              } else {
                screenColumn += 1;
                return "<span class='ace_cjk' style='width:" + self2.config.characterWidth * 2 + "px'>" + c + "</span>";
              }
            };
            var output = value.replace(replaceReg, replaceFunc);
            if (!this.$textToken[token.type]) {
              var classes = "ace_" + token.type.replace(/\./g, " ace_");
              var style = "";
              if (token.type == "fold")
                style = " style='width:" + token.value.length * this.config.characterWidth + "px;' ";
              stringBuilder.push("<span class='", classes, "'", style, ">", output, "</span>");
            } else {
              stringBuilder.push(output);
            }
            return screenColumn + value.length;
          };
          this.renderIndentGuide = function(stringBuilder, value, max) {
            var cols = value.search(this.$indentGuideRe);
            if (cols <= 0 || cols >= max)
              return value;
            if (value[0] == " ") {
              cols -= cols % this.tabSize;
              stringBuilder.push(lang.stringRepeat(this.$tabStrings[" "], cols / this.tabSize));
              return value.substr(cols);
            } else if (value[0] == "	") {
              stringBuilder.push(lang.stringRepeat(this.$tabStrings["	"], cols));
              return value.substr(cols);
            }
            return value;
          };
          this.$renderWrappedLine = function(stringBuilder, tokens, splits, onlyContents) {
            var chars = 0;
            var split = 0;
            var splitChars = splits[0];
            var screenColumn = 0;
            for (var i = 0; i < tokens.length; i++) {
              var token = tokens[i];
              var value = token.value;
              if (i == 0 && this.displayIndentGuides) {
                chars = value.length;
                value = this.renderIndentGuide(stringBuilder, value, splitChars);
                if (!value)
                  continue;
                chars -= value.length;
              }
              if (chars + value.length < splitChars) {
                screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                chars += value.length;
              } else {
                while (chars + value.length >= splitChars) {
                  screenColumn = this.$renderToken(
                    stringBuilder,
                    screenColumn,
                    token,
                    value.substring(0, splitChars - chars)
                  );
                  value = value.substring(splitChars - chars);
                  chars = splitChars;
                  if (!onlyContents) {
                    stringBuilder.push(
                      "</div>",
                      "<div class='ace_line' style='height:",
                      this.config.lineHeight,
                      "px'>"
                    );
                  }
                  stringBuilder.push(lang.stringRepeat("\xA0", splits.indent));
                  split++;
                  screenColumn = 0;
                  splitChars = splits[split] || Number.MAX_VALUE;
                }
                if (value.length != 0) {
                  chars += value.length;
                  screenColumn = this.$renderToken(
                    stringBuilder,
                    screenColumn,
                    token,
                    value
                  );
                }
              }
            }
          };
          this.$renderSimpleLine = function(stringBuilder, tokens) {
            var screenColumn = 0;
            var token = tokens[0];
            var value = token.value;
            if (this.displayIndentGuides)
              value = this.renderIndentGuide(stringBuilder, value);
            if (value)
              screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
            for (var i = 1; i < tokens.length; i++) {
              token = tokens[i];
              value = token.value;
              screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
            }
          };
          this.$renderLine = function(stringBuilder, row, onlyContents, foldLine) {
            if (!foldLine && foldLine != false)
              foldLine = this.session.getFoldLine(row);
            if (foldLine)
              var tokens = this.$getFoldLineTokens(row, foldLine);
            else
              var tokens = this.session.getTokens(row);
            if (!onlyContents) {
              stringBuilder.push(
                "<div class='ace_line' style='height:",
                this.config.lineHeight * (this.$useLineGroups() ? 1 : this.session.getRowLength(row)),
                "px'>"
              );
            }
            if (tokens.length) {
              var splits = this.session.getRowSplitData(row);
              if (splits && splits.length)
                this.$renderWrappedLine(stringBuilder, tokens, splits, onlyContents);
              else
                this.$renderSimpleLine(stringBuilder, tokens);
            }
            if (this.showInvisibles) {
              if (foldLine)
                row = foldLine.end.row;
              stringBuilder.push(
                "<span class='ace_invisible ace_invisible_eol'>",
                row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR,
                "</span>"
              );
            }
            if (!onlyContents)
              stringBuilder.push("</div>");
          };
          this.$getFoldLineTokens = function(row, foldLine) {
            var session = this.session;
            var renderTokens = [];
            function addTokens(tokens2, from, to) {
              var idx = 0, col = 0;
              while (col + tokens2[idx].value.length < from) {
                col += tokens2[idx].value.length;
                idx++;
                if (idx == tokens2.length)
                  return;
              }
              if (col != from) {
                var value = tokens2[idx].value.substring(from - col);
                if (value.length > to - from)
                  value = value.substring(0, to - from);
                renderTokens.push({
                  type: tokens2[idx].type,
                  value
                });
                col = from + value.length;
                idx += 1;
              }
              while (col < to && idx < tokens2.length) {
                var value = tokens2[idx].value;
                if (value.length + col > to) {
                  renderTokens.push({
                    type: tokens2[idx].type,
                    value: value.substring(0, to - col)
                  });
                } else
                  renderTokens.push(tokens2[idx]);
                col += value.length;
                idx += 1;
              }
            }
            var tokens = session.getTokens(row);
            foldLine.walk(function(placeholder, row2, column, lastColumn, isNewRow) {
              if (placeholder != null) {
                renderTokens.push({
                  type: "fold",
                  value: placeholder
                });
              } else {
                if (isNewRow)
                  tokens = session.getTokens(row2);
                if (tokens.length)
                  addTokens(tokens, lastColumn, column);
              }
            }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);
            return renderTokens;
          };
          this.$useLineGroups = function() {
            return this.session.getUseWrapMode();
          };
          this.destroy = function() {
            clearInterval(this.$pollSizeChangesTimer);
            if (this.$measureNode)
              this.$measureNode.parentNode.removeChild(this.$measureNode);
            delete this.$measureNode;
          };
        }).call(Text.prototype);
        exports2.Text = Text;
      });
      ace.define("ace/layer/cursor", ["require", "exports", "module", "ace/lib/dom"], function(acequire, exports2, module2) {
        "use strict";
        var dom = acequire("../lib/dom");
        var isIE8;
        var Cursor = function(parentEl) {
          this.element = dom.createElement("div");
          this.element.className = "ace_layer ace_cursor-layer";
          parentEl.appendChild(this.element);
          if (isIE8 === void 0)
            isIE8 = !("opacity" in this.element.style);
          this.isVisible = false;
          this.isBlinking = true;
          this.blinkInterval = 1e3;
          this.smoothBlinking = false;
          this.cursors = [];
          this.cursor = this.addCursor();
          dom.addCssClass(this.element, "ace_hidden-cursors");
          this.$updateCursors = (isIE8 ? this.$updateVisibility : this.$updateOpacity).bind(this);
        };
        (function() {
          this.$updateVisibility = function(val) {
            var cursors = this.cursors;
            for (var i = cursors.length; i--; )
              cursors[i].style.visibility = val ? "" : "hidden";
          };
          this.$updateOpacity = function(val) {
            var cursors = this.cursors;
            for (var i = cursors.length; i--; )
              cursors[i].style.opacity = val ? "" : "0";
          };
          this.$padding = 0;
          this.setPadding = function(padding) {
            this.$padding = padding;
          };
          this.setSession = function(session) {
            this.session = session;
          };
          this.setBlinking = function(blinking) {
            if (blinking != this.isBlinking) {
              this.isBlinking = blinking;
              this.restartTimer();
            }
          };
          this.setBlinkInterval = function(blinkInterval) {
            if (blinkInterval != this.blinkInterval) {
              this.blinkInterval = blinkInterval;
              this.restartTimer();
            }
          };
          this.setSmoothBlinking = function(smoothBlinking) {
            if (smoothBlinking != this.smoothBlinking && !isIE8) {
              this.smoothBlinking = smoothBlinking;
              dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
              this.$updateCursors(true);
              this.$updateCursors = this.$updateOpacity.bind(this);
              this.restartTimer();
            }
          };
          this.addCursor = function() {
            var el = dom.createElement("div");
            el.className = "ace_cursor";
            this.element.appendChild(el);
            this.cursors.push(el);
            return el;
          };
          this.removeCursor = function() {
            if (this.cursors.length > 1) {
              var el = this.cursors.pop();
              el.parentNode.removeChild(el);
              return el;
            }
          };
          this.hideCursor = function() {
            this.isVisible = false;
            dom.addCssClass(this.element, "ace_hidden-cursors");
            this.restartTimer();
          };
          this.showCursor = function() {
            this.isVisible = true;
            dom.removeCssClass(this.element, "ace_hidden-cursors");
            this.restartTimer();
          };
          this.restartTimer = function() {
            var update = this.$updateCursors;
            clearInterval(this.intervalId);
            clearTimeout(this.timeoutId);
            if (this.smoothBlinking) {
              dom.removeCssClass(this.element, "ace_smooth-blinking");
            }
            update(true);
            if (!this.isBlinking || !this.blinkInterval || !this.isVisible)
              return;
            if (this.smoothBlinking) {
              setTimeout(function() {
                dom.addCssClass(this.element, "ace_smooth-blinking");
              }.bind(this));
            }
            var blink = function() {
              this.timeoutId = setTimeout(function() {
                update(false);
              }, 0.6 * this.blinkInterval);
            }.bind(this);
            this.intervalId = setInterval(function() {
              update(true);
              blink();
            }, this.blinkInterval);
            blink();
          };
          this.getPixelPosition = function(position, onScreen) {
            if (!this.config || !this.session)
              return { left: 0, top: 0 };
            if (!position)
              position = this.session.selection.getCursor();
            var pos = this.session.documentToScreenPosition(position);
            var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position.row) ? this.session.$bidiHandler.getPosLeft(pos.column) : pos.column * this.config.characterWidth);
            var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) * this.config.lineHeight;
            return { left: cursorLeft, top: cursorTop };
          };
          this.update = function(config) {
            this.config = config;
            var selections = this.session.$selectionMarkers;
            var i = 0, cursorIndex = 0;
            if (selections === void 0 || selections.length === 0) {
              selections = [{ cursor: null }];
            }
            for (var i = 0, n = selections.length; i < n; i++) {
              var pixelPos = this.getPixelPosition(selections[i].cursor, true);
              if ((pixelPos.top > config.height + config.offset || pixelPos.top < 0) && i > 1) {
                continue;
              }
              var style = (this.cursors[cursorIndex++] || this.addCursor()).style;
              if (!this.drawCursor) {
                style.left = pixelPos.left + "px";
                style.top = pixelPos.top + "px";
                style.width = config.characterWidth + "px";
                style.height = config.lineHeight + "px";
              } else {
                this.drawCursor(style, pixelPos, config, selections[i], this.session);
              }
            }
            while (this.cursors.length > cursorIndex)
              this.removeCursor();
            var overwrite = this.session.getOverwrite();
            this.$setOverwrite(overwrite);
            this.$pixelPos = pixelPos;
            this.restartTimer();
          };
          this.drawCursor = null;
          this.$setOverwrite = function(overwrite) {
            if (overwrite != this.overwrite) {
              this.overwrite = overwrite;
              if (overwrite)
                dom.addCssClass(this.element, "ace_overwrite-cursors");
              else
                dom.removeCssClass(this.element, "ace_overwrite-cursors");
            }
          };
          this.destroy = function() {
            clearInterval(this.intervalId);
            clearTimeout(this.timeoutId);
          };
        }).call(Cursor.prototype);
        exports2.Cursor = Cursor;
      });
      ace.define("ace/scrollbar", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/event", "ace/lib/event_emitter"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("./lib/oop");
        var dom = acequire("./lib/dom");
        var event = acequire("./lib/event");
        var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
        var MAX_SCROLL_H = 32768;
        var ScrollBar = function(parent) {
          this.element = dom.createElement("div");
          this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix;
          this.inner = dom.createElement("div");
          this.inner.className = "ace_scrollbar-inner";
          this.element.appendChild(this.inner);
          parent.appendChild(this.element);
          this.setVisible(false);
          this.skipEvent = false;
          event.addListener(this.element, "scroll", this.onScroll.bind(this));
          event.addListener(this.element, "mousedown", event.preventDefault);
        };
        (function() {
          oop.implement(this, EventEmitter);
          this.setVisible = function(isVisible) {
            this.element.style.display = isVisible ? "" : "none";
            this.isVisible = isVisible;
            this.coeff = 1;
          };
        }).call(ScrollBar.prototype);
        var VScrollBar = function(parent, renderer) {
          ScrollBar.call(this, parent);
          this.scrollTop = 0;
          this.scrollHeight = 0;
          renderer.$scrollbarWidth = this.width = dom.scrollbarWidth(parent.ownerDocument);
          this.inner.style.width = this.element.style.width = (this.width || 15) + 5 + "px";
          this.$minWidth = 0;
        };
        oop.inherits(VScrollBar, ScrollBar);
        (function() {
          this.classSuffix = "-v";
          this.onScroll = function() {
            if (!this.skipEvent) {
              this.scrollTop = this.element.scrollTop;
              if (this.coeff != 1) {
                var h = this.element.clientHeight / this.scrollHeight;
                this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);
              }
              this._emit("scroll", { data: this.scrollTop });
            }
            this.skipEvent = false;
          };
          this.getWidth = function() {
            return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
          };
          this.setHeight = function(height) {
            this.element.style.height = height + "px";
          };
          this.setInnerHeight = this.setScrollHeight = function(height) {
            this.scrollHeight = height;
            if (height > MAX_SCROLL_H) {
              this.coeff = MAX_SCROLL_H / height;
              height = MAX_SCROLL_H;
            } else if (this.coeff != 1) {
              this.coeff = 1;
            }
            this.inner.style.height = height + "px";
          };
          this.setScrollTop = function(scrollTop) {
            if (this.scrollTop != scrollTop) {
              this.skipEvent = true;
              this.scrollTop = scrollTop;
              this.element.scrollTop = scrollTop * this.coeff;
            }
          };
        }).call(VScrollBar.prototype);
        var HScrollBar = function(parent, renderer) {
          ScrollBar.call(this, parent);
          this.scrollLeft = 0;
          this.height = renderer.$scrollbarWidth;
          this.inner.style.height = this.element.style.height = (this.height || 15) + 5 + "px";
        };
        oop.inherits(HScrollBar, ScrollBar);
        (function() {
          this.classSuffix = "-h";
          this.onScroll = function() {
            if (!this.skipEvent) {
              this.scrollLeft = this.element.scrollLeft;
              this._emit("scroll", { data: this.scrollLeft });
            }
            this.skipEvent = false;
          };
          this.getHeight = function() {
            return this.isVisible ? this.height : 0;
          };
          this.setWidth = function(width) {
            this.element.style.width = width + "px";
          };
          this.setInnerWidth = function(width) {
            this.inner.style.width = width + "px";
          };
          this.setScrollWidth = function(width) {
            this.inner.style.width = width + "px";
          };
          this.setScrollLeft = function(scrollLeft) {
            if (this.scrollLeft != scrollLeft) {
              this.skipEvent = true;
              this.scrollLeft = this.element.scrollLeft = scrollLeft;
            }
          };
        }).call(HScrollBar.prototype);
        exports2.ScrollBar = VScrollBar;
        exports2.ScrollBarV = VScrollBar;
        exports2.ScrollBarH = HScrollBar;
        exports2.VScrollBar = VScrollBar;
        exports2.HScrollBar = HScrollBar;
      });
      ace.define("ace/renderloop", ["require", "exports", "module", "ace/lib/event"], function(acequire, exports2, module2) {
        "use strict";
        var event = acequire("./lib/event");
        var RenderLoop = function(onRender, win) {
          this.onRender = onRender;
          this.pending = false;
          this.changes = 0;
          this.window = win || window;
        };
        (function() {
          this.schedule = function(change) {
            this.changes = this.changes | change;
            if (!this.pending && this.changes) {
              this.pending = true;
              var _self = this;
              event.nextFrame(function() {
                _self.pending = false;
                var changes;
                while (changes = _self.changes) {
                  _self.changes = 0;
                  _self.onRender(changes);
                }
              }, this.window);
            }
          };
        }).call(RenderLoop.prototype);
        exports2.RenderLoop = RenderLoop;
      });
      ace.define("ace/layer/font_metrics", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/lib/event_emitter"], function(acequire, exports2, module2) {
        var oop = acequire("../lib/oop");
        var dom = acequire("../lib/dom");
        var lang = acequire("../lib/lang");
        var useragent = acequire("../lib/useragent");
        var EventEmitter = acequire("../lib/event_emitter").EventEmitter;
        var CHAR_COUNT = 0;
        var FontMetrics = exports2.FontMetrics = function(parentEl) {
          this.el = dom.createElement("div");
          this.$setMeasureNodeStyles(this.el.style, true);
          this.$main = dom.createElement("div");
          this.$setMeasureNodeStyles(this.$main.style);
          this.$measureNode = dom.createElement("div");
          this.$setMeasureNodeStyles(this.$measureNode.style);
          this.el.appendChild(this.$main);
          this.el.appendChild(this.$measureNode);
          parentEl.appendChild(this.el);
          if (!CHAR_COUNT)
            this.$testFractionalRect();
          this.$measureNode.innerHTML = lang.stringRepeat("X", CHAR_COUNT);
          this.$characterSize = { width: 0, height: 0 };
          this.checkForSizeChanges();
        };
        (function() {
          oop.implement(this, EventEmitter);
          this.$characterSize = { width: 0, height: 0 };
          this.$testFractionalRect = function() {
            var el = dom.createElement("div");
            this.$setMeasureNodeStyles(el.style);
            el.style.width = "0.2px";
            document.documentElement.appendChild(el);
            var w = el.getBoundingClientRect().width;
            if (w > 0 && w < 1)
              CHAR_COUNT = 50;
            else
              CHAR_COUNT = 100;
            el.parentNode.removeChild(el);
          };
          this.$setMeasureNodeStyles = function(style, isRoot) {
            style.width = style.height = "auto";
            style.left = style.top = "0px";
            style.visibility = "hidden";
            style.position = "absolute";
            style.whiteSpace = "pre";
            if (useragent.isIE < 8) {
              style["font-family"] = "inherit";
            } else {
              style.font = "inherit";
            }
            style.overflow = isRoot ? "hidden" : "visible";
          };
          this.checkForSizeChanges = function() {
            var size = this.$measureSizes();
            if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
              this.$measureNode.style.fontWeight = "bold";
              var boldSize = this.$measureSizes();
              this.$measureNode.style.fontWeight = "";
              this.$characterSize = size;
              this.charSizes = /* @__PURE__ */ Object.create(null);
              this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
              this._emit("changeCharacterSize", { data: size });
            }
          };
          this.$pollSizeChanges = function() {
            if (this.$pollSizeChangesTimer)
              return this.$pollSizeChangesTimer;
            var self2 = this;
            return this.$pollSizeChangesTimer = setInterval(function() {
              self2.checkForSizeChanges();
            }, 500);
          };
          this.setPolling = function(val) {
            if (val) {
              this.$pollSizeChanges();
            } else if (this.$pollSizeChangesTimer) {
              clearInterval(this.$pollSizeChangesTimer);
              this.$pollSizeChangesTimer = 0;
            }
          };
          this.$measureSizes = function() {
            if (CHAR_COUNT === 50) {
              var rect = null;
              try {
                rect = this.$measureNode.getBoundingClientRect();
              } catch (e) {
                rect = { width: 0, height: 0 };
              }
              var size = {
                height: rect.height,
                width: rect.width / CHAR_COUNT
              };
            } else {
              var size = {
                height: this.$measureNode.clientHeight,
                width: this.$measureNode.clientWidth / CHAR_COUNT
              };
            }
            if (size.width === 0 || size.height === 0)
              return null;
            return size;
          };
          this.$measureCharWidth = function(ch) {
            this.$main.innerHTML = lang.stringRepeat(ch, CHAR_COUNT);
            var rect = this.$main.getBoundingClientRect();
            return rect.width / CHAR_COUNT;
          };
          this.getCharacterWidth = function(ch) {
            var w = this.charSizes[ch];
            if (w === void 0) {
              w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
            }
            return w;
          };
          this.destroy = function() {
            clearInterval(this.$pollSizeChangesTimer);
            if (this.el && this.el.parentNode)
              this.el.parentNode.removeChild(this.el);
          };
        }).call(FontMetrics.prototype);
      });
      ace.define("ace/virtual_renderer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/config", "ace/lib/useragent", "ace/layer/gutter", "ace/layer/marker", "ace/layer/text", "ace/layer/cursor", "ace/scrollbar", "ace/scrollbar", "ace/renderloop", "ace/layer/font_metrics", "ace/lib/event_emitter"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("./lib/oop");
        var dom = acequire("./lib/dom");
        var config = acequire("./config");
        var useragent = acequire("./lib/useragent");
        var GutterLayer = acequire("./layer/gutter").Gutter;
        var MarkerLayer = acequire("./layer/marker").Marker;
        var TextLayer = acequire("./layer/text").Text;
        var CursorLayer = acequire("./layer/cursor").Cursor;
        var HScrollBar = acequire("./scrollbar").HScrollBar;
        var VScrollBar = acequire("./scrollbar").VScrollBar;
        var RenderLoop = acequire("./renderloop").RenderLoop;
        var FontMetrics = acequire("./layer/font_metrics").FontMetrics;
        var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
        var editorCss = `.ace_editor {position: relative;overflow: hidden;font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;direction: ltr;text-align: left;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);}.ace_scroller {position: absolute;overflow: hidden;top: 0;bottom: 0;background-color: inherit;-ms-user-select: none;-moz-user-select: none;-webkit-user-select: none;user-select: none;cursor: text;}.ace_content {position: absolute;-moz-box-sizing: border-box;-webkit-box-sizing: border-box;box-sizing: border-box;min-width: 100%;}.ace_dragging .ace_scroller:before{position: absolute;top: 0;left: 0;right: 0;bottom: 0;content: '';background: rgba(250, 250, 250, 0.01);z-index: 1000;}.ace_dragging.ace_dark .ace_scroller:before{background: rgba(0, 0, 0, 0.01);}.ace_selecting, .ace_selecting * {cursor: text !important;}.ace_gutter {position: absolute;overflow : hidden;width: auto;top: 0;bottom: 0;left: 0;cursor: default;z-index: 4;-ms-user-select: none;-moz-user-select: none;-webkit-user-select: none;user-select: none;}.ace_gutter-active-line {position: absolute;left: 0;right: 0;}.ace_scroller.ace_scroll-left {box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;}.ace_gutter-cell {padding-left: 19px;padding-right: 6px;background-repeat: no-repeat;}.ace_gutter-cell.ace_error {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==");background-repeat: no-repeat;background-position: 2px center;}.ace_gutter-cell.ace_warning {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==");background-position: 2px center;}.ace_gutter-cell.ace_info {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=");background-position: 2px center;}.ace_dark .ace_gutter-cell.ace_info {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC");}.ace_scrollbar {position: absolute;right: 0;bottom: 0;z-index: 6;}.ace_scrollbar-inner {position: absolute;cursor: text;left: 0;top: 0;}.ace_scrollbar-v{overflow-x: hidden;overflow-y: scroll;top: 0;}.ace_scrollbar-h {overflow-x: scroll;overflow-y: hidden;left: 0;}.ace_print-margin {position: absolute;height: 100%;}.ace_text-input {position: absolute;z-index: 0;width: 0.5em;height: 1em;opacity: 0;background: transparent;-moz-appearance: none;appearance: none;border: none;resize: none;outline: none;overflow: hidden;font: inherit;padding: 0 1px;margin: 0 -1px;text-indent: -1em;-ms-user-select: text;-moz-user-select: text;-webkit-user-select: text;user-select: text;white-space: pre!important;}.ace_text-input.ace_composition {background: inherit;color: inherit;z-index: 1000;opacity: 1;text-indent: 0;}.ace_layer {z-index: 1;position: absolute;overflow: hidden;word-wrap: normal;white-space: pre;height: 100%;width: 100%;-moz-box-sizing: border-box;-webkit-box-sizing: border-box;box-sizing: border-box;pointer-events: none;}.ace_gutter-layer {position: relative;width: auto;text-align: right;pointer-events: auto;}.ace_text-layer {font: inherit !important;}.ace_cjk {display: inline-block;text-align: center;}.ace_cursor-layer {z-index: 4;}.ace_cursor {z-index: 4;position: absolute;-moz-box-sizing: border-box;-webkit-box-sizing: border-box;box-sizing: border-box;border-left: 2px solid;transform: translatez(0);}.ace_multiselect .ace_cursor {border-left-width: 1px;}.ace_slim-cursors .ace_cursor {border-left-width: 1px;}.ace_overwrite-cursors .ace_cursor {border-left-width: 0;border-bottom: 1px solid;}.ace_hidden-cursors .ace_cursor {opacity: 0.2;}.ace_smooth-blinking .ace_cursor {-webkit-transition: opacity 0.18s;transition: opacity 0.18s;}.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {position: absolute;z-index: 3;}.ace_marker-layer .ace_selection {position: absolute;z-index: 5;}.ace_marker-layer .ace_bracket {position: absolute;z-index: 6;}.ace_marker-layer .ace_active-line {position: absolute;z-index: 2;}.ace_marker-layer .ace_selected-word {position: absolute;z-index: 4;-moz-box-sizing: border-box;-webkit-box-sizing: border-box;box-sizing: border-box;}.ace_line .ace_fold {-moz-box-sizing: border-box;-webkit-box-sizing: border-box;box-sizing: border-box;display: inline-block;height: 11px;margin-top: -2px;vertical-align: middle;background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=");background-repeat: no-repeat, repeat-x;background-position: center center, top left;color: transparent;border: 1px solid black;border-radius: 2px;cursor: pointer;pointer-events: auto;}.ace_dark .ace_fold {}.ace_fold:hover{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC");}.ace_tooltip {background-color: #FFF;background-image: -webkit-linear-gradient(top, transparent, rgba(0, 0, 0, 0.1));background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));border: 1px solid gray;border-radius: 1px;box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);color: black;max-width: 100%;padding: 3px 4px;position: fixed;z-index: 999999;-moz-box-sizing: border-box;-webkit-box-sizing: border-box;box-sizing: border-box;cursor: default;white-space: pre;word-wrap: break-word;line-height: normal;font-style: normal;font-weight: normal;letter-spacing: normal;pointer-events: none;}.ace_folding-enabled > .ace_gutter-cell {padding-right: 13px;}.ace_fold-widget {-moz-box-sizing: border-box;-webkit-box-sizing: border-box;box-sizing: border-box;margin: 0 -12px 0 1px;display: none;width: 11px;vertical-align: top;background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==");background-repeat: no-repeat;background-position: center;border-radius: 3px;border: 1px solid transparent;cursor: pointer;}.ace_folding-enabled .ace_fold-widget {display: inline-block;   }.ace_fold-widget.ace_end {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==");}.ace_fold-widget.ace_closed {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==");}.ace_fold-widget:hover {border: 1px solid rgba(0, 0, 0, 0.3);background-color: rgba(255, 255, 255, 0.2);box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);}.ace_fold-widget:active {border: 1px solid rgba(0, 0, 0, 0.4);background-color: rgba(0, 0, 0, 0.05);box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);}.ace_dark .ace_fold-widget {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC");}.ace_dark .ace_fold-widget.ace_end {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==");}.ace_dark .ace_fold-widget.ace_closed {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==");}.ace_dark .ace_fold-widget:hover {box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);background-color: rgba(255, 255, 255, 0.1);}.ace_dark .ace_fold-widget:active {box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);}.ace_fold-widget.ace_invalid {background-color: #FFB4B4;border-color: #DE5555;}.ace_fade-fold-widgets .ace_fold-widget {-webkit-transition: opacity 0.4s ease 0.05s;transition: opacity 0.4s ease 0.05s;opacity: 0;}.ace_fade-fold-widgets:hover .ace_fold-widget {-webkit-transition: opacity 0.05s ease 0.05s;transition: opacity 0.05s ease 0.05s;opacity:1;}.ace_underline {text-decoration: underline;}.ace_bold {font-weight: bold;}.ace_nobold .ace_bold {font-weight: normal;}.ace_italic {font-style: italic;}.ace_error-marker {background-color: rgba(255, 0, 0,0.2);position: absolute;z-index: 9;}.ace_highlight-marker {background-color: rgba(255, 255, 0,0.2);position: absolute;z-index: 8;}.ace_br1 {border-top-left-radius    : 3px;}.ace_br2 {border-top-right-radius   : 3px;}.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}.ace_br4 {border-bottom-right-radius: 3px;}.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}.ace_br8 {border-bottom-left-radius : 3px;}.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}.ace_text-input-ios {position: absolute !important;top: -100000px !important;left: -100000px !important;}`;
        dom.importCssString(editorCss, "ace_editor.css");
        var VirtualRenderer = function(container, theme) {
          var _self = this;
          this.container = container || dom.createElement("div");
          this.$keepTextAreaAtCursor = !useragent.isOldIE;
          dom.addCssClass(this.container, "ace_editor");
          this.setTheme(theme);
          this.$gutter = dom.createElement("div");
          this.$gutter.className = "ace_gutter";
          this.container.appendChild(this.$gutter);
          this.$gutter.setAttribute("aria-hidden", true);
          this.scroller = dom.createElement("div");
          this.scroller.className = "ace_scroller";
          this.container.appendChild(this.scroller);
          this.content = dom.createElement("div");
          this.content.className = "ace_content";
          this.scroller.appendChild(this.content);
          this.$gutterLayer = new GutterLayer(this.$gutter);
          this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));
          this.$markerBack = new MarkerLayer(this.content);
          var textLayer = this.$textLayer = new TextLayer(this.content);
          this.canvas = textLayer.element;
          this.$markerFront = new MarkerLayer(this.content);
          this.$cursorLayer = new CursorLayer(this.content);
          this.$horizScroll = false;
          this.$vScroll = false;
          this.scrollBar = this.scrollBarV = new VScrollBar(this.container, this);
          this.scrollBarH = new HScrollBar(this.container, this);
          this.scrollBarV.addEventListener("scroll", function(e) {
            if (!_self.$scrollAnimation)
              _self.session.setScrollTop(e.data - _self.scrollMargin.top);
          });
          this.scrollBarH.addEventListener("scroll", function(e) {
            if (!_self.$scrollAnimation)
              _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
          });
          this.scrollTop = 0;
          this.scrollLeft = 0;
          this.cursorPos = {
            row: 0,
            column: 0
          };
          this.$fontMetrics = new FontMetrics(this.container);
          this.$textLayer.$setFontMetrics(this.$fontMetrics);
          this.$textLayer.addEventListener("changeCharacterSize", function(e) {
            _self.updateCharacterSize();
            _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
            _self._signal("changeCharacterSize", e);
          });
          this.$size = {
            width: 0,
            height: 0,
            scrollerHeight: 0,
            scrollerWidth: 0,
            $dirty: true
          };
          this.layerConfig = {
            width: 1,
            padding: 0,
            firstRow: 0,
            firstRowScreen: 0,
            lastRow: 0,
            lineHeight: 0,
            characterWidth: 0,
            minHeight: 1,
            maxHeight: 1,
            offset: 0,
            height: 1,
            gutterOffset: 1
          };
          this.scrollMargin = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
            v: 0,
            h: 0
          };
          this.$loop = new RenderLoop(
            this.$renderChanges.bind(this),
            this.container.ownerDocument.defaultView
          );
          this.$loop.schedule(this.CHANGE_FULL);
          this.updateCharacterSize();
          this.setPadding(4);
          config.resetOptions(this);
          config._emit("renderer", this);
        };
        (function() {
          this.CHANGE_CURSOR = 1;
          this.CHANGE_MARKER = 2;
          this.CHANGE_GUTTER = 4;
          this.CHANGE_SCROLL = 8;
          this.CHANGE_LINES = 16;
          this.CHANGE_TEXT = 32;
          this.CHANGE_SIZE = 64;
          this.CHANGE_MARKER_BACK = 128;
          this.CHANGE_MARKER_FRONT = 256;
          this.CHANGE_FULL = 512;
          this.CHANGE_H_SCROLL = 1024;
          oop.implement(this, EventEmitter);
          this.updateCharacterSize = function() {
            if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
              this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
              this.setStyle("ace_nobold", !this.$allowBoldFonts);
            }
            this.layerConfig.characterWidth = this.characterWidth = this.$textLayer.getCharacterWidth();
            this.layerConfig.lineHeight = this.lineHeight = this.$textLayer.getLineHeight();
            this.$updatePrintMargin();
          };
          this.setSession = function(session) {
            if (this.session)
              this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
            this.session = session;
            if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
              session.setScrollTop(-this.scrollMargin.top);
            this.$cursorLayer.setSession(session);
            this.$markerBack.setSession(session);
            this.$markerFront.setSession(session);
            this.$gutterLayer.setSession(session);
            this.$textLayer.setSession(session);
            if (!session)
              return;
            this.$loop.schedule(this.CHANGE_FULL);
            this.session.$setFontMetrics(this.$fontMetrics);
            this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
            this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
            this.onChangeNewLineMode();
            this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
          };
          this.updateLines = function(firstRow, lastRow, force) {
            if (lastRow === void 0)
              lastRow = Infinity;
            if (!this.$changedLines) {
              this.$changedLines = {
                firstRow,
                lastRow
              };
            } else {
              if (this.$changedLines.firstRow > firstRow)
                this.$changedLines.firstRow = firstRow;
              if (this.$changedLines.lastRow < lastRow)
                this.$changedLines.lastRow = lastRow;
            }
            if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
              if (force)
                this.$changedLines.lastRow = this.layerConfig.lastRow;
              else
                return;
            }
            if (this.$changedLines.firstRow > this.layerConfig.lastRow)
              return;
            this.$loop.schedule(this.CHANGE_LINES);
          };
          this.onChangeNewLineMode = function() {
            this.$loop.schedule(this.CHANGE_TEXT);
            this.$textLayer.$updateEolChar();
            this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);
          };
          this.onChangeTabSize = function() {
            this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
            this.$textLayer.onChangeTabSize();
          };
          this.updateText = function() {
            this.$loop.schedule(this.CHANGE_TEXT);
          };
          this.updateFull = function(force) {
            if (force)
              this.$renderChanges(this.CHANGE_FULL, true);
            else
              this.$loop.schedule(this.CHANGE_FULL);
          };
          this.updateFontSize = function() {
            this.$textLayer.checkForSizeChanges();
          };
          this.$changes = 0;
          this.$updateSizeAsync = function() {
            if (this.$loop.pending)
              this.$size.$dirty = true;
            else
              this.onResize();
          };
          this.onResize = function(force, gutterWidth, width, height) {
            if (this.resizing > 2)
              return;
            else if (this.resizing > 0)
              this.resizing++;
            else
              this.resizing = force ? 1 : 0;
            var el = this.container;
            if (!height)
              height = el.clientHeight || el.scrollHeight;
            if (!width)
              width = el.clientWidth || el.scrollWidth;
            var changes = this.$updateCachedSize(force, gutterWidth, width, height);
            if (!this.$size.scrollerHeight || !width && !height)
              return this.resizing = 0;
            if (force)
              this.$gutterLayer.$padding = null;
            if (force)
              this.$renderChanges(changes | this.$changes, true);
            else
              this.$loop.schedule(changes | this.$changes);
            if (this.resizing)
              this.resizing = 0;
            this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;
          };
          this.$updateCachedSize = function(force, gutterWidth, width, height) {
            height -= this.$extraHeight || 0;
            var changes = 0;
            var size = this.$size;
            var oldSize = {
              width: size.width,
              height: size.height,
              scrollerHeight: size.scrollerHeight,
              scrollerWidth: size.scrollerWidth
            };
            if (height && (force || size.height != height)) {
              size.height = height;
              changes |= this.CHANGE_SIZE;
              size.scrollerHeight = size.height;
              if (this.$horizScroll)
                size.scrollerHeight -= this.scrollBarH.getHeight();
              this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";
              changes = changes | this.CHANGE_SCROLL;
            }
            if (width && (force || size.width != width)) {
              changes |= this.CHANGE_SIZE;
              size.width = width;
              if (gutterWidth == null)
                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
              this.gutterWidth = gutterWidth;
              this.scrollBarH.element.style.left = this.scroller.style.left = gutterWidth + "px";
              size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth());
              this.scrollBarH.element.style.right = this.scroller.style.right = this.scrollBarV.getWidth() + "px";
              this.scroller.style.bottom = this.scrollBarH.getHeight() + "px";
              if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force)
                changes |= this.CHANGE_FULL;
            }
            size.$dirty = !width || !height;
            if (changes)
              this._signal("resize", oldSize);
            return changes;
          };
          this.onGutterResize = function() {
            var gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
            if (gutterWidth != this.gutterWidth)
              this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);
            if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
              this.$loop.schedule(this.CHANGE_FULL);
            } else if (this.$size.$dirty) {
              this.$loop.schedule(this.CHANGE_FULL);
            } else {
              this.$computeLayerConfig();
              this.$loop.schedule(this.CHANGE_MARKER);
            }
          };
          this.adjustWrapLimit = function() {
            var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
            var limit = Math.floor(availableWidth / this.characterWidth);
            return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
          };
          this.setAnimatedScroll = function(shouldAnimate) {
            this.setOption("animatedScroll", shouldAnimate);
          };
          this.getAnimatedScroll = function() {
            return this.$animatedScroll;
          };
          this.setShowInvisibles = function(showInvisibles) {
            this.setOption("showInvisibles", showInvisibles);
            this.session.$bidiHandler.setShowInvisibles(showInvisibles);
          };
          this.getShowInvisibles = function() {
            return this.getOption("showInvisibles");
          };
          this.getDisplayIndentGuides = function() {
            return this.getOption("displayIndentGuides");
          };
          this.setDisplayIndentGuides = function(display) {
            this.setOption("displayIndentGuides", display);
          };
          this.setShowPrintMargin = function(showPrintMargin) {
            this.setOption("showPrintMargin", showPrintMargin);
          };
          this.getShowPrintMargin = function() {
            return this.getOption("showPrintMargin");
          };
          this.setPrintMarginColumn = function(showPrintMargin) {
            this.setOption("printMarginColumn", showPrintMargin);
          };
          this.getPrintMarginColumn = function() {
            return this.getOption("printMarginColumn");
          };
          this.getShowGutter = function() {
            return this.getOption("showGutter");
          };
          this.setShowGutter = function(show) {
            return this.setOption("showGutter", show);
          };
          this.getFadeFoldWidgets = function() {
            return this.getOption("fadeFoldWidgets");
          };
          this.setFadeFoldWidgets = function(show) {
            this.setOption("fadeFoldWidgets", show);
          };
          this.setHighlightGutterLine = function(shouldHighlight) {
            this.setOption("highlightGutterLine", shouldHighlight);
          };
          this.getHighlightGutterLine = function() {
            return this.getOption("highlightGutterLine");
          };
          this.$updateGutterLineHighlight = function() {
            var pos = this.$cursorLayer.$pixelPos;
            var height = this.layerConfig.lineHeight;
            if (this.session.getUseWrapMode()) {
              var cursor = this.session.selection.getCursor();
              cursor.column = 0;
              pos = this.$cursorLayer.getPixelPosition(cursor, true);
              height *= this.session.getRowLength(cursor.row);
            }
            this.$gutterLineHighlight.style.top = pos.top - this.layerConfig.offset + "px";
            this.$gutterLineHighlight.style.height = height + "px";
          };
          this.$updatePrintMargin = function() {
            if (!this.$showPrintMargin && !this.$printMarginEl)
              return;
            if (!this.$printMarginEl) {
              var containerEl = dom.createElement("div");
              containerEl.className = "ace_layer ace_print-margin-layer";
              this.$printMarginEl = dom.createElement("div");
              this.$printMarginEl.className = "ace_print-margin";
              containerEl.appendChild(this.$printMarginEl);
              this.content.insertBefore(containerEl, this.content.firstChild);
            }
            var style = this.$printMarginEl.style;
            style.left = this.characterWidth * this.$printMarginColumn + this.$padding + "px";
            style.visibility = this.$showPrintMargin ? "visible" : "hidden";
            if (this.session && this.session.$wrap == -1)
              this.adjustWrapLimit();
          };
          this.getContainerElement = function() {
            return this.container;
          };
          this.getMouseEventTarget = function() {
            return this.scroller;
          };
          this.getTextAreaContainer = function() {
            return this.container;
          };
          this.$moveTextAreaToCursor = function() {
            if (!this.$keepTextAreaAtCursor)
              return;
            var config2 = this.layerConfig;
            var posTop = this.$cursorLayer.$pixelPos.top;
            var posLeft = this.$cursorLayer.$pixelPos.left;
            posTop -= config2.offset;
            var style = this.textarea.style;
            var h = this.lineHeight;
            if (posTop < 0 || posTop > config2.height - h) {
              style.top = style.left = "0";
              return;
            }
            var w = this.characterWidth;
            if (this.$composition) {
              var val = this.textarea.value.replace(/^\x01+/, "");
              w *= this.session.$getStringScreenWidth(val)[0] + 2;
              h += 2;
            }
            posLeft -= this.scrollLeft;
            if (posLeft > this.$size.scrollerWidth - w)
              posLeft = this.$size.scrollerWidth - w;
            posLeft += this.gutterWidth;
            style.height = h + "px";
            style.width = w + "px";
            style.left = Math.min(posLeft, this.$size.scrollerWidth - w) + "px";
            style.top = Math.min(posTop, this.$size.height - h) + "px";
          };
          this.getFirstVisibleRow = function() {
            return this.layerConfig.firstRow;
          };
          this.getFirstFullyVisibleRow = function() {
            return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
          };
          this.getLastFullyVisibleRow = function() {
            var config2 = this.layerConfig;
            var lastRow = config2.lastRow;
            var top = this.session.documentToScreenRow(lastRow, 0) * config2.lineHeight;
            if (top - this.session.getScrollTop() > config2.height - config2.lineHeight)
              return lastRow - 1;
            return lastRow;
          };
          this.getLastVisibleRow = function() {
            return this.layerConfig.lastRow;
          };
          this.$padding = null;
          this.setPadding = function(padding) {
            this.$padding = padding;
            this.$textLayer.setPadding(padding);
            this.$cursorLayer.setPadding(padding);
            this.$markerFront.setPadding(padding);
            this.$markerBack.setPadding(padding);
            this.$loop.schedule(this.CHANGE_FULL);
            this.$updatePrintMargin();
          };
          this.setScrollMargin = function(top, bottom, left, right) {
            var sm = this.scrollMargin;
            sm.top = top | 0;
            sm.bottom = bottom | 0;
            sm.right = right | 0;
            sm.left = left | 0;
            sm.v = sm.top + sm.bottom;
            sm.h = sm.left + sm.right;
            if (sm.top && this.scrollTop <= 0 && this.session)
              this.session.setScrollTop(-sm.top);
            this.updateFull();
          };
          this.getHScrollBarAlwaysVisible = function() {
            return this.$hScrollBarAlwaysVisible;
          };
          this.setHScrollBarAlwaysVisible = function(alwaysVisible) {
            this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
          };
          this.getVScrollBarAlwaysVisible = function() {
            return this.$vScrollBarAlwaysVisible;
          };
          this.setVScrollBarAlwaysVisible = function(alwaysVisible) {
            this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
          };
          this.$updateScrollBarV = function() {
            var scrollHeight = this.layerConfig.maxHeight;
            var scrollerHeight = this.$size.scrollerHeight;
            if (!this.$maxLines && this.$scrollPastEnd) {
              scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
              if (this.scrollTop > scrollHeight - scrollerHeight) {
                scrollHeight = this.scrollTop + scrollerHeight;
                this.scrollBarV.scrollTop = null;
              }
            }
            this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
            this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
          };
          this.$updateScrollBarH = function() {
            this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
            this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
          };
          this.$frozen = false;
          this.freeze = function() {
            this.$frozen = true;
          };
          this.unfreeze = function() {
            this.$frozen = false;
          };
          this.$renderChanges = function(changes, force) {
            if (this.$changes) {
              changes |= this.$changes;
              this.$changes = 0;
            }
            if (!this.session || !this.container.offsetWidth || this.$frozen || !changes && !force) {
              this.$changes |= changes;
              return;
            }
            if (this.$size.$dirty) {
              this.$changes |= changes;
              return this.onResize(true);
            }
            if (!this.lineHeight) {
              this.$textLayer.checkForSizeChanges();
            }
            this._signal("beforeRender");
            if (this.session && this.session.$bidiHandler)
              this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);
            var config2 = this.layerConfig;
            if (changes & this.CHANGE_FULL || changes & this.CHANGE_SIZE || changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES || changes & this.CHANGE_SCROLL || changes & this.CHANGE_H_SCROLL) {
              changes |= this.$computeLayerConfig();
              if (config2.firstRow != this.layerConfig.firstRow && config2.firstRowScreen == this.layerConfig.firstRowScreen) {
                var st = this.scrollTop + (config2.firstRow - this.layerConfig.firstRow) * this.lineHeight;
                if (st > 0) {
                  this.scrollTop = st;
                  changes = changes | this.CHANGE_SCROLL;
                  changes |= this.$computeLayerConfig();
                }
              }
              config2 = this.layerConfig;
              this.$updateScrollBarV();
              if (changes & this.CHANGE_H_SCROLL)
                this.$updateScrollBarH();
              this.$gutterLayer.element.style.marginTop = -config2.offset + "px";
              this.content.style.marginTop = -config2.offset + "px";
              this.content.style.width = config2.width + 2 * this.$padding + "px";
              this.content.style.height = config2.minHeight + "px";
            }
            if (changes & this.CHANGE_H_SCROLL) {
              this.content.style.marginLeft = -this.scrollLeft + "px";
              this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
            }
            if (changes & this.CHANGE_FULL) {
              this.$textLayer.update(config2);
              if (this.$showGutter)
                this.$gutterLayer.update(config2);
              this.$markerBack.update(config2);
              this.$markerFront.update(config2);
              this.$cursorLayer.update(config2);
              this.$moveTextAreaToCursor();
              this.$highlightGutterLine && this.$updateGutterLineHighlight();
              this._signal("afterRender");
              return;
            }
            if (changes & this.CHANGE_SCROLL) {
              if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
                this.$textLayer.update(config2);
              else
                this.$textLayer.scrollLines(config2);
              if (this.$showGutter)
                this.$gutterLayer.update(config2);
              this.$markerBack.update(config2);
              this.$markerFront.update(config2);
              this.$cursorLayer.update(config2);
              this.$highlightGutterLine && this.$updateGutterLineHighlight();
              this.$moveTextAreaToCursor();
              this._signal("afterRender");
              return;
            }
            if (changes & this.CHANGE_TEXT) {
              this.$textLayer.update(config2);
              if (this.$showGutter)
                this.$gutterLayer.update(config2);
            } else if (changes & this.CHANGE_LINES) {
              if (this.$updateLines() || changes & this.CHANGE_GUTTER && this.$showGutter)
                this.$gutterLayer.update(config2);
            } else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
              if (this.$showGutter)
                this.$gutterLayer.update(config2);
            }
            if (changes & this.CHANGE_CURSOR) {
              this.$cursorLayer.update(config2);
              this.$moveTextAreaToCursor();
              this.$highlightGutterLine && this.$updateGutterLineHighlight();
            }
            if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
              this.$markerFront.update(config2);
            }
            if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
              this.$markerBack.update(config2);
            }
            this._signal("afterRender");
          };
          this.$autosize = function() {
            var height = this.session.getScreenLength() * this.lineHeight;
            var maxHeight = this.$maxLines * this.lineHeight;
            var desiredHeight = Math.min(
              maxHeight,
              Math.max((this.$minLines || 1) * this.lineHeight, height)
            ) + this.scrollMargin.v + (this.$extraHeight || 0);
            if (this.$horizScroll)
              desiredHeight += this.scrollBarH.getHeight();
            if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight)
              desiredHeight = this.$maxPixelHeight;
            var vScroll = height > maxHeight;
            if (desiredHeight != this.desiredHeight || this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
              if (vScroll != this.$vScroll) {
                this.$vScroll = vScroll;
                this.scrollBarV.setVisible(vScroll);
              }
              var w = this.container.clientWidth;
              this.container.style.height = desiredHeight + "px";
              this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
              this.desiredHeight = desiredHeight;
              this._signal("autosize");
            }
          };
          this.$computeLayerConfig = function() {
            var session = this.session;
            var size = this.$size;
            var hideScrollbars = size.height <= 2 * this.lineHeight;
            var screenLines = this.session.getScreenLength();
            var maxHeight = screenLines * this.lineHeight;
            var longestLine = this.$getLongestLine();
            var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible || size.scrollerWidth - longestLine - 2 * this.$padding < 0);
            var hScrollChanged = this.$horizScroll !== horizScroll;
            if (hScrollChanged) {
              this.$horizScroll = horizScroll;
              this.scrollBarH.setVisible(horizScroll);
            }
            var vScrollBefore = this.$vScroll;
            if (this.$maxLines && this.lineHeight > 1)
              this.$autosize();
            var offset = this.scrollTop % this.lineHeight;
            var minHeight = size.scrollerHeight + this.lineHeight;
            var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd : 0;
            maxHeight += scrollPastEnd;
            var sm = this.scrollMargin;
            this.session.setScrollTop(Math.max(
              -sm.top,
              Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)
            ));
            this.session.setScrollLeft(Math.max(-sm.left, Math.min(
              this.scrollLeft,
              longestLine + 2 * this.$padding - size.scrollerWidth + sm.right
            )));
            var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible || size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
            var vScrollChanged = vScrollBefore !== vScroll;
            if (vScrollChanged) {
              this.$vScroll = vScroll;
              this.scrollBarV.setVisible(vScroll);
            }
            var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
            var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
            var lastRow = firstRow + lineCount;
            var firstRowScreen, firstRowHeight;
            var lineHeight = this.lineHeight;
            firstRow = session.screenToDocumentRow(firstRow, 0);
            var foldLine = session.getFoldLine(firstRow);
            if (foldLine) {
              firstRow = foldLine.start.row;
            }
            firstRowScreen = session.documentToScreenRow(firstRow, 0);
            firstRowHeight = session.getRowLength(firstRow) * lineHeight;
            lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
            minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight + firstRowHeight;
            offset = this.scrollTop - firstRowScreen * lineHeight;
            var changes = 0;
            if (this.layerConfig.width != longestLine)
              changes = this.CHANGE_H_SCROLL;
            if (hScrollChanged || vScrollChanged) {
              changes = this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
              this._signal("scrollbarVisibilityChanged");
              if (vScrollChanged)
                longestLine = this.$getLongestLine();
            }
            this.layerConfig = {
              width: longestLine,
              padding: this.$padding,
              firstRow,
              firstRowScreen,
              lastRow,
              lineHeight,
              characterWidth: this.characterWidth,
              minHeight,
              maxHeight,
              offset,
              gutterOffset: lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
              height: this.$size.scrollerHeight
            };
            return changes;
          };
          this.$updateLines = function() {
            if (!this.$changedLines)
              return;
            var firstRow = this.$changedLines.firstRow;
            var lastRow = this.$changedLines.lastRow;
            this.$changedLines = null;
            var layerConfig = this.layerConfig;
            if (firstRow > layerConfig.lastRow + 1) {
              return;
            }
            if (lastRow < layerConfig.firstRow) {
              return;
            }
            if (lastRow === Infinity) {
              if (this.$showGutter)
                this.$gutterLayer.update(layerConfig);
              this.$textLayer.update(layerConfig);
              return;
            }
            this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
            return true;
          };
          this.$getLongestLine = function() {
            var charCount = this.session.getScreenWidth();
            if (this.showInvisibles && !this.session.$useWrapMode)
              charCount += 1;
            return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
          };
          this.updateFrontMarkers = function() {
            this.$markerFront.setMarkers(this.session.getMarkers(true));
            this.$loop.schedule(this.CHANGE_MARKER_FRONT);
          };
          this.updateBackMarkers = function() {
            this.$markerBack.setMarkers(this.session.getMarkers());
            this.$loop.schedule(this.CHANGE_MARKER_BACK);
          };
          this.addGutterDecoration = function(row, className) {
            this.$gutterLayer.addGutterDecoration(row, className);
          };
          this.removeGutterDecoration = function(row, className) {
            this.$gutterLayer.removeGutterDecoration(row, className);
          };
          this.updateBreakpoints = function(rows) {
            this.$loop.schedule(this.CHANGE_GUTTER);
          };
          this.setAnnotations = function(annotations) {
            this.$gutterLayer.setAnnotations(annotations);
            this.$loop.schedule(this.CHANGE_GUTTER);
          };
          this.updateCursor = function() {
            this.$loop.schedule(this.CHANGE_CURSOR);
          };
          this.hideCursor = function() {
            this.$cursorLayer.hideCursor();
          };
          this.showCursor = function() {
            this.$cursorLayer.showCursor();
          };
          this.scrollSelectionIntoView = function(anchor, lead, offset) {
            this.scrollCursorIntoView(anchor, offset);
            this.scrollCursorIntoView(lead, offset);
          };
          this.scrollCursorIntoView = function(cursor, offset, $viewMargin) {
            if (this.$size.scrollerHeight === 0)
              return;
            var pos = this.$cursorLayer.getPixelPosition(cursor);
            var left = pos.left;
            var top = pos.top;
            var topMargin = $viewMargin && $viewMargin.top || 0;
            var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
            var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
            if (scrollTop + topMargin > top) {
              if (offset && scrollTop + topMargin > top + this.lineHeight)
                top -= offset * this.$size.scrollerHeight;
              if (top === 0)
                top = -this.scrollMargin.top;
              this.session.setScrollTop(top);
            } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {
              if (offset && scrollTop + this.$size.scrollerHeight - bottomMargin < top - this.lineHeight)
                top += offset * this.$size.scrollerHeight;
              this.session.setScrollTop(top + this.lineHeight - this.$size.scrollerHeight);
            }
            var scrollLeft = this.scrollLeft;
            if (scrollLeft > left) {
              if (left < this.$padding + 2 * this.layerConfig.characterWidth)
                left = -this.scrollMargin.left;
              this.session.setScrollLeft(left);
            } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {
              this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
            } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {
              this.session.setScrollLeft(0);
            }
          };
          this.getScrollTop = function() {
            return this.session.getScrollTop();
          };
          this.getScrollLeft = function() {
            return this.session.getScrollLeft();
          };
          this.getScrollTopRow = function() {
            return this.scrollTop / this.lineHeight;
          };
          this.getScrollBottomRow = function() {
            return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
          };
          this.scrollToRow = function(row) {
            this.session.setScrollTop(row * this.lineHeight);
          };
          this.alignCursor = function(cursor, alignment) {
            if (typeof cursor == "number")
              cursor = { row: cursor, column: 0 };
            var pos = this.$cursorLayer.getPixelPosition(cursor);
            var h = this.$size.scrollerHeight - this.lineHeight;
            var offset = pos.top - h * (alignment || 0);
            this.session.setScrollTop(offset);
            return offset;
          };
          this.STEPS = 8;
          this.$calcSteps = function(fromValue, toValue) {
            var i = 0;
            var l = this.STEPS;
            var steps = [];
            var func = function(t, x_min, dx) {
              return dx * (Math.pow(t - 1, 3) + 1) + x_min;
            };
            for (i = 0; i < l; ++i)
              steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));
            return steps;
          };
          this.scrollToLine = function(line, center, animate, callback) {
            var pos = this.$cursorLayer.getPixelPosition({ row: line, column: 0 });
            var offset = pos.top;
            if (center)
              offset -= this.$size.scrollerHeight / 2;
            var initialScroll = this.scrollTop;
            this.session.setScrollTop(offset);
            if (animate !== false)
              this.animateScrolling(initialScroll, callback);
          };
          this.animateScrolling = function(fromValue, callback) {
            var toValue = this.scrollTop;
            if (!this.$animatedScroll)
              return;
            var _self = this;
            if (fromValue == toValue)
              return;
            if (this.$scrollAnimation) {
              var oldSteps = this.$scrollAnimation.steps;
              if (oldSteps.length) {
                fromValue = oldSteps[0];
                if (fromValue == toValue)
                  return;
              }
            }
            var steps = _self.$calcSteps(fromValue, toValue);
            this.$scrollAnimation = { from: fromValue, to: toValue, steps };
            clearInterval(this.$timer);
            _self.session.setScrollTop(steps.shift());
            _self.session.$scrollTop = toValue;
            this.$timer = setInterval(function() {
              if (steps.length) {
                _self.session.setScrollTop(steps.shift());
                _self.session.$scrollTop = toValue;
              } else if (toValue != null) {
                _self.session.$scrollTop = -1;
                _self.session.setScrollTop(toValue);
                toValue = null;
              } else {
                _self.$timer = clearInterval(_self.$timer);
                _self.$scrollAnimation = null;
                callback && callback();
              }
            }, 10);
          };
          this.scrollToY = function(scrollTop) {
            if (this.scrollTop !== scrollTop) {
              this.$loop.schedule(this.CHANGE_SCROLL);
              this.scrollTop = scrollTop;
            }
          };
          this.scrollToX = function(scrollLeft) {
            if (this.scrollLeft !== scrollLeft)
              this.scrollLeft = scrollLeft;
            this.$loop.schedule(this.CHANGE_H_SCROLL);
          };
          this.scrollTo = function(x, y) {
            this.session.setScrollTop(y);
            this.session.setScrollLeft(y);
          };
          this.scrollBy = function(deltaX, deltaY) {
            deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
            deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
          };
          this.isScrollableBy = function(deltaX, deltaY) {
            if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
              return true;
            if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
              return true;
            if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
              return true;
            if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth - this.layerConfig.width < -1 + this.scrollMargin.right)
              return true;
          };
          this.pixelToScreenCoordinates = function(x, y) {
            var canvasPos = this.scroller.getBoundingClientRect();
            var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
            var offset = offsetX / this.characterWidth;
            var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
            var col = Math.round(offset);
            return { row, column: col, side: offset - col > 0 ? 1 : -1, offsetX };
          };
          this.screenToTextCoordinates = function(x, y) {
            var canvasPos = this.scroller.getBoundingClientRect();
            var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
            var col = Math.round(offsetX / this.characterWidth);
            var row = (y + this.scrollTop - canvasPos.top) / this.lineHeight;
            return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);
          };
          this.textToScreenCoordinates = function(row, column) {
            var canvasPos = this.scroller.getBoundingClientRect();
            var pos = this.session.documentToScreenPosition(row, column);
            var x = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, row) ? this.session.$bidiHandler.getPosLeft(pos.column) : Math.round(pos.column * this.characterWidth));
            var y = pos.row * this.lineHeight;
            return {
              pageX: canvasPos.left + x - this.scrollLeft,
              pageY: canvasPos.top + y - this.scrollTop
            };
          };
          this.visualizeFocus = function() {
            dom.addCssClass(this.container, "ace_focus");
          };
          this.visualizeBlur = function() {
            dom.removeCssClass(this.container, "ace_focus");
          };
          this.showComposition = function(position) {
            if (!this.$composition)
              this.$composition = {
                keepTextAreaAtCursor: this.$keepTextAreaAtCursor,
                cssText: this.textarea.style.cssText
              };
            this.$keepTextAreaAtCursor = true;
            dom.addCssClass(this.textarea, "ace_composition");
            this.textarea.style.cssText = "";
            this.$moveTextAreaToCursor();
          };
          this.setCompositionText = function(text) {
            this.$moveTextAreaToCursor();
          };
          this.hideComposition = function() {
            if (!this.$composition)
              return;
            dom.removeCssClass(this.textarea, "ace_composition");
            this.$keepTextAreaAtCursor = this.$composition.keepTextAreaAtCursor;
            this.textarea.style.cssText = this.$composition.cssText;
            this.$composition = null;
          };
          this.setTheme = function(theme, cb) {
            var _self = this;
            this.$themeId = theme;
            _self._dispatchEvent("themeChange", { theme });
            if (!theme || typeof theme == "string") {
              var moduleName = theme || this.$options.theme.initialValue;
              config.loadModule(["theme", moduleName], afterLoad);
            } else {
              afterLoad(theme);
            }
            function afterLoad(module3) {
              if (_self.$themeId != theme)
                return cb && cb();
              if (!module3 || !module3.cssClass)
                throw new Error("couldn't load module " + theme + " or it didn't call define");
              dom.importCssString(
                module3.cssText,
                module3.cssClass,
                _self.container.ownerDocument
              );
              if (_self.theme)
                dom.removeCssClass(_self.container, _self.theme.cssClass);
              var padding = "padding" in module3 ? module3.padding : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
              if (_self.$padding && padding != _self.$padding)
                _self.setPadding(padding);
              _self.$theme = module3.cssClass;
              _self.theme = module3;
              dom.addCssClass(_self.container, module3.cssClass);
              dom.setCssClass(_self.container, "ace_dark", module3.isDark);
              if (_self.$size) {
                _self.$size.width = 0;
                _self.$updateSizeAsync();
              }
              _self._dispatchEvent("themeLoaded", { theme: module3 });
              cb && cb();
            }
          };
          this.getTheme = function() {
            return this.$themeId;
          };
          this.setStyle = function(style, include) {
            dom.setCssClass(this.container, style, include !== false);
          };
          this.unsetStyle = function(style) {
            dom.removeCssClass(this.container, style);
          };
          this.setCursorStyle = function(style) {
            if (this.scroller.style.cursor != style)
              this.scroller.style.cursor = style;
          };
          this.setMouseCursor = function(cursorStyle) {
            this.scroller.style.cursor = cursorStyle;
          };
          this.destroy = function() {
            this.$textLayer.destroy();
            this.$cursorLayer.destroy();
          };
        }).call(VirtualRenderer.prototype);
        config.defineOptions(VirtualRenderer.prototype, "renderer", {
          animatedScroll: { initialValue: false },
          showInvisibles: {
            set: function(value) {
              if (this.$textLayer.setShowInvisibles(value))
                this.$loop.schedule(this.CHANGE_TEXT);
            },
            initialValue: false
          },
          showPrintMargin: {
            set: function() {
              this.$updatePrintMargin();
            },
            initialValue: true
          },
          printMarginColumn: {
            set: function() {
              this.$updatePrintMargin();
            },
            initialValue: 80
          },
          printMargin: {
            set: function(val) {
              if (typeof val == "number")
                this.$printMarginColumn = val;
              this.$showPrintMargin = !!val;
              this.$updatePrintMargin();
            },
            get: function() {
              return this.$showPrintMargin && this.$printMarginColumn;
            }
          },
          showGutter: {
            set: function(show) {
              this.$gutter.style.display = show ? "block" : "none";
              this.$loop.schedule(this.CHANGE_FULL);
              this.onGutterResize();
            },
            initialValue: true
          },
          fadeFoldWidgets: {
            set: function(show) {
              dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
            },
            initialValue: false
          },
          showFoldWidgets: {
            set: function(show) {
              this.$gutterLayer.setShowFoldWidgets(show);
            },
            initialValue: true
          },
          showLineNumbers: {
            set: function(show) {
              this.$gutterLayer.setShowLineNumbers(show);
              this.$loop.schedule(this.CHANGE_GUTTER);
            },
            initialValue: true
          },
          displayIndentGuides: {
            set: function(show) {
              if (this.$textLayer.setDisplayIndentGuides(show))
                this.$loop.schedule(this.CHANGE_TEXT);
            },
            initialValue: true
          },
          highlightGutterLine: {
            set: function(shouldHighlight) {
              if (!this.$gutterLineHighlight) {
                this.$gutterLineHighlight = dom.createElement("div");
                this.$gutterLineHighlight.className = "ace_gutter-active-line";
                this.$gutter.appendChild(this.$gutterLineHighlight);
                return;
              }
              this.$gutterLineHighlight.style.display = shouldHighlight ? "" : "none";
              if (this.$cursorLayer.$pixelPos)
                this.$updateGutterLineHighlight();
            },
            initialValue: false,
            value: true
          },
          hScrollBarAlwaysVisible: {
            set: function(val) {
              if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
                this.$loop.schedule(this.CHANGE_SCROLL);
            },
            initialValue: false
          },
          vScrollBarAlwaysVisible: {
            set: function(val) {
              if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
                this.$loop.schedule(this.CHANGE_SCROLL);
            },
            initialValue: false
          },
          fontSize: {
            set: function(size) {
              if (typeof size == "number")
                size = size + "px";
              this.container.style.fontSize = size;
              this.updateFontSize();
            },
            initialValue: 12
          },
          fontFamily: {
            set: function(name) {
              this.container.style.fontFamily = name;
              this.updateFontSize();
            }
          },
          maxLines: {
            set: function(val) {
              this.updateFull();
            }
          },
          minLines: {
            set: function(val) {
              this.updateFull();
            }
          },
          maxPixelHeight: {
            set: function(val) {
              this.updateFull();
            },
            initialValue: 0
          },
          scrollPastEnd: {
            set: function(val) {
              val = +val || 0;
              if (this.$scrollPastEnd == val)
                return;
              this.$scrollPastEnd = val;
              this.$loop.schedule(this.CHANGE_SCROLL);
            },
            initialValue: 0,
            handlesSet: true
          },
          fixedWidthGutter: {
            set: function(val) {
              this.$gutterLayer.$fixedWidth = !!val;
              this.$loop.schedule(this.CHANGE_GUTTER);
            }
          },
          theme: {
            set: function(val) {
              this.setTheme(val);
            },
            get: function() {
              return this.$themeId || this.theme;
            },
            initialValue: "./theme/textmate",
            handlesSet: true
          }
        });
        exports2.VirtualRenderer = VirtualRenderer;
      });
      ace.define("ace/worker/worker_client", ["require", "exports", "module", "ace/lib/oop", "ace/lib/net", "ace/lib/event_emitter", "ace/config"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("../lib/oop");
        var net = acequire("../lib/net");
        var EventEmitter = acequire("../lib/event_emitter").EventEmitter;
        var config = acequire("../config");
        function $workerBlob(workerUrl, mod) {
          var script = mod.src;
          "importScripts('" + net.qualifyURL(workerUrl) + "');";
          try {
            return new Blob([script], { "type": "application/javascript" });
          } catch (e) {
            var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
            var blobBuilder = new BlobBuilder();
            blobBuilder.append(script);
            return blobBuilder.getBlob("application/javascript");
          }
        }
        function createWorker(workerUrl, mod) {
          var blob = $workerBlob(workerUrl, mod);
          var URL = window.URL || window.webkitURL;
          var blobURL = URL.createObjectURL(blob);
          return new Worker(blobURL);
        }
        var WorkerClient = function(topLevelNamespaces, mod, classname, workerUrl, importScripts) {
          this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
          this.changeListener = this.changeListener.bind(this);
          this.onMessage = this.onMessage.bind(this);
          if (acequire.nameToUrl && !acequire.toUrl)
            acequire.toUrl = acequire.nameToUrl;
          if (config.get("packaged") || !acequire.toUrl) {
            workerUrl = workerUrl || config.moduleUrl(mod.id, "worker");
          } else {
            var normalizePath = this.$normalizePath;
            workerUrl = workerUrl || normalizePath(acequire.toUrl("ace/worker/worker.js", null, "_"));
            var tlns = {};
            topLevelNamespaces.forEach(function(ns) {
              tlns[ns] = normalizePath(acequire.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
            });
          }
          this.$worker = createWorker(workerUrl, mod);
          if (importScripts) {
            this.send("importScripts", importScripts);
          }
          this.$worker.postMessage({
            init: true,
            tlns,
            module: mod.id,
            classname
          });
          this.callbackId = 1;
          this.callbacks = {};
          this.$worker.onmessage = this.onMessage;
        };
        (function() {
          oop.implement(this, EventEmitter);
          this.onMessage = function(e) {
            var msg = e.data;
            switch (msg.type) {
              case "event":
                this._signal(msg.name, { data: msg.data });
                break;
              case "call":
                var callback = this.callbacks[msg.id];
                if (callback) {
                  callback(msg.data);
                  delete this.callbacks[msg.id];
                }
                break;
              case "error":
                this.reportError(msg.data);
                break;
              case "log":
                window.console && console.log && console.log.apply(console, msg.data);
                break;
            }
          };
          this.reportError = function(err) {
            window.console && console.error && console.error(err);
          };
          this.$normalizePath = function(path) {
            return net.qualifyURL(path);
          };
          this.terminate = function() {
            this._signal("terminate", {});
            this.deltaQueue = null;
            this.$worker.terminate();
            this.$worker = null;
            if (this.$doc)
              this.$doc.off("change", this.changeListener);
            this.$doc = null;
          };
          this.send = function(cmd, args) {
            this.$worker.postMessage({ command: cmd, args });
          };
          this.call = function(cmd, args, callback) {
            if (callback) {
              var id = this.callbackId++;
              this.callbacks[id] = callback;
              args.push(id);
            }
            this.send(cmd, args);
          };
          this.emit = function(event, data) {
            try {
              this.$worker.postMessage({ event, data: { data: data.data } });
            } catch (ex) {
              console.error(ex.stack);
            }
          };
          this.attachToDocument = function(doc) {
            if (this.$doc)
              this.terminate();
            this.$doc = doc;
            this.call("setValue", [doc.getValue()]);
            doc.on("change", this.changeListener);
          };
          this.changeListener = function(delta) {
            if (!this.deltaQueue) {
              this.deltaQueue = [];
              setTimeout(this.$sendDeltaQueue, 0);
            }
            if (delta.action == "insert")
              this.deltaQueue.push(delta.start, delta.lines);
            else
              this.deltaQueue.push(delta.start, delta.end);
          };
          this.$sendDeltaQueue = function() {
            var q = this.deltaQueue;
            if (!q)
              return;
            this.deltaQueue = null;
            if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {
              this.call("setValue", [this.$doc.getValue()]);
            } else
              this.emit("change", { data: q });
          };
        }).call(WorkerClient.prototype);
        var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
          this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
          this.changeListener = this.changeListener.bind(this);
          this.callbackId = 1;
          this.callbacks = {};
          this.messageBuffer = [];
          var main = null;
          var emitSync = false;
          var sender = Object.create(EventEmitter);
          var _self = this;
          this.$worker = {};
          this.$worker.terminate = function() {
          };
          this.$worker.postMessage = function(e) {
            _self.messageBuffer.push(e);
            if (main) {
              if (emitSync)
                setTimeout(processNext);
              else
                processNext();
            }
          };
          this.setEmitSync = function(val) {
            emitSync = val;
          };
          var processNext = function() {
            var msg = _self.messageBuffer.shift();
            if (msg.command)
              main[msg.command].apply(main, msg.args);
            else if (msg.event)
              sender._signal(msg.event, msg.data);
          };
          sender.postMessage = function(msg) {
            _self.onMessage({ data: msg });
          };
          sender.callback = function(data, callbackId) {
            this.postMessage({ type: "call", id: callbackId, data });
          };
          sender.emit = function(name, data) {
            this.postMessage({ type: "event", name, data });
          };
          config.loadModule(["worker", mod], function(Main) {
            main = new Main[classname](sender);
            while (_self.messageBuffer.length)
              processNext();
          });
        };
        UIWorkerClient.prototype = WorkerClient.prototype;
        exports2.UIWorkerClient = UIWorkerClient;
        exports2.WorkerClient = WorkerClient;
        exports2.createWorker = createWorker;
      });
      ace.define("ace/placeholder", ["require", "exports", "module", "ace/range", "ace/lib/event_emitter", "ace/lib/oop"], function(acequire, exports2, module2) {
        "use strict";
        var Range = acequire("./range").Range;
        var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
        var oop = acequire("./lib/oop");
        var PlaceHolder = function(session, length, pos, others, mainClass, othersClass) {
          var _self = this;
          this.length = length;
          this.session = session;
          this.doc = session.getDocument();
          this.mainClass = mainClass;
          this.othersClass = othersClass;
          this.$onUpdate = this.onUpdate.bind(this);
          this.doc.on("change", this.$onUpdate);
          this.$others = others;
          this.$onCursorChange = function() {
            setTimeout(function() {
              _self.onCursorChange();
            });
          };
          this.$pos = pos;
          var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || { length: -1 };
          this.$undoStackDepth = undoStack.length;
          this.setup();
          session.selection.on("changeCursor", this.$onCursorChange);
        };
        (function() {
          oop.implement(this, EventEmitter);
          this.setup = function() {
            var _self = this;
            var doc = this.doc;
            var session = this.session;
            this.selectionBefore = session.selection.toJSON();
            if (session.selection.inMultiSelectMode)
              session.selection.toSingleRange();
            this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
            var pos = this.pos;
            pos.$insertRight = true;
            pos.detach();
            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
            this.others = [];
            this.$others.forEach(function(other) {
              var anchor = doc.createAnchor(other.row, other.column);
              anchor.$insertRight = true;
              anchor.detach();
              _self.others.push(anchor);
            });
            session.setUndoSelect(false);
          };
          this.showOtherMarkers = function() {
            if (this.othersActive)
              return;
            var session = this.session;
            var _self = this;
            this.othersActive = true;
            this.others.forEach(function(anchor) {
              anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column + _self.length), _self.othersClass, null, false);
            });
          };
          this.hideOtherMarkers = function() {
            if (!this.othersActive)
              return;
            this.othersActive = false;
            for (var i = 0; i < this.others.length; i++) {
              this.session.removeMarker(this.others[i].markerId);
            }
          };
          this.onUpdate = function(delta) {
            if (this.$updating)
              return this.updateAnchors(delta);
            var range = delta;
            if (range.start.row !== range.end.row)
              return;
            if (range.start.row !== this.pos.row)
              return;
            this.$updating = true;
            var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
            var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
            var distanceFromStart = range.start.column - this.pos.column;
            this.updateAnchors(delta);
            if (inMainRange)
              this.length += lengthDiff;
            if (inMainRange && !this.session.$fromUndo) {
              if (delta.action === "insert") {
                for (var i = this.others.length - 1; i >= 0; i--) {
                  var otherPos = this.others[i];
                  var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
                  this.doc.insertMergedLines(newPos, delta.lines);
                }
              } else if (delta.action === "remove") {
                for (var i = this.others.length - 1; i >= 0; i--) {
                  var otherPos = this.others[i];
                  var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
                  this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                }
              }
            }
            this.$updating = false;
            this.updateMarkers();
          };
          this.updateAnchors = function(delta) {
            this.pos.onChange(delta);
            for (var i = this.others.length; i--; )
              this.others[i].onChange(delta);
            this.updateMarkers();
          };
          this.updateMarkers = function() {
            if (this.$updating)
              return;
            var _self = this;
            var session = this.session;
            var updateMarker = function(pos, className) {
              session.removeMarker(pos.markerId);
              pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + _self.length), className, null, false);
            };
            updateMarker(this.pos, this.mainClass);
            for (var i = this.others.length; i--; )
              updateMarker(this.others[i], this.othersClass);
          };
          this.onCursorChange = function(event) {
            if (this.$updating || !this.session)
              return;
            var pos = this.session.selection.getCursor();
            if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
              this.showOtherMarkers();
              this._emit("cursorEnter", event);
            } else {
              this.hideOtherMarkers();
              this._emit("cursorLeave", event);
            }
          };
          this.detach = function() {
            this.session.removeMarker(this.pos && this.pos.markerId);
            this.hideOtherMarkers();
            this.doc.removeEventListener("change", this.$onUpdate);
            this.session.selection.removeEventListener("changeCursor", this.$onCursorChange);
            this.session.setUndoSelect(true);
            this.session = null;
          };
          this.cancel = function() {
            if (this.$undoStackDepth === -1)
              return;
            var undoManager = this.session.getUndoManager();
            var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
            for (var i = 0; i < undosRequired; i++) {
              undoManager.undo(true);
            }
            if (this.selectionBefore)
              this.session.selection.fromJSON(this.selectionBefore);
          };
        }).call(PlaceHolder.prototype);
        exports2.PlaceHolder = PlaceHolder;
      });
      ace.define("ace/mouse/multi_select_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function(acequire, exports2, module2) {
        var event = acequire("../lib/event");
        var useragent = acequire("../lib/useragent");
        function isSamePoint(p1, p2) {
          return p1.row == p2.row && p1.column == p2.column;
        }
        function onMouseDown(e) {
          var ev = e.domEvent;
          var alt = ev.altKey;
          var shift = ev.shiftKey;
          var ctrl = ev.ctrlKey;
          var accel = e.getAccelKey();
          var button = e.getButton();
          if (ctrl && useragent.isMac)
            button = ev.button;
          if (e.editor.inMultiSelectMode && button == 2) {
            e.editor.textInput.onContextMenu(e.domEvent);
            return;
          }
          if (!ctrl && !alt && !accel) {
            if (button === 0 && e.editor.inMultiSelectMode)
              e.editor.exitMultiSelectMode();
            return;
          }
          if (button !== 0)
            return;
          var editor = e.editor;
          var selection = editor.selection;
          var isMultiSelect = editor.inMultiSelectMode;
          var pos = e.getDocumentPosition();
          var cursor = selection.getCursor();
          var inSelection = e.inSelection() || selection.isEmpty() && isSamePoint(pos, cursor);
          var mouseX = e.x, mouseY = e.y;
          var onMouseSelection = function(e2) {
            mouseX = e2.clientX;
            mouseY = e2.clientY;
          };
          var session = editor.session;
          var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
          var screenCursor = screenAnchor;
          var selectionMode;
          if (editor.$mouseHandler.$enableJumpToDef) {
            if (ctrl && alt || accel && alt)
              selectionMode = shift ? "block" : "add";
            else if (alt && editor.$blockSelectEnabled)
              selectionMode = "block";
          } else {
            if (accel && !alt) {
              selectionMode = "add";
              if (!isMultiSelect && shift)
                return;
            } else if (alt && editor.$blockSelectEnabled) {
              selectionMode = "block";
            }
          }
          if (selectionMode && useragent.isMac && ev.ctrlKey) {
            editor.$mouseHandler.cancelContextMenu();
          }
          if (selectionMode == "add") {
            if (!isMultiSelect && inSelection)
              return;
            if (!isMultiSelect) {
              var range = selection.toOrientedRange();
              editor.addSelectionMarker(range);
            }
            var oldRange = selection.rangeList.rangeAtPoint(pos);
            editor.$blockScrolling++;
            editor.inVirtualSelectionMode = true;
            if (shift) {
              oldRange = null;
              range = selection.ranges[0] || range;
              editor.removeSelectionMarker(range);
            }
            editor.once("mouseup", function() {
              var tmpSel = selection.toOrientedRange();
              if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
                selection.substractPoint(tmpSel.cursor);
              else {
                if (shift) {
                  selection.substractPoint(range.cursor);
                } else if (range) {
                  editor.removeSelectionMarker(range);
                  selection.addRange(range);
                }
                selection.addRange(tmpSel);
              }
              editor.$blockScrolling--;
              editor.inVirtualSelectionMode = false;
            });
          } else if (selectionMode == "block") {
            e.stop();
            editor.inVirtualSelectionMode = true;
            var initialRange;
            var rectSel = [];
            var blockSelect = function() {
              var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
              var cursor2 = session.screenToDocumentPosition(newCursor.row, newCursor.column, newCursor.offsetX);
              if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor2, selection.lead))
                return;
              screenCursor = newCursor;
              editor.$blockScrolling++;
              editor.selection.moveToPosition(cursor2);
              editor.renderer.scrollCursorIntoView();
              editor.removeSelectionMarkers(rectSel);
              rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
              if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
                rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
              rectSel.forEach(editor.addSelectionMarker, editor);
              editor.updateSelectionMarkers();
              editor.$blockScrolling--;
            };
            editor.$blockScrolling++;
            if (isMultiSelect && !accel) {
              selection.toSingleRange();
            } else if (!isMultiSelect && accel) {
              initialRange = selection.toOrientedRange();
              editor.addSelectionMarker(initialRange);
            }
            if (shift)
              screenAnchor = session.documentToScreenPosition(selection.lead);
            else
              selection.moveToPosition(pos);
            editor.$blockScrolling--;
            screenCursor = { row: -1, column: -1 };
            var onMouseSelectionEnd = function(e2) {
              clearInterval(timerId);
              editor.removeSelectionMarkers(rectSel);
              if (!rectSel.length)
                rectSel = [selection.toOrientedRange()];
              editor.$blockScrolling++;
              if (initialRange) {
                editor.removeSelectionMarker(initialRange);
                selection.toSingleRange(initialRange);
              }
              for (var i = 0; i < rectSel.length; i++)
                selection.addRange(rectSel[i]);
              editor.inVirtualSelectionMode = false;
              editor.$mouseHandler.$clickSelection = null;
              editor.$blockScrolling--;
            };
            var onSelectionInterval = blockSelect;
            event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
            var timerId = setInterval(function() {
              onSelectionInterval();
            }, 20);
            return e.preventDefault();
          }
        }
        exports2.onMouseDown = onMouseDown;
      });
      ace.define("ace/commands/multi_select_commands", ["require", "exports", "module", "ace/keyboard/hash_handler"], function(acequire, exports2, module2) {
        exports2.defaultCommands = [{
          name: "addCursorAbove",
          exec: function(editor) {
            editor.selectMoreLines(-1);
          },
          bindKey: { win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up" },
          scrollIntoView: "cursor",
          readOnly: true
        }, {
          name: "addCursorBelow",
          exec: function(editor) {
            editor.selectMoreLines(1);
          },
          bindKey: { win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down" },
          scrollIntoView: "cursor",
          readOnly: true
        }, {
          name: "addCursorAboveSkipCurrent",
          exec: function(editor) {
            editor.selectMoreLines(-1, true);
          },
          bindKey: { win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up" },
          scrollIntoView: "cursor",
          readOnly: true
        }, {
          name: "addCursorBelowSkipCurrent",
          exec: function(editor) {
            editor.selectMoreLines(1, true);
          },
          bindKey: { win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down" },
          scrollIntoView: "cursor",
          readOnly: true
        }, {
          name: "selectMoreBefore",
          exec: function(editor) {
            editor.selectMore(-1);
          },
          bindKey: { win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left" },
          scrollIntoView: "cursor",
          readOnly: true
        }, {
          name: "selectMoreAfter",
          exec: function(editor) {
            editor.selectMore(1);
          },
          bindKey: { win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right" },
          scrollIntoView: "cursor",
          readOnly: true
        }, {
          name: "selectNextBefore",
          exec: function(editor) {
            editor.selectMore(-1, true);
          },
          bindKey: { win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left" },
          scrollIntoView: "cursor",
          readOnly: true
        }, {
          name: "selectNextAfter",
          exec: function(editor) {
            editor.selectMore(1, true);
          },
          bindKey: { win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right" },
          scrollIntoView: "cursor",
          readOnly: true
        }, {
          name: "splitIntoLines",
          exec: function(editor) {
            editor.multiSelect.splitIntoLines();
          },
          bindKey: { win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L" },
          readOnly: true
        }, {
          name: "alignCursors",
          exec: function(editor) {
            editor.alignCursors();
          },
          bindKey: { win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A" },
          scrollIntoView: "cursor"
        }, {
          name: "findAll",
          exec: function(editor) {
            editor.findAll();
          },
          bindKey: { win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G" },
          scrollIntoView: "cursor",
          readOnly: true
        }];
        exports2.multiSelectCommands = [{
          name: "singleSelection",
          bindKey: "esc",
          exec: function(editor) {
            editor.exitMultiSelectMode();
          },
          scrollIntoView: "cursor",
          readOnly: true,
          isAvailable: function(editor) {
            return editor && editor.inMultiSelectMode;
          }
        }];
        var HashHandler = acequire("../keyboard/hash_handler").HashHandler;
        exports2.keyboardHandler = new HashHandler(exports2.multiSelectCommands);
      });
      ace.define("ace/multi_select", ["require", "exports", "module", "ace/range_list", "ace/range", "ace/selection", "ace/mouse/multi_select_handler", "ace/lib/event", "ace/lib/lang", "ace/commands/multi_select_commands", "ace/search", "ace/edit_session", "ace/editor", "ace/config"], function(acequire, exports2, module2) {
        var RangeList = acequire("./range_list").RangeList;
        var Range = acequire("./range").Range;
        var Selection = acequire("./selection").Selection;
        var onMouseDown = acequire("./mouse/multi_select_handler").onMouseDown;
        var event = acequire("./lib/event");
        var lang = acequire("./lib/lang");
        var commands = acequire("./commands/multi_select_commands");
        exports2.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
        var Search = acequire("./search").Search;
        var search = new Search();
        function find(session, needle, dir) {
          search.$options.wrap = true;
          search.$options.needle = needle;
          search.$options.backwards = dir == -1;
          return search.find(session);
        }
        var EditSession = acequire("./edit_session").EditSession;
        (function() {
          this.getSelectionMarkers = function() {
            return this.$selectionMarkers;
          };
        }).call(EditSession.prototype);
        (function() {
          this.ranges = null;
          this.rangeList = null;
          this.addRange = function(range, $blockChangeEvents) {
            if (!range)
              return;
            if (!this.inMultiSelectMode && this.rangeCount === 0) {
              var oldRange = this.toOrientedRange();
              this.rangeList.add(oldRange);
              this.rangeList.add(range);
              if (this.rangeList.ranges.length != 2) {
                this.rangeList.removeAll();
                return $blockChangeEvents || this.fromOrientedRange(range);
              }
              this.rangeList.removeAll();
              this.rangeList.add(oldRange);
              this.$onAddRange(oldRange);
            }
            if (!range.cursor)
              range.cursor = range.end;
            var removed = this.rangeList.add(range);
            this.$onAddRange(range);
            if (removed.length)
              this.$onRemoveRange(removed);
            if (this.rangeCount > 1 && !this.inMultiSelectMode) {
              this._signal("multiSelect");
              this.inMultiSelectMode = true;
              this.session.$undoSelect = false;
              this.rangeList.attach(this.session);
            }
            return $blockChangeEvents || this.fromOrientedRange(range);
          };
          this.toSingleRange = function(range) {
            range = range || this.ranges[0];
            var removed = this.rangeList.removeAll();
            if (removed.length)
              this.$onRemoveRange(removed);
            range && this.fromOrientedRange(range);
          };
          this.substractPoint = function(pos) {
            var removed = this.rangeList.substractPoint(pos);
            if (removed) {
              this.$onRemoveRange(removed);
              return removed[0];
            }
          };
          this.mergeOverlappingRanges = function() {
            var removed = this.rangeList.merge();
            if (removed.length)
              this.$onRemoveRange(removed);
            else if (this.ranges[0])
              this.fromOrientedRange(this.ranges[0]);
          };
          this.$onAddRange = function(range) {
            this.rangeCount = this.rangeList.ranges.length;
            this.ranges.unshift(range);
            this._signal("addRange", { range });
          };
          this.$onRemoveRange = function(removed) {
            this.rangeCount = this.rangeList.ranges.length;
            if (this.rangeCount == 1 && this.inMultiSelectMode) {
              var lastRange = this.rangeList.ranges.pop();
              removed.push(lastRange);
              this.rangeCount = 0;
            }
            for (var i = removed.length; i--; ) {
              var index = this.ranges.indexOf(removed[i]);
              this.ranges.splice(index, 1);
            }
            this._signal("removeRange", { ranges: removed });
            if (this.rangeCount === 0 && this.inMultiSelectMode) {
              this.inMultiSelectMode = false;
              this._signal("singleSelect");
              this.session.$undoSelect = true;
              this.rangeList.detach(this.session);
            }
            lastRange = lastRange || this.ranges[0];
            if (lastRange && !lastRange.isEqual(this.getRange()))
              this.fromOrientedRange(lastRange);
          };
          this.$initRangeList = function() {
            if (this.rangeList)
              return;
            this.rangeList = new RangeList();
            this.ranges = [];
            this.rangeCount = 0;
          };
          this.getAllRanges = function() {
            return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
          };
          this.splitIntoLines = function() {
            if (this.rangeCount > 1) {
              var ranges = this.rangeList.ranges;
              var lastRange = ranges[ranges.length - 1];
              var range = Range.fromPoints(ranges[0].start, lastRange.end);
              this.toSingleRange();
              this.setSelectionRange(range, lastRange.cursor == lastRange.start);
            } else {
              var range = this.getRange();
              var isBackwards = this.isBackwards();
              var startRow = range.start.row;
              var endRow = range.end.row;
              if (startRow == endRow) {
                if (isBackwards)
                  var start = range.end, end = range.start;
                else
                  var start = range.start, end = range.end;
                this.addRange(Range.fromPoints(end, end));
                this.addRange(Range.fromPoints(start, start));
                return;
              }
              var rectSel = [];
              var r = this.getLineRange(startRow, true);
              r.start.column = range.start.column;
              rectSel.push(r);
              for (var i = startRow + 1; i < endRow; i++)
                rectSel.push(this.getLineRange(i, true));
              r = this.getLineRange(endRow, true);
              r.end.column = range.end.column;
              rectSel.push(r);
              rectSel.forEach(this.addRange, this);
            }
          };
          this.toggleBlockSelection = function() {
            if (this.rangeCount > 1) {
              var ranges = this.rangeList.ranges;
              var lastRange = ranges[ranges.length - 1];
              var range = Range.fromPoints(ranges[0].start, lastRange.end);
              this.toSingleRange();
              this.setSelectionRange(range, lastRange.cursor == lastRange.start);
            } else {
              var cursor = this.session.documentToScreenPosition(this.selectionLead);
              var anchor = this.session.documentToScreenPosition(this.selectionAnchor);
              var rectSel = this.rectangularRangeBlock(cursor, anchor);
              rectSel.forEach(this.addRange, this);
            }
          };
          this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
            var rectSel = [];
            var xBackwards = screenCursor.column < screenAnchor.column;
            if (xBackwards) {
              var startColumn = screenCursor.column;
              var endColumn = screenAnchor.column;
              var startOffsetX = screenCursor.offsetX;
              var endOffsetX = screenAnchor.offsetX;
            } else {
              var startColumn = screenAnchor.column;
              var endColumn = screenCursor.column;
              var startOffsetX = screenAnchor.offsetX;
              var endOffsetX = screenCursor.offsetX;
            }
            var yBackwards = screenCursor.row < screenAnchor.row;
            if (yBackwards) {
              var startRow = screenCursor.row;
              var endRow = screenAnchor.row;
            } else {
              var startRow = screenAnchor.row;
              var endRow = screenCursor.row;
            }
            if (startColumn < 0)
              startColumn = 0;
            if (startRow < 0)
              startRow = 0;
            if (startRow == endRow)
              includeEmptyLines = true;
            for (var row = startRow; row <= endRow; row++) {
              var range = Range.fromPoints(
                this.session.screenToDocumentPosition(row, startColumn, startOffsetX),
                this.session.screenToDocumentPosition(row, endColumn, endOffsetX)
              );
              if (range.isEmpty()) {
                if (docEnd && isSamePoint(range.end, docEnd))
                  break;
                var docEnd = range.end;
              }
              range.cursor = xBackwards ? range.start : range.end;
              rectSel.push(range);
            }
            if (yBackwards)
              rectSel.reverse();
            if (!includeEmptyLines) {
              var end = rectSel.length - 1;
              while (rectSel[end].isEmpty() && end > 0)
                end--;
              if (end > 0) {
                var start = 0;
                while (rectSel[start].isEmpty())
                  start++;
              }
              for (var i = end; i >= start; i--) {
                if (rectSel[i].isEmpty())
                  rectSel.splice(i, 1);
              }
            }
            return rectSel;
          };
        }).call(Selection.prototype);
        var Editor = acequire("./editor").Editor;
        (function() {
          this.updateSelectionMarkers = function() {
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
          };
          this.addSelectionMarker = function(orientedRange) {
            if (!orientedRange.cursor)
              orientedRange.cursor = orientedRange.end;
            var style = this.getSelectionStyle();
            orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);
            this.session.$selectionMarkers.push(orientedRange);
            this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
            return orientedRange;
          };
          this.removeSelectionMarker = function(range) {
            if (!range.marker)
              return;
            this.session.removeMarker(range.marker);
            var index = this.session.$selectionMarkers.indexOf(range);
            if (index != -1)
              this.session.$selectionMarkers.splice(index, 1);
            this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
          };
          this.removeSelectionMarkers = function(ranges) {
            var markerList = this.session.$selectionMarkers;
            for (var i = ranges.length; i--; ) {
              var range = ranges[i];
              if (!range.marker)
                continue;
              this.session.removeMarker(range.marker);
              var index = markerList.indexOf(range);
              if (index != -1)
                markerList.splice(index, 1);
            }
            this.session.selectionMarkerCount = markerList.length;
          };
          this.$onAddRange = function(e) {
            this.addSelectionMarker(e.range);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
          };
          this.$onRemoveRange = function(e) {
            this.removeSelectionMarkers(e.ranges);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
          };
          this.$onMultiSelect = function(e) {
            if (this.inMultiSelectMode)
              return;
            this.inMultiSelectMode = true;
            this.setStyle("ace_multiselect");
            this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
            this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
          };
          this.$onSingleSelect = function(e) {
            if (this.session.multiSelect.inVirtualMode)
              return;
            this.inMultiSelectMode = false;
            this.unsetStyle("ace_multiselect");
            this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);
            this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
            this._emit("changeSelection");
          };
          this.$onMultiSelectExec = function(e) {
            var command = e.command;
            var editor = e.editor;
            if (!editor.multiSelect)
              return;
            if (!command.multiSelectAction) {
              var result = command.exec(editor, e.args || {});
              editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
              editor.multiSelect.mergeOverlappingRanges();
            } else if (command.multiSelectAction == "forEach") {
              result = editor.forEachSelection(command, e.args);
            } else if (command.multiSelectAction == "forEachLine") {
              result = editor.forEachSelection(command, e.args, true);
            } else if (command.multiSelectAction == "single") {
              editor.exitMultiSelectMode();
              result = command.exec(editor, e.args || {});
            } else {
              result = command.multiSelectAction(editor, e.args || {});
            }
            return result;
          };
          this.forEachSelection = function(cmd, args, options) {
            if (this.inVirtualSelectionMode)
              return;
            var keepOrder = options && options.keepOrder;
            var $byLines = options == true || options && options.$byLines;
            var session = this.session;
            var selection = this.selection;
            var rangeList = selection.rangeList;
            var ranges = (keepOrder ? selection : rangeList).ranges;
            var result;
            if (!ranges.length)
              return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
            var reg = selection._eventRegistry;
            selection._eventRegistry = {};
            var tmpSel = new Selection(session);
            this.inVirtualSelectionMode = true;
            for (var i = ranges.length; i--; ) {
              if ($byLines) {
                while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)
                  i--;
              }
              tmpSel.fromOrientedRange(ranges[i]);
              tmpSel.index = i;
              this.selection = session.selection = tmpSel;
              var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
              if (!result && cmdResult !== void 0)
                result = cmdResult;
              tmpSel.toOrientedRange(ranges[i]);
            }
            tmpSel.detach();
            this.selection = session.selection = selection;
            this.inVirtualSelectionMode = false;
            selection._eventRegistry = reg;
            selection.mergeOverlappingRanges();
            var anim = this.renderer.$scrollAnimation;
            this.onCursorChange();
            this.onSelectionChange();
            if (anim && anim.from == anim.to)
              this.renderer.animateScrolling(anim.from);
            return result;
          };
          this.exitMultiSelectMode = function() {
            if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
              return;
            this.multiSelect.toSingleRange();
          };
          this.getSelectedText = function() {
            var text = "";
            if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
              var ranges = this.multiSelect.rangeList.ranges;
              var buf = [];
              for (var i = 0; i < ranges.length; i++) {
                buf.push(this.session.getTextRange(ranges[i]));
              }
              var nl = this.session.getDocument().getNewLineCharacter();
              text = buf.join(nl);
              if (text.length == (buf.length - 1) * nl.length)
                text = "";
            } else if (!this.selection.isEmpty()) {
              text = this.session.getTextRange(this.getSelectionRange());
            }
            return text;
          };
          this.$checkMultiselectChange = function(e, anchor) {
            if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
              var range = this.multiSelect.ranges[0];
              if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
                return;
              var pos = anchor == this.multiSelect.anchor ? range.cursor == range.start ? range.end : range.start : range.cursor;
              if (pos.row != anchor.row || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
                this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
            }
          };
          this.findAll = function(needle, options, additive) {
            options = options || {};
            options.needle = needle || options.needle;
            if (options.needle == void 0) {
              var range = this.selection.isEmpty() ? this.selection.getWordRange() : this.selection.getRange();
              options.needle = this.session.getTextRange(range);
            }
            this.$search.set(options);
            var ranges = this.$search.findAll(this.session);
            if (!ranges.length)
              return 0;
            this.$blockScrolling += 1;
            var selection = this.multiSelect;
            if (!additive)
              selection.toSingleRange(ranges[0]);
            for (var i = ranges.length; i--; )
              selection.addRange(ranges[i], true);
            if (range && selection.rangeList.rangeAtPoint(range.start))
              selection.addRange(range, true);
            this.$blockScrolling -= 1;
            return ranges.length;
          };
          this.selectMoreLines = function(dir, skip) {
            var range = this.selection.toOrientedRange();
            var isBackwards = range.cursor == range.end;
            var screenLead = this.session.documentToScreenPosition(range.cursor);
            if (this.selection.$desiredColumn)
              screenLead.column = this.selection.$desiredColumn;
            var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);
            if (!range.isEmpty()) {
              var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
              var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
            } else {
              var anchor = lead;
            }
            if (isBackwards) {
              var newRange = Range.fromPoints(lead, anchor);
              newRange.cursor = newRange.start;
            } else {
              var newRange = Range.fromPoints(anchor, lead);
              newRange.cursor = newRange.end;
            }
            newRange.desiredColumn = screenLead.column;
            if (!this.selection.inMultiSelectMode) {
              this.selection.addRange(range);
            } else {
              if (skip)
                var toRemove = range.cursor;
            }
            this.selection.addRange(newRange);
            if (toRemove)
              this.selection.substractPoint(toRemove);
          };
          this.transposeSelections = function(dir) {
            var session = this.session;
            var sel = session.multiSelect;
            var all = sel.ranges;
            for (var i = all.length; i--; ) {
              var range = all[i];
              if (range.isEmpty()) {
                var tmp = session.getWordRange(range.start.row, range.start.column);
                range.start.row = tmp.start.row;
                range.start.column = tmp.start.column;
                range.end.row = tmp.end.row;
                range.end.column = tmp.end.column;
              }
            }
            sel.mergeOverlappingRanges();
            var words = [];
            for (var i = all.length; i--; ) {
              var range = all[i];
              words.unshift(session.getTextRange(range));
            }
            if (dir < 0)
              words.unshift(words.pop());
            else
              words.push(words.shift());
            for (var i = all.length; i--; ) {
              var range = all[i];
              var tmp = range.clone();
              session.replace(range, words[i]);
              range.start.row = tmp.start.row;
              range.start.column = tmp.start.column;
            }
          };
          this.selectMore = function(dir, skip, stopAtFirst) {
            var session = this.session;
            var sel = session.multiSelect;
            var range = sel.toOrientedRange();
            if (range.isEmpty()) {
              range = session.getWordRange(range.start.row, range.start.column);
              range.cursor = dir == -1 ? range.start : range.end;
              this.multiSelect.addRange(range);
              if (stopAtFirst)
                return;
            }
            var needle = session.getTextRange(range);
            var newRange = find(session, needle, dir);
            if (newRange) {
              newRange.cursor = dir == -1 ? newRange.start : newRange.end;
              this.$blockScrolling += 1;
              this.session.unfold(newRange);
              this.multiSelect.addRange(newRange);
              this.$blockScrolling -= 1;
              this.renderer.scrollCursorIntoView(null, 0.5);
            }
            if (skip)
              this.multiSelect.substractPoint(range.cursor);
          };
          this.alignCursors = function() {
            var session = this.session;
            var sel = session.multiSelect;
            var ranges = sel.ranges;
            var row = -1;
            var sameRowRanges = ranges.filter(function(r) {
              if (r.cursor.row == row)
                return true;
              row = r.cursor.row;
            });
            if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
              var range = this.selection.getRange();
              var fr = range.start.row, lr = range.end.row;
              var guessRange = fr == lr;
              if (guessRange) {
                var max = this.session.getLength();
                var line;
                do {
                  line = this.session.getLine(lr);
                } while (/[=:]/.test(line) && ++lr < max);
                do {
                  line = this.session.getLine(fr);
                } while (/[=:]/.test(line) && --fr > 0);
                if (fr < 0)
                  fr = 0;
                if (lr >= max)
                  lr = max - 1;
              }
              var lines = this.session.removeFullLines(fr, lr);
              lines = this.$reAlignText(lines, guessRange);
              this.session.insert({ row: fr, column: 0 }, lines.join("\n") + "\n");
              if (!guessRange) {
                range.start.column = 0;
                range.end.column = lines[lines.length - 1].length;
              }
              this.selection.setRange(range);
            } else {
              sameRowRanges.forEach(function(r) {
                sel.substractPoint(r.cursor);
              });
              var maxCol = 0;
              var minSpace = Infinity;
              var spaceOffsets = ranges.map(function(r) {
                var p = r.cursor;
                var line2 = session.getLine(p.row);
                var spaceOffset = line2.substr(p.column).search(/\S/g);
                if (spaceOffset == -1)
                  spaceOffset = 0;
                if (p.column > maxCol)
                  maxCol = p.column;
                if (spaceOffset < minSpace)
                  minSpace = spaceOffset;
                return spaceOffset;
              });
              ranges.forEach(function(r, i) {
                var p = r.cursor;
                var l = maxCol - p.column;
                var d = spaceOffsets[i] - minSpace;
                if (l > d)
                  session.insert(p, lang.stringRepeat(" ", l - d));
                else
                  session.remove(new Range(p.row, p.column, p.row, p.column - l + d));
                r.start.column = r.end.column = maxCol;
                r.start.row = r.end.row = p.row;
                r.cursor = r.end;
              });
              sel.fromOrientedRange(ranges[0]);
              this.renderer.updateCursor();
              this.renderer.updateBackMarkers();
            }
          };
          this.$reAlignText = function(lines, forceLeft) {
            var isLeftAligned = true, isRightAligned = true;
            var startW, textW, endW;
            return lines.map(function(line) {
              var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
              if (!m)
                return [line];
              if (startW == null) {
                startW = m[1].length;
                textW = m[2].length;
                endW = m[3].length;
                return m;
              }
              if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
                isRightAligned = false;
              if (startW != m[1].length)
                isLeftAligned = false;
              if (startW > m[1].length)
                startW = m[1].length;
              if (textW < m[2].length)
                textW = m[2].length;
              if (endW > m[3].length)
                endW = m[3].length;
              return m;
            }).map(forceLeft ? alignLeft : isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);
            function spaces(n) {
              return lang.stringRepeat(" ", n);
            }
            function alignLeft(m) {
              return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(textW - m[2].length + endW) + m[4].replace(/^([=:])\s+/, "$1 ");
            }
            function alignRight(m) {
              return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2] + spaces(endW, " ") + m[4].replace(/^([=:])\s+/, "$1 ");
            }
            function unAlign(m) {
              return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(endW) + m[4].replace(/^([=:])\s+/, "$1 ");
            }
          };
        }).call(Editor.prototype);
        function isSamePoint(p1, p2) {
          return p1.row == p2.row && p1.column == p2.column;
        }
        exports2.onSessionChange = function(e) {
          var session = e.session;
          if (session && !session.multiSelect) {
            session.$selectionMarkers = [];
            session.selection.$initRangeList();
            session.multiSelect = session.selection;
          }
          this.multiSelect = session && session.multiSelect;
          var oldSession = e.oldSession;
          if (oldSession) {
            oldSession.multiSelect.off("addRange", this.$onAddRange);
            oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
            oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
            oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
            oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
            oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
          }
          if (session) {
            session.multiSelect.on("addRange", this.$onAddRange);
            session.multiSelect.on("removeRange", this.$onRemoveRange);
            session.multiSelect.on("multiSelect", this.$onMultiSelect);
            session.multiSelect.on("singleSelect", this.$onSingleSelect);
            session.multiSelect.lead.on("change", this.$checkMultiselectChange);
            session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
          }
          if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
            if (session.selection.inMultiSelectMode)
              this.$onMultiSelect();
            else
              this.$onSingleSelect();
          }
        };
        function MultiSelect(editor) {
          if (editor.$multiselectOnSessionChange)
            return;
          editor.$onAddRange = editor.$onAddRange.bind(editor);
          editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
          editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
          editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
          editor.$multiselectOnSessionChange = exports2.onSessionChange.bind(editor);
          editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);
          editor.$multiselectOnSessionChange(editor);
          editor.on("changeSession", editor.$multiselectOnSessionChange);
          editor.on("mousedown", onMouseDown);
          editor.commands.addCommands(commands.defaultCommands);
          addAltCursorListeners(editor);
        }
        function addAltCursorListeners(editor) {
          var el = editor.textInput.getElement();
          var altCursor = false;
          event.addListener(el, "keydown", function(e) {
            var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
            if (editor.$blockSelectEnabled && altDown) {
              if (!altCursor) {
                editor.renderer.setMouseCursor("crosshair");
                altCursor = true;
              }
            } else if (altCursor) {
              reset();
            }
          });
          event.addListener(el, "keyup", reset);
          event.addListener(el, "blur", reset);
          function reset(e) {
            if (altCursor) {
              editor.renderer.setMouseCursor("");
              altCursor = false;
            }
          }
        }
        exports2.MultiSelect = MultiSelect;
        acequire("./config").defineOptions(Editor.prototype, "editor", {
          enableMultiselect: {
            set: function(val) {
              MultiSelect(this);
              if (val) {
                this.on("changeSession", this.$multiselectOnSessionChange);
                this.on("mousedown", onMouseDown);
              } else {
                this.off("changeSession", this.$multiselectOnSessionChange);
                this.off("mousedown", onMouseDown);
              }
            },
            value: true
          },
          enableBlockSelect: {
            set: function(val) {
              this.$blockSelectEnabled = val;
            },
            value: true
          }
        });
      });
      ace.define("ace/mode/folding/fold_mode", ["require", "exports", "module", "ace/range"], function(acequire, exports2, module2) {
        "use strict";
        var Range = acequire("../../range").Range;
        var FoldMode = exports2.FoldMode = function() {
        };
        (function() {
          this.foldingStartMarker = null;
          this.foldingStopMarker = null;
          this.getFoldWidget = function(session, foldStyle, row) {
            var line = session.getLine(row);
            if (this.foldingStartMarker.test(line))
              return "start";
            if (foldStyle == "markbeginend" && this.foldingStopMarker && this.foldingStopMarker.test(line))
              return "end";
            return "";
          };
          this.getFoldWidgetRange = function(session, foldStyle, row) {
            return null;
          };
          this.indentationBlock = function(session, row, column) {
            var re = /\S/;
            var line = session.getLine(row);
            var startLevel = line.search(re);
            if (startLevel == -1)
              return;
            var startColumn = column || line.length;
            var maxRow = session.getLength();
            var startRow = row;
            var endRow = row;
            while (++row < maxRow) {
              var level = session.getLine(row).search(re);
              if (level == -1)
                continue;
              if (level <= startLevel)
                break;
              endRow = row;
            }
            if (endRow > startRow) {
              var endColumn = session.getLine(endRow).length;
              return new Range(startRow, startColumn, endRow, endColumn);
            }
          };
          this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
            var start = { row, column: column + 1 };
            var end = session.$findClosingBracket(bracket, start, typeRe);
            if (!end)
              return;
            var fw = session.foldWidgets[end.row];
            if (fw == null)
              fw = session.getFoldWidget(end.row);
            if (fw == "start" && end.row > start.row) {
              end.row--;
              end.column = session.getLine(end.row).length;
            }
            return Range.fromPoints(start, end);
          };
          this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
            var end = { row, column };
            var start = session.$findOpeningBracket(bracket, end);
            if (!start)
              return;
            start.column++;
            end.column--;
            return Range.fromPoints(start, end);
          };
        }).call(FoldMode.prototype);
      });
      ace.define("ace/theme/textmate", ["require", "exports", "module", "ace/lib/dom"], function(acequire, exports2, module2) {
        "use strict";
        exports2.isDark = false;
        exports2.cssClass = "ace-tm";
        exports2.cssText = '.ace-tm .ace_gutter {background: #f0f0f0;color: #333;}.ace-tm .ace_print-margin {width: 1px;background: #e8e8e8;}.ace-tm .ace_fold {background-color: #6B72E6;}.ace-tm {background-color: #FFFFFF;color: black;}.ace-tm .ace_cursor {color: black;}.ace-tm .ace_invisible {color: rgb(191, 191, 191);}.ace-tm .ace_storage,.ace-tm .ace_keyword {color: blue;}.ace-tm .ace_constant {color: rgb(197, 6, 11);}.ace-tm .ace_constant.ace_buildin {color: rgb(88, 72, 246);}.ace-tm .ace_constant.ace_language {color: rgb(88, 92, 246);}.ace-tm .ace_constant.ace_library {color: rgb(6, 150, 14);}.ace-tm .ace_invalid {background-color: rgba(255, 0, 0, 0.1);color: red;}.ace-tm .ace_support.ace_function {color: rgb(60, 76, 114);}.ace-tm .ace_support.ace_constant {color: rgb(6, 150, 14);}.ace-tm .ace_support.ace_type,.ace-tm .ace_support.ace_class {color: rgb(109, 121, 222);}.ace-tm .ace_keyword.ace_operator {color: rgb(104, 118, 135);}.ace-tm .ace_string {color: rgb(3, 106, 7);}.ace-tm .ace_comment {color: rgb(76, 136, 107);}.ace-tm .ace_comment.ace_doc {color: rgb(0, 102, 255);}.ace-tm .ace_comment.ace_doc.ace_tag {color: rgb(128, 159, 191);}.ace-tm .ace_constant.ace_numeric {color: rgb(0, 0, 205);}.ace-tm .ace_variable {color: rgb(49, 132, 149);}.ace-tm .ace_xml-pe {color: rgb(104, 104, 91);}.ace-tm .ace_entity.ace_name.ace_function {color: #0000A2;}.ace-tm .ace_heading {color: rgb(12, 7, 255);}.ace-tm .ace_list {color:rgb(185, 6, 144);}.ace-tm .ace_meta.ace_tag {color:rgb(0, 22, 142);}.ace-tm .ace_string.ace_regex {color: rgb(255, 0, 0)}.ace-tm .ace_marker-layer .ace_selection {background: rgb(181, 213, 255);}.ace-tm.ace_multiselect .ace_selection.ace_start {box-shadow: 0 0 3px 0px white;}.ace-tm .ace_marker-layer .ace_step {background: rgb(252, 255, 0);}.ace-tm .ace_marker-layer .ace_stack {background: rgb(164, 229, 101);}.ace-tm .ace_marker-layer .ace_bracket {margin: -1px 0 0 -1px;border: 1px solid rgb(192, 192, 192);}.ace-tm .ace_marker-layer .ace_active-line {background: rgba(0, 0, 0, 0.07);}.ace-tm .ace_gutter-active-line {background-color : #dcdcdc;}.ace-tm .ace_marker-layer .ace_selected-word {background: rgb(250, 250, 255);border: 1px solid rgb(200, 200, 250);}.ace-tm .ace_indent-guide {background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;}';
        var dom = acequire("../lib/dom");
        dom.importCssString(exports2.cssText, exports2.cssClass);
      });
      ace.define("ace/line_widgets", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/range"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("./lib/oop");
        var dom = acequire("./lib/dom");
        var Range = acequire("./range").Range;
        function LineWidgets(session) {
          this.session = session;
          this.session.widgetManager = this;
          this.session.getRowLength = this.getRowLength;
          this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
          this.updateOnChange = this.updateOnChange.bind(this);
          this.renderWidgets = this.renderWidgets.bind(this);
          this.measureWidgets = this.measureWidgets.bind(this);
          this.session._changedWidgets = [];
          this.$onChangeEditor = this.$onChangeEditor.bind(this);
          this.session.on("change", this.updateOnChange);
          this.session.on("changeFold", this.updateOnFold);
          this.session.on("changeEditor", this.$onChangeEditor);
        }
        (function() {
          this.getRowLength = function(row) {
            var h;
            if (this.lineWidgets)
              h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
            else
              h = 0;
            if (!this.$useWrapMode || !this.$wrapData[row]) {
              return 1 + h;
            } else {
              return this.$wrapData[row].length + 1 + h;
            }
          };
          this.$getWidgetScreenLength = function() {
            var screenRows = 0;
            this.lineWidgets.forEach(function(w) {
              if (w && w.rowCount && !w.hidden)
                screenRows += w.rowCount;
            });
            return screenRows;
          };
          this.$onChangeEditor = function(e) {
            this.attach(e.editor);
          };
          this.attach = function(editor) {
            if (editor && editor.widgetManager && editor.widgetManager != this)
              editor.widgetManager.detach();
            if (this.editor == editor)
              return;
            this.detach();
            this.editor = editor;
            if (editor) {
              editor.widgetManager = this;
              editor.renderer.on("beforeRender", this.measureWidgets);
              editor.renderer.on("afterRender", this.renderWidgets);
            }
          };
          this.detach = function(e) {
            var editor = this.editor;
            if (!editor)
              return;
            this.editor = null;
            editor.widgetManager = null;
            editor.renderer.off("beforeRender", this.measureWidgets);
            editor.renderer.off("afterRender", this.renderWidgets);
            var lineWidgets = this.session.lineWidgets;
            lineWidgets && lineWidgets.forEach(function(w) {
              if (w && w.el && w.el.parentNode) {
                w._inDocument = false;
                w.el.parentNode.removeChild(w.el);
              }
            });
          };
          this.updateOnFold = function(e, session) {
            var lineWidgets = session.lineWidgets;
            if (!lineWidgets || !e.action)
              return;
            var fold = e.data;
            var start = fold.start.row;
            var end = fold.end.row;
            var hide = e.action == "add";
            for (var i = start + 1; i < end; i++) {
              if (lineWidgets[i])
                lineWidgets[i].hidden = hide;
            }
            if (lineWidgets[end]) {
              if (hide) {
                if (!lineWidgets[start])
                  lineWidgets[start] = lineWidgets[end];
                else
                  lineWidgets[end].hidden = hide;
              } else {
                if (lineWidgets[start] == lineWidgets[end])
                  lineWidgets[start] = void 0;
                lineWidgets[end].hidden = hide;
              }
            }
          };
          this.updateOnChange = function(delta) {
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets)
              return;
            var startRow = delta.start.row;
            var len = delta.end.row - startRow;
            if (len === 0) {
            } else if (delta.action == "remove") {
              var removed = lineWidgets.splice(startRow + 1, len);
              removed.forEach(function(w) {
                w && this.removeLineWidget(w);
              }, this);
              this.$updateRows();
            } else {
              var args = new Array(len);
              args.unshift(startRow, 0);
              lineWidgets.splice.apply(lineWidgets, args);
              this.$updateRows();
            }
          };
          this.$updateRows = function() {
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets)
              return;
            var noWidgets = true;
            lineWidgets.forEach(function(w, i) {
              if (w) {
                noWidgets = false;
                w.row = i;
                while (w.$oldWidget) {
                  w.$oldWidget.row = i;
                  w = w.$oldWidget;
                }
              }
            });
            if (noWidgets)
              this.session.lineWidgets = null;
          };
          this.addLineWidget = function(w) {
            if (!this.session.lineWidgets)
              this.session.lineWidgets = new Array(this.session.getLength());
            var old = this.session.lineWidgets[w.row];
            if (old) {
              w.$oldWidget = old;
              if (old.el && old.el.parentNode) {
                old.el.parentNode.removeChild(old.el);
                old._inDocument = false;
              }
            }
            this.session.lineWidgets[w.row] = w;
            w.session = this.session;
            var renderer = this.editor.renderer;
            if (w.html && !w.el) {
              w.el = dom.createElement("div");
              w.el.innerHTML = w.html;
            }
            if (w.el) {
              dom.addCssClass(w.el, "ace_lineWidgetContainer");
              w.el.style.position = "absolute";
              w.el.style.zIndex = 5;
              renderer.container.appendChild(w.el);
              w._inDocument = true;
            }
            if (!w.coverGutter) {
              w.el.style.zIndex = 3;
            }
            if (w.pixelHeight == null) {
              w.pixelHeight = w.el.offsetHeight;
            }
            if (w.rowCount == null) {
              w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
            }
            var fold = this.session.getFoldAt(w.row, 0);
            w.$fold = fold;
            if (fold) {
              var lineWidgets = this.session.lineWidgets;
              if (w.row == fold.end.row && !lineWidgets[fold.start.row])
                lineWidgets[fold.start.row] = w;
              else
                w.hidden = true;
            }
            this.session._emit("changeFold", { data: { start: { row: w.row } } });
            this.$updateRows();
            this.renderWidgets(null, renderer);
            this.onWidgetChanged(w);
            return w;
          };
          this.removeLineWidget = function(w) {
            w._inDocument = false;
            w.session = null;
            if (w.el && w.el.parentNode)
              w.el.parentNode.removeChild(w.el);
            if (w.editor && w.editor.destroy)
              try {
                w.editor.destroy();
              } catch (e) {
              }
            if (this.session.lineWidgets) {
              var w1 = this.session.lineWidgets[w.row];
              if (w1 == w) {
                this.session.lineWidgets[w.row] = w.$oldWidget;
                if (w.$oldWidget)
                  this.onWidgetChanged(w.$oldWidget);
              } else {
                while (w1) {
                  if (w1.$oldWidget == w) {
                    w1.$oldWidget = w.$oldWidget;
                    break;
                  }
                  w1 = w1.$oldWidget;
                }
              }
            }
            this.session._emit("changeFold", { data: { start: { row: w.row } } });
            this.$updateRows();
          };
          this.getWidgetsAtRow = function(row) {
            var lineWidgets = this.session.lineWidgets;
            var w = lineWidgets && lineWidgets[row];
            var list = [];
            while (w) {
              list.push(w);
              w = w.$oldWidget;
            }
            return list;
          };
          this.onWidgetChanged = function(w) {
            this.session._changedWidgets.push(w);
            this.editor && this.editor.renderer.updateFull();
          };
          this.measureWidgets = function(e, renderer) {
            var changedWidgets = this.session._changedWidgets;
            var config = renderer.layerConfig;
            if (!changedWidgets || !changedWidgets.length)
              return;
            var min = Infinity;
            for (var i = 0; i < changedWidgets.length; i++) {
              var w = changedWidgets[i];
              if (!w || !w.el)
                continue;
              if (w.session != this.session)
                continue;
              if (!w._inDocument) {
                if (this.session.lineWidgets[w.row] != w)
                  continue;
                w._inDocument = true;
                renderer.container.appendChild(w.el);
              }
              w.h = w.el.offsetHeight;
              if (!w.fixedWidth) {
                w.w = w.el.offsetWidth;
                w.screenWidth = Math.ceil(w.w / config.characterWidth);
              }
              var rowCount = w.h / config.lineHeight;
              if (w.coverLine) {
                rowCount -= this.session.getRowLineCount(w.row);
                if (rowCount < 0)
                  rowCount = 0;
              }
              if (w.rowCount != rowCount) {
                w.rowCount = rowCount;
                if (w.row < min)
                  min = w.row;
              }
            }
            if (min != Infinity) {
              this.session._emit("changeFold", { data: { start: { row: min } } });
              this.session.lineWidgetWidth = null;
            }
            this.session._changedWidgets = [];
          };
          this.renderWidgets = function(e, renderer) {
            var config = renderer.layerConfig;
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets)
              return;
            var first = Math.min(this.firstRow, config.firstRow);
            var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
            while (first > 0 && !lineWidgets[first])
              first--;
            this.firstRow = config.firstRow;
            this.lastRow = config.lastRow;
            renderer.$cursorLayer.config = config;
            for (var i = first; i <= last; i++) {
              var w = lineWidgets[i];
              if (!w || !w.el)
                continue;
              if (w.hidden) {
                w.el.style.top = -100 - (w.pixelHeight || 0) + "px";
                continue;
              }
              if (!w._inDocument) {
                w._inDocument = true;
                renderer.container.appendChild(w.el);
              }
              var top = renderer.$cursorLayer.getPixelPosition({ row: i, column: 0 }, true).top;
              if (!w.coverLine)
                top += config.lineHeight * this.session.getRowLineCount(w.row);
              w.el.style.top = top - config.offset + "px";
              var left = w.coverGutter ? 0 : renderer.gutterWidth;
              if (!w.fixedWidth)
                left -= renderer.scrollLeft;
              w.el.style.left = left + "px";
              if (w.fullWidth && w.screenWidth) {
                w.el.style.minWidth = config.width + 2 * config.padding + "px";
              }
              if (w.fixedWidth) {
                w.el.style.right = renderer.scrollBar.getWidth() + "px";
              } else {
                w.el.style.right = "";
              }
            }
          };
        }).call(LineWidgets.prototype);
        exports2.LineWidgets = LineWidgets;
      });
      ace.define("ace/ext/error_marker", ["require", "exports", "module", "ace/line_widgets", "ace/lib/dom", "ace/range"], function(acequire, exports2, module2) {
        "use strict";
        var LineWidgets = acequire("../line_widgets").LineWidgets;
        var dom = acequire("../lib/dom");
        var Range = acequire("../range").Range;
        function binarySearch(array, needle, comparator) {
          var first = 0;
          var last = array.length - 1;
          while (first <= last) {
            var mid = first + last >> 1;
            var c = comparator(needle, array[mid]);
            if (c > 0)
              first = mid + 1;
            else if (c < 0)
              last = mid - 1;
            else
              return mid;
          }
          return -(first + 1);
        }
        function findAnnotations(session, row, dir) {
          var annotations = session.getAnnotations().sort(Range.comparePoints);
          if (!annotations.length)
            return;
          var i = binarySearch(annotations, { row, column: -1 }, Range.comparePoints);
          if (i < 0)
            i = -i - 1;
          if (i >= annotations.length)
            i = dir > 0 ? 0 : annotations.length - 1;
          else if (i === 0 && dir < 0)
            i = annotations.length - 1;
          var annotation = annotations[i];
          if (!annotation || !dir)
            return;
          if (annotation.row === row) {
            do {
              annotation = annotations[i += dir];
            } while (annotation && annotation.row === row);
            if (!annotation)
              return annotations.slice();
          }
          var matched = [];
          row = annotation.row;
          do {
            matched[dir < 0 ? "unshift" : "push"](annotation);
            annotation = annotations[i += dir];
          } while (annotation && annotation.row == row);
          return matched.length && matched;
        }
        exports2.showErrorMarker = function(editor, dir) {
          var session = editor.session;
          if (!session.widgetManager) {
            session.widgetManager = new LineWidgets(session);
            session.widgetManager.attach(editor);
          }
          var pos = editor.getCursorPosition();
          var row = pos.row;
          var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function(w2) {
            return w2.type == "errorMarker";
          })[0];
          if (oldWidget) {
            oldWidget.destroy();
          } else {
            row -= dir;
          }
          var annotations = findAnnotations(session, row, dir);
          var gutterAnno;
          if (annotations) {
            var annotation = annotations[0];
            pos.column = (annotation.pos && typeof annotation.column != "number" ? annotation.pos.sc : annotation.column) || 0;
            pos.row = annotation.row;
            gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
          } else if (oldWidget) {
            return;
          } else {
            gutterAnno = {
              text: ["Looks good!"],
              className: "ace_ok"
            };
          }
          editor.session.unfold(pos.row);
          editor.selection.moveToPosition(pos);
          var w = {
            row: pos.row,
            fixedWidth: true,
            coverGutter: true,
            el: dom.createElement("div"),
            type: "errorMarker"
          };
          var el = w.el.appendChild(dom.createElement("div"));
          var arrow = w.el.appendChild(dom.createElement("div"));
          arrow.className = "error_widget_arrow " + gutterAnno.className;
          var left = editor.renderer.$cursorLayer.getPixelPosition(pos).left;
          arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
          w.el.className = "error_widget_wrapper";
          el.className = "error_widget " + gutterAnno.className;
          el.innerHTML = gutterAnno.text.join("<br>");
          el.appendChild(dom.createElement("div"));
          var kb = function(_, hashId, keyString) {
            if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
              w.destroy();
              return { command: "null" };
            }
          };
          w.destroy = function() {
            if (editor.$mouseHandler.isMousePressed)
              return;
            editor.keyBinding.removeKeyboardHandler(kb);
            session.widgetManager.removeLineWidget(w);
            editor.off("changeSelection", w.destroy);
            editor.off("changeSession", w.destroy);
            editor.off("mouseup", w.destroy);
            editor.off("change", w.destroy);
          };
          editor.keyBinding.addKeyboardHandler(kb);
          editor.on("changeSelection", w.destroy);
          editor.on("changeSession", w.destroy);
          editor.on("mouseup", w.destroy);
          editor.on("change", w.destroy);
          editor.session.widgetManager.addLineWidget(w);
          w.el.onmousedown = editor.focus.bind(editor);
          editor.renderer.scrollCursorIntoView(null, 0.5, { bottom: w.el.offsetHeight });
        };
        dom.importCssString("    .error_widget_wrapper {        background: inherit;        color: inherit;        border:none    }    .error_widget {        border-top: solid 2px;        border-bottom: solid 2px;        margin: 5px 0;        padding: 10px 40px;        white-space: pre-wrap;    }    .error_widget.ace_error, .error_widget_arrow.ace_error{        border-color: #ff5a5a    }    .error_widget.ace_warning, .error_widget_arrow.ace_warning{        border-color: #F1D817    }    .error_widget.ace_info, .error_widget_arrow.ace_info{        border-color: #5a5a5a    }    .error_widget.ace_ok, .error_widget_arrow.ace_ok{        border-color: #5aaa5a    }    .error_widget_arrow {        position: absolute;        border: solid 5px;        border-top-color: transparent!important;        border-right-color: transparent!important;        border-left-color: transparent!important;        top: -5px;    }", "");
      });
      ace.define("ace/ace", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/dom", "ace/lib/event", "ace/editor", "ace/edit_session", "ace/undomanager", "ace/virtual_renderer", "ace/worker/worker_client", "ace/keyboard/hash_handler", "ace/placeholder", "ace/multi_select", "ace/mode/folding/fold_mode", "ace/theme/textmate", "ace/ext/error_marker", "ace/config"], function(acequire, exports2, module2) {
        "use strict";
        acequire("./lib/fixoldbrowsers");
        var dom = acequire("./lib/dom");
        var event = acequire("./lib/event");
        var Editor = acequire("./editor").Editor;
        var EditSession = acequire("./edit_session").EditSession;
        var UndoManager = acequire("./undomanager").UndoManager;
        var Renderer = acequire("./virtual_renderer").VirtualRenderer;
        acequire("./worker/worker_client");
        acequire("./keyboard/hash_handler");
        acequire("./placeholder");
        acequire("./multi_select");
        acequire("./mode/folding/fold_mode");
        acequire("./theme/textmate");
        acequire("./ext/error_marker");
        exports2.config = acequire("./config");
        exports2.acequire = acequire;
        if (typeof define === "function")
          exports2.define = define;
        exports2.edit = function(el) {
          if (typeof el == "string") {
            var _id = el;
            el = document.getElementById(_id);
            if (!el)
              throw new Error("ace.edit can't find div #" + _id);
          }
          if (el && el.env && el.env.editor instanceof Editor)
            return el.env.editor;
          var value = "";
          if (el && /input|textarea/i.test(el.tagName)) {
            var oldNode = el;
            value = oldNode.value;
            el = dom.createElement("pre");
            oldNode.parentNode.replaceChild(el, oldNode);
          } else if (el) {
            value = dom.getInnerText(el);
            el.innerHTML = "";
          }
          var doc = exports2.createEditSession(value);
          var editor = new Editor(new Renderer(el));
          editor.setSession(doc);
          var env = {
            document: doc,
            editor,
            onResize: editor.resize.bind(editor, null)
          };
          if (oldNode)
            env.textarea = oldNode;
          event.addListener(window, "resize", env.onResize);
          editor.on("destroy", function() {
            event.removeListener(window, "resize", env.onResize);
            env.editor.container.env = null;
          });
          editor.container.env = editor.env = env;
          return editor;
        };
        exports2.createEditSession = function(text, mode) {
          var doc = new EditSession(text, mode);
          doc.setUndoManager(new UndoManager());
          return doc;
        };
        exports2.EditSession = EditSession;
        exports2.UndoManager = UndoManager;
        exports2.version = "1.2.9";
      });
      (function() {
        ace.acequire(["ace/ace"], function(a) {
          if (a) {
            a.config.init(true);
            a.define = ace.define;
          }
          if (!window.ace)
            window.ace = a;
          for (var key in a)
            if (a.hasOwnProperty(key))
              window.ace[key] = a[key];
        });
      })();
      module.exports = window.ace.acequire("ace/ace");
    }
  });

  // demo/res/js/src/gt-mode.js
  var require_gt_mode = __commonJS({
    "demo/res/js/src/gt-mode.js"(exports, module) {
      var ace2 = require_brace();
      var { Mode } = ace2.acequire("ace/mode/text");
      var { TextHighlightRules } = ace2.acequire("ace/mode/text_highlight_rules");
      var CustomHighlightRules = class extends TextHighlightRules {
        constructor() {
          super();
          const url = /http(?:s)?:\/\/[\w\-.]+\.[a-zA-Z]{2,}(?:\/[^\s\]]+)?\/?/;
          const lineEnd = "\\s*$";
          const keywordStart = "^\\t*\\*";
          const colon = "(:\\s*)";
          const colonOrLineEnd = "(:\\s*|\\s*$)";
          const identifier = "[a-zA-Z][a-zA-Z0-9_]*";
          const identifierCaptured = "(" + identifier + ")";
          const number = "-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)";
          const keyword = [
            "after",
            "audio",
            "back",
            "before",
            "blank",
            "body",
            "button",
            "cancel",
            "caption",
            "chart",
            "classes",
            "clear",
            "click",
            "color",
            "component",
            "confirm",
            "console",
            "database",
            "date",
            "description",
            "email",
            "error",
            "events",
            "everytime",
            "experiment",
            "frequency",
            "goto",
            "group",
            "header",
            "hide",
            "history",
            "html",
            "icon",
            "identifier",
            "image",
            "label",
            "list",
            "login",
            "maintain",
            "management",
            "menu",
            "method",
            "multiple",
            "name",
            "navigation",
            "other",
            "page",
            "path",
            "picture",
            "position",
            "program",
            "progress",
            "purchase",
            "question",
            "quit",
            "randomize",
            "repeat",
            "required",
            "reset",
            "return",
            "service",
            "settings",
            "share",
            "shuffle",
            "start",
            "startup",
            "status",
            "style",
            "subject",
            "success",
            "summary",
            "switch",
            "tags",
            "throwaway",
            "time",
            "tip",
            "title",
            "to",
            "trendline",
            "trigger",
            "type",
            "url",
            "video",
            "what",
            "xaxis",
            "yaxis"
          ].join("|");
          function captureKeyword(keyword2) {
            return "(" + keywordStart + keyword2 + ")";
          }
          const embeddingOperatorClass = "keyword.operator";
          function embeddedExpressionStartToken(nextState) {
            return { token: embeddingOperatorClass, regex: /\{/, next: nextState };
          }
          function expressionWithTerminator(terminatorRegex, nextState) {
            return [
              {
                token: embeddingOperatorClass,
                regex: terminatorRegex,
                next: nextState
              },
              { token: "constant.numeric", regex: number },
              { token: "variable", regex: identifier },
              { token: "string", regex: /"[^"]*"/ },
              { token: "keyword.operator", regex: /[+-/*=^]/ },
              //*/
              { token: "keyword.operator", regex: /[<>](?:=)?/ },
              { token: "keyword.operator", regex: /(and|or|not|in)\W/ },
              { token: "keyword.operator", regex: /[[\]]/ },
              { token: "keyword.operator", regex: /[()]/ },
              { token: "keyword.operator", regex: /[{}]/ }
            ];
          }
          function keywordWithInlineExpression(keyword2) {
            return {
              token: ["keyword", "keyword.operator"],
              regex: captureKeyword(keyword2) + colonOrLineEnd,
              next: "expression"
            };
          }
          this.$rules = {
            start: [
              //*settings
              {
                token: "keyword",
                regex: keywordStart + "(?:" + keyword + ")" + lineEnd
              },
              // *question: How are you?
              {
                token: ["keyword", "keyword.operator"],
                regex: "(" + keywordStart + "(?:" + keyword + "))" + colon,
                next: "inline-text"
              },
              // *points: hide
              {
                token: ["keyword", "keyword.operator", "constant.character"],
                regex: captureKeyword("points") + colon + "(\\s*hide)" + lineEnd
              },
              // *points: 2 type
              {
                token: [
                  "keyword",
                  "keyword.operator",
                  "constant.numeric",
                  "variable"
                ],
                regex: captureKeyword("points") + colon + "(\\s*" + number + ")(\\s+" + identifier + ")?" + lineEnd
              },
              // *set: visited
              {
                token: ["keyword", "keyword.operator", "variable"],
                regex: captureKeyword("set") + colon + identifierCaptured + lineEnd
              },
              // *save: answer
              {
                token: ["keyword", "keyword.operator", "variable"],
                regex: captureKeyword("save") + colon + identifierCaptured + lineEnd
              },
              // *if: visited and points >= 10
              keywordWithInlineExpression("if"),
              // *while: not quit
              keywordWithInlineExpression("while"),
              // *data: [["a", 1], ["b", 2]]
              keywordWithInlineExpression("data"),
              // *answers: ["One", "Two", "Three"]
              keywordWithInlineExpression("answers"),
              // *min: 4.32 * 5 - 3
              keywordWithInlineExpression("min"),
              // *max: 10.32 / 3
              keywordWithInlineExpression("max"),
              // *ticks: [[1.5, "littler"], [2.5, "bigger"]]
              keywordWithInlineExpression("ticks"),
              // *opacity: 0.2 + my_preference
              keywordWithInlineExpression("opacity"),
              // *when: calendar::now + 1.days
              keywordWithInlineExpression("when"),
              // *every: 1.day
              keywordWithInlineExpression("every"),
              // *until: calendar::now + 1.days
              keywordWithInlineExpression("until"),
              // *countdown: 1.hour
              keywordWithInlineExpression("countdown"),
              // *send: { "some" -> "data" }
              keywordWithInlineExpression("send"),
              // *with: {"a" -> {"b" -> "c"}}
              keywordWithInlineExpression("with"),
              // *default: ["one", "two", "three"]
              keywordWithInlineExpression("default"),
              // *wait: 1.minute + 5.seconds
              keywordWithInlineExpression("wait"),
              {
                token: "comment",
                regex: /^\s*--/,
                next: "comment-body"
              },
              // >> x = 3
              {
                token: ["keyword", "console-command"],
                regex: /^\s*>>/,
                next: "console-command"
              },
              // *rollovers: ["One", "Two", "Three"]
              {
                token: ["keyword", "keyword.operator"],
                regex: captureKeyword("rollovers") + colon,
                next: "expression"
              },
              {
                token: "keyword",
                regex: keywordStart + "(?:rollovers)" + lineEnd
              },
              // *for: key, value in expression
              {
                token: ["keyword", "keyword.operator"],
                regex: captureKeyword("for") + colon,
                next: "for-identifiers"
              },
              embeddedExpressionStartToken("embedded-expression"),
              { token: "string", regex: url },
              { token: embeddingOperatorClass, regex: /\[/, next: "link" }
            ],
            // -- TODO: task
            // -- normal comment
            "comment-body": [
              { defaultToken: "comment" },
              {
                token: "constant.language.bold",
                regex: /[A-Z]+:/
              },
              { token: "comment", regex: "$", next: "start" }
            ],
            "inline-text": [
              { defaultToken: "constant.character" },
              { token: "text", regex: "$", next: "start" },
              embeddedExpressionStartToken("expression-embedded-in-inline-text")
            ],
            "console-command": [
              { token: "text", regex: "$", next: "start" },
              { token: "variable", regex: /.+\s*(?==)/, next: "expression" },
              {
                token: ["variable"],
                regex: "\\w+(?=\\.)",
                next: "mutator-method-target"
              }
            ],
            "mutator-method-target": expressionWithTerminator(
              "\\.",
              "mutator-method"
            ),
            "mutator-method": [
              {
                token: "variable",
                regex: identifier + "$",
                next: "start"
              },
              {
                token: "variable",
                regex: identifier,
                next: "expression"
              }
            ],
            link: [
              { defaultToken: "keyword" },
              { token: embeddingOperatorClass, regex: /\]/, next: "start" },
              { token: embeddingOperatorClass, regex: /\|/ },
              { token: "string", regex: url },
              embeddedExpressionStartToken("expression-embedded-in-link")
            ],
            "for-identifiers": expressionWithTerminator(" in ", "expression"),
            expression: expressionWithTerminator("$", "start"),
            "embedded-expression": expressionWithTerminator(/\}/, "start"),
            "expression-embedded-in-inline-text": expressionWithTerminator(
              /\}(?=[^$])/,
              "inline-text"
            ).concat([{ token: embeddingOperatorClass, regex: /$/, next: "start" }]),
            "expression-embedded-in-link": expressionWithTerminator(/\}/, "link")
          };
        }
      };
      var GuidedTrackMode = class extends Mode {
        constructor() {
          super();
          this.lineCommentStart = "--";
          this.HighlightRules = CustomHighlightRules;
        }
      };
      module.exports = {
        CustomHighlightRules,
        GuidedTrackMode
      };
    }
  });

  // node_modules/lodash/lodash.js
  var require_lodash = __commonJS({
    "node_modules/lodash/lodash.js"(exports, module) {
      (function() {
        var undefined2;
        var VERSION = "4.17.21";
        var LARGE_ARRAY_SIZE = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [
          ["ary", WRAP_ARY_FLAG],
          ["bind", WRAP_BIND_FLAG],
          ["bindKey", WRAP_BIND_KEY_FLAG],
          ["curry", WRAP_CURRY_FLAG],
          ["curryRight", WRAP_CURRY_RIGHT_FLAG],
          ["flip", WRAP_FLIP_FLAG],
          ["partial", WRAP_PARTIAL_FLAG],
          ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
          ["rearg", WRAP_REARG_FLAG]
        ];
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
        var reTrimStart = /^\s+/;
        var reWhitespace = /\s/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
        var reEscapeChar = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags = /\w*$/;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsOctal = /^0o[0-7]+$/i;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([
          rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
          rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
          rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
          rsUpper + "+" + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji
        ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [
          "Array",
          "Buffer",
          "DataView",
          "Date",
          "Error",
          "Float32Array",
          "Float64Array",
          "Function",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Map",
          "Math",
          "Object",
          "Promise",
          "RegExp",
          "Set",
          "String",
          "Symbol",
          "TypeError",
          "Uint8Array",
          "Uint8ClampedArray",
          "Uint16Array",
          "Uint32Array",
          "WeakMap",
          "_",
          "clearTimeout",
          "isFinite",
          "parseInt",
          "setTimeout"
        ];
        var templateCounter = -1;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var deburredLetters = {
          // Latin-1 Supplement block.
          "\xC0": "A",
          "\xC1": "A",
          "\xC2": "A",
          "\xC3": "A",
          "\xC4": "A",
          "\xC5": "A",
          "\xE0": "a",
          "\xE1": "a",
          "\xE2": "a",
          "\xE3": "a",
          "\xE4": "a",
          "\xE5": "a",
          "\xC7": "C",
          "\xE7": "c",
          "\xD0": "D",
          "\xF0": "d",
          "\xC8": "E",
          "\xC9": "E",
          "\xCA": "E",
          "\xCB": "E",
          "\xE8": "e",
          "\xE9": "e",
          "\xEA": "e",
          "\xEB": "e",
          "\xCC": "I",
          "\xCD": "I",
          "\xCE": "I",
          "\xCF": "I",
          "\xEC": "i",
          "\xED": "i",
          "\xEE": "i",
          "\xEF": "i",
          "\xD1": "N",
          "\xF1": "n",
          "\xD2": "O",
          "\xD3": "O",
          "\xD4": "O",
          "\xD5": "O",
          "\xD6": "O",
          "\xD8": "O",
          "\xF2": "o",
          "\xF3": "o",
          "\xF4": "o",
          "\xF5": "o",
          "\xF6": "o",
          "\xF8": "o",
          "\xD9": "U",
          "\xDA": "U",
          "\xDB": "U",
          "\xDC": "U",
          "\xF9": "u",
          "\xFA": "u",
          "\xFB": "u",
          "\xFC": "u",
          "\xDD": "Y",
          "\xFD": "y",
          "\xFF": "y",
          "\xC6": "Ae",
          "\xE6": "ae",
          "\xDE": "Th",
          "\xFE": "th",
          "\xDF": "ss",
          // Latin Extended-A block.
          "\u0100": "A",
          "\u0102": "A",
          "\u0104": "A",
          "\u0101": "a",
          "\u0103": "a",
          "\u0105": "a",
          "\u0106": "C",
          "\u0108": "C",
          "\u010A": "C",
          "\u010C": "C",
          "\u0107": "c",
          "\u0109": "c",
          "\u010B": "c",
          "\u010D": "c",
          "\u010E": "D",
          "\u0110": "D",
          "\u010F": "d",
          "\u0111": "d",
          "\u0112": "E",
          "\u0114": "E",
          "\u0116": "E",
          "\u0118": "E",
          "\u011A": "E",
          "\u0113": "e",
          "\u0115": "e",
          "\u0117": "e",
          "\u0119": "e",
          "\u011B": "e",
          "\u011C": "G",
          "\u011E": "G",
          "\u0120": "G",
          "\u0122": "G",
          "\u011D": "g",
          "\u011F": "g",
          "\u0121": "g",
          "\u0123": "g",
          "\u0124": "H",
          "\u0126": "H",
          "\u0125": "h",
          "\u0127": "h",
          "\u0128": "I",
          "\u012A": "I",
          "\u012C": "I",
          "\u012E": "I",
          "\u0130": "I",
          "\u0129": "i",
          "\u012B": "i",
          "\u012D": "i",
          "\u012F": "i",
          "\u0131": "i",
          "\u0134": "J",
          "\u0135": "j",
          "\u0136": "K",
          "\u0137": "k",
          "\u0138": "k",
          "\u0139": "L",
          "\u013B": "L",
          "\u013D": "L",
          "\u013F": "L",
          "\u0141": "L",
          "\u013A": "l",
          "\u013C": "l",
          "\u013E": "l",
          "\u0140": "l",
          "\u0142": "l",
          "\u0143": "N",
          "\u0145": "N",
          "\u0147": "N",
          "\u014A": "N",
          "\u0144": "n",
          "\u0146": "n",
          "\u0148": "n",
          "\u014B": "n",
          "\u014C": "O",
          "\u014E": "O",
          "\u0150": "O",
          "\u014D": "o",
          "\u014F": "o",
          "\u0151": "o",
          "\u0154": "R",
          "\u0156": "R",
          "\u0158": "R",
          "\u0155": "r",
          "\u0157": "r",
          "\u0159": "r",
          "\u015A": "S",
          "\u015C": "S",
          "\u015E": "S",
          "\u0160": "S",
          "\u015B": "s",
          "\u015D": "s",
          "\u015F": "s",
          "\u0161": "s",
          "\u0162": "T",
          "\u0164": "T",
          "\u0166": "T",
          "\u0163": "t",
          "\u0165": "t",
          "\u0167": "t",
          "\u0168": "U",
          "\u016A": "U",
          "\u016C": "U",
          "\u016E": "U",
          "\u0170": "U",
          "\u0172": "U",
          "\u0169": "u",
          "\u016B": "u",
          "\u016D": "u",
          "\u016F": "u",
          "\u0171": "u",
          "\u0173": "u",
          "\u0174": "W",
          "\u0175": "w",
          "\u0176": "Y",
          "\u0177": "y",
          "\u0178": "Y",
          "\u0179": "Z",
          "\u017B": "Z",
          "\u017D": "Z",
          "\u017A": "z",
          "\u017C": "z",
          "\u017E": "z",
          "\u0132": "IJ",
          "\u0133": "ij",
          "\u0152": "Oe",
          "\u0153": "oe",
          "\u0149": "'n",
          "\u017F": "s"
        };
        var htmlEscapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        };
        var stringEscapes = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt = parseInt;
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
          try {
            var types = freeModule && freeModule.require && freeModule.require("util").types;
            if (types) {
              return types;
            }
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e) {
          }
        }();
        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayAggregator(array, setter, iteratee, accumulator) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            var value = array[index];
            setter(accumulator, value, iteratee(value), array);
          }
          return accumulator;
        }
        function arrayEach(array, iteratee) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length = array == null ? 0 : array.length;
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function arrayIncludes(array, value) {
          var length = array == null ? 0 : array.length;
          return !!length && baseIndexOf(array, value, 0) > -1;
        }
        function arrayIncludesWith(array, value, comparator) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (comparator(value, array[index])) {
              return true;
            }
          }
          return false;
        }
        function arrayMap(array, iteratee) {
          var index = -1, length = array == null ? 0 : array.length, result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
        function arrayPush(array, values) {
          var index = -1, length = values.length, offset = array.length;
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }
        function arrayReduce(array, iteratee, accumulator, initAccum) {
          var index = -1, length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[++index];
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initAccum) {
          var length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
        var asciiSize = baseProperty("length");
        function asciiToArray(string) {
          return string.split("");
        }
        function asciiWords(string) {
          return string.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function(value, key, collection2) {
            if (predicate(value, key, collection2)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
          var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index-- : ++index < length) {
            if (predicate(array[index], index, array)) {
              return index;
            }
          }
          return -1;
        }
        function baseIndexOf(array, value, fromIndex) {
          return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
        }
        function baseIndexOfWith(array, value, fromIndex, comparator) {
          var index = fromIndex - 1, length = array.length;
          while (++index < length) {
            if (comparator(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function baseMean(array, iteratee) {
          var length = array == null ? 0 : array.length;
          return length ? baseSum(array, iteratee) / length : NAN;
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined2 : object[key];
          };
        }
        function basePropertyOf(object) {
          return function(key) {
            return object == null ? undefined2 : object[key];
          };
        }
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function(value, index, collection2) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
          });
          return accumulator;
        }
        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);
          while (length--) {
            array[length] = array[length].value;
          }
          return array;
        }
        function baseSum(array, iteratee) {
          var result, index = -1, length = array.length;
          while (++index < length) {
            var current = iteratee(array[index]);
            if (current !== undefined2) {
              result = result === undefined2 ? current : result + current;
            }
          }
          return result;
        }
        function baseTimes(n, iteratee) {
          var index = -1, result = Array(n);
          while (++index < n) {
            result[index] = iteratee(index);
          }
          return result;
        }
        function baseToPairs(object, props) {
          return arrayMap(props, function(key) {
            return [key, object[key]];
          });
        }
        function baseTrim(string) {
          return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        function baseValues(object, props) {
          return arrayMap(props, function(key) {
            return object[key];
          });
        }
        function cacheHas(cache, key) {
          return cache.has(key);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index = -1, length = strSymbols.length;
          while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index = strSymbols.length;
          while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function countHolders(array, placeholder) {
          var length = array.length, result = 0;
          while (length--) {
            if (array[length] === placeholder) {
              ++result;
            }
          }
          return result;
        }
        var deburrLetter = basePropertyOf(deburredLetters);
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr];
        }
        function getValue(object, key) {
          return object == null ? undefined2 : object[key];
        }
        function hasUnicode(string) {
          return reHasUnicode.test(string);
        }
        function hasUnicodeWord(string) {
          return reHasUnicodeWord.test(string);
        }
        function iteratorToArray(iterator) {
          var data, result = [];
          while (!(data = iterator.next()).done) {
            result.push(data.value);
          }
          return result;
        }
        function mapToArray(map) {
          var index = -1, result = Array(map.size);
          map.forEach(function(value, key) {
            result[++index] = [key, value];
          });
          return result;
        }
        function overArg(func, transform) {
          return function(arg) {
            return func(transform(arg));
          };
        }
        function replaceHolders(array, placeholder) {
          var index = -1, length = array.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array[index];
            if (value === placeholder || value === PLACEHOLDER) {
              array[index] = PLACEHOLDER;
              result[resIndex++] = index;
            }
          }
          return result;
        }
        function setToArray(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = value;
          });
          return result;
        }
        function setToPairs(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = [value, value];
          });
          return result;
        }
        function strictIndexOf(array, value, fromIndex) {
          var index = fromIndex - 1, length = array.length;
          while (++index < length) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function strictLastIndexOf(array, value, fromIndex) {
          var index = fromIndex + 1;
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return index;
        }
        function stringSize(string) {
          return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
        }
        function stringToArray(string) {
          return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
        }
        function trimmedEndIndex(string) {
          var index = string.length;
          while (index-- && reWhitespace.test(string.charAt(index))) {
          }
          return index;
        }
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        function unicodeSize(string) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string)) {
            ++result;
          }
          return result;
        }
        function unicodeToArray(string) {
          return string.match(reUnicode) || [];
        }
        function unicodeWords(string) {
          return string.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext2(context) {
          context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
          var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
          var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
          var coreJsData = context["__core-js_shared__"];
          var funcToString = funcProto.toString;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var idCounter = 0;
          var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
          }();
          var nativeObjectToString = objectProto.toString;
          var objectCtorString = funcToString.call(Object2);
          var oldDash = root._;
          var reIsNative = RegExp2(
            "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
          );
          var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
          var defineProperty = function() {
            try {
              var func = getNative(Object2, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e) {
            }
          }();
          var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
          var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
          var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
          var metaMap = WeakMap2 && new WeakMap2();
          var realNames = {};
          var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
          var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
          function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty.call(value, "__wrapped__")) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }
          var baseCreate = function() {
            function object() {
            }
            return function(proto) {
              if (!isObject(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object.prototype = proto;
              var result2 = new object();
              object.prototype = undefined2;
              return result2;
            };
          }();
          function baseLodash() {
          }
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined2;
          }
          lodash.templateSettings = {
            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "escape": reEscape,
            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "evaluate": reEvaluate,
            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "interpolate": reInterpolate,
            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type {string}
             */
            "variable": "",
            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type {Object}
             */
            "imports": {
              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type {Function}
               */
              "_": lodash
            }
          };
          lodash.prototype = baseLodash.prototype;
          lodash.prototype.constructor = lodash;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          function lazyClone() {
            var result2 = new LazyWrapper(this.__wrapped__);
            result2.__actions__ = copyArray(this.__actions__);
            result2.__dir__ = this.__dir__;
            result2.__filtered__ = this.__filtered__;
            result2.__iteratees__ = copyArray(this.__iteratees__);
            result2.__takeCount__ = this.__takeCount__;
            result2.__views__ = copyArray(this.__views__);
            return result2;
          }
          function lazyReverse() {
            if (this.__filtered__) {
              var result2 = new LazyWrapper(this);
              result2.__dir__ = -1;
              result2.__filtered__ = true;
            } else {
              result2 = this.clone();
              result2.__dir__ *= -1;
            }
            return result2;
          }
          function lazyValue() {
            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length && takeCount == length) {
              return baseWrapperValue(array, this.__actions__);
            }
            var result2 = [];
            outer:
              while (length-- && resIndex < takeCount) {
                index += dir;
                var iterIndex = -1, value = array[index];
                while (++iterIndex < iterLength) {
                  var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                  if (type == LAZY_MAP_FLAG) {
                    value = computed;
                  } else if (!computed) {
                    if (type == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
                result2[resIndex++] = value;
              }
            return result2;
          }
          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          function Hash(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          function hashDelete(key) {
            var result2 = this.has(key) && delete this.__data__[key];
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result2 = data[key];
              return result2 === HASH_UNDEFINED ? undefined2 : result2;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined2;
          }
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
          }
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
            return this;
          }
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          function ListCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return index < 0 ? undefined2 : data[index][1];
          }
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          function listCacheSet(key, value) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }
            return this;
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          function MapCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash(),
              "map": new (Map2 || ListCache)(),
              "string": new Hash()
            };
          }
          function mapCacheDelete(key) {
            var result2 = getMapData(this, key)["delete"](key);
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          function mapCacheSet(key, value) {
            var data = getMapData(this, key), size2 = data.size;
            data.set(key, value);
            this.size += data.size == size2 ? 0 : 1;
            return this;
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          function SetCache(values2) {
            var index = -1, length = values2 == null ? 0 : values2.length;
            this.__data__ = new MapCache();
            while (++index < length) {
              this.add(values2[index]);
            }
          }
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          function stackDelete(key) {
            var data = this.__data__, result2 = data["delete"](key);
            this.size = data.size;
            return result2;
          }
          function stackGet(key) {
            return this.__data__.get(key);
          }
          function stackHas(key) {
            return this.__data__.has(key);
          }
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          Stack.prototype.clear = stackClear;
          Stack.prototype["delete"] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
              (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
              isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
              isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
              isIndex(key, length)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function arraySample(array) {
            var length = array.length;
            return length ? array[baseRandom(0, length - 1)] : undefined2;
          }
          function arraySampleSize(array, n) {
            return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
          }
          function arrayShuffle(array) {
            return shuffleSelf(copyArray(array));
          }
          function assignMergeValue(object, key, value) {
            if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          function baseAggregator(collection, setter, iteratee2, accumulator) {
            baseEach(collection, function(value, key, collection2) {
              setter(accumulator, value, iteratee2(value), collection2);
            });
            return accumulator;
          }
          function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
          }
          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }
          function baseAssignValue(object, key, value) {
            if (key == "__proto__" && defineProperty) {
              defineProperty(object, key, {
                "configurable": true,
                "enumerable": true,
                "value": value,
                "writable": true
              });
            } else {
              object[key] = value;
            }
          }
          function baseAt(object, paths) {
            var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
            while (++index < length) {
              result2[index] = skip ? undefined2 : get(object, paths[index]);
            }
            return result2;
          }
          function baseClamp(number, lower, upper) {
            if (number === number) {
              if (upper !== undefined2) {
                number = number <= upper ? number : upper;
              }
              if (lower !== undefined2) {
                number = number >= lower ? number : lower;
              }
            }
            return number;
          }
          function baseClone(value, bitmask, customizer, key, object, stack) {
            var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) {
              result2 = object ? customizer(value, key, object, stack) : customizer(value);
            }
            if (result2 !== undefined2) {
              return result2;
            }
            if (!isObject(value)) {
              return value;
            }
            var isArr = isArray(value);
            if (isArr) {
              result2 = initCloneArray(value);
              if (!isDeep) {
                return copyArray(value, result2);
              }
            } else {
              var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
              }
              if (tag == objectTag || tag == argsTag || isFunc && !object) {
                result2 = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value : {};
                }
                result2 = initCloneByTag(value, tag, isDeep);
              }
            }
            stack || (stack = new Stack());
            var stacked = stack.get(value);
            if (stacked) {
              return stacked;
            }
            stack.set(value, result2);
            if (isSet(value)) {
              value.forEach(function(subValue) {
                result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
              });
            } else if (isMap(value)) {
              value.forEach(function(subValue, key2) {
                result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
            var props = isArr ? undefined2 : keysFunc(value);
            arrayEach(props || value, function(subValue, key2) {
              if (props) {
                key2 = subValue;
                subValue = value[key2];
              }
              assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
            return result2;
          }
          function baseConforms(source) {
            var props = keys(source);
            return function(object) {
              return baseConformsTo(object, source, props);
            };
          }
          function baseConformsTo(object, source, props) {
            var length = props.length;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (length--) {
              var key = props[length], predicate = source[key], value = object[key];
              if (value === undefined2 && !(key in object) || !predicate(value)) {
                return false;
              }
            }
            return true;
          }
          function baseDelay(func, wait, args) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return setTimeout2(function() {
              func.apply(undefined2, args);
            }, wait);
          }
          function baseDifference(array, values2, iteratee2, comparator) {
            var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
            if (!length) {
              return result2;
            }
            if (iteratee2) {
              values2 = arrayMap(values2, baseUnary(iteratee2));
            }
            if (comparator) {
              includes2 = arrayIncludesWith;
              isCommon = false;
            } else if (values2.length >= LARGE_ARRAY_SIZE) {
              includes2 = cacheHas;
              isCommon = false;
              values2 = new SetCache(values2);
            }
            outer:
              while (++index < length) {
                var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var valuesIndex = valuesLength;
                  while (valuesIndex--) {
                    if (values2[valuesIndex] === computed) {
                      continue outer;
                    }
                  }
                  result2.push(value);
                } else if (!includes2(values2, computed, comparator)) {
                  result2.push(value);
                }
              }
            return result2;
          }
          var baseEach = createBaseEach(baseForOwn);
          var baseEachRight = createBaseEach(baseForOwnRight, true);
          function baseEvery(collection, predicate) {
            var result2 = true;
            baseEach(collection, function(value, index, collection2) {
              result2 = !!predicate(value, index, collection2);
              return result2;
            });
            return result2;
          }
          function baseExtremum(array, iteratee2, comparator) {
            var index = -1, length = array.length;
            while (++index < length) {
              var value = array[index], current = iteratee2(value);
              if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
                var computed = current, result2 = value;
              }
            }
            return result2;
          }
          function baseFill(array, value, start, end) {
            var length = array.length;
            start = toInteger(start);
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end === undefined2 || end > length ? length : toInteger(end);
            if (end < 0) {
              end += length;
            }
            end = start > end ? 0 : toLength(end);
            while (start < end) {
              array[start++] = value;
            }
            return array;
          }
          function baseFilter(collection, predicate) {
            var result2 = [];
            baseEach(collection, function(value, index, collection2) {
              if (predicate(value, index, collection2)) {
                result2.push(value);
              }
            });
            return result2;
          }
          function baseFlatten(array, depth, predicate, isStrict, result2) {
            var index = -1, length = array.length;
            predicate || (predicate = isFlattenable);
            result2 || (result2 = []);
            while (++index < length) {
              var value = array[index];
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  baseFlatten(value, depth - 1, predicate, isStrict, result2);
                } else {
                  arrayPush(result2, value);
                }
              } else if (!isStrict) {
                result2[result2.length] = value;
              }
            }
            return result2;
          }
          var baseFor = createBaseFor();
          var baseForRight = createBaseFor(true);
          function baseForOwn(object, iteratee2) {
            return object && baseFor(object, iteratee2, keys);
          }
          function baseForOwnRight(object, iteratee2) {
            return object && baseForRight(object, iteratee2, keys);
          }
          function baseFunctions(object, props) {
            return arrayFilter(props, function(key) {
              return isFunction(object[key]);
            });
          }
          function baseGet(object, path) {
            path = castPath(path, object);
            var index = 0, length = path.length;
            while (object != null && index < length) {
              object = object[toKey(path[index++])];
            }
            return index && index == length ? object : undefined2;
          }
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result2 = keysFunc(object);
            return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
          }
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined2 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
          }
          function baseGt(value, other) {
            return value > other;
          }
          function baseHas(object, key) {
            return object != null && hasOwnProperty.call(object, key);
          }
          function baseHasIn(object, key) {
            return object != null && key in Object2(object);
          }
          function baseInRange(number, start, end) {
            return number >= nativeMin(start, end) && number < nativeMax(start, end);
          }
          function baseIntersection(arrays, iteratee2, comparator) {
            var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
            while (othIndex--) {
              var array = arrays[othIndex];
              if (othIndex && iteratee2) {
                array = arrayMap(array, baseUnary(iteratee2));
              }
              maxLength = nativeMin(array.length, maxLength);
              caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
            }
            array = arrays[0];
            var index = -1, seen = caches[0];
            outer:
              while (++index < length && result2.length < maxLength) {
                var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                  othIndex = othLength;
                  while (--othIndex) {
                    var cache = caches[othIndex];
                    if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                      continue outer;
                    }
                  }
                  if (seen) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseInverter(object, setter, iteratee2, accumulator) {
            baseForOwn(object, function(value, key, object2) {
              setter(accumulator, iteratee2(value), key, object2);
            });
            return accumulator;
          }
          function baseInvoke(object, path, args) {
            path = castPath(path, object);
            object = parent(object, path);
            var func = object == null ? object : object[toKey(last(path))];
            return func == null ? undefined2 : apply(func, object, args);
          }
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }
          function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
          }
          function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
          }
          function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
          }
          function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object)) {
              if (!isBuffer(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack());
              return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack || (stack = new Stack());
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
          }
          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
          }
          function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length, length = index, noCustomizer = !customizer;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (index--) {
              var data = matchData[index];
              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
              }
            }
            while (++index < length) {
              data = matchData[index];
              var key = data[0], objValue = object[key], srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === undefined2 && !(key in object)) {
                  return false;
                }
              } else {
                var stack = new Stack();
                if (customizer) {
                  var result2 = customizer(objValue, srcValue, key, object, source, stack);
                }
                if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                  return false;
                }
              }
            }
            return true;
          }
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
          }
          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
          }
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          function baseIteratee(value) {
            if (typeof value == "function") {
              return value;
            }
            if (value == null) {
              return identity;
            }
            if (typeof value == "object") {
              return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
          }
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }
            var result2 = [];
            for (var key in Object2(object)) {
              if (hasOwnProperty.call(object, key) && key != "constructor") {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseKeysIn(object) {
            if (!isObject(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype(object), result2 = [];
            for (var key in object) {
              if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseLt(value, other) {
            return value < other;
          }
          function baseMap(collection, iteratee2) {
            var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value, key, collection2) {
              result2[++index] = iteratee2(value, key, collection2);
            });
            return result2;
          }
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object) {
              return object === source || baseIsMatch(object, source, matchData);
            };
          }
          function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path), srcValue);
            }
            return function(object) {
              var objValue = get(object, path);
              return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return;
            }
            baseFor(source, function(srcValue, key) {
              stack || (stack = new Stack());
              if (isObject(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
                if (newValue === undefined2) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }
          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
            var isCommon = newValue === undefined2;
            if (isCommon) {
              var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject(objValue) || isFunction(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack["delete"](srcValue);
            }
            assignMergeValue(object, key, newValue);
          }
          function baseNth(array, n) {
            var length = array.length;
            if (!length) {
              return;
            }
            n += n < 0 ? length : 0;
            return isIndex(n, length) ? array[n] : undefined2;
          }
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap(iteratees, function(iteratee2) {
                if (isArray(iteratee2)) {
                  return function(value) {
                    return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                  };
                }
                return iteratee2;
              });
            } else {
              iteratees = [identity];
            }
            var index = -1;
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            var result2 = baseMap(collection, function(value, key, collection2) {
              var criteria = arrayMap(iteratees, function(iteratee2) {
                return iteratee2(value);
              });
              return { "criteria": criteria, "index": ++index, "value": value };
            });
            return baseSortBy(result2, function(object, other) {
              return compareMultiple(object, other, orders);
            });
          }
          function basePick(object, paths) {
            return basePickBy(object, paths, function(value, path) {
              return hasIn(object, path);
            });
          }
          function basePickBy(object, paths, predicate) {
            var index = -1, length = paths.length, result2 = {};
            while (++index < length) {
              var path = paths[index], value = baseGet(object, path);
              if (predicate(value, path)) {
                baseSet(result2, castPath(path, object), value);
              }
            }
            return result2;
          }
          function basePropertyDeep(path) {
            return function(object) {
              return baseGet(object, path);
            };
          }
          function basePullAll(array, values2, iteratee2, comparator) {
            var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
            if (array === values2) {
              values2 = copyArray(values2);
            }
            if (iteratee2) {
              seen = arrayMap(array, baseUnary(iteratee2));
            }
            while (++index < length) {
              var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
              while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
                if (seen !== array) {
                  splice.call(seen, fromIndex, 1);
                }
                splice.call(array, fromIndex, 1);
              }
            }
            return array;
          }
          function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0, lastIndex = length - 1;
            while (length--) {
              var index = indexes[length];
              if (length == lastIndex || index !== previous) {
                var previous = index;
                if (isIndex(index)) {
                  splice.call(array, index, 1);
                } else {
                  baseUnset(array, index);
                }
              }
            }
            return array;
          }
          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
          }
          function baseRange(start, end, step, fromRight) {
            var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
            while (length--) {
              result2[fromRight ? length : ++index] = start;
              start += step;
            }
            return result2;
          }
          function baseRepeat(string, n) {
            var result2 = "";
            if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
              return result2;
            }
            do {
              if (n % 2) {
                result2 += string;
              }
              n = nativeFloor(n / 2);
              if (n) {
                string += string;
              }
            } while (n);
            return result2;
          }
          function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + "");
          }
          function baseSample(collection) {
            return arraySample(values(collection));
          }
          function baseSampleSize(collection, n) {
            var array = values(collection);
            return shuffleSelf(array, baseClamp(n, 0, array.length));
          }
          function baseSet(object, path, value, customizer) {
            if (!isObject(object)) {
              return object;
            }
            path = castPath(path, object);
            var index = -1, length = path.length, lastIndex = length - 1, nested = object;
            while (nested != null && ++index < length) {
              var key = toKey(path[index]), newValue = value;
              if (key === "__proto__" || key === "constructor" || key === "prototype") {
                return object;
              }
              if (index != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined2;
                if (newValue === undefined2) {
                  newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                }
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object;
          }
          var baseSetData = !metaMap ? identity : function(func, data) {
            metaMap.set(func, data);
            return func;
          };
          var baseSetToString = !defineProperty ? identity : function(func, string) {
            return defineProperty(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant(string),
              "writable": true
            });
          };
          function baseShuffle(collection) {
            return shuffleSelf(values(collection));
          }
          function baseSlice(array, start, end) {
            var index = -1, length = array.length;
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end > length ? length : end;
            if (end < 0) {
              end += length;
            }
            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result2 = Array2(length);
            while (++index < length) {
              result2[index] = array[index + start];
            }
            return result2;
          }
          function baseSome(collection, predicate) {
            var result2;
            baseEach(collection, function(value, index, collection2) {
              result2 = predicate(value, index, collection2);
              return !result2;
            });
            return !!result2;
          }
          function baseSortedIndex(array, value, retHighest) {
            var low = 0, high = array == null ? low : array.length;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1, computed = array[mid];
                if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return baseSortedIndexBy(array, value, identity, retHighest);
          }
          function baseSortedIndexBy(array, value, iteratee2, retHighest) {
            var low = 0, high = array == null ? 0 : array.length;
            if (high === 0) {
              return 0;
            }
            value = iteratee2(value);
            var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed <= value : computed < value;
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }
          function baseSortedUniq(array, iteratee2) {
            var index = -1, length = array.length, resIndex = 0, result2 = [];
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              if (!index || !eq(computed, seen)) {
                var seen = computed;
                result2[resIndex++] = value === 0 ? 0 : value;
              }
            }
            return result2;
          }
          function baseToNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            return +value;
          }
          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isArray(value)) {
              return arrayMap(value, baseToString) + "";
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function baseUniq(array, iteratee2, comparator) {
            var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
            if (comparator) {
              isCommon = false;
              includes2 = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
              var set2 = iteratee2 ? null : createSet(array);
              if (set2) {
                return setToArray(set2);
              }
              isCommon = false;
              includes2 = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee2 ? [] : result2;
            }
            outer:
              while (++index < length) {
                var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var seenIndex = seen.length;
                  while (seenIndex--) {
                    if (seen[seenIndex] === computed) {
                      continue outer;
                    }
                  }
                  if (iteratee2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                } else if (!includes2(seen, computed, comparator)) {
                  if (seen !== result2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseUnset(object, path) {
            path = castPath(path, object);
            object = parent(object, path);
            return object == null || delete object[toKey(last(path))];
          }
          function baseUpdate(object, path, updater, customizer) {
            return baseSet(object, path, updater(baseGet(object, path)), customizer);
          }
          function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length, index = fromRight ? length : -1;
            while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
            }
            return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
          }
          function baseWrapperValue(value, actions) {
            var result2 = value;
            if (result2 instanceof LazyWrapper) {
              result2 = result2.value();
            }
            return arrayReduce(actions, function(result3, action) {
              return action.func.apply(action.thisArg, arrayPush([result3], action.args));
            }, result2);
          }
          function baseXor(arrays, iteratee2, comparator) {
            var length = arrays.length;
            if (length < 2) {
              return length ? baseUniq(arrays[0]) : [];
            }
            var index = -1, result2 = Array2(length);
            while (++index < length) {
              var array = arrays[index], othIndex = -1;
              while (++othIndex < length) {
                if (othIndex != index) {
                  result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
                }
              }
            }
            return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
          }
          function baseZipObject(props, values2, assignFunc) {
            var index = -1, length = props.length, valsLength = values2.length, result2 = {};
            while (++index < length) {
              var value = index < valsLength ? values2[index] : undefined2;
              assignFunc(result2, props[index], value);
            }
            return result2;
          }
          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
          }
          function castFunction(value) {
            return typeof value == "function" ? value : identity;
          }
          function castPath(value, object) {
            if (isArray(value)) {
              return value;
            }
            return isKey(value, object) ? [value] : stringToPath(toString2(value));
          }
          var castRest = baseRest;
          function castSlice(array, start, end) {
            var length = array.length;
            end = end === undefined2 ? length : end;
            return !start && end >= length ? array : baseSlice(array, start, end);
          }
          var clearTimeout2 = ctxClearTimeout || function(id) {
            return root.clearTimeout(id);
          };
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }
            var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            buffer.copy(result2);
            return result2;
          }
          function cloneArrayBuffer(arrayBuffer) {
            var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
            return result2;
          }
          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }
          function cloneRegExp(regexp) {
            var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result2.lastIndex = regexp.lastIndex;
            return result2;
          }
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
          }
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
              var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }
          function compareMultiple(object, other, orders) {
            var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
            while (++index < length) {
              var result2 = compareAscending(objCriteria[index], othCriteria[index]);
              if (result2) {
                if (index >= ordersLength) {
                  return result2;
                }
                var order = orders[index];
                return result2 * (order == "desc" ? -1 : 1);
              }
            }
            return object.index - other.index;
          }
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
              result2[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[holders[argsIndex]] = args[argsIndex];
              }
            }
            while (rangeLength--) {
              result2[leftIndex++] = args[argsIndex++];
            }
            return result2;
          }
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
              result2[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
              result2[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[offset + holders[holdersIndex]] = args[argsIndex++];
              }
            }
            return result2;
          }
          function copyArray(source, array) {
            var index = -1, length = source.length;
            array || (array = Array2(length));
            while (++index < length) {
              array[index] = source[index];
            }
            return array;
          }
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1, length = props.length;
            while (++index < length) {
              var key = props[index];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
              if (newValue === undefined2) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }
            return object;
          }
          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
          }
          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }
          function createAggregator(setter, initializer) {
            return function(collection, iteratee2) {
              var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
            };
          }
          function createAssigner(assigner) {
            return baseRest(function(object, sources) {
              var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
              customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined2 : customizer;
                length = 1;
              }
              object = Object2(object);
              while (++index < length) {
                var source = sources[index];
                if (source) {
                  assigner(object, source, index, customizer);
                }
              }
              return object;
            });
          }
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee2) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee2);
              }
              var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
              while (fromRight ? index-- : ++index < length) {
                if (iteratee2(iterable[index], index, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor(fromRight) {
            return function(object, iteratee2, keysFunc) {
              var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
              while (length--) {
                var key = props[fromRight ? length : ++index];
                if (iteratee2(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return fn.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
          }
          function createCaseFirst(methodName) {
            return function(string) {
              string = toString2(string);
              var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
              var chr = strSymbols ? strSymbols[0] : string.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          function createCompounder(callback) {
            return function(string) {
              return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
            };
          }
          function createCtor(Ctor) {
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor();
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
              return isObject(result2) ? result2 : thisBinding;
            };
          }
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
              while (index--) {
                args[index] = arguments[index];
              }
              var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length -= holders.length;
              if (length < arity) {
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  undefined2,
                  args,
                  holders,
                  undefined2,
                  undefined2,
                  arity - length
                );
              }
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return apply(fn, this, args);
            }
            return wrapper;
          }
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object2(collection);
              if (!isArrayLike(collection)) {
                var iteratee2 = getIteratee(predicate, 3);
                collection = keys(collection);
                predicate = function(key) {
                  return iteratee2(iterable[key], key, iterable);
                };
              }
              var index = findIndexFunc(collection, predicate, fromIndex);
              return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
            };
          }
          function createFlow(fromRight) {
            return flatRest(function(funcs) {
              var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
              if (fromRight) {
                funcs.reverse();
              }
              while (index--) {
                var func = funcs[index];
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                  var wrapper = new LodashWrapper([], true);
                }
              }
              index = wrapper ? index : length;
              while (++index < length) {
                func = funcs[index];
                var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                } else {
                  wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }
              return function() {
                var args = arguments, value = args[0];
                if (wrapper && args.length == 1 && isArray(value)) {
                  return wrapper.plant(value).value();
                }
                var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
                while (++index2 < length) {
                  result2 = funcs[index2].call(this, result2);
                }
                return result2;
              };
            });
          }
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index = length;
              while (index--) {
                args[index] = arguments[index];
              }
              if (isCurried) {
                var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }
              length -= holdersCount;
              if (isCurried && length < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  thisArg,
                  args,
                  newHolders,
                  argPos,
                  ary2,
                  arity - length
                );
              }
              var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
              length = args.length;
              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length > 1) {
                args.reverse();
              }
              if (isAry && ary2 < length) {
                args.length = ary2;
              }
              if (this && this !== root && this instanceof wrapper) {
                fn = Ctor || createCtor(fn);
              }
              return fn.apply(thisBinding, args);
            }
            return wrapper;
          }
          function createInverter(setter, toIteratee) {
            return function(object, iteratee2) {
              return baseInverter(object, setter, toIteratee(iteratee2), {});
            };
          }
          function createMathOperation(operator, defaultValue) {
            return function(value, other) {
              var result2;
              if (value === undefined2 && other === undefined2) {
                return defaultValue;
              }
              if (value !== undefined2) {
                result2 = value;
              }
              if (other !== undefined2) {
                if (result2 === undefined2) {
                  return other;
                }
                if (typeof value == "string" || typeof other == "string") {
                  value = baseToString(value);
                  other = baseToString(other);
                } else {
                  value = baseToNumber(value);
                  other = baseToNumber(other);
                }
                result2 = operator(value, other);
              }
              return result2;
            };
          }
          function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
              iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
              return baseRest(function(args) {
                var thisArg = this;
                return arrayFunc(iteratees, function(iteratee2) {
                  return apply(iteratee2, thisArg, args);
                });
              });
            });
          }
          function createPadding(length, chars) {
            chars = chars === undefined2 ? " " : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length) : chars;
            }
            var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
          }
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              return apply(fn, isBind ? thisArg : this, args);
            }
            return wrapper;
          }
          function createRange(fromRight) {
            return function(start, end, step) {
              if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
                end = step = undefined2;
              }
              start = toFinite(start);
              if (end === undefined2) {
                end = start;
                start = 0;
              } else {
                end = toFinite(end);
              }
              step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
              return baseRange(start, end, step, fromRight);
            };
          }
          function createRelationalOperation(operator) {
            return function(value, other) {
              if (!(typeof value == "string" && typeof other == "string")) {
                value = toNumber(value);
                other = toNumber(other);
              }
              return operator(value, other);
            };
          }
          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }
            var newData = [
              func,
              bitmask,
              thisArg,
              newPartials,
              newHolders,
              newPartialsRight,
              newHoldersRight,
              argPos,
              ary2,
              arity
            ];
            var result2 = wrapFunc.apply(undefined2, newData);
            if (isLaziable(func)) {
              setData(result2, newData);
            }
            result2.placeholder = placeholder;
            return setWrapToString(result2, func, bitmask);
          }
          function createRound(methodName) {
            var func = Math2[methodName];
            return function(number, precision) {
              number = toNumber(number);
              precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
              if (precision && nativeIsFinite(number)) {
                var pair = (toString2(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                pair = (toString2(value) + "e").split("e");
                return +(pair[0] + "e" + (+pair[1] - precision));
              }
              return func(number);
            };
          }
          var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
            return new Set2(values2);
          };
          function createToPairs(keysFunc) {
            return function(object) {
              var tag = getTag(object);
              if (tag == mapTag) {
                return mapToArray(object);
              }
              if (tag == setTag) {
                return setToPairs(object);
              }
              return baseToPairs(object, keysFunc(object));
            };
          }
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined2;
            }
            ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
            arity = arity === undefined2 ? arity : toInteger(arity);
            length -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials, holdersRight = holders;
              partials = holders = undefined2;
            }
            var data = isBindKey ? undefined2 : getData(func);
            var newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary2,
              arity
            ];
            if (data) {
              mergeData(newData, data);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result2 = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result2 = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result2 = createPartial(func, bitmask, thisArg, partials);
            } else {
              result2 = createHybrid.apply(undefined2, newData);
            }
            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result2, newData), func, bitmask);
          }
          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              return srcValue;
            }
            return objValue;
          }
          function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            if (isObject(objValue) && isObject(srcValue)) {
              stack.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
              stack["delete"](srcValue);
            }
            return objValue;
          }
          function customOmitClone(value) {
            return isPlainObject(value) ? undefined2 : value;
          }
          function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var arrStacked = stack.get(array);
            var othStacked = stack.get(other);
            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array;
            }
            var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
            stack.set(array, other);
            stack.set(other, array);
            while (++index < arrLength) {
              var arrValue = array[index], othValue = other[index];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
              }
              if (compared !== undefined2) {
                if (compared) {
                  continue;
                }
                result2 = false;
                break;
              }
              if (seen) {
                if (!arraySome(other, function(othValue2, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result2 = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result2 = false;
                break;
              }
            }
            stack["delete"](array);
            stack["delete"](other);
            return result2;
          }
          function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }
                object = object.buffer;
                other = other.buffer;
              case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                  return false;
                }
                return true;
              case boolTag:
              case dateTag:
              case numberTag:
                return eq(+object, +other);
              case errorTag:
                return object.name == other.name && object.message == other.message;
              case regexpTag:
              case stringTag:
                return object == other + "";
              case mapTag:
                var convert = mapToArray;
              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);
                if (object.size != other.size && !isPartial) {
                  return false;
                }
                var stacked = stack.get(object);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;
                stack.set(object, other);
                var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                stack["delete"](object);
                return result2;
              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
            }
            return false;
          }
          function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index = objLength;
            while (index--) {
              var key = objProps[index];
              if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                return false;
              }
            }
            var objStacked = stack.get(object);
            var othStacked = stack.get(other);
            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object;
            }
            var result2 = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while (++index < objLength) {
              key = objProps[index];
              var objValue = object[key], othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
              }
              if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result2 = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result2 && !skipCtor) {
              var objCtor = object.constructor, othCtor = other.constructor;
              if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result2 = false;
              }
            }
            stack["delete"](object);
            stack["delete"](other);
            return result2;
          }
          function flatRest(func) {
            return setToString(overRest(func, undefined2, flatten), func + "");
          }
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
          }
          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
          }
          var getData = !metaMap ? noop : function(func) {
            return metaMap.get(func);
          };
          function getFuncName(func) {
            var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
            while (length--) {
              var data = array[length], otherFunc = data.func;
              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }
            return result2;
          }
          function getHolder(func) {
            var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
            return object.placeholder;
          }
          function getIteratee() {
            var result2 = lodash.iteratee || iteratee;
            result2 = result2 === iteratee ? baseIteratee : result2;
            return arguments.length ? result2(arguments[0], arguments[1]) : result2;
          }
          function getMapData(map2, key) {
            var data = map2.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          function getMatchData(object) {
            var result2 = keys(object), length = result2.length;
            while (length--) {
              var key = result2[length], value = object[key];
              result2[length] = [key, value, isStrictComparable(value)];
            }
            return result2;
          }
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined2;
          }
          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
              value[symToStringTag] = undefined2;
              var unmasked = true;
            } catch (e) {
            }
            var result2 = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result2;
          }
          var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
            if (object == null) {
              return [];
            }
            object = Object2(object);
            return arrayFilter(nativeGetSymbols(object), function(symbol) {
              return propertyIsEnumerable.call(object, symbol);
            });
          };
          var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
            var result2 = [];
            while (object) {
              arrayPush(result2, getSymbols(object));
              object = getPrototype(object);
            }
            return result2;
          };
          var getTag = baseGetTag;
          if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
            getTag = function(value) {
              var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;
                  case mapCtorString:
                    return mapTag;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag;
                  case weakMapCtorString:
                    return weakMapTag;
                }
              }
              return result2;
            };
          }
          function getView(start, end, transforms) {
            var index = -1, length = transforms.length;
            while (++index < length) {
              var data = transforms[index], size2 = data.size;
              switch (data.type) {
                case "drop":
                  start += size2;
                  break;
                case "dropRight":
                  end -= size2;
                  break;
                case "take":
                  end = nativeMin(end, start + size2);
                  break;
                case "takeRight":
                  start = nativeMax(start, end - size2);
                  break;
              }
            }
            return { "start": start, "end": end };
          }
          function getWrapDetails(source) {
            var match = source.match(reWrapDetails);
            return match ? match[1].split(reSplitDetails) : [];
          }
          function hasPath(object, path, hasFunc) {
            path = castPath(path, object);
            var index = -1, length = path.length, result2 = false;
            while (++index < length) {
              var key = toKey(path[index]);
              if (!(result2 = object != null && hasFunc(object, key))) {
                break;
              }
              object = object[key];
            }
            if (result2 || ++index != length) {
              return result2;
            }
            length = object == null ? 0 : object.length;
            return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
          }
          function initCloneArray(array) {
            var length = array.length, result2 = new array.constructor(length);
            if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
              result2.index = array.index;
              result2.input = array.input;
            }
            return result2;
          }
          function initCloneObject(object) {
            return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);
              case boolTag:
              case dateTag:
                return new Ctor(+object);
              case dataViewTag:
                return cloneDataView(object, isDeep);
              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);
              case mapTag:
                return new Ctor();
              case numberTag:
              case stringTag:
                return new Ctor(object);
              case regexpTag:
                return cloneRegExp(object);
              case setTag:
                return new Ctor();
              case symbolTag:
                return cloneSymbol(object);
            }
          }
          function insertWrapDetails(source, details) {
            var length = details.length;
            if (!length) {
              return source;
            }
            var lastIndex = length - 1;
            details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
            details = details.join(length > 2 ? ", " : " ");
            return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
          }
          function isFlattenable(value) {
            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
          }
          function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
              return false;
            }
            var type = typeof index;
            if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
              return eq(object[index], value);
            }
            return false;
          }
          function isKey(value, object) {
            if (isArray(value)) {
              return false;
            }
            var type = typeof value;
            if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
          }
          function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
          }
          function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash[funcName];
            if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
              return false;
            }
            if (func === other) {
              return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
          }
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          var isMaskable = coreJsData ? isFunction : stubFalse;
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
            return value === proto;
          }
          function isStrictComparable(value) {
            return value === value && !isObject(value);
          }
          function matchesStrictComparable(key, srcValue) {
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
            };
          }
          function memoizeCapped(func) {
            var result2 = memoize(func, function(key) {
              if (cache.size === MAX_MEMOIZE_SIZE) {
                cache.clear();
              }
              return key;
            });
            var cache = result2.cache;
            return result2;
          }
          function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!(isCommon || isCombo)) {
              return data;
            }
            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2];
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            value = source[5];
            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            value = source[7];
            if (value) {
              data[7] = value;
            }
            if (srcBitmask & WRAP_ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            if (data[9] == null) {
              data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
          }
          function nativeKeysIn(object) {
            var result2 = [];
            if (object != null) {
              for (var key in Object2(object)) {
                result2.push(key);
              }
            }
            return result2;
          }
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          function overRest(func, start, transform2) {
            start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
            return function() {
              var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
              while (++index < length) {
                array[index] = args[start + index];
              }
              index = -1;
              var otherArgs = Array2(start + 1);
              while (++index < start) {
                otherArgs[index] = args[index];
              }
              otherArgs[start] = transform2(array);
              return apply(func, this, otherArgs);
            };
          }
          function parent(object, path) {
            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
          }
          function reorder(array, indexes) {
            var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
            while (length--) {
              var index = indexes[length];
              array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
            }
            return array;
          }
          function safeGet(object, key) {
            if (key === "constructor" && typeof object[key] === "function") {
              return;
            }
            if (key == "__proto__") {
              return;
            }
            return object[key];
          }
          var setData = shortOut(baseSetData);
          var setTimeout2 = ctxSetTimeout || function(func, wait) {
            return root.setTimeout(func, wait);
          };
          var setToString = shortOut(baseSetToString);
          function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + "";
            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined2, arguments);
            };
          }
          function shuffleSelf(array, size2) {
            var index = -1, length = array.length, lastIndex = length - 1;
            size2 = size2 === undefined2 ? length : size2;
            while (++index < size2) {
              var rand = baseRandom(index, lastIndex), value = array[rand];
              array[rand] = array[index];
              array[index] = value;
            }
            array.length = size2;
            return array;
          }
          var stringToPath = memoizeCapped(function(string) {
            var result2 = [];
            if (string.charCodeAt(0) === 46) {
              result2.push("");
            }
            string.replace(rePropName, function(match, number, quote, subString) {
              result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
            });
            return result2;
          });
          function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) {
              return value;
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {
              }
              try {
                return func + "";
              } catch (e) {
              }
            }
            return "";
          }
          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function(pair) {
              var value = "_." + pair[0];
              if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }
          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
              return wrapper.clone();
            }
            var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result2.__actions__ = copyArray(wrapper.__actions__);
            result2.__index__ = wrapper.__index__;
            result2.__values__ = wrapper.__values__;
            return result2;
          }
          function chunk(array, size2, guard) {
            if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
              size2 = 1;
            } else {
              size2 = nativeMax(toInteger(size2), 0);
            }
            var length = array == null ? 0 : array.length;
            if (!length || size2 < 1) {
              return [];
            }
            var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
            while (index < length) {
              result2[resIndex++] = baseSlice(array, index, index += size2);
            }
            return result2;
          }
          function compact(array) {
            var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
            while (++index < length) {
              var value = array[index];
              if (value) {
                result2[resIndex++] = value;
              }
            }
            return result2;
          }
          function concat() {
            var length = arguments.length;
            if (!length) {
              return [];
            }
            var args = Array2(length - 1), array = arguments[0], index = length;
            while (index--) {
              args[index - 1] = arguments[index];
            }
            return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
          }
          var difference = baseRest(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
          });
          var differenceBy = baseRest(function(array, values2) {
            var iteratee2 = last(values2);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
          });
          var differenceWith = baseRest(function(array, values2) {
            var comparator = last(values2);
            if (isArrayLikeObject(comparator)) {
              comparator = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
          });
          function drop(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            return baseSlice(array, n < 0 ? 0 : n, length);
          }
          function dropRight(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }
          function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
          }
          function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
          }
          function fill(array, value, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
              start = 0;
              end = length;
            }
            return baseFill(array, value, start, end);
          }
          function findIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length + index, 0);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index);
          }
          function findLastIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = length - 1;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index, true);
          }
          function flatten(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, 1) : [];
          }
          function flattenDeep(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, INFINITY) : [];
          }
          function flattenDepth(array, depth) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(array, depth);
          }
          function fromPairs(pairs) {
            var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
            while (++index < length) {
              var pair = pairs[index];
              result2[pair[0]] = pair[1];
            }
            return result2;
          }
          function head(array) {
            return array && array.length ? array[0] : undefined2;
          }
          function indexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length + index, 0);
            }
            return baseIndexOf(array, value, index);
          }
          function initial(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 0, -1) : [];
          }
          var intersection = baseRest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          var intersectionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            if (iteratee2 === last(mapped)) {
              iteratee2 = undefined2;
            } else {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
          });
          var intersectionWith = baseRest(function(arrays) {
            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            if (comparator) {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
          });
          function join(array, separator) {
            return array == null ? "" : nativeJoin.call(array, separator);
          }
          function last(array) {
            var length = array == null ? 0 : array.length;
            return length ? array[length - 1] : undefined2;
          }
          function lastIndexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = length;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
          }
          function nth(array, n) {
            return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
          }
          var pull = baseRest(pullAll);
          function pullAll(array, values2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
          }
          function pullAllBy(array, values2, iteratee2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
          }
          function pullAllWith(array, values2, comparator) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
          }
          var pullAt = flatRest(function(array, indexes) {
            var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
            basePullAt(array, arrayMap(indexes, function(index) {
              return isIndex(index, length) ? +index : index;
            }).sort(compareAscending));
            return result2;
          });
          function remove(array, predicate) {
            var result2 = [];
            if (!(array && array.length)) {
              return result2;
            }
            var index = -1, indexes = [], length = array.length;
            predicate = getIteratee(predicate, 3);
            while (++index < length) {
              var value = array[index];
              if (predicate(value, index, array)) {
                result2.push(value);
                indexes.push(index);
              }
            }
            basePullAt(array, indexes);
            return result2;
          }
          function reverse(array) {
            return array == null ? array : nativeReverse.call(array);
          }
          function slice(array, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
              start = 0;
              end = length;
            } else {
              start = start == null ? 0 : toInteger(start);
              end = end === undefined2 ? length : toInteger(end);
            }
            return baseSlice(array, start, end);
          }
          function sortedIndex(array, value) {
            return baseSortedIndex(array, value);
          }
          function sortedIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
          }
          function sortedIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index = baseSortedIndex(array, value);
              if (index < length && eq(array[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, true);
          }
          function sortedLastIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
          }
          function sortedLastIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index = baseSortedIndex(array, value, true) - 1;
              if (eq(array[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
          }
          function sortedUniqBy(array, iteratee2) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function tail(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 1, length) : [];
          }
          function take(array, n, guard) {
            if (!(array && array.length)) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }
          function takeRight(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, n < 0 ? 0 : n, length);
          }
          function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
          }
          function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
          }
          var union = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });
          var unionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
          });
          var unionWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
          });
          function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
          }
          function uniqBy(array, iteratee2) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function uniqWith(array, comparator) {
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return array && array.length ? baseUniq(array, undefined2, comparator) : [];
          }
          function unzip(array) {
            if (!(array && array.length)) {
              return [];
            }
            var length = 0;
            array = arrayFilter(array, function(group) {
              if (isArrayLikeObject(group)) {
                length = nativeMax(group.length, length);
                return true;
              }
            });
            return baseTimes(length, function(index) {
              return arrayMap(array, baseProperty(index));
            });
          }
          function unzipWith(array, iteratee2) {
            if (!(array && array.length)) {
              return [];
            }
            var result2 = unzip(array);
            if (iteratee2 == null) {
              return result2;
            }
            return arrayMap(result2, function(group) {
              return apply(iteratee2, undefined2, group);
            });
          }
          var without = baseRest(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
          });
          var xor = baseRest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
          });
          var xorBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
          });
          var xorWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
          });
          var zip = baseRest(unzip);
          function zipObject(props, values2) {
            return baseZipObject(props || [], values2 || [], assignValue);
          }
          function zipObjectDeep(props, values2) {
            return baseZipObject(props || [], values2 || [], baseSet);
          }
          var zipWith = baseRest(function(arrays) {
            var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
            iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
            return unzipWith(arrays, iteratee2);
          });
          function chain(value) {
            var result2 = lodash(value);
            result2.__chain__ = true;
            return result2;
          }
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          function thru(value, interceptor) {
            return interceptor(value);
          }
          var wrapperAt = flatRest(function(paths) {
            var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
              return baseAt(object, paths);
            };
            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
              return this.thru(interceptor);
            }
            value = value.slice(start, +start + (length ? 1 : 0));
            value.__actions__.push({
              "func": thru,
              "args": [interceptor],
              "thisArg": undefined2
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array) {
              if (length && !array.length) {
                array.push(undefined2);
              }
              return array;
            });
          });
          function wrapperChain() {
            return chain(this);
          }
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          function wrapperNext() {
            if (this.__values__ === undefined2) {
              this.__values__ = toArray(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
            return { "done": done, "value": value };
          }
          function wrapperToIterator() {
            return this;
          }
          function wrapperPlant(value) {
            var result2, parent2 = this;
            while (parent2 instanceof baseLodash) {
              var clone2 = wrapperClone(parent2);
              clone2.__index__ = 0;
              clone2.__values__ = undefined2;
              if (result2) {
                previous.__wrapped__ = clone2;
              } else {
                result2 = clone2;
              }
              var previous = clone2;
              parent2 = parent2.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result2;
          }
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                "func": thru,
                "args": [reverse],
                "thisArg": undefined2
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
          }
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          var countBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              ++result2[key];
            } else {
              baseAssignValue(result2, key, 1);
            }
          });
          function every(collection, predicate, guard) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          function filter(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          var find = createFind(findIndex);
          var findLast = createFind(findLastIndex);
          function flatMap(collection, iteratee2) {
            return baseFlatten(map(collection, iteratee2), 1);
          }
          function flatMapDeep(collection, iteratee2) {
            return baseFlatten(map(collection, iteratee2), INFINITY);
          }
          function flatMapDepth(collection, iteratee2, depth) {
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(map(collection, iteratee2), depth);
          }
          function forEach(collection, iteratee2) {
            var func = isArray(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function forEachRight(collection, iteratee2) {
            var func = isArray(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee2, 3));
          }
          var groupBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              result2[key].push(value);
            } else {
              baseAssignValue(result2, key, [value]);
            }
          });
          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            if (fromIndex < 0) {
              fromIndex = nativeMax(length + fromIndex, 0);
            }
            return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
          }
          var invokeMap = baseRest(function(collection, path, args) {
            var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value) {
              result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
            });
            return result2;
          });
          var keyBy = createAggregator(function(result2, value, key) {
            baseAssignValue(result2, key, value);
          });
          function map(collection, iteratee2) {
            var func = isArray(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (!isArray(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined2 : orders;
            if (!isArray(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseOrderBy(collection, iteratees, orders);
          }
          var partition = createAggregator(function(result2, value, key) {
            result2[key ? 0 : 1].push(value);
          }, function() {
            return [[], []];
          });
          function reduce(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
          }
          function reduceRight(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
          }
          function reject(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
          }
          function sample(collection) {
            var func = isArray(collection) ? arraySample : baseSample;
            return func(collection);
          }
          function sampleSize(collection, n, guard) {
            if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            var func = isArray(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n);
          }
          function shuffle(collection) {
            var func = isArray(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          function size(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike(collection)) {
              return isString(collection) ? stringSize(collection) : collection.length;
            }
            var tag = getTag(collection);
            if (tag == mapTag || tag == setTag) {
              return collection.size;
            }
            return baseKeys(collection).length;
          }
          function some(collection, predicate, guard) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          var sortBy = baseRest(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length = iteratees.length;
            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          var now = ctxNow || function() {
            return root.Date.now();
          };
          function after(n, func) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
              if (--n < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          function ary(func, n, guard) {
            n = guard ? undefined2 : n;
            n = func && n == null ? func.length : n;
            return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
          }
          function before(n, func) {
            var result2;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
              if (--n > 0) {
                result2 = func.apply(this, arguments);
              }
              if (n <= 1) {
                func = undefined2;
              }
              return result2;
            };
          }
          var bind = baseRest(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          var bindKey = baseRest(function(object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object, partials, holders);
          });
          function curry(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curry.placeholder;
            return result2;
          }
          function curryRight(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curryRight.placeholder;
            return result2;
          }
          function debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            wait = toNumber(wait) || 0;
            if (isObject(options)) {
              leading = !!options.leading;
              maxing = "maxWait" in options;
              maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = undefined2;
              lastInvokeTime = time;
              result2 = func.apply(thisArg, args);
              return result2;
            }
            function leadingEdge(time) {
              lastInvokeTime = time;
              timerId = setTimeout2(timerExpired, wait);
              return leading ? invokeFunc(time) : result2;
            }
            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
              return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time = now();
              if (shouldInvoke(time)) {
                return trailingEdge(time);
              }
              timerId = setTimeout2(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
              timerId = undefined2;
              if (trailing && lastArgs) {
                return invokeFunc(time);
              }
              lastArgs = lastThis = undefined2;
              return result2;
            }
            function cancel() {
              if (timerId !== undefined2) {
                clearTimeout2(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined2;
            }
            function flush() {
              return timerId === undefined2 ? result2 : trailingEdge(now());
            }
            function debounced() {
              var time = now(), isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;
              if (isInvoking) {
                if (timerId === undefined2) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  clearTimeout2(timerId);
                  timerId = setTimeout2(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === undefined2) {
                timerId = setTimeout2(timerExpired, wait);
              }
              return result2;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
          }
          var defer = baseRest(function(func, args) {
            return baseDelay(func, 1, args);
          });
          var delay = baseRest(function(func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
          });
          function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          function memoize(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var memoized = function() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
              if (cache.has(key)) {
                return cache.get(key);
              }
              var result2 = func.apply(this, args);
              memoized.cache = cache.set(key, result2) || cache;
              return result2;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }
          memoize.Cache = MapCache;
          function negate(predicate) {
            if (typeof predicate != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }
          function once(func) {
            return before(2, func);
          }
          var overArgs = castRest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function(args) {
              var index = -1, length = nativeMin(args.length, funcsLength);
              while (++index < length) {
                args[index] = transforms[index].call(this, args[index]);
              }
              return apply(func, this, args);
            });
          });
          var partial = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
          });
          var partialRight = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
          });
          var rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
          });
          function rest(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start === undefined2 ? start : toInteger(start);
            return baseRest(func, start);
          }
          function spread(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start == null ? 0 : nativeMax(toInteger(start), 0);
            return baseRest(function(args) {
              var array = args[start], otherArgs = castSlice(args, 0, start);
              if (array) {
                arrayPush(otherArgs, array);
              }
              return apply(func, this, otherArgs);
            });
          }
          function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (isObject(options)) {
              leading = "leading" in options ? !!options.leading : leading;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return debounce(func, wait, {
              "leading": leading,
              "maxWait": wait,
              "trailing": trailing
            });
          }
          function unary(func) {
            return ary(func, 1);
          }
          function wrap(value, wrapper) {
            return partial(castFunction(wrapper), value);
          }
          function castArray() {
            if (!arguments.length) {
              return [];
            }
            var value = arguments[0];
            return isArray(value) ? value : [value];
          }
          function clone(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }
          function cloneWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
          }
          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }
          function conformsTo(object, source) {
            return source == null || baseConformsTo(object, source, keys(source));
          }
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          var gt2 = createRelationalOperation(baseGt);
          var gte = createRelationalOperation(function(value, other) {
            return value >= other;
          });
          var isArguments = baseIsArguments(function() {
            return arguments;
          }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
          };
          var isArray = Array2.isArray;
          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
          }
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          function isBoolean(value) {
            return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
          }
          var isBuffer = nativeIsBuffer || stubFalse;
          var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
          function isElement(value) {
            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
          }
          function isEmpty(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
              return !value.length;
            }
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) {
              return !value.size;
            }
            if (isPrototype(value)) {
              return !baseKeys(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty.call(value, key)) {
                return false;
              }
            }
            return true;
          }
          function isEqual(value, other) {
            return baseIsEqual(value, other);
          }
          function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            var result2 = customizer ? customizer(value, other) : undefined2;
            return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
          }
          function isError(value) {
            if (!isObjectLike(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
          }
          function isFinite2(value) {
            return typeof value == "number" && nativeIsFinite(value);
          }
          function isFunction(value) {
            if (!isObject(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          function isInteger(value) {
            return typeof value == "number" && value == toInteger(value);
          }
          function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          function isObject(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
          }
          function isObjectLike(value) {
            return value != null && typeof value == "object";
          }
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
          }
          function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseIsMatch(object, source, getMatchData(source), customizer);
          }
          function isNaN2(value) {
            return isNumber(value) && value != +value;
          }
          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error2(CORE_ERROR_TEXT);
            }
            return baseIsNative(value);
          }
          function isNull(value) {
            return value === null;
          }
          function isNil(value) {
            return value == null;
          }
          function isNumber(value) {
            return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
          }
          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
          }
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          function isString(value) {
            return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
          }
          function isSymbol(value) {
            return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
          }
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          function isUndefined(value) {
            return value === undefined2;
          }
          function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
          }
          function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
          }
          var lt = createRelationalOperation(baseLt);
          var lte = createRelationalOperation(function(value, other) {
            return value <= other;
          });
          function toArray(value) {
            if (!value) {
              return [];
            }
            if (isArrayLike(value)) {
              return isString(value) ? stringToArray(value) : copyArray(value);
            }
            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }
            var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
            return func(value);
          }
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
              var sign = value < 0 ? -1 : 1;
              return sign * MAX_INTEGER;
            }
            return value === value ? value : 0;
          }
          function toInteger(value) {
            var result2 = toFinite(value), remainder = result2 % 1;
            return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
          }
          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          function toNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            if (isObject(value)) {
              var other = typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject(other) ? other + "" : other;
            }
            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }
          function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
          }
          function toString2(value) {
            return value == null ? "" : baseToString(value);
          }
          var assign = createAssigner(function(object, source) {
            if (isPrototype(source) || isArrayLike(source)) {
              copyObject(source, keys(source), object);
              return;
            }
            for (var key in source) {
              if (hasOwnProperty.call(source, key)) {
                assignValue(object, key, source[key]);
              }
            }
          });
          var assignIn = createAssigner(function(object, source) {
            copyObject(source, keysIn(source), object);
          });
          var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
          });
          var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keys(source), object, customizer);
          });
          var at = flatRest(baseAt);
          function create(prototype, properties) {
            var result2 = baseCreate(prototype);
            return properties == null ? result2 : baseAssign(result2, properties);
          }
          var defaults = baseRest(function(object, sources) {
            object = Object2(object);
            var index = -1;
            var length = sources.length;
            var guard = length > 2 ? sources[2] : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length = 1;
            }
            while (++index < length) {
              var source = sources[index];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];
                if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                  object[key] = source[key];
                }
              }
            }
            return object;
          });
          var defaultsDeep = baseRest(function(args) {
            args.push(undefined2, customDefaultsMerge);
            return apply(mergeWith, undefined2, args);
          });
          function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
          }
          function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
          }
          function forIn(object, iteratee2) {
            return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forInRight(object, iteratee2) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forOwn(object, iteratee2) {
            return object && baseForOwn(object, getIteratee(iteratee2, 3));
          }
          function forOwnRight(object, iteratee2) {
            return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
          }
          function functions(object) {
            return object == null ? [] : baseFunctions(object, keys(object));
          }
          function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object));
          }
          function get(object, path, defaultValue) {
            var result2 = object == null ? undefined2 : baseGet(object, path);
            return result2 === undefined2 ? defaultValue : result2;
          }
          function has(object, path) {
            return object != null && hasPath(object, path, baseHas);
          }
          function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
          }
          var invert = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            result2[value] = key;
          }, constant(identity));
          var invertBy = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            if (hasOwnProperty.call(result2, value)) {
              result2[value].push(key);
            } else {
              result2[value] = [key];
            }
          }, getIteratee);
          var invoke = baseRest(baseInvoke);
          function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }
          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
          }
          function mapKeys(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, iteratee2(value, key, object2), value);
            });
            return result2;
          }
          function mapValues(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, key, iteratee2(value, key, object2));
            });
            return result2;
          }
          var merge = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });
          var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
          });
          var omit = flatRest(function(object, paths) {
            var result2 = {};
            if (object == null) {
              return result2;
            }
            var isDeep = false;
            paths = arrayMap(paths, function(path) {
              path = castPath(path, object);
              isDeep || (isDeep = path.length > 1);
              return path;
            });
            copyObject(object, getAllKeysIn(object), result2);
            if (isDeep) {
              result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }
            var length = paths.length;
            while (length--) {
              baseUnset(result2, paths[length]);
            }
            return result2;
          });
          function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)));
          }
          var pick = flatRest(function(object, paths) {
            return object == null ? {} : basePick(object, paths);
          });
          function pickBy(object, predicate) {
            if (object == null) {
              return {};
            }
            var props = arrayMap(getAllKeysIn(object), function(prop) {
              return [prop];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object, props, function(value, path) {
              return predicate(value, path[0]);
            });
          }
          function result(object, path, defaultValue) {
            path = castPath(path, object);
            var index = -1, length = path.length;
            if (!length) {
              length = 1;
              object = undefined2;
            }
            while (++index < length) {
              var value = object == null ? undefined2 : object[toKey(path[index])];
              if (value === undefined2) {
                index = length;
                value = defaultValue;
              }
              object = isFunction(value) ? value.call(object) : value;
            }
            return object;
          }
          function set(object, path, value) {
            return object == null ? object : baseSet(object, path, value);
          }
          function setWith(object, path, value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseSet(object, path, value, customizer);
          }
          var toPairs = createToPairs(keys);
          var toPairsIn = createToPairs(keysIn);
          function transform(object, iteratee2, accumulator) {
            var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
            iteratee2 = getIteratee(iteratee2, 4);
            if (accumulator == null) {
              var Ctor = object && object.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject(object)) {
                accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
              return iteratee2(accumulator, value, index, object2);
            });
            return accumulator;
          }
          function unset(object, path) {
            return object == null ? true : baseUnset(object, path);
          }
          function update(object, path, updater) {
            return object == null ? object : baseUpdate(object, path, castFunction(updater));
          }
          function updateWith(object, path, updater, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
          }
          function values(object) {
            return object == null ? [] : baseValues(object, keys(object));
          }
          function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object));
          }
          function clamp(number, lower, upper) {
            if (upper === undefined2) {
              upper = lower;
              lower = undefined2;
            }
            if (upper !== undefined2) {
              upper = toNumber(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower !== undefined2) {
              lower = toNumber(lower);
              lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber(number), lower, upper);
          }
          function inRange(number, start, end) {
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            number = toNumber(number);
            return baseInRange(number, start, end);
          }
          function random(lower, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
              upper = floating = undefined2;
            }
            if (floating === undefined2) {
              if (typeof upper == "boolean") {
                floating = upper;
                upper = undefined2;
              } else if (typeof lower == "boolean") {
                floating = lower;
                lower = undefined2;
              }
            }
            if (lower === undefined2 && upper === undefined2) {
              lower = 0;
              upper = 1;
            } else {
              lower = toFinite(lower);
              if (upper === undefined2) {
                upper = lower;
                lower = 0;
              } else {
                upper = toFinite(upper);
              }
            }
            if (lower > upper) {
              var temp = lower;
              lower = upper;
              upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower, upper);
          }
          var camelCase = createCompounder(function(result2, word, index) {
            word = word.toLowerCase();
            return result2 + (index ? capitalize(word) : word);
          });
          function capitalize(string) {
            return upperFirst(toString2(string).toLowerCase());
          }
          function deburr(string) {
            string = toString2(string);
            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
          }
          function endsWith(string, target, position) {
            string = toString2(string);
            target = baseToString(target);
            var length = string.length;
            position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
            var end = position;
            position -= target.length;
            return position >= 0 && string.slice(position, end) == target;
          }
          function escape(string) {
            string = toString2(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
          }
          function escapeRegExp(string) {
            string = toString2(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
          }
          var kebabCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "-" : "") + word.toLowerCase();
          });
          var lowerCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toLowerCase();
          });
          var lowerFirst = createCaseFirst("toLowerCase");
          function pad(string, length, chars) {
            string = toString2(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            if (!length || strLength >= length) {
              return string;
            }
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
          }
          function padEnd(string, length, chars) {
            string = toString2(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
          }
          function padStart(string, length, chars) {
            string = toString2(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
          }
          function parseInt2(string, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            return nativeParseInt(toString2(string).replace(reTrimStart, ""), radix || 0);
          }
          function repeat(string, n, guard) {
            if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            return baseRepeat(toString2(string), n);
          }
          function replace() {
            var args = arguments, string = toString2(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
          }
          var snakeCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "_" : "") + word.toLowerCase();
          });
          function split(string, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
              separator = limit = undefined2;
            }
            limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
              return [];
            }
            string = toString2(string);
            if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
              separator = baseToString(separator);
              if (!separator && hasUnicode(string)) {
                return castSlice(stringToArray(string), 0, limit);
              }
            }
            return string.split(separator, limit);
          }
          var startCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + upperFirst(word);
          });
          function startsWith(string, target, position) {
            string = toString2(string);
            position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
            target = baseToString(target);
            return string.slice(position, position + target.length) == target;
          }
          function template(string, options, guard) {
            var settings = lodash.templateSettings;
            if (guard && isIterateeCall(string, options, guard)) {
              options = undefined2;
            }
            string = toString2(string);
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp2(
              (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
              "g"
            );
            var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue);
              source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index = offset + match.length;
              return match;
            });
            source += "';\n";
            var variable = hasOwnProperty.call(options, "variable") && options.variable;
            if (!variable) {
              source = "with (obj) {\n" + source + "\n}\n";
            } else if (reForbiddenIdentifierChars.test(variable)) {
              throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result2 = attempt(function() {
              return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
            });
            result2.source = source;
            if (isError(result2)) {
              throw result2;
            }
            return result2;
          }
          function toLower(value) {
            return toString2(value).toLowerCase();
          }
          function toUpper(value) {
            return toString2(value).toUpperCase();
          }
          function trim(string, chars, guard) {
            string = toString2(string);
            if (string && (guard || chars === undefined2)) {
              return baseTrim(string);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start, end).join("");
          }
          function trimEnd(string, chars, guard) {
            string = toString2(string);
            if (string && (guard || chars === undefined2)) {
              return string.slice(0, trimmedEndIndex(string) + 1);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join("");
          }
          function trimStart(string, chars, guard) {
            string = toString2(string);
            if (string && (guard || chars === undefined2)) {
              return string.replace(reTrimStart, "");
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start).join("");
          }
          function truncate(string, options) {
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject(options)) {
              var separator = "separator" in options ? options.separator : separator;
              length = "length" in options ? toInteger(options.length) : length;
              omission = "omission" in options ? baseToString(options.omission) : omission;
            }
            string = toString2(string);
            var strLength = string.length;
            if (hasUnicode(string)) {
              var strSymbols = stringToArray(string);
              strLength = strSymbols.length;
            }
            if (length >= strLength) {
              return string;
            }
            var end = length - stringSize(omission);
            if (end < 1) {
              return omission;
            }
            var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
            if (separator === undefined2) {
              return result2 + omission;
            }
            if (strSymbols) {
              end += result2.length - end;
            }
            if (isRegExp(separator)) {
              if (string.slice(end).search(separator)) {
                var match, substring = result2;
                if (!separator.global) {
                  separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
                }
                separator.lastIndex = 0;
                while (match = separator.exec(substring)) {
                  var newEnd = match.index;
                }
                result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
              }
            } else if (string.indexOf(baseToString(separator), end) != end) {
              var index = result2.lastIndexOf(separator);
              if (index > -1) {
                result2 = result2.slice(0, index);
              }
            }
            return result2 + omission;
          }
          function unescape(string) {
            string = toString2(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
          }
          var upperCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toUpperCase();
          });
          var upperFirst = createCaseFirst("toUpperCase");
          function words(string, pattern, guard) {
            string = toString2(string);
            pattern = guard ? undefined2 : pattern;
            if (pattern === undefined2) {
              return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
            }
            return string.match(pattern) || [];
          }
          var attempt = baseRest(function(func, args) {
            try {
              return apply(func, undefined2, args);
            } catch (e) {
              return isError(e) ? e : new Error2(e);
            }
          });
          var bindAll = flatRest(function(object, methodNames) {
            arrayEach(methodNames, function(key) {
              key = toKey(key);
              baseAssignValue(object, key, bind(object[key], object));
            });
            return object;
          });
          function cond(pairs) {
            var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
            pairs = !length ? [] : arrayMap(pairs, function(pair) {
              if (typeof pair[1] != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              return [toIteratee(pair[0]), pair[1]];
            });
            return baseRest(function(args) {
              var index = -1;
              while (++index < length) {
                var pair = pairs[index];
                if (apply(pair[0], this, args)) {
                  return apply(pair[1], this, args);
                }
              }
            });
          }
          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
          }
          function constant(value) {
            return function() {
              return value;
            };
          }
          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
          }
          var flow = createFlow();
          var flowRight = createFlow(true);
          function identity(value) {
            return value;
          }
          function iteratee(func) {
            return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
          }
          function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
          }
          function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
          }
          var method = baseRest(function(path, args) {
            return function(object) {
              return baseInvoke(object, path, args);
            };
          });
          var methodOf = baseRest(function(object, args) {
            return function(path) {
              return baseInvoke(object, path, args);
            };
          });
          function mixin(object, source, options) {
            var props = keys(source), methodNames = baseFunctions(source, props);
            if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
              options = source;
              source = object;
              object = this;
              methodNames = baseFunctions(source, keys(source));
            }
            var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
            arrayEach(methodNames, function(methodName) {
              var func = source[methodName];
              object[methodName] = func;
              if (isFunc) {
                object.prototype[methodName] = function() {
                  var chainAll = this.__chain__;
                  if (chain2 || chainAll) {
                    var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                    actions.push({ "func": func, "args": arguments, "thisArg": object });
                    result2.__chain__ = chainAll;
                    return result2;
                  }
                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }
            });
            return object;
          }
          function noConflict() {
            if (root._ === this) {
              root._ = oldDash;
            }
            return this;
          }
          function noop() {
          }
          function nthArg(n) {
            n = toInteger(n);
            return baseRest(function(args) {
              return baseNth(args, n);
            });
          }
          var over = createOver(arrayMap);
          var overEvery = createOver(arrayEvery);
          var overSome = createOver(arraySome);
          function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
          }
          function propertyOf(object) {
            return function(path) {
              return object == null ? undefined2 : baseGet(object, path);
            };
          }
          var range = createRange();
          var rangeRight = createRange(true);
          function stubArray() {
            return [];
          }
          function stubFalse() {
            return false;
          }
          function stubObject() {
            return {};
          }
          function stubString() {
            return "";
          }
          function stubTrue() {
            return true;
          }
          function times(n, iteratee2) {
            n = toInteger(n);
            if (n < 1 || n > MAX_SAFE_INTEGER) {
              return [];
            }
            var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
            iteratee2 = getIteratee(iteratee2);
            n -= MAX_ARRAY_LENGTH;
            var result2 = baseTimes(length, iteratee2);
            while (++index < n) {
              iteratee2(index);
            }
            return result2;
          }
          function toPath(value) {
            if (isArray(value)) {
              return arrayMap(value, toKey);
            }
            return isSymbol(value) ? [value] : copyArray(stringToPath(toString2(value)));
          }
          function uniqueId(prefix) {
            var id = ++idCounter;
            return toString2(prefix) + id;
          }
          var add = createMathOperation(function(augend, addend) {
            return augend + addend;
          }, 0);
          var ceil = createRound("ceil");
          var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
          }, 1);
          var floor = createRound("floor");
          function max(array) {
            return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
          }
          function maxBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
          }
          function mean(array) {
            return baseMean(array, identity);
          }
          function meanBy(array, iteratee2) {
            return baseMean(array, getIteratee(iteratee2, 2));
          }
          function min(array) {
            return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
          }
          function minBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
          }
          var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          var round = createRound("round");
          var subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          function sum(array) {
            return array && array.length ? baseSum(array, identity) : 0;
          }
          function sumBy(array, iteratee2) {
            return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
          }
          lodash.after = after;
          lodash.ary = ary;
          lodash.assign = assign;
          lodash.assignIn = assignIn;
          lodash.assignInWith = assignInWith;
          lodash.assignWith = assignWith;
          lodash.at = at;
          lodash.before = before;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey;
          lodash.castArray = castArray;
          lodash.chain = chain;
          lodash.chunk = chunk;
          lodash.compact = compact;
          lodash.concat = concat;
          lodash.cond = cond;
          lodash.conforms = conforms;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce;
          lodash.defaults = defaults;
          lodash.defaultsDeep = defaultsDeep;
          lodash.defer = defer;
          lodash.delay = delay;
          lodash.difference = difference;
          lodash.differenceBy = differenceBy;
          lodash.differenceWith = differenceWith;
          lodash.drop = drop;
          lodash.dropRight = dropRight;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill;
          lodash.filter = filter;
          lodash.flatMap = flatMap;
          lodash.flatMapDeep = flatMapDeep;
          lodash.flatMapDepth = flatMapDepth;
          lodash.flatten = flatten;
          lodash.flattenDeep = flattenDeep;
          lodash.flattenDepth = flattenDepth;
          lodash.flip = flip;
          lodash.flow = flow;
          lodash.flowRight = flowRight;
          lodash.fromPairs = fromPairs;
          lodash.functions = functions;
          lodash.functionsIn = functionsIn;
          lodash.groupBy = groupBy;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.intersectionBy = intersectionBy;
          lodash.intersectionWith = intersectionWith;
          lodash.invert = invert;
          lodash.invertBy = invertBy;
          lodash.invokeMap = invokeMap;
          lodash.iteratee = iteratee;
          lodash.keyBy = keyBy;
          lodash.keys = keys;
          lodash.keysIn = keysIn;
          lodash.map = map;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues;
          lodash.matches = matches;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize;
          lodash.merge = merge;
          lodash.mergeWith = mergeWith;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.negate = negate;
          lodash.nthArg = nthArg;
          lodash.omit = omit;
          lodash.omitBy = omitBy;
          lodash.once = once;
          lodash.orderBy = orderBy;
          lodash.over = over;
          lodash.overArgs = overArgs;
          lodash.overEvery = overEvery;
          lodash.overSome = overSome;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick;
          lodash.pickBy = pickBy;
          lodash.property = property;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAll = pullAll;
          lodash.pullAllBy = pullAllBy;
          lodash.pullAllWith = pullAllWith;
          lodash.pullAt = pullAt;
          lodash.range = range;
          lodash.rangeRight = rangeRight;
          lodash.rearg = rearg;
          lodash.reject = reject;
          lodash.remove = remove;
          lodash.rest = rest;
          lodash.reverse = reverse;
          lodash.sampleSize = sampleSize;
          lodash.set = set;
          lodash.setWith = setWith;
          lodash.shuffle = shuffle;
          lodash.slice = slice;
          lodash.sortBy = sortBy;
          lodash.sortedUniq = sortedUniq;
          lodash.sortedUniqBy = sortedUniqBy;
          lodash.split = split;
          lodash.spread = spread;
          lodash.tail = tail;
          lodash.take = take;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle;
          lodash.thru = thru;
          lodash.toArray = toArray;
          lodash.toPairs = toPairs;
          lodash.toPairsIn = toPairsIn;
          lodash.toPath = toPath;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform;
          lodash.unary = unary;
          lodash.union = union;
          lodash.unionBy = unionBy;
          lodash.unionWith = unionWith;
          lodash.uniq = uniq;
          lodash.uniqBy = uniqBy;
          lodash.uniqWith = uniqWith;
          lodash.unset = unset;
          lodash.unzip = unzip;
          lodash.unzipWith = unzipWith;
          lodash.update = update;
          lodash.updateWith = updateWith;
          lodash.values = values;
          lodash.valuesIn = valuesIn;
          lodash.without = without;
          lodash.words = words;
          lodash.wrap = wrap;
          lodash.xor = xor;
          lodash.xorBy = xorBy;
          lodash.xorWith = xorWith;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
          lodash.zipObjectDeep = zipObjectDeep;
          lodash.zipWith = zipWith;
          lodash.entries = toPairs;
          lodash.entriesIn = toPairsIn;
          lodash.extend = assignIn;
          lodash.extendWith = assignInWith;
          mixin(lodash, lodash);
          lodash.add = add;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase;
          lodash.capitalize = capitalize;
          lodash.ceil = ceil;
          lodash.clamp = clamp;
          lodash.clone = clone;
          lodash.cloneDeep = cloneDeep;
          lodash.cloneDeepWith = cloneDeepWith;
          lodash.cloneWith = cloneWith;
          lodash.conformsTo = conformsTo;
          lodash.deburr = deburr;
          lodash.defaultTo = defaultTo;
          lodash.divide = divide;
          lodash.endsWith = endsWith;
          lodash.eq = eq;
          lodash.escape = escape;
          lodash.escapeRegExp = escapeRegExp;
          lodash.every = every;
          lodash.find = find;
          lodash.findIndex = findIndex;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.floor = floor;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.get = get;
          lodash.gt = gt2;
          lodash.gte = gte;
          lodash.has = has;
          lodash.hasIn = hasIn;
          lodash.head = head;
          lodash.identity = identity;
          lodash.includes = includes;
          lodash.indexOf = indexOf;
          lodash.inRange = inRange;
          lodash.invoke = invoke;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray;
          lodash.isArrayBuffer = isArrayBuffer;
          lodash.isArrayLike = isArrayLike;
          lodash.isArrayLikeObject = isArrayLikeObject;
          lodash.isBoolean = isBoolean;
          lodash.isBuffer = isBuffer;
          lodash.isDate = isDate;
          lodash.isElement = isElement;
          lodash.isEmpty = isEmpty;
          lodash.isEqual = isEqual;
          lodash.isEqualWith = isEqualWith;
          lodash.isError = isError;
          lodash.isFinite = isFinite2;
          lodash.isFunction = isFunction;
          lodash.isInteger = isInteger;
          lodash.isLength = isLength;
          lodash.isMap = isMap;
          lodash.isMatch = isMatch;
          lodash.isMatchWith = isMatchWith;
          lodash.isNaN = isNaN2;
          lodash.isNative = isNative;
          lodash.isNil = isNil;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber;
          lodash.isObject = isObject;
          lodash.isObjectLike = isObjectLike;
          lodash.isPlainObject = isPlainObject;
          lodash.isRegExp = isRegExp;
          lodash.isSafeInteger = isSafeInteger;
          lodash.isSet = isSet;
          lodash.isString = isString;
          lodash.isSymbol = isSymbol;
          lodash.isTypedArray = isTypedArray;
          lodash.isUndefined = isUndefined;
          lodash.isWeakMap = isWeakMap;
          lodash.isWeakSet = isWeakSet;
          lodash.join = join;
          lodash.kebabCase = kebabCase;
          lodash.last = last;
          lodash.lastIndexOf = lastIndexOf;
          lodash.lowerCase = lowerCase;
          lodash.lowerFirst = lowerFirst;
          lodash.lt = lt;
          lodash.lte = lte;
          lodash.max = max;
          lodash.maxBy = maxBy;
          lodash.mean = mean;
          lodash.meanBy = meanBy;
          lodash.min = min;
          lodash.minBy = minBy;
          lodash.stubArray = stubArray;
          lodash.stubFalse = stubFalse;
          lodash.stubObject = stubObject;
          lodash.stubString = stubString;
          lodash.stubTrue = stubTrue;
          lodash.multiply = multiply;
          lodash.nth = nth;
          lodash.noConflict = noConflict;
          lodash.noop = noop;
          lodash.now = now;
          lodash.pad = pad;
          lodash.padEnd = padEnd;
          lodash.padStart = padStart;
          lodash.parseInt = parseInt2;
          lodash.random = random;
          lodash.reduce = reduce;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.replace = replace;
          lodash.result = result;
          lodash.round = round;
          lodash.runInContext = runInContext2;
          lodash.sample = sample;
          lodash.size = size;
          lodash.snakeCase = snakeCase;
          lodash.some = some;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedIndexBy = sortedIndexBy;
          lodash.sortedIndexOf = sortedIndexOf;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.sortedLastIndexBy = sortedLastIndexBy;
          lodash.sortedLastIndexOf = sortedLastIndexOf;
          lodash.startCase = startCase;
          lodash.startsWith = startsWith;
          lodash.subtract = subtract;
          lodash.sum = sum;
          lodash.sumBy = sumBy;
          lodash.template = template;
          lodash.times = times;
          lodash.toFinite = toFinite;
          lodash.toInteger = toInteger;
          lodash.toLength = toLength;
          lodash.toLower = toLower;
          lodash.toNumber = toNumber;
          lodash.toSafeInteger = toSafeInteger;
          lodash.toString = toString2;
          lodash.toUpper = toUpper;
          lodash.trim = trim;
          lodash.trimEnd = trimEnd;
          lodash.trimStart = trimStart;
          lodash.truncate = truncate;
          lodash.unescape = unescape;
          lodash.uniqueId = uniqueId;
          lodash.upperCase = upperCase;
          lodash.upperFirst = upperFirst;
          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.first = head;
          mixin(lodash, function() {
            var source = {};
            baseForOwn(lodash, function(func, methodName) {
              if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), { "chain": false });
          lodash.VERSION = VERSION;
          arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
            lodash[methodName].placeholder = lodash;
          });
          arrayEach(["drop", "take"], function(methodName, index) {
            LazyWrapper.prototype[methodName] = function(n) {
              n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
              var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
              if (result2.__filtered__) {
                result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
              } else {
                result2.__views__.push({
                  "size": nativeMin(n, MAX_ARRAY_LENGTH),
                  "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                });
              }
              return result2;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n) {
              return this.reverse()[methodName](n).reverse();
            };
          });
          arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
            var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee2) {
              var result2 = this.clone();
              result2.__iteratees__.push({
                "iteratee": getIteratee(iteratee2, 3),
                "type": type
              });
              result2.__filtered__ = result2.__filtered__ || isFilter;
              return result2;
            };
          });
          arrayEach(["head", "last"], function(methodName, index) {
            var takeName = "take" + (index ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
              return this[takeName](1).value()[0];
            };
          });
          arrayEach(["initial", "tail"], function(methodName, index) {
            var dropName = "drop" + (index ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function() {
            return this.filter(identity);
          };
          LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
            if (typeof path == "function") {
              return new LazyWrapper(this);
            }
            return this.map(function(value) {
              return baseInvoke(value, path, args);
            });
          });
          LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function(start, end) {
            start = toInteger(start);
            var result2 = this;
            if (result2.__filtered__ && (start > 0 || end < 0)) {
              return new LazyWrapper(result2);
            }
            if (start < 0) {
              result2 = result2.takeRight(-start);
            } else if (start) {
              result2 = result2.drop(start);
            }
            if (end !== undefined2) {
              end = toInteger(end);
              result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
            }
            return result2;
          };
          LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
          };
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
              return;
            }
            lodash.prototype[methodName] = function() {
              var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
              var interceptor = function(value2) {
                var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
                return isTaker && chainAll ? result3[0] : result3;
              };
              if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                isLazy = useLazy = false;
              }
              var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result2 = func.apply(value, args);
                result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
                return new LodashWrapper(result2, chainAll);
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }
              result2 = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
            };
          });
          arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray(value) ? value : [], args);
              }
              return this[chainName](function(value2) {
                return func.apply(isArray(value2) ? value2 : [], args);
              });
            };
          });
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + "";
              if (!hasOwnProperty.call(realNames, key)) {
                realNames[key] = [];
              }
              realNames[key].push({ "name": methodName, "func": lodashFunc });
            }
          });
          realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
            "name": "wrapper",
            "func": undefined2
          }];
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;
          lodash.prototype.at = wrapperAt;
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.next = wrapperNext;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
          lodash.prototype.first = lodash.prototype.head;
          if (symIterator) {
            lodash.prototype[symIterator] = wrapperToIterator;
          }
          return lodash;
        };
        var _ = runInContext();
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          root._ = _;
          define(function() {
            return _;
          });
        } else if (freeModule) {
          (freeModule.exports = _)._ = _;
          freeExports._ = _;
        } else {
          root._ = _;
        }
      }).call(exports);
    }
  });

  // node_modules/brace/worker/css.js
  var require_css = __commonJS({
    "node_modules/brace/worker/css.js"(exports, module) {
      module.exports.id = "ace/mode/css_worker";
      module.exports.src = `"no use strict";!function(window){function resolveModuleId(id,paths){for(var testPath=id,tail="";testPath;){var alias=paths[testPath];if("string"==typeof alias)return alias+tail;if(alias)return alias.location.replace(/\\/*$/,"/")+(tail||alias.main||alias.name);if(alias===!1)return"";var i=testPath.lastIndexOf("/");if(-1===i)break;tail=testPath.substr(i)+tail,testPath=testPath.slice(0,i)}return id}if(!(void 0!==window.window&&window.document||window.acequire&&window.define)){window.console||(window.console=function(){var msgs=Array.prototype.slice.call(arguments,0);postMessage({type:"log",data:msgs})},window.console.error=window.console.warn=window.console.log=window.console.trace=window.console),window.window=window,window.ace=window,window.onerror=function(message,file,line,col,err){postMessage({type:"error",data:{message:message,data:err.data,file:file,line:line,col:col,stack:err.stack}})},window.normalizeModule=function(parentId,moduleName){if(-1!==moduleName.indexOf("!")){var chunks=moduleName.split("!");return window.normalizeModule(parentId,chunks[0])+"!"+window.normalizeModule(parentId,chunks[1])}if("."==moduleName.charAt(0)){var base=parentId.split("/").slice(0,-1).join("/");for(moduleName=(base?base+"/":"")+moduleName;-1!==moduleName.indexOf(".")&&previous!=moduleName;){var previous=moduleName;moduleName=moduleName.replace(/^\\.\\//,"").replace(/\\/\\.\\//,"/").replace(/[^\\/]+\\/\\.\\.\\//,"")}}return moduleName},window.acequire=function acequire(parentId,id){if(id||(id=parentId,parentId=null),!id.charAt)throw Error("worker.js acequire() accepts only (parentId, id) as arguments");id=window.normalizeModule(parentId,id);var module=window.acequire.modules[id];if(module)return module.initialized||(module.initialized=!0,module.exports=module.factory().exports),module.exports;if(!window.acequire.tlns)return console.log("unable to load "+id);var path=resolveModuleId(id,window.acequire.tlns);return".js"!=path.slice(-3)&&(path+=".js"),window.acequire.id=id,window.acequire.modules[id]={},importScripts(path),window.acequire(parentId,id)},window.acequire.modules={},window.acequire.tlns={},window.define=function(id,deps,factory){if(2==arguments.length?(factory=deps,"string"!=typeof id&&(deps=id,id=window.acequire.id)):1==arguments.length&&(factory=id,deps=[],id=window.acequire.id),"function"!=typeof factory)return window.acequire.modules[id]={exports:factory,initialized:!0},void 0;deps.length||(deps=["require","exports","module"]);var req=function(childId){return window.acequire(id,childId)};window.acequire.modules[id]={exports:{},factory:function(){var module=this,returnExports=factory.apply(this,deps.map(function(dep){switch(dep){case"require":return req;case"exports":return module.exports;case"module":return module;default:return req(dep)}}));return returnExports&&(module.exports=returnExports),module}}},window.define.amd={},acequire.tlns={},window.initBaseUrls=function(topLevelNamespaces){for(var i in topLevelNamespaces)acequire.tlns[i]=topLevelNamespaces[i]},window.initSender=function(){var EventEmitter=window.acequire("ace/lib/event_emitter").EventEmitter,oop=window.acequire("ace/lib/oop"),Sender=function(){};return function(){oop.implement(this,EventEmitter),this.callback=function(data,callbackId){postMessage({type:"call",id:callbackId,data:data})},this.emit=function(name,data){postMessage({type:"event",name:name,data:data})}}.call(Sender.prototype),new Sender};var main=window.main=null,sender=window.sender=null;window.onmessage=function(e){var msg=e.data;if(msg.event&&sender)sender._signal(msg.event,msg.data);else if(msg.command)if(main[msg.command])main[msg.command].apply(main,msg.args);else{if(!window[msg.command])throw Error("Unknown command:"+msg.command);window[msg.command].apply(window,msg.args)}else if(msg.init){window.initBaseUrls(msg.tlns),acequire("ace/lib/es5-shim"),sender=window.sender=window.initSender();var clazz=acequire(msg.module)[msg.classname];main=window.main=new clazz(sender)}}}}(this),ace.define("ace/lib/oop",["require","exports","module"],function(acequire,exports){"use strict";exports.inherits=function(ctor,superCtor){ctor.super_=superCtor,ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:!1,writable:!0,configurable:!0}})},exports.mixin=function(obj,mixin){for(var key in mixin)obj[key]=mixin[key];return obj},exports.implement=function(proto,mixin){exports.mixin(proto,mixin)}}),ace.define("ace/lib/lang",["require","exports","module"],function(acequire,exports){"use strict";exports.last=function(a){return a[a.length-1]},exports.stringReverse=function(string){return string.split("").reverse().join("")},exports.stringRepeat=function(string,count){for(var result="";count>0;)1&count&&(result+=string),(count>>=1)&&(string+=string);return result};var trimBeginRegexp=/^\\s\\s*/,trimEndRegexp=/\\s\\s*$/;exports.stringTrimLeft=function(string){return string.replace(trimBeginRegexp,"")},exports.stringTrimRight=function(string){return string.replace(trimEndRegexp,"")},exports.copyObject=function(obj){var copy={};for(var key in obj)copy[key]=obj[key];return copy},exports.copyArray=function(array){for(var copy=[],i=0,l=array.length;l>i;i++)copy[i]=array[i]&&"object"==typeof array[i]?this.copyObject(array[i]):array[i];return copy},exports.deepCopy=function deepCopy(obj){if("object"!=typeof obj||!obj)return obj;var copy;if(Array.isArray(obj)){copy=[];for(var key=0;obj.length>key;key++)copy[key]=deepCopy(obj[key]);return copy}if("[object Object]"!==Object.prototype.toString.call(obj))return obj;copy={};for(var key in obj)copy[key]=deepCopy(obj[key]);return copy},exports.arrayToMap=function(arr){for(var map={},i=0;arr.length>i;i++)map[arr[i]]=1;return map},exports.createMap=function(props){var map=Object.create(null);for(var i in props)map[i]=props[i];return map},exports.arrayRemove=function(array,value){for(var i=0;array.length>=i;i++)value===array[i]&&array.splice(i,1)},exports.escapeRegExp=function(str){return str.replace(/([.*+?^\${}()|[\\]\\/\\\\])/g,"\\\\$1")},exports.escapeHTML=function(str){return str.replace(/&/g,"&#38;").replace(/"/g,"&#34;").replace(/'/g,"&#39;").replace(/</g,"&#60;")},exports.getMatchOffsets=function(string,regExp){var matches=[];return string.replace(regExp,function(str){matches.push({offset:arguments[arguments.length-2],length:str.length})}),matches},exports.deferredCall=function(fcn){var timer=null,callback=function(){timer=null,fcn()},deferred=function(timeout){return deferred.cancel(),timer=setTimeout(callback,timeout||0),deferred};return deferred.schedule=deferred,deferred.call=function(){return this.cancel(),fcn(),deferred},deferred.cancel=function(){return clearTimeout(timer),timer=null,deferred},deferred.isPending=function(){return timer},deferred},exports.delayedCall=function(fcn,defaultTimeout){var timer=null,callback=function(){timer=null,fcn()},_self=function(timeout){null==timer&&(timer=setTimeout(callback,timeout||defaultTimeout))};return _self.delay=function(timeout){timer&&clearTimeout(timer),timer=setTimeout(callback,timeout||defaultTimeout)},_self.schedule=_self,_self.call=function(){this.cancel(),fcn()},_self.cancel=function(){timer&&clearTimeout(timer),timer=null},_self.isPending=function(){return timer},_self}}),ace.define("ace/range",["require","exports","module"],function(acequire,exports){"use strict";var comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},Range=function(startRow,startColumn,endRow,endColumn){this.start={row:startRow,column:startColumn},this.end={row:endRow,column:endColumn}};(function(){this.isEqual=function(range){return this.start.row===range.start.row&&this.end.row===range.end.row&&this.start.column===range.start.column&&this.end.column===range.end.column},this.toString=function(){return"Range: ["+this.start.row+"/"+this.start.column+"] -> ["+this.end.row+"/"+this.end.column+"]"},this.contains=function(row,column){return 0==this.compare(row,column)},this.compareRange=function(range){var cmp,end=range.end,start=range.start;return cmp=this.compare(end.row,end.column),1==cmp?(cmp=this.compare(start.row,start.column),1==cmp?2:0==cmp?1:0):-1==cmp?-2:(cmp=this.compare(start.row,start.column),-1==cmp?-1:1==cmp?42:0)},this.comparePoint=function(p){return this.compare(p.row,p.column)},this.containsRange=function(range){return 0==this.comparePoint(range.start)&&0==this.comparePoint(range.end)},this.intersects=function(range){var cmp=this.compareRange(range);return-1==cmp||0==cmp||1==cmp},this.isEnd=function(row,column){return this.end.row==row&&this.end.column==column},this.isStart=function(row,column){return this.start.row==row&&this.start.column==column},this.setStart=function(row,column){"object"==typeof row?(this.start.column=row.column,this.start.row=row.row):(this.start.row=row,this.start.column=column)},this.setEnd=function(row,column){"object"==typeof row?(this.end.column=row.column,this.end.row=row.row):(this.end.row=row,this.end.column=column)},this.inside=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)||this.isStart(row,column)?!1:!0:!1},this.insideStart=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)?!1:!0:!1},this.insideEnd=function(row,column){return 0==this.compare(row,column)?this.isStart(row,column)?!1:!0:!1},this.compare=function(row,column){return this.isMultiLine()||row!==this.start.row?this.start.row>row?-1:row>this.end.row?1:this.start.row===row?column>=this.start.column?0:-1:this.end.row===row?this.end.column>=column?0:1:0:this.start.column>column?-1:column>this.end.column?1:0},this.compareStart=function(row,column){return this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.compareEnd=function(row,column){return this.end.row==row&&this.end.column==column?1:this.compare(row,column)},this.compareInside=function(row,column){return this.end.row==row&&this.end.column==column?1:this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.clipRows=function(firstRow,lastRow){if(this.end.row>lastRow)var end={row:lastRow+1,column:0};else if(firstRow>this.end.row)var end={row:firstRow,column:0};if(this.start.row>lastRow)var start={row:lastRow+1,column:0};else if(firstRow>this.start.row)var start={row:firstRow,column:0};return Range.fromPoints(start||this.start,end||this.end)},this.extend=function(row,column){var cmp=this.compare(row,column);if(0==cmp)return this;if(-1==cmp)var start={row:row,column:column};else var end={row:row,column:column};return Range.fromPoints(start||this.start,end||this.end)},this.isEmpty=function(){return this.start.row===this.end.row&&this.start.column===this.end.column},this.isMultiLine=function(){return this.start.row!==this.end.row},this.clone=function(){return Range.fromPoints(this.start,this.end)},this.collapseRows=function(){return 0==this.end.column?new Range(this.start.row,0,Math.max(this.start.row,this.end.row-1),0):new Range(this.start.row,0,this.end.row,0)},this.toScreenRange=function(session){var screenPosStart=session.documentToScreenPosition(this.start),screenPosEnd=session.documentToScreenPosition(this.end);return new Range(screenPosStart.row,screenPosStart.column,screenPosEnd.row,screenPosEnd.column)},this.moveBy=function(row,column){this.start.row+=row,this.start.column+=column,this.end.row+=row,this.end.column+=column}}).call(Range.prototype),Range.fromPoints=function(start,end){return new Range(start.row,start.column,end.row,end.column)},Range.comparePoints=comparePoints,Range.comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},exports.Range=Range}),ace.define("ace/apply_delta",["require","exports","module"],function(acequire,exports){"use strict";exports.applyDelta=function(docLines,delta){var row=delta.start.row,startColumn=delta.start.column,line=docLines[row]||"";switch(delta.action){case"insert":var lines=delta.lines;if(1===lines.length)docLines[row]=line.substring(0,startColumn)+delta.lines[0]+line.substring(startColumn);else{var args=[row,1].concat(delta.lines);docLines.splice.apply(docLines,args),docLines[row]=line.substring(0,startColumn)+docLines[row],docLines[row+delta.lines.length-1]+=line.substring(startColumn)}break;case"remove":var endColumn=delta.end.column,endRow=delta.end.row;row===endRow?docLines[row]=line.substring(0,startColumn)+line.substring(endColumn):docLines.splice(row,endRow-row+1,line.substring(0,startColumn)+docLines[endRow].substring(endColumn))}}}),ace.define("ace/lib/event_emitter",["require","exports","module"],function(acequire,exports){"use strict";var EventEmitter={},stopPropagation=function(){this.propagationStopped=!0},preventDefault=function(){this.defaultPrevented=!0};EventEmitter._emit=EventEmitter._dispatchEvent=function(eventName,e){this._eventRegistry||(this._eventRegistry={}),this._defaultHandlers||(this._defaultHandlers={});var listeners=this._eventRegistry[eventName]||[],defaultHandler=this._defaultHandlers[eventName];if(listeners.length||defaultHandler){"object"==typeof e&&e||(e={}),e.type||(e.type=eventName),e.stopPropagation||(e.stopPropagation=stopPropagation),e.preventDefault||(e.preventDefault=preventDefault),listeners=listeners.slice();for(var i=0;listeners.length>i&&(listeners[i](e,this),!e.propagationStopped);i++);return defaultHandler&&!e.defaultPrevented?defaultHandler(e,this):void 0}},EventEmitter._signal=function(eventName,e){var listeners=(this._eventRegistry||{})[eventName];if(listeners){listeners=listeners.slice();for(var i=0;listeners.length>i;i++)listeners[i](e,this)}},EventEmitter.once=function(eventName,callback){var _self=this;callback&&this.addEventListener(eventName,function newCallback(){_self.removeEventListener(eventName,newCallback),callback.apply(null,arguments)})},EventEmitter.setDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers||(handlers=this._defaultHandlers={_disabled_:{}}),handlers[eventName]){var old=handlers[eventName],disabled=handlers._disabled_[eventName];disabled||(handlers._disabled_[eventName]=disabled=[]),disabled.push(old);var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}handlers[eventName]=callback},EventEmitter.removeDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers){var disabled=handlers._disabled_[eventName];if(handlers[eventName]==callback)handlers[eventName],disabled&&this.setDefaultHandler(eventName,disabled.pop());else if(disabled){var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}}},EventEmitter.on=EventEmitter.addEventListener=function(eventName,callback,capturing){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];return listeners||(listeners=this._eventRegistry[eventName]=[]),-1==listeners.indexOf(callback)&&listeners[capturing?"unshift":"push"](callback),callback},EventEmitter.off=EventEmitter.removeListener=EventEmitter.removeEventListener=function(eventName,callback){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];if(listeners){var index=listeners.indexOf(callback);-1!==index&&listeners.splice(index,1)}},EventEmitter.removeAllListeners=function(eventName){this._eventRegistry&&(this._eventRegistry[eventName]=[])},exports.EventEmitter=EventEmitter}),ace.define("ace/anchor",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"],function(acequire,exports){"use strict";var oop=acequire("./lib/oop"),EventEmitter=acequire("./lib/event_emitter").EventEmitter,Anchor=exports.Anchor=function(doc,row,column){this.$onChange=this.onChange.bind(this),this.attach(doc),column===void 0?this.setPosition(row.row,row.column):this.setPosition(row,column)};(function(){function $pointsInOrder(point1,point2,equalPointsInOrder){var bColIsAfter=equalPointsInOrder?point1.column<=point2.column:point1.column<point2.column;return point1.row<point2.row||point1.row==point2.row&&bColIsAfter}function $getTransformedPoint(delta,point,moveIfEqual){var deltaIsInsert="insert"==delta.action,deltaRowShift=(deltaIsInsert?1:-1)*(delta.end.row-delta.start.row),deltaColShift=(deltaIsInsert?1:-1)*(delta.end.column-delta.start.column),deltaStart=delta.start,deltaEnd=deltaIsInsert?deltaStart:delta.end;return $pointsInOrder(point,deltaStart,moveIfEqual)?{row:point.row,column:point.column}:$pointsInOrder(deltaEnd,point,!moveIfEqual)?{row:point.row+deltaRowShift,column:point.column+(point.row==deltaEnd.row?deltaColShift:0)}:{row:deltaStart.row,column:deltaStart.column}}oop.implement(this,EventEmitter),this.getPosition=function(){return this.$clipPositionToDocument(this.row,this.column)},this.getDocument=function(){return this.document},this.$insertRight=!1,this.onChange=function(delta){if(!(delta.start.row==delta.end.row&&delta.start.row!=this.row||delta.start.row>this.row)){var point=$getTransformedPoint(delta,{row:this.row,column:this.column},this.$insertRight);this.setPosition(point.row,point.column,!0)}},this.setPosition=function(row,column,noClip){var pos;if(pos=noClip?{row:row,column:column}:this.$clipPositionToDocument(row,column),this.row!=pos.row||this.column!=pos.column){var old={row:this.row,column:this.column};this.row=pos.row,this.column=pos.column,this._signal("change",{old:old,value:pos})}},this.detach=function(){this.document.removeEventListener("change",this.$onChange)},this.attach=function(doc){this.document=doc||this.document,this.document.on("change",this.$onChange)},this.$clipPositionToDocument=function(row,column){var pos={};return row>=this.document.getLength()?(pos.row=Math.max(0,this.document.getLength()-1),pos.column=this.document.getLine(pos.row).length):0>row?(pos.row=0,pos.column=0):(pos.row=row,pos.column=Math.min(this.document.getLine(pos.row).length,Math.max(0,column))),0>column&&(pos.column=0),pos}}).call(Anchor.prototype)}),ace.define("ace/document",["require","exports","module","ace/lib/oop","ace/apply_delta","ace/lib/event_emitter","ace/range","ace/anchor"],function(acequire,exports){"use strict";var oop=acequire("./lib/oop"),applyDelta=acequire("./apply_delta").applyDelta,EventEmitter=acequire("./lib/event_emitter").EventEmitter,Range=acequire("./range").Range,Anchor=acequire("./anchor").Anchor,Document=function(textOrLines){this.$lines=[""],0===textOrLines.length?this.$lines=[""]:Array.isArray(textOrLines)?this.insertMergedLines({row:0,column:0},textOrLines):this.insert({row:0,column:0},textOrLines)};(function(){oop.implement(this,EventEmitter),this.setValue=function(text){var len=this.getLength()-1;this.remove(new Range(0,0,len,this.getLine(len).length)),this.insert({row:0,column:0},text)},this.getValue=function(){return this.getAllLines().join(this.getNewLineCharacter())},this.createAnchor=function(row,column){return new Anchor(this,row,column)},this.$split=0==="aaa".split(/a/).length?function(text){return text.replace(/\\r\\n|\\r/g,"\\n").split("\\n")}:function(text){return text.split(/\\r\\n|\\r|\\n/)},this.$detectNewLine=function(text){var match=text.match(/^.*?(\\r\\n|\\r|\\n)/m);this.$autoNewLine=match?match[1]:"\\n",this._signal("changeNewLineMode")},this.getNewLineCharacter=function(){switch(this.$newLineMode){case"windows":return"\\r\\n";case"unix":return"\\n";default:return this.$autoNewLine||"\\n"}},this.$autoNewLine="",this.$newLineMode="auto",this.setNewLineMode=function(newLineMode){this.$newLineMode!==newLineMode&&(this.$newLineMode=newLineMode,this._signal("changeNewLineMode"))},this.getNewLineMode=function(){return this.$newLineMode},this.isNewLine=function(text){return"\\r\\n"==text||"\\r"==text||"\\n"==text},this.getLine=function(row){return this.$lines[row]||""},this.getLines=function(firstRow,lastRow){return this.$lines.slice(firstRow,lastRow+1)},this.getAllLines=function(){return this.getLines(0,this.getLength())},this.getLength=function(){return this.$lines.length},this.getTextRange=function(range){return this.getLinesForRange(range).join(this.getNewLineCharacter())},this.getLinesForRange=function(range){var lines;if(range.start.row===range.end.row)lines=[this.getLine(range.start.row).substring(range.start.column,range.end.column)];else{lines=this.getLines(range.start.row,range.end.row),lines[0]=(lines[0]||"").substring(range.start.column);var l=lines.length-1;range.end.row-range.start.row==l&&(lines[l]=lines[l].substring(0,range.end.column))}return lines},this.insertLines=function(row,lines){return console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead."),this.insertFullLines(row,lines)},this.removeLines=function(firstRow,lastRow){return console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead."),this.removeFullLines(firstRow,lastRow)},this.insertNewLine=function(position){return console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead."),this.insertMergedLines(position,["",""])},this.insert=function(position,text){return 1>=this.getLength()&&this.$detectNewLine(text),this.insertMergedLines(position,this.$split(text))},this.insertInLine=function(position,text){var start=this.clippedPos(position.row,position.column),end=this.pos(position.row,position.column+text.length);return this.applyDelta({start:start,end:end,action:"insert",lines:[text]},!0),this.clonePos(end)},this.clippedPos=function(row,column){var length=this.getLength();void 0===row?row=length:0>row?row=0:row>=length&&(row=length-1,column=void 0);var line=this.getLine(row);return void 0==column&&(column=line.length),column=Math.min(Math.max(column,0),line.length),{row:row,column:column}},this.clonePos=function(pos){return{row:pos.row,column:pos.column}},this.pos=function(row,column){return{row:row,column:column}},this.$clipPosition=function(position){var length=this.getLength();return position.row>=length?(position.row=Math.max(0,length-1),position.column=this.getLine(length-1).length):(position.row=Math.max(0,position.row),position.column=Math.min(Math.max(position.column,0),this.getLine(position.row).length)),position},this.insertFullLines=function(row,lines){row=Math.min(Math.max(row,0),this.getLength());var column=0;this.getLength()>row?(lines=lines.concat([""]),column=0):(lines=[""].concat(lines),row--,column=this.$lines[row].length),this.insertMergedLines({row:row,column:column},lines)},this.insertMergedLines=function(position,lines){var start=this.clippedPos(position.row,position.column),end={row:start.row+lines.length-1,column:(1==lines.length?start.column:0)+lines[lines.length-1].length};return this.applyDelta({start:start,end:end,action:"insert",lines:lines}),this.clonePos(end)},this.remove=function(range){var start=this.clippedPos(range.start.row,range.start.column),end=this.clippedPos(range.end.row,range.end.column);return this.applyDelta({start:start,end:end,action:"remove",lines:this.getLinesForRange({start:start,end:end})}),this.clonePos(start)},this.removeInLine=function(row,startColumn,endColumn){var start=this.clippedPos(row,startColumn),end=this.clippedPos(row,endColumn);return this.applyDelta({start:start,end:end,action:"remove",lines:this.getLinesForRange({start:start,end:end})},!0),this.clonePos(start)},this.removeFullLines=function(firstRow,lastRow){firstRow=Math.min(Math.max(0,firstRow),this.getLength()-1),lastRow=Math.min(Math.max(0,lastRow),this.getLength()-1);var deleteFirstNewLine=lastRow==this.getLength()-1&&firstRow>0,deleteLastNewLine=this.getLength()-1>lastRow,startRow=deleteFirstNewLine?firstRow-1:firstRow,startCol=deleteFirstNewLine?this.getLine(startRow).length:0,endRow=deleteLastNewLine?lastRow+1:lastRow,endCol=deleteLastNewLine?0:this.getLine(endRow).length,range=new Range(startRow,startCol,endRow,endCol),deletedLines=this.$lines.slice(firstRow,lastRow+1);return this.applyDelta({start:range.start,end:range.end,action:"remove",lines:this.getLinesForRange(range)}),deletedLines},this.removeNewLine=function(row){this.getLength()-1>row&&row>=0&&this.applyDelta({start:this.pos(row,this.getLine(row).length),end:this.pos(row+1,0),action:"remove",lines:["",""]})},this.replace=function(range,text){if(range instanceof Range||(range=Range.fromPoints(range.start,range.end)),0===text.length&&range.isEmpty())return range.start;if(text==this.getTextRange(range))return range.end;this.remove(range);var end;return end=text?this.insert(range.start,text):range.start},this.applyDeltas=function(deltas){for(var i=0;deltas.length>i;i++)this.applyDelta(deltas[i])},this.revertDeltas=function(deltas){for(var i=deltas.length-1;i>=0;i--)this.revertDelta(deltas[i])},this.applyDelta=function(delta,doNotValidate){var isInsert="insert"==delta.action;(isInsert?1>=delta.lines.length&&!delta.lines[0]:!Range.comparePoints(delta.start,delta.end))||(isInsert&&delta.lines.length>2e4&&this.$splitAndapplyLargeDelta(delta,2e4),applyDelta(this.$lines,delta,doNotValidate),this._signal("change",delta))},this.$splitAndapplyLargeDelta=function(delta,MAX){for(var lines=delta.lines,l=lines.length,row=delta.start.row,column=delta.start.column,from=0,to=0;;){from=to,to+=MAX-1;var chunk=lines.slice(from,to);if(to>l){delta.lines=chunk,delta.start.row=row+from,delta.start.column=column;break}chunk.push(""),this.applyDelta({start:this.pos(row+from,column),end:this.pos(row+to,column=0),action:delta.action,lines:chunk},!0)}},this.revertDelta=function(delta){this.applyDelta({start:this.clonePos(delta.start),end:this.clonePos(delta.end),action:"insert"==delta.action?"remove":"insert",lines:delta.lines.slice()})},this.indexToPosition=function(index,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,i=startRow||0,l=lines.length;l>i;i++)if(index-=lines[i].length+newlineLength,0>index)return{row:i,column:index+lines[i].length+newlineLength};return{row:l-1,column:lines[l-1].length}},this.positionToIndex=function(pos,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,index=0,row=Math.min(pos.row,lines.length),i=startRow||0;row>i;++i)index+=lines[i].length+newlineLength;return index+pos.column}}).call(Document.prototype),exports.Document=Document}),ace.define("ace/worker/mirror",["require","exports","module","ace/range","ace/document","ace/lib/lang"],function(acequire,exports){"use strict";acequire("../range").Range;var Document=acequire("../document").Document,lang=acequire("../lib/lang"),Mirror=exports.Mirror=function(sender){this.sender=sender;var doc=this.doc=new Document(""),deferredUpdate=this.deferredUpdate=lang.delayedCall(this.onUpdate.bind(this)),_self=this;sender.on("change",function(e){var data=e.data;if(data[0].start)doc.applyDeltas(data);else for(var i=0;data.length>i;i+=2){if(Array.isArray(data[i+1]))var d={action:"insert",start:data[i],lines:data[i+1]};else var d={action:"remove",start:data[i],end:data[i+1]};doc.applyDelta(d,!0)}return _self.$timeout?deferredUpdate.schedule(_self.$timeout):(_self.onUpdate(),void 0)})};(function(){this.$timeout=500,this.setTimeout=function(timeout){this.$timeout=timeout},this.setValue=function(value){this.doc.setValue(value),this.deferredUpdate.schedule(this.$timeout)},this.getValue=function(callbackId){this.sender.callback(this.doc.getValue(),callbackId)},this.onUpdate=function(){},this.isPending=function(){return this.deferredUpdate.isPending()}}).call(Mirror.prototype)}),ace.define("ace/mode/css/csslint",["require","exports","module"],function(acequire,exports,module){function objectToString(o){return Object.prototype.toString.call(o)}function clone(parent,circular,depth,prototype){function _clone(parent,depth){if(null===parent)return null;if(0==depth)return parent;var child;if("object"!=typeof parent)return parent;if(util.isArray(parent))child=[];else if(util.isRegExp(parent))child=RegExp(parent.source,util.getRegExpFlags(parent)),parent.lastIndex&&(child.lastIndex=parent.lastIndex);else if(util.isDate(parent))child=new Date(parent.getTime());else{if(useBuffer&&Buffer.isBuffer(parent))return child=new Buffer(parent.length),parent.copy(child),child;child=prototype===void 0?Object.create(Object.getPrototypeOf(parent)):Object.create(prototype)}if(circular){var index=allParents.indexOf(parent);if(-1!=index)return allChildren[index];allParents.push(parent),allChildren.push(child)}for(var i in parent)child[i]=_clone(parent[i],depth-1);return child}var allParents=[],allChildren=[],useBuffer="undefined"!=typeof Buffer;return circular===void 0&&(circular=!0),depth===void 0&&(depth=1/0),_clone(parent,depth)}function Reporter(lines,ruleset){this.messages=[],this.stats=[],this.lines=lines,this.ruleset=ruleset}var parserlib={};(function(){function EventTarget(){this._listeners={}}function StringReader(text){this._input=text.replace(/\\n\\r?/g,"\\n"),this._line=1,this._col=1,this._cursor=0}function SyntaxError(message,line,col){this.col=col,this.line=line,this.message=message}function SyntaxUnit(text,line,col,type){this.col=col,this.line=line,this.text=text,this.type=type}function TokenStreamBase(input,tokenData){this._reader=input?new StringReader(""+input):null,this._token=null,this._tokenData=tokenData,this._lt=[],this._ltIndex=0,this._ltIndexCache=[]}EventTarget.prototype={constructor:EventTarget,addListener:function(type,listener){this._listeners[type]||(this._listeners[type]=[]),this._listeners[type].push(listener)},fire:function(event){if("string"==typeof event&&(event={type:event}),event.target!==void 0&&(event.target=this),event.type===void 0)throw Error("Event object missing 'type' property.");if(this._listeners[event.type])for(var listeners=this._listeners[event.type].concat(),i=0,len=listeners.length;len>i;i++)listeners[i].call(this,event)},removeListener:function(type,listener){if(this._listeners[type])for(var listeners=this._listeners[type],i=0,len=listeners.length;len>i;i++)if(listeners[i]===listener){listeners.splice(i,1);break}}},StringReader.prototype={constructor:StringReader,getCol:function(){return this._col},getLine:function(){return this._line},eof:function(){return this._cursor==this._input.length},peek:function(count){var c=null;return count=count===void 0?1:count,this._cursor<this._input.length&&(c=this._input.charAt(this._cursor+count-1)),c},read:function(){var c=null;return this._cursor<this._input.length&&("\\n"==this._input.charAt(this._cursor)?(this._line++,this._col=1):this._col++,c=this._input.charAt(this._cursor++)),c},mark:function(){this._bookmark={cursor:this._cursor,line:this._line,col:this._col}},reset:function(){this._bookmark&&(this._cursor=this._bookmark.cursor,this._line=this._bookmark.line,this._col=this._bookmark.col,delete this._bookmark)},readTo:function(pattern){for(var c,buffer="";buffer.length<pattern.length||buffer.lastIndexOf(pattern)!=buffer.length-pattern.length;){if(c=this.read(),!c)throw Error('Expected "'+pattern+'" at line '+this._line+", col "+this._col+".");buffer+=c}return buffer},readWhile:function(filter){for(var buffer="",c=this.read();null!==c&&filter(c);)buffer+=c,c=this.read();return buffer},readMatch:function(matcher){var source=this._input.substring(this._cursor),value=null;return"string"==typeof matcher?0===source.indexOf(matcher)&&(value=this.readCount(matcher.length)):matcher instanceof RegExp&&matcher.test(source)&&(value=this.readCount(RegExp.lastMatch.length)),value},readCount:function(count){for(var buffer="";count--;)buffer+=this.read();return buffer}},SyntaxError.prototype=Error(),SyntaxUnit.fromToken=function(token){return new SyntaxUnit(token.value,token.startLine,token.startCol)},SyntaxUnit.prototype={constructor:SyntaxUnit,valueOf:function(){return this.text},toString:function(){return this.text}},TokenStreamBase.createTokenData=function(tokens){var nameMap=[],typeMap={},tokenData=tokens.concat([]),i=0,len=tokenData.length+1;for(tokenData.UNKNOWN=-1,tokenData.unshift({name:"EOF"});len>i;i++)nameMap.push(tokenData[i].name),tokenData[tokenData[i].name]=i,tokenData[i].text&&(typeMap[tokenData[i].text]=i);return tokenData.name=function(tt){return nameMap[tt]},tokenData.type=function(c){return typeMap[c]},tokenData},TokenStreamBase.prototype={constructor:TokenStreamBase,match:function(tokenTypes,channel){tokenTypes instanceof Array||(tokenTypes=[tokenTypes]);
for(var tt=this.get(channel),i=0,len=tokenTypes.length;len>i;)if(tt==tokenTypes[i++])return!0;return this.unget(),!1},mustMatch:function(tokenTypes){var token;if(tokenTypes instanceof Array||(tokenTypes=[tokenTypes]),!this.match.apply(this,arguments))throw token=this.LT(1),new SyntaxError("Expected "+this._tokenData[tokenTypes[0]].name+" at line "+token.startLine+", col "+token.startCol+".",token.startLine,token.startCol)},advance:function(tokenTypes,channel){for(;0!==this.LA(0)&&!this.match(tokenTypes,channel);)this.get();return this.LA(0)},get:function(channel){var token,info,tokenInfo=this._tokenData,i=(this._reader,0);if(tokenInfo.length,this._lt.length&&this._ltIndex>=0&&this._ltIndex<this._lt.length){for(i++,this._token=this._lt[this._ltIndex++],info=tokenInfo[this._token.type];void 0!==info.channel&&channel!==info.channel&&this._ltIndex<this._lt.length;)this._token=this._lt[this._ltIndex++],info=tokenInfo[this._token.type],i++;if((void 0===info.channel||channel===info.channel)&&this._ltIndex<=this._lt.length)return this._ltIndexCache.push(i),this._token.type}return token=this._getToken(),token.type>-1&&!tokenInfo[token.type].hide&&(token.channel=tokenInfo[token.type].channel,this._token=token,this._lt.push(token),this._ltIndexCache.push(this._lt.length-this._ltIndex+i),this._lt.length>5&&this._lt.shift(),this._ltIndexCache.length>5&&this._ltIndexCache.shift(),this._ltIndex=this._lt.length),info=tokenInfo[token.type],info&&(info.hide||void 0!==info.channel&&channel!==info.channel)?this.get(channel):token.type},LA:function(index){var tt,total=index;if(index>0){if(index>5)throw Error("Too much lookahead.");for(;total;)tt=this.get(),total--;for(;index>total;)this.unget(),total++}else if(0>index){if(!this._lt[this._ltIndex+index])throw Error("Too much lookbehind.");tt=this._lt[this._ltIndex+index].type}else tt=this._token.type;return tt},LT:function(index){return this.LA(index),this._lt[this._ltIndex+index-1]},peek:function(){return this.LA(1)},token:function(){return this._token},tokenName:function(tokenType){return 0>tokenType||tokenType>this._tokenData.length?"UNKNOWN_TOKEN":this._tokenData[tokenType].name},tokenType:function(tokenName){return this._tokenData[tokenName]||-1},unget:function(){if(!this._ltIndexCache.length)throw Error("Too much lookahead.");this._ltIndex-=this._ltIndexCache.pop(),this._token=this._lt[this._ltIndex-1]}},parserlib.util={StringReader:StringReader,SyntaxError:SyntaxError,SyntaxUnit:SyntaxUnit,EventTarget:EventTarget,TokenStreamBase:TokenStreamBase}})(),function(){function Combinator(text,line,col){SyntaxUnit.call(this,text,line,col,Parser.COMBINATOR_TYPE),this.type="unknown",/^\\s+$/.test(text)?this.type="descendant":">"==text?this.type="child":"+"==text?this.type="adjacent-sibling":"~"==text&&(this.type="sibling")}function MediaFeature(name,value){SyntaxUnit.call(this,"("+name+(null!==value?":"+value:"")+")",name.startLine,name.startCol,Parser.MEDIA_FEATURE_TYPE),this.name=name,this.value=value}function MediaQuery(modifier,mediaType,features,line,col){SyntaxUnit.call(this,(modifier?modifier+" ":"")+(mediaType?mediaType:"")+(mediaType&&features.length>0?" and ":"")+features.join(" and "),line,col,Parser.MEDIA_QUERY_TYPE),this.modifier=modifier,this.mediaType=mediaType,this.features=features}function Parser(options){EventTarget.call(this),this.options=options||{},this._tokenStream=null}function PropertyName(text,hack,line,col){SyntaxUnit.call(this,text,line,col,Parser.PROPERTY_NAME_TYPE),this.hack=hack}function PropertyValue(parts,line,col){SyntaxUnit.call(this,parts.join(" "),line,col,Parser.PROPERTY_VALUE_TYPE),this.parts=parts}function PropertyValueIterator(value){this._i=0,this._parts=value.parts,this._marks=[],this.value=value}function PropertyValuePart(text,line,col){SyntaxUnit.call(this,text,line,col,Parser.PROPERTY_VALUE_PART_TYPE),this.type="unknown";var temp;if(/^([+\\-]?[\\d\\.]+)([a-z]+)$/i.test(text))switch(this.type="dimension",this.value=+RegExp.$1,this.units=RegExp.$2,this.units.toLowerCase()){case"em":case"rem":case"ex":case"px":case"cm":case"mm":case"in":case"pt":case"pc":case"ch":case"vh":case"vw":case"vmax":case"vmin":this.type="length";break;case"deg":case"rad":case"grad":this.type="angle";break;case"ms":case"s":this.type="time";break;case"hz":case"khz":this.type="frequency";break;case"dpi":case"dpcm":this.type="resolution"}else/^([+\\-]?[\\d\\.]+)%$/i.test(text)?(this.type="percentage",this.value=+RegExp.$1):/^([+\\-]?\\d+)$/i.test(text)?(this.type="integer",this.value=+RegExp.$1):/^([+\\-]?[\\d\\.]+)$/i.test(text)?(this.type="number",this.value=+RegExp.$1):/^#([a-f0-9]{3,6})/i.test(text)?(this.type="color",temp=RegExp.$1,3==temp.length?(this.red=parseInt(temp.charAt(0)+temp.charAt(0),16),this.green=parseInt(temp.charAt(1)+temp.charAt(1),16),this.blue=parseInt(temp.charAt(2)+temp.charAt(2),16)):(this.red=parseInt(temp.substring(0,2),16),this.green=parseInt(temp.substring(2,4),16),this.blue=parseInt(temp.substring(4,6),16))):/^rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/i.test(text)?(this.type="color",this.red=+RegExp.$1,this.green=+RegExp.$2,this.blue=+RegExp.$3):/^rgb\\(\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*\\)/i.test(text)?(this.type="color",this.red=255*+RegExp.$1/100,this.green=255*+RegExp.$2/100,this.blue=255*+RegExp.$3/100):/^rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*([\\d\\.]+)\\s*\\)/i.test(text)?(this.type="color",this.red=+RegExp.$1,this.green=+RegExp.$2,this.blue=+RegExp.$3,this.alpha=+RegExp.$4):/^rgba\\(\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*([\\d\\.]+)\\s*\\)/i.test(text)?(this.type="color",this.red=255*+RegExp.$1/100,this.green=255*+RegExp.$2/100,this.blue=255*+RegExp.$3/100,this.alpha=+RegExp.$4):/^hsl\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*\\)/i.test(text)?(this.type="color",this.hue=+RegExp.$1,this.saturation=+RegExp.$2/100,this.lightness=+RegExp.$3/100):/^hsla\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*([\\d\\.]+)\\s*\\)/i.test(text)?(this.type="color",this.hue=+RegExp.$1,this.saturation=+RegExp.$2/100,this.lightness=+RegExp.$3/100,this.alpha=+RegExp.$4):/^url\\(["']?([^\\)"']+)["']?\\)/i.test(text)?(this.type="uri",this.uri=RegExp.$1):/^([^\\(]+)\\(/i.test(text)?(this.type="function",this.name=RegExp.$1,this.value=text):/^["'][^"']*["']/.test(text)?(this.type="string",this.value=eval(text)):Colors[text.toLowerCase()]?(this.type="color",temp=Colors[text.toLowerCase()].substring(1),this.red=parseInt(temp.substring(0,2),16),this.green=parseInt(temp.substring(2,4),16),this.blue=parseInt(temp.substring(4,6),16)):/^[\\,\\/]$/.test(text)?(this.type="operator",this.value=text):/^[a-z\\-_\\u0080-\\uFFFF][a-z0-9\\-_\\u0080-\\uFFFF]*$/i.test(text)&&(this.type="identifier",this.value=text)}function Selector(parts,line,col){SyntaxUnit.call(this,parts.join(" "),line,col,Parser.SELECTOR_TYPE),this.parts=parts,this.specificity=Specificity.calculate(this)}function SelectorPart(elementName,modifiers,text,line,col){SyntaxUnit.call(this,text,line,col,Parser.SELECTOR_PART_TYPE),this.elementName=elementName,this.modifiers=modifiers}function SelectorSubPart(text,type,line,col){SyntaxUnit.call(this,text,line,col,Parser.SELECTOR_SUB_PART_TYPE),this.type=type,this.args=[]}function Specificity(a,b,c,d){this.a=a,this.b=b,this.c=c,this.d=d}function isHexDigit(c){return null!==c&&h.test(c)}function isDigit(c){return null!==c&&/\\d/.test(c)}function isWhitespace(c){return null!==c&&/\\s/.test(c)}function isNewLine(c){return null!==c&&nl.test(c)}function isNameStart(c){return null!==c&&/[a-z_\\u0080-\\uFFFF\\\\]/i.test(c)}function isNameChar(c){return null!==c&&(isNameStart(c)||/[0-9\\-\\\\]/.test(c))}function isIdentStart(c){return null!==c&&(isNameStart(c)||/\\-\\\\/.test(c))}function mix(receiver,supplier){for(var prop in supplier)supplier.hasOwnProperty(prop)&&(receiver[prop]=supplier[prop]);return receiver}function TokenStream(input){TokenStreamBase.call(this,input,Tokens)}function ValidationError(message,line,col){this.col=col,this.line=line,this.message=message}var EventTarget=parserlib.util.EventTarget,TokenStreamBase=parserlib.util.TokenStreamBase,StringReader=parserlib.util.StringReader,SyntaxError=parserlib.util.SyntaxError,SyntaxUnit=parserlib.util.SyntaxUnit,Colors={aliceblue:"#f0f8ff",antiquewhite:"#faebd7",aqua:"#00ffff",aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc",bisque:"#ffe4c4",black:"#000000",blanchedalmond:"#ffebcd",blue:"#0000ff",blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",darkgrey:"#a9a9a9",darkgreen:"#006400",darkkhaki:"#bdb76b",darkmagenta:"#8b008b",darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932cc",darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",darkslateblue:"#483d8b",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",darkturquoise:"#00ced1",darkviolet:"#9400d3",deeppink:"#ff1493",deepskyblue:"#00bfff",dimgray:"#696969",dimgrey:"#696969",dodgerblue:"#1e90ff",firebrick:"#b22222",floralwhite:"#fffaf0",forestgreen:"#228b22",fuchsia:"#ff00ff",gainsboro:"#dcdcdc",ghostwhite:"#f8f8ff",gold:"#ffd700",goldenrod:"#daa520",gray:"#808080",grey:"#808080",green:"#008000",greenyellow:"#adff2f",honeydew:"#f0fff0",hotpink:"#ff69b4",indianred:"#cd5c5c",indigo:"#4b0082",ivory:"#fffff0",khaki:"#f0e68c",lavender:"#e6e6fa",lavenderblush:"#fff0f5",lawngreen:"#7cfc00",lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:"#f08080",lightcyan:"#e0ffff",lightgoldenrodyellow:"#fafad2",lightgray:"#d3d3d3",lightgrey:"#d3d3d3",lightgreen:"#90ee90",lightpink:"#ffb6c1",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",lightslategray:"#778899",lightslategrey:"#778899",lightsteelblue:"#b0c4de",lightyellow:"#ffffe0",lime:"#00ff00",limegreen:"#32cd32",linen:"#faf0e6",magenta:"#ff00ff",maroon:"#800000",mediumaquamarine:"#66cdaa",mediumblue:"#0000cd",mediumorchid:"#ba55d3",mediumpurple:"#9370d8",mediumseagreen:"#3cb371",mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",mediumturquoise:"#48d1cc",mediumvioletred:"#c71585",midnightblue:"#191970",mintcream:"#f5fffa",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",navajowhite:"#ffdead",navy:"#000080",oldlace:"#fdf5e6",olive:"#808000",olivedrab:"#6b8e23",orange:"#ffa500",orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",palegreen:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#d87093",papayawhip:"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",plum:"#dda0dd",powderblue:"#b0e0e6",purple:"#800080",red:"#ff0000",rosybrown:"#bc8f8f",royalblue:"#4169e1",saddlebrown:"#8b4513",salmon:"#fa8072",sandybrown:"#f4a460",seagreen:"#2e8b57",seashell:"#fff5ee",sienna:"#a0522d",silver:"#c0c0c0",skyblue:"#87ceeb",slateblue:"#6a5acd",slategray:"#708090",slategrey:"#708090",snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:"#d2b48c",teal:"#008080",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#40e0d0",violet:"#ee82ee",wheat:"#f5deb3",white:"#ffffff",whitesmoke:"#f5f5f5",yellow:"#ffff00",yellowgreen:"#9acd32",activeBorder:"Active window border.",activecaption:"Active window caption.",appworkspace:"Background color of multiple document interface.",background:"Desktop background.",buttonface:"The face background color for 3-D elements that appear 3-D due to one layer of surrounding border.",buttonhighlight:"The color of the border facing the light source for 3-D elements that appear 3-D due to one layer of surrounding border.",buttonshadow:"The color of the border away from the light source for 3-D elements that appear 3-D due to one layer of surrounding border.",buttontext:"Text on push buttons.",captiontext:"Text in caption, size box, and scrollbar arrow box.",graytext:"Grayed (disabled) text. This color is set to #000 if the current display driver does not support a solid gray color.",greytext:"Greyed (disabled) text. This color is set to #000 if the current display driver does not support a solid grey color.",highlight:"Item(s) selected in a control.",highlighttext:"Text of item(s) selected in a control.",inactiveborder:"Inactive window border.",inactivecaption:"Inactive window caption.",inactivecaptiontext:"Color of text in an inactive caption.",infobackground:"Background color for tooltip controls.",infotext:"Text color for tooltip controls.",menu:"Menu background.",menutext:"Text in menus.",scrollbar:"Scroll bar gray area.",threeddarkshadow:"The color of the darker (generally outer) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",threedface:"The face background color for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",threedhighlight:"The color of the lighter (generally outer) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",threedlightshadow:"The color of the darker (generally inner) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",threedshadow:"The color of the lighter (generally inner) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",window:"Window background.",windowframe:"Window frame.",windowtext:"Text in windows."};Combinator.prototype=new SyntaxUnit,Combinator.prototype.constructor=Combinator,MediaFeature.prototype=new SyntaxUnit,MediaFeature.prototype.constructor=MediaFeature,MediaQuery.prototype=new SyntaxUnit,MediaQuery.prototype.constructor=MediaQuery,Parser.DEFAULT_TYPE=0,Parser.COMBINATOR_TYPE=1,Parser.MEDIA_FEATURE_TYPE=2,Parser.MEDIA_QUERY_TYPE=3,Parser.PROPERTY_NAME_TYPE=4,Parser.PROPERTY_VALUE_TYPE=5,Parser.PROPERTY_VALUE_PART_TYPE=6,Parser.SELECTOR_TYPE=7,Parser.SELECTOR_PART_TYPE=8,Parser.SELECTOR_SUB_PART_TYPE=9,Parser.prototype=function(){var prop,proto=new EventTarget,additions={constructor:Parser,DEFAULT_TYPE:0,COMBINATOR_TYPE:1,MEDIA_FEATURE_TYPE:2,MEDIA_QUERY_TYPE:3,PROPERTY_NAME_TYPE:4,PROPERTY_VALUE_TYPE:5,PROPERTY_VALUE_PART_TYPE:6,SELECTOR_TYPE:7,SELECTOR_PART_TYPE:8,SELECTOR_SUB_PART_TYPE:9,_stylesheet:function(){var count,token,tt,tokenStream=this._tokenStream;for(this.fire("startstylesheet"),this._charset(),this._skipCruft();tokenStream.peek()==Tokens.IMPORT_SYM;)this._import(),this._skipCruft();for(;tokenStream.peek()==Tokens.NAMESPACE_SYM;)this._namespace(),this._skipCruft();for(tt=tokenStream.peek();tt>Tokens.EOF;){try{switch(tt){case Tokens.MEDIA_SYM:this._media(),this._skipCruft();break;case Tokens.PAGE_SYM:this._page(),this._skipCruft();break;case Tokens.FONT_FACE_SYM:this._font_face(),this._skipCruft();break;case Tokens.KEYFRAMES_SYM:this._keyframes(),this._skipCruft();break;case Tokens.VIEWPORT_SYM:this._viewport(),this._skipCruft();break;case Tokens.UNKNOWN_SYM:if(tokenStream.get(),this.options.strict)throw new SyntaxError("Unknown @ rule.",tokenStream.LT(0).startLine,tokenStream.LT(0).startCol);for(this.fire({type:"error",error:null,message:"Unknown @ rule: "+tokenStream.LT(0).value+".",line:tokenStream.LT(0).startLine,col:tokenStream.LT(0).startCol}),count=0;tokenStream.advance([Tokens.LBRACE,Tokens.RBRACE])==Tokens.LBRACE;)count++;for(;count;)tokenStream.advance([Tokens.RBRACE]),count--;break;case Tokens.S:this._readWhitespace();break;default:if(!this._ruleset())switch(tt){case Tokens.CHARSET_SYM:throw token=tokenStream.LT(1),this._charset(!1),new SyntaxError("@charset not allowed here.",token.startLine,token.startCol);case Tokens.IMPORT_SYM:throw token=tokenStream.LT(1),this._import(!1),new SyntaxError("@import not allowed here.",token.startLine,token.startCol);case Tokens.NAMESPACE_SYM:throw token=tokenStream.LT(1),this._namespace(!1),new SyntaxError("@namespace not allowed here.",token.startLine,token.startCol);default:tokenStream.get(),this._unexpectedToken(tokenStream.token())}}}catch(ex){if(!(ex instanceof SyntaxError)||this.options.strict)throw ex;this.fire({type:"error",error:ex,message:ex.message,line:ex.line,col:ex.col})}tt=tokenStream.peek()}tt!=Tokens.EOF&&this._unexpectedToken(tokenStream.token()),this.fire("endstylesheet")},_charset:function(emit){var charset,token,line,col,tokenStream=this._tokenStream;tokenStream.match(Tokens.CHARSET_SYM)&&(line=tokenStream.token().startLine,col=tokenStream.token().startCol,this._readWhitespace(),tokenStream.mustMatch(Tokens.STRING),token=tokenStream.token(),charset=token.value,this._readWhitespace(),tokenStream.mustMatch(Tokens.SEMICOLON),emit!==!1&&this.fire({type:"charset",charset:charset,line:line,col:col}))},_import:function(emit){var uri,importToken,tokenStream=this._tokenStream,mediaList=[];tokenStream.mustMatch(Tokens.IMPORT_SYM),importToken=tokenStream.token(),this._readWhitespace(),tokenStream.mustMatch([Tokens.STRING,Tokens.URI]),uri=tokenStream.token().value.replace(/^(?:url\\()?["']?([^"']+?)["']?\\)?$/,"$1"),this._readWhitespace(),mediaList=this._media_query_list(),tokenStream.mustMatch(Tokens.SEMICOLON),this._readWhitespace(),emit!==!1&&this.fire({type:"import",uri:uri,media:mediaList,line:importToken.startLine,col:importToken.startCol})},_namespace:function(emit){var line,col,prefix,uri,tokenStream=this._tokenStream;tokenStream.mustMatch(Tokens.NAMESPACE_SYM),line=tokenStream.token().startLine,col=tokenStream.token().startCol,this._readWhitespace(),tokenStream.match(Tokens.IDENT)&&(prefix=tokenStream.token().value,this._readWhitespace()),tokenStream.mustMatch([Tokens.STRING,Tokens.URI]),uri=tokenStream.token().value.replace(/(?:url\\()?["']([^"']+)["']\\)?/,"$1"),this._readWhitespace(),tokenStream.mustMatch(Tokens.SEMICOLON),this._readWhitespace(),emit!==!1&&this.fire({type:"namespace",prefix:prefix,uri:uri,line:line,col:col})},_media:function(){var line,col,mediaList,tokenStream=this._tokenStream;for(tokenStream.mustMatch(Tokens.MEDIA_SYM),line=tokenStream.token().startLine,col=tokenStream.token().startCol,this._readWhitespace(),mediaList=this._media_query_list(),tokenStream.mustMatch(Tokens.LBRACE),this._readWhitespace(),this.fire({type:"startmedia",media:mediaList,line:line,col:col});;)if(tokenStream.peek()==Tokens.PAGE_SYM)this._page();else if(tokenStream.peek()==Tokens.FONT_FACE_SYM)this._font_face();else if(tokenStream.peek()==Tokens.VIEWPORT_SYM)this._viewport();else if(!this._ruleset())break;tokenStream.mustMatch(Tokens.RBRACE),this._readWhitespace(),this.fire({type:"endmedia",media:mediaList,line:line,col:col})},_media_query_list:function(){var tokenStream=this._tokenStream,mediaList=[];for(this._readWhitespace(),(tokenStream.peek()==Tokens.IDENT||tokenStream.peek()==Tokens.LPAREN)&&mediaList.push(this._media_query());tokenStream.match(Tokens.COMMA);)this._readWhitespace(),mediaList.push(this._media_query());return mediaList},_media_query:function(){var tokenStream=this._tokenStream,type=null,ident=null,token=null,expressions=[];if(tokenStream.match(Tokens.IDENT)&&(ident=tokenStream.token().value.toLowerCase(),"only"!=ident&&"not"!=ident?(tokenStream.unget(),ident=null):token=tokenStream.token()),this._readWhitespace(),tokenStream.peek()==Tokens.IDENT?(type=this._media_type(),null===token&&(token=tokenStream.token())):tokenStream.peek()==Tokens.LPAREN&&(null===token&&(token=tokenStream.LT(1)),expressions.push(this._media_expression())),null===type&&0===expressions.length)return null;for(this._readWhitespace();tokenStream.match(Tokens.IDENT);)"and"!=tokenStream.token().value.toLowerCase()&&this._unexpectedToken(tokenStream.token()),this._readWhitespace(),expressions.push(this._media_expression());return new MediaQuery(ident,type,expressions,token.startLine,token.startCol)},_media_type:function(){return this._media_feature()},_media_expression:function(){var token,tokenStream=this._tokenStream,feature=null,expression=null;return tokenStream.mustMatch(Tokens.LPAREN),this._readWhitespace(),feature=this._media_feature(),this._readWhitespace(),tokenStream.match(Tokens.COLON)&&(this._readWhitespace(),token=tokenStream.LT(1),expression=this._expression()),tokenStream.mustMatch(Tokens.RPAREN),this._readWhitespace(),new MediaFeature(feature,expression?new SyntaxUnit(expression,token.startLine,token.startCol):null)},_media_feature:function(){var tokenStream=this._tokenStream;return tokenStream.mustMatch(Tokens.IDENT),SyntaxUnit.fromToken(tokenStream.token())},_page:function(){var line,col,tokenStream=this._tokenStream,identifier=null,pseudoPage=null;tokenStream.mustMatch(Tokens.PAGE_SYM),line=tokenStream.token().startLine,col=tokenStream.token().startCol,this._readWhitespace(),tokenStream.match(Tokens.IDENT)&&(identifier=tokenStream.token().value,"auto"===identifier.toLowerCase()&&this._unexpectedToken(tokenStream.token())),tokenStream.peek()==Tokens.COLON&&(pseudoPage=this._pseudo_page()),this._readWhitespace(),this.fire({type:"startpage",id:identifier,pseudo:pseudoPage,line:line,col:col}),this._readDeclarations(!0,!0),this.fire({type:"endpage",id:identifier,pseudo:pseudoPage,line:line,col:col})},_margin:function(){var line,col,tokenStream=this._tokenStream,marginSym=this._margin_sym();return marginSym?(line=tokenStream.token().startLine,col=tokenStream.token().startCol,this.fire({type:"startpagemargin",margin:marginSym,line:line,col:col}),this._readDeclarations(!0),this.fire({type:"endpagemargin",margin:marginSym,line:line,col:col}),!0):!1},_margin_sym:function(){var tokenStream=this._tokenStream;return tokenStream.match([Tokens.TOPLEFTCORNER_SYM,Tokens.TOPLEFT_SYM,Tokens.TOPCENTER_SYM,Tokens.TOPRIGHT_SYM,Tokens.TOPRIGHTCORNER_SYM,Tokens.BOTTOMLEFTCORNER_SYM,Tokens.BOTTOMLEFT_SYM,Tokens.BOTTOMCENTER_SYM,Tokens.BOTTOMRIGHT_SYM,Tokens.BOTTOMRIGHTCORNER_SYM,Tokens.LEFTTOP_SYM,Tokens.LEFTMIDDLE_SYM,Tokens.LEFTBOTTOM_SYM,Tokens.RIGHTTOP_SYM,Tokens.RIGHTMIDDLE_SYM,Tokens.RIGHTBOTTOM_SYM])?SyntaxUnit.fromToken(tokenStream.token()):null},_pseudo_page:function(){var tokenStream=this._tokenStream;return tokenStream.mustMatch(Tokens.COLON),tokenStream.mustMatch(Tokens.IDENT),tokenStream.token().value},_font_face:function(){var line,col,tokenStream=this._tokenStream;tokenStream.mustMatch(Tokens.FONT_FACE_SYM),line=tokenStream.token().startLine,col=tokenStream.token().startCol,this._readWhitespace(),this.fire({type:"startfontface",line:line,col:col}),this._readDeclarations(!0),this.fire({type:"endfontface",line:line,col:col})},_viewport:function(){var line,col,tokenStream=this._tokenStream;tokenStream.mustMatch(Tokens.VIEWPORT_SYM),line=tokenStream.token().startLine,col=tokenStream.token().startCol,this._readWhitespace(),this.fire({type:"startviewport",line:line,col:col}),this._readDeclarations(!0),this.fire({type:"endviewport",line:line,col:col})},_operator:function(inFunction){var tokenStream=this._tokenStream,token=null;return(tokenStream.match([Tokens.SLASH,Tokens.COMMA])||inFunction&&tokenStream.match([Tokens.PLUS,Tokens.STAR,Tokens.MINUS]))&&(token=tokenStream.token(),this._readWhitespace()),token?PropertyValuePart.fromToken(token):null},_combinator:function(){var token,tokenStream=this._tokenStream,value=null;return tokenStream.match([Tokens.PLUS,Tokens.GREATER,Tokens.TILDE])&&(token=tokenStream.token(),value=new Combinator(token.value,token.startLine,token.startCol),this._readWhitespace()),value},_unary_operator:function(){var tokenStream=this._tokenStream;return tokenStream.match([Tokens.MINUS,Tokens.PLUS])?tokenStream.token().value:null},_property:function(){var tokenValue,token,line,col,tokenStream=this._tokenStream,value=null,hack=null;return tokenStream.peek()==Tokens.STAR&&this.options.starHack&&(tokenStream.get(),token=tokenStream.token(),hack=token.value,line=token.startLine,col=token.startCol),tokenStream.match(Tokens.IDENT)&&(token=tokenStream.token(),tokenValue=token.value,"_"==tokenValue.charAt(0)&&this.options.underscoreHack&&(hack="_",tokenValue=tokenValue.substring(1)),value=new PropertyName(tokenValue,hack,line||token.startLine,col||token.startCol),this._readWhitespace()),value},_ruleset:function(){var tt,selectors,tokenStream=this._tokenStream;try{selectors=this._selectors_group()}catch(ex){if(!(ex instanceof SyntaxError)||this.options.strict)throw ex;if(this.fire({type:"error",error:ex,message:ex.message,line:ex.line,col:ex.col}),tt=tokenStream.advance([Tokens.RBRACE]),tt!=Tokens.RBRACE)throw ex;return!0}return selectors&&(this.fire({type:"startrule",selectors:selectors,line:selectors[0].line,col:selectors[0].col}),this._readDeclarations(!0),this.fire({type:"endrule",selectors:selectors,line:selectors[0].line,col:selectors[0].col})),selectors},_selectors_group:function(){var selector,tokenStream=this._tokenStream,selectors=[];if(selector=this._selector(),null!==selector)for(selectors.push(selector);tokenStream.match(Tokens.COMMA);)this._readWhitespace(),selector=this._selector(),null!==selector?selectors.push(selector):this._unexpectedToken(tokenStream.LT(1));return selectors.length?selectors:null},_selector:function(){var tokenStream=this._tokenStream,selector=[],nextSelector=null,combinator=null,ws=null;if(nextSelector=this._simple_selector_sequence(),null===nextSelector)return null;for(selector.push(nextSelector);;)if(combinator=this._combinator(),null!==combinator)selector.push(combinator),nextSelector=this._simple_selector_sequence(),null===nextSelector?this._unexpectedToken(tokenStream.LT(1)):selector.push(nextSelector);else{if(!this._readWhitespace())break;ws=new Combinator(tokenStream.token().value,tokenStream.token().startLine,tokenStream.token().startCol),combinator=this._combinator(),nextSelector=this._simple_selector_sequence(),null===nextSelector?null!==combinator&&this._unexpectedToken(tokenStream.LT(1)):(null!==combinator?selector.push(combinator):selector.push(ws),selector.push(nextSelector))}return new Selector(selector,selector[0].line,selector[0].col)},_simple_selector_sequence:function(){var line,col,tokenStream=this._tokenStream,elementName=null,modifiers=[],selectorText="",components=[function(){return tokenStream.match(Tokens.HASH)?new SelectorSubPart(tokenStream.token().value,"id",tokenStream.token().startLine,tokenStream.token().startCol):null},this._class,this._attrib,this._pseudo,this._negation],i=0,len=components.length,component=null;for(line=tokenStream.LT(1).startLine,col=tokenStream.LT(1).startCol,elementName=this._type_selector(),elementName||(elementName=this._universal()),null!==elementName&&(selectorText+=elementName);;){if(tokenStream.peek()===Tokens.S)break;for(;len>i&&null===component;)component=components[i++].call(this);if(null===component){if(""===selectorText)return null;break}i=0,modifiers.push(component),selectorText+=""+component,component=null}return""!==selectorText?new SelectorPart(elementName,modifiers,selectorText,line,col):null},_type_selector:function(){var tokenStream=this._tokenStream,ns=this._namespace_prefix(),elementName=this._element_name();return elementName?(ns&&(elementName.text=ns+elementName.text,elementName.col-=ns.length),elementName):(ns&&(tokenStream.unget(),ns.length>1&&tokenStream.unget()),null)},_class:function(){var token,tokenStream=this._tokenStream;return tokenStream.match(Tokens.DOT)?(tokenStream.mustMatch(Tokens.IDENT),token=tokenStream.token(),new SelectorSubPart("."+token.value,"class",token.startLine,token.startCol-1)):null},_element_name:function(){var token,tokenStream=this._tokenStream;return tokenStream.match(Tokens.IDENT)?(token=tokenStream.token(),new SelectorSubPart(token.value,"elementName",token.startLine,token.startCol)):null},_namespace_prefix:function(){var tokenStream=this._tokenStream,value="";return(tokenStream.LA(1)===Tokens.PIPE||tokenStream.LA(2)===Tokens.PIPE)&&(tokenStream.match([Tokens.IDENT,Tokens.STAR])&&(value+=tokenStream.token().value),tokenStream.mustMatch(Tokens.PIPE),value+="|"),value.length?value:null},_universal:function(){var ns,tokenStream=this._tokenStream,value="";return ns=this._namespace_prefix(),ns&&(value+=ns),tokenStream.match(Tokens.STAR)&&(value+="*"),value.length?value:null},_attrib:function(){var ns,token,tokenStream=this._tokenStream,value=null;return tokenStream.match(Tokens.LBRACKET)?(token=tokenStream.token(),value=token.value,value+=this._readWhitespace(),ns=this._namespace_prefix(),ns&&(value+=ns),tokenStream.mustMatch(Tokens.IDENT),value+=tokenStream.token().value,value+=this._readWhitespace(),tokenStream.match([Tokens.PREFIXMATCH,Tokens.SUFFIXMATCH,Tokens.SUBSTRINGMATCH,Tokens.EQUALS,Tokens.INCLUDES,Tokens.DASHMATCH])&&(value+=tokenStream.token().value,value+=this._readWhitespace(),tokenStream.mustMatch([Tokens.IDENT,Tokens.STRING]),value+=tokenStream.token().value,value+=this._readWhitespace()),tokenStream.mustMatch(Tokens.RBRACKET),new SelectorSubPart(value+"]","attribute",token.startLine,token.startCol)):null},_pseudo:function(){var line,col,tokenStream=this._tokenStream,pseudo=null,colons=":";return tokenStream.match(Tokens.COLON)&&(tokenStream.match(Tokens.COLON)&&(colons+=":"),tokenStream.match(Tokens.IDENT)?(pseudo=tokenStream.token().value,line=tokenStream.token().startLine,col=tokenStream.token().startCol-colons.length):tokenStream.peek()==Tokens.FUNCTION&&(line=tokenStream.LT(1).startLine,col=tokenStream.LT(1).startCol-colons.length,pseudo=this._functional_pseudo()),pseudo&&(pseudo=new SelectorSubPart(colons+pseudo,"pseudo",line,col))),pseudo},_functional_pseudo:function(){var tokenStream=this._tokenStream,value=null;return tokenStream.match(Tokens.FUNCTION)&&(value=tokenStream.token().value,value+=this._readWhitespace(),value+=this._expression(),tokenStream.mustMatch(Tokens.RPAREN),value+=")"),value},_expression:function(){for(var tokenStream=this._tokenStream,value="";tokenStream.match([Tokens.PLUS,Tokens.MINUS,Tokens.DIMENSION,Tokens.NUMBER,Tokens.STRING,Tokens.IDENT,Tokens.LENGTH,Tokens.FREQ,Tokens.ANGLE,Tokens.TIME,Tokens.RESOLUTION,Tokens.SLASH]);)value+=tokenStream.token().value,value+=this._readWhitespace();return value.length?value:null},_negation:function(){var line,col,arg,tokenStream=this._tokenStream,value="",subpart=null;return tokenStream.match(Tokens.NOT)&&(value=tokenStream.token().value,line=tokenStream.token().startLine,col=tokenStream.token().startCol,value+=this._readWhitespace(),arg=this._negation_arg(),value+=arg,value+=this._readWhitespace(),tokenStream.match(Tokens.RPAREN),value+=tokenStream.token().value,subpart=new SelectorSubPart(value,"not",line,col),subpart.args.push(arg)),subpart},_negation_arg:function(){var line,col,part,tokenStream=this._tokenStream,args=[this._type_selector,this._universal,function(){return tokenStream.match(Tokens.HASH)?new SelectorSubPart(tokenStream.token().value,"id",tokenStream.token().startLine,tokenStream.token().startCol):null},this._class,this._attrib,this._pseudo],arg=null,i=0,len=args.length;for(line=tokenStream.LT(1).startLine,col=tokenStream.LT(1).startCol;len>i&&null===arg;)arg=args[i].call(this),i++;return null===arg&&this._unexpectedToken(tokenStream.LT(1)),part="elementName"==arg.type?new SelectorPart(arg,[],""+arg,line,col):new SelectorPart(null,[arg],""+arg,line,col)},_declaration:function(){var tokenStream=this._tokenStream,property=null,expr=null,prio=null,invalid=null,propertyName="";if(property=this._property(),null!==property){tokenStream.mustMatch(Tokens.COLON),this._readWhitespace(),expr=this._expr(),expr&&0!==expr.length||this._unexpectedToken(tokenStream.LT(1)),prio=this._prio(),propertyName=""+property,(this.options.starHack&&"*"==property.hack||this.options.underscoreHack&&"_"==property.hack)&&(propertyName=property.text);try{this._validateProperty(propertyName,expr)}catch(ex){invalid=ex}return this.fire({type:"property",property:property,value:expr,important:prio,line:property.line,col:property.col,invalid:invalid}),!0}return!1},_prio:function(){var tokenStream=this._tokenStream,result=tokenStream.match(Tokens.IMPORTANT_SYM);return this._readWhitespace(),result},_expr:function(inFunction){var values=(this._tokenStream,[]),value=null,operator=null;if(value=this._term(inFunction),null!==value)for(values.push(value);;){if(operator=this._operator(inFunction),operator&&values.push(operator),value=this._term(inFunction),null===value)break;
values.push(value)}return values.length>0?new PropertyValue(values,values[0].line,values[0].col):null},_term:function(inFunction){var token,line,col,tokenStream=this._tokenStream,unary=null,value=null,endChar=null;return unary=this._unary_operator(),null!==unary&&(line=tokenStream.token().startLine,col=tokenStream.token().startCol),tokenStream.peek()==Tokens.IE_FUNCTION&&this.options.ieFilters?(value=this._ie_function(),null===unary&&(line=tokenStream.token().startLine,col=tokenStream.token().startCol)):inFunction&&tokenStream.match([Tokens.LPAREN,Tokens.LBRACE,Tokens.LBRACKET])?(token=tokenStream.token(),endChar=token.endChar,value=token.value+this._expr(inFunction).text,null===unary&&(line=tokenStream.token().startLine,col=tokenStream.token().startCol),tokenStream.mustMatch(Tokens.type(endChar)),value+=endChar,this._readWhitespace()):tokenStream.match([Tokens.NUMBER,Tokens.PERCENTAGE,Tokens.LENGTH,Tokens.ANGLE,Tokens.TIME,Tokens.FREQ,Tokens.STRING,Tokens.IDENT,Tokens.URI,Tokens.UNICODE_RANGE])?(value=tokenStream.token().value,null===unary&&(line=tokenStream.token().startLine,col=tokenStream.token().startCol),this._readWhitespace()):(token=this._hexcolor(),null===token?(null===unary&&(line=tokenStream.LT(1).startLine,col=tokenStream.LT(1).startCol),null===value&&(value=tokenStream.LA(3)==Tokens.EQUALS&&this.options.ieFilters?this._ie_function():this._function())):(value=token.value,null===unary&&(line=token.startLine,col=token.startCol))),null!==value?new PropertyValuePart(null!==unary?unary+value:value,line,col):null},_function:function(){var lt,tokenStream=this._tokenStream,functionText=null,expr=null;if(tokenStream.match(Tokens.FUNCTION)){if(functionText=tokenStream.token().value,this._readWhitespace(),expr=this._expr(!0),functionText+=expr,this.options.ieFilters&&tokenStream.peek()==Tokens.EQUALS)do for(this._readWhitespace()&&(functionText+=tokenStream.token().value),tokenStream.LA(0)==Tokens.COMMA&&(functionText+=tokenStream.token().value),tokenStream.match(Tokens.IDENT),functionText+=tokenStream.token().value,tokenStream.match(Tokens.EQUALS),functionText+=tokenStream.token().value,lt=tokenStream.peek();lt!=Tokens.COMMA&&lt!=Tokens.S&&lt!=Tokens.RPAREN;)tokenStream.get(),functionText+=tokenStream.token().value,lt=tokenStream.peek();while(tokenStream.match([Tokens.COMMA,Tokens.S]));tokenStream.match(Tokens.RPAREN),functionText+=")",this._readWhitespace()}return functionText},_ie_function:function(){var lt,tokenStream=this._tokenStream,functionText=null;if(tokenStream.match([Tokens.IE_FUNCTION,Tokens.FUNCTION])){functionText=tokenStream.token().value;do for(this._readWhitespace()&&(functionText+=tokenStream.token().value),tokenStream.LA(0)==Tokens.COMMA&&(functionText+=tokenStream.token().value),tokenStream.match(Tokens.IDENT),functionText+=tokenStream.token().value,tokenStream.match(Tokens.EQUALS),functionText+=tokenStream.token().value,lt=tokenStream.peek();lt!=Tokens.COMMA&&lt!=Tokens.S&&lt!=Tokens.RPAREN;)tokenStream.get(),functionText+=tokenStream.token().value,lt=tokenStream.peek();while(tokenStream.match([Tokens.COMMA,Tokens.S]));tokenStream.match(Tokens.RPAREN),functionText+=")",this._readWhitespace()}return functionText},_hexcolor:function(){var color,tokenStream=this._tokenStream,token=null;if(tokenStream.match(Tokens.HASH)){if(token=tokenStream.token(),color=token.value,!/#[a-f0-9]{3,6}/i.test(color))throw new SyntaxError("Expected a hex color but found '"+color+"' at line "+token.startLine+", col "+token.startCol+".",token.startLine,token.startCol);this._readWhitespace()}return token},_keyframes:function(){var token,tt,name,tokenStream=this._tokenStream,prefix="";for(tokenStream.mustMatch(Tokens.KEYFRAMES_SYM),token=tokenStream.token(),/^@\\-([^\\-]+)\\-/.test(token.value)&&(prefix=RegExp.$1),this._readWhitespace(),name=this._keyframe_name(),this._readWhitespace(),tokenStream.mustMatch(Tokens.LBRACE),this.fire({type:"startkeyframes",name:name,prefix:prefix,line:token.startLine,col:token.startCol}),this._readWhitespace(),tt=tokenStream.peek();tt==Tokens.IDENT||tt==Tokens.PERCENTAGE;)this._keyframe_rule(),this._readWhitespace(),tt=tokenStream.peek();this.fire({type:"endkeyframes",name:name,prefix:prefix,line:token.startLine,col:token.startCol}),this._readWhitespace(),tokenStream.mustMatch(Tokens.RBRACE)},_keyframe_name:function(){var tokenStream=this._tokenStream;return tokenStream.mustMatch([Tokens.IDENT,Tokens.STRING]),SyntaxUnit.fromToken(tokenStream.token())},_keyframe_rule:function(){var keyList=(this._tokenStream,this._key_list());this.fire({type:"startkeyframerule",keys:keyList,line:keyList[0].line,col:keyList[0].col}),this._readDeclarations(!0),this.fire({type:"endkeyframerule",keys:keyList,line:keyList[0].line,col:keyList[0].col})},_key_list:function(){var tokenStream=this._tokenStream,keyList=[];for(keyList.push(this._key()),this._readWhitespace();tokenStream.match(Tokens.COMMA);)this._readWhitespace(),keyList.push(this._key()),this._readWhitespace();return keyList},_key:function(){var token,tokenStream=this._tokenStream;if(tokenStream.match(Tokens.PERCENTAGE))return SyntaxUnit.fromToken(tokenStream.token());if(tokenStream.match(Tokens.IDENT)){if(token=tokenStream.token(),/from|to/i.test(token.value))return SyntaxUnit.fromToken(token);tokenStream.unget()}this._unexpectedToken(tokenStream.LT(1))},_skipCruft:function(){for(;this._tokenStream.match([Tokens.S,Tokens.CDO,Tokens.CDC]););},_readDeclarations:function(checkStart,readMargins){var tt,tokenStream=this._tokenStream;this._readWhitespace(),checkStart&&tokenStream.mustMatch(Tokens.LBRACE),this._readWhitespace();try{for(;;){if(tokenStream.match(Tokens.SEMICOLON)||readMargins&&this._margin());else{if(!this._declaration())break;if(!tokenStream.match(Tokens.SEMICOLON))break}this._readWhitespace()}tokenStream.mustMatch(Tokens.RBRACE),this._readWhitespace()}catch(ex){if(!(ex instanceof SyntaxError)||this.options.strict)throw ex;if(this.fire({type:"error",error:ex,message:ex.message,line:ex.line,col:ex.col}),tt=tokenStream.advance([Tokens.SEMICOLON,Tokens.RBRACE]),tt==Tokens.SEMICOLON)this._readDeclarations(!1,readMargins);else if(tt!=Tokens.RBRACE)throw ex}},_readWhitespace:function(){for(var tokenStream=this._tokenStream,ws="";tokenStream.match(Tokens.S);)ws+=tokenStream.token().value;return ws},_unexpectedToken:function(token){throw new SyntaxError("Unexpected token '"+token.value+"' at line "+token.startLine+", col "+token.startCol+".",token.startLine,token.startCol)},_verifyEnd:function(){this._tokenStream.LA(1)!=Tokens.EOF&&this._unexpectedToken(this._tokenStream.LT(1))},_validateProperty:function(property,value){Validation.validate(property,value)},parse:function(input){this._tokenStream=new TokenStream(input,Tokens),this._stylesheet()},parseStyleSheet:function(input){return this.parse(input)},parseMediaQuery:function(input){this._tokenStream=new TokenStream(input,Tokens);var result=this._media_query();return this._verifyEnd(),result},parsePropertyValue:function(input){this._tokenStream=new TokenStream(input,Tokens),this._readWhitespace();var result=this._expr();return this._readWhitespace(),this._verifyEnd(),result},parseRule:function(input){this._tokenStream=new TokenStream(input,Tokens),this._readWhitespace();var result=this._ruleset();return this._readWhitespace(),this._verifyEnd(),result},parseSelector:function(input){this._tokenStream=new TokenStream(input,Tokens),this._readWhitespace();var result=this._selector();return this._readWhitespace(),this._verifyEnd(),result},parseStyleAttribute:function(input){input+="}",this._tokenStream=new TokenStream(input,Tokens),this._readDeclarations()}};for(prop in additions)additions.hasOwnProperty(prop)&&(proto[prop]=additions[prop]);return proto}();var Properties={"align-items":"flex-start | flex-end | center | baseline | stretch","align-content":"flex-start | flex-end | center | space-between | space-around | stretch","align-self":"auto | flex-start | flex-end | center | baseline | stretch","-webkit-align-items":"flex-start | flex-end | center | baseline | stretch","-webkit-align-content":"flex-start | flex-end | center | space-between | space-around | stretch","-webkit-align-self":"auto | flex-start | flex-end | center | baseline | stretch","alignment-adjust":"auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical | <percentage> | <length>","alignment-baseline":"baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",animation:1,"animation-delay":{multi:"<time>",comma:!0},"animation-direction":{multi:"normal | reverse | alternate | alternate-reverse",comma:!0},"animation-duration":{multi:"<time>",comma:!0},"animation-fill-mode":{multi:"none | forwards | backwards | both",comma:!0},"animation-iteration-count":{multi:"<number> | infinite",comma:!0},"animation-name":{multi:"none | <ident>",comma:!0},"animation-play-state":{multi:"running | paused",comma:!0},"animation-timing-function":1,"-moz-animation-delay":{multi:"<time>",comma:!0},"-moz-animation-direction":{multi:"normal | reverse | alternate | alternate-reverse",comma:!0},"-moz-animation-duration":{multi:"<time>",comma:!0},"-moz-animation-iteration-count":{multi:"<number> | infinite",comma:!0},"-moz-animation-name":{multi:"none | <ident>",comma:!0},"-moz-animation-play-state":{multi:"running | paused",comma:!0},"-ms-animation-delay":{multi:"<time>",comma:!0},"-ms-animation-direction":{multi:"normal | reverse | alternate | alternate-reverse",comma:!0},"-ms-animation-duration":{multi:"<time>",comma:!0},"-ms-animation-iteration-count":{multi:"<number> | infinite",comma:!0},"-ms-animation-name":{multi:"none | <ident>",comma:!0},"-ms-animation-play-state":{multi:"running | paused",comma:!0},"-webkit-animation-delay":{multi:"<time>",comma:!0},"-webkit-animation-direction":{multi:"normal | reverse | alternate | alternate-reverse",comma:!0},"-webkit-animation-duration":{multi:"<time>",comma:!0},"-webkit-animation-fill-mode":{multi:"none | forwards | backwards | both",comma:!0},"-webkit-animation-iteration-count":{multi:"<number> | infinite",comma:!0},"-webkit-animation-name":{multi:"none | <ident>",comma:!0},"-webkit-animation-play-state":{multi:"running | paused",comma:!0},"-o-animation-delay":{multi:"<time>",comma:!0},"-o-animation-direction":{multi:"normal | reverse | alternate | alternate-reverse",comma:!0},"-o-animation-duration":{multi:"<time>",comma:!0},"-o-animation-iteration-count":{multi:"<number> | infinite",comma:!0},"-o-animation-name":{multi:"none | <ident>",comma:!0},"-o-animation-play-state":{multi:"running | paused",comma:!0},appearance:"icon | window | desktop | workspace | document | tooltip | dialog | button | push-button | hyperlink | radio-button | checkbox | menu-item | tab | menu | menubar | pull-down-menu | pop-up-menu | list-menu | radio-group | checkbox-group | outline-tree | range | field | combo-box | signature | password | normal | none | inherit",azimuth:function(expression){var part,simple="<angle> | leftwards | rightwards | inherit",direction="left-side | far-left | left | center-left | center | center-right | right | far-right | right-side",behind=!1,valid=!1;if(ValidationTypes.isAny(expression,simple)||(ValidationTypes.isAny(expression,"behind")&&(behind=!0,valid=!0),ValidationTypes.isAny(expression,direction)&&(valid=!0,behind||ValidationTypes.isAny(expression,"behind"))),expression.hasNext())throw part=expression.next(),valid?new ValidationError("Expected end of value but found '"+part+"'.",part.line,part.col):new ValidationError("Expected (<'azimuth'>) but found '"+part+"'.",part.line,part.col)},"backface-visibility":"visible | hidden",background:1,"background-attachment":{multi:"<attachment>",comma:!0},"background-clip":{multi:"<box>",comma:!0},"background-color":"<color> | inherit","background-image":{multi:"<bg-image>",comma:!0},"background-origin":{multi:"<box>",comma:!0},"background-position":{multi:"<bg-position>",comma:!0},"background-repeat":{multi:"<repeat-style>"},"background-size":{multi:"<bg-size>",comma:!0},"baseline-shift":"baseline | sub | super | <percentage> | <length>",behavior:1,binding:1,bleed:"<length>","bookmark-label":"<content> | <attr> | <string>","bookmark-level":"none | <integer>","bookmark-state":"open | closed","bookmark-target":"none | <uri> | <attr>",border:"<border-width> || <border-style> || <color>","border-bottom":"<border-width> || <border-style> || <color>","border-bottom-color":"<color> | inherit","border-bottom-left-radius":"<x-one-radius>","border-bottom-right-radius":"<x-one-radius>","border-bottom-style":"<border-style>","border-bottom-width":"<border-width>","border-collapse":"collapse | separate | inherit","border-color":{multi:"<color> | inherit",max:4},"border-image":1,"border-image-outset":{multi:"<length> | <number>",max:4},"border-image-repeat":{multi:"stretch | repeat | round",max:2},"border-image-slice":function(expression){var part,valid=!1,numeric="<number> | <percentage>",fill=!1,count=0,max=4;for(ValidationTypes.isAny(expression,"fill")&&(fill=!0,valid=!0);expression.hasNext()&&max>count&&(valid=ValidationTypes.isAny(expression,numeric));)count++;if(fill?valid=!0:ValidationTypes.isAny(expression,"fill"),expression.hasNext())throw part=expression.next(),valid?new ValidationError("Expected end of value but found '"+part+"'.",part.line,part.col):new ValidationError("Expected ([<number> | <percentage>]{1,4} && fill?) but found '"+part+"'.",part.line,part.col)},"border-image-source":"<image> | none","border-image-width":{multi:"<length> | <percentage> | <number> | auto",max:4},"border-left":"<border-width> || <border-style> || <color>","border-left-color":"<color> | inherit","border-left-style":"<border-style>","border-left-width":"<border-width>","border-radius":function(expression){for(var part,valid=!1,simple="<length> | <percentage> | inherit",slash=!1,count=0,max=8;expression.hasNext()&&max>count;){if(valid=ValidationTypes.isAny(expression,simple),!valid){if(!("/"==expression.peek()&&count>0)||slash)break;slash=!0,max=count+5,expression.next()}count++}if(expression.hasNext())throw part=expression.next(),valid?new ValidationError("Expected end of value but found '"+part+"'.",part.line,part.col):new ValidationError("Expected (<'border-radius'>) but found '"+part+"'.",part.line,part.col)},"border-right":"<border-width> || <border-style> || <color>","border-right-color":"<color> | inherit","border-right-style":"<border-style>","border-right-width":"<border-width>","border-spacing":{multi:"<length> | inherit",max:2},"border-style":{multi:"<border-style>",max:4},"border-top":"<border-width> || <border-style> || <color>","border-top-color":"<color> | inherit","border-top-left-radius":"<x-one-radius>","border-top-right-radius":"<x-one-radius>","border-top-style":"<border-style>","border-top-width":"<border-width>","border-width":{multi:"<border-width>",max:4},bottom:"<margin-width> | inherit","-moz-box-align":"start | end | center | baseline | stretch","-moz-box-decoration-break":"slice |clone","-moz-box-direction":"normal | reverse | inherit","-moz-box-flex":"<number>","-moz-box-flex-group":"<integer>","-moz-box-lines":"single | multiple","-moz-box-ordinal-group":"<integer>","-moz-box-orient":"horizontal | vertical | inline-axis | block-axis | inherit","-moz-box-pack":"start | end | center | justify","-webkit-box-align":"start | end | center | baseline | stretch","-webkit-box-decoration-break":"slice |clone","-webkit-box-direction":"normal | reverse | inherit","-webkit-box-flex":"<number>","-webkit-box-flex-group":"<integer>","-webkit-box-lines":"single | multiple","-webkit-box-ordinal-group":"<integer>","-webkit-box-orient":"horizontal | vertical | inline-axis | block-axis | inherit","-webkit-box-pack":"start | end | center | justify","box-shadow":function(expression){var part;if(ValidationTypes.isAny(expression,"none")){if(expression.hasNext())throw part=expression.next(),new ValidationError("Expected end of value but found '"+part+"'.",part.line,part.col)}else Validation.multiProperty("<shadow>",expression,!0,1/0)},"box-sizing":"content-box | border-box | inherit","break-after":"auto | always | avoid | left | right | page | column | avoid-page | avoid-column","break-before":"auto | always | avoid | left | right | page | column | avoid-page | avoid-column","break-inside":"auto | avoid | avoid-page | avoid-column","caption-side":"top | bottom | inherit",clear:"none | right | left | both | inherit",clip:1,color:"<color> | inherit","color-profile":1,"column-count":"<integer> | auto","column-fill":"auto | balance","column-gap":"<length> | normal","column-rule":"<border-width> || <border-style> || <color>","column-rule-color":"<color>","column-rule-style":"<border-style>","column-rule-width":"<border-width>","column-span":"none | all","column-width":"<length> | auto",columns:1,content:1,"counter-increment":1,"counter-reset":1,crop:"<shape> | auto",cue:"cue-after | cue-before | inherit","cue-after":1,"cue-before":1,cursor:1,direction:"ltr | rtl | inherit",display:"inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | grid | inline-grid | none | inherit | -moz-box | -moz-inline-block | -moz-inline-box | -moz-inline-grid | -moz-inline-stack | -moz-inline-table | -moz-grid | -moz-grid-group | -moz-grid-line | -moz-groupbox | -moz-deck | -moz-popup | -moz-stack | -moz-marker | -webkit-box | -webkit-inline-box | -ms-flexbox | -ms-inline-flexbox | flex | -webkit-flex | inline-flex | -webkit-inline-flex","dominant-baseline":1,"drop-initial-after-adjust":"central | middle | after-edge | text-after-edge | ideographic | alphabetic | mathematical | <percentage> | <length>","drop-initial-after-align":"baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical","drop-initial-before-adjust":"before-edge | text-before-edge | central | middle | hanging | mathematical | <percentage> | <length>","drop-initial-before-align":"caps-height | baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical","drop-initial-size":"auto | line | <length> | <percentage>","drop-initial-value":"initial | <integer>",elevation:"<angle> | below | level | above | higher | lower | inherit","empty-cells":"show | hide | inherit",filter:1,fit:"fill | hidden | meet | slice","fit-position":1,flex:"<flex>","flex-basis":"<width>","flex-direction":"row | row-reverse | column | column-reverse","flex-flow":"<flex-direction> || <flex-wrap>","flex-grow":"<number>","flex-shrink":"<number>","flex-wrap":"nowrap | wrap | wrap-reverse","-webkit-flex":"<flex>","-webkit-flex-basis":"<width>","-webkit-flex-direction":"row | row-reverse | column | column-reverse","-webkit-flex-flow":"<flex-direction> || <flex-wrap>","-webkit-flex-grow":"<number>","-webkit-flex-shrink":"<number>","-webkit-flex-wrap":"nowrap | wrap | wrap-reverse","-ms-flex":"<flex>","-ms-flex-align":"start | end | center | stretch | baseline","-ms-flex-direction":"row | row-reverse | column | column-reverse | inherit","-ms-flex-order":"<number>","-ms-flex-pack":"start | end | center | justify","-ms-flex-wrap":"nowrap | wrap | wrap-reverse","float":"left | right | none | inherit","float-offset":1,font:1,"font-family":1,"font-size":"<absolute-size> | <relative-size> | <length> | <percentage> | inherit","font-size-adjust":"<number> | none | inherit","font-stretch":"normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | inherit","font-style":"normal | italic | oblique | inherit","font-variant":"normal | small-caps | inherit","font-weight":"normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 | inherit","grid-cell-stacking":"columns | rows | layer","grid-column":1,"grid-columns":1,"grid-column-align":"start | end | center | stretch","grid-column-sizing":1,"grid-column-span":"<integer>","grid-flow":"none | rows | columns","grid-layer":"<integer>","grid-row":1,"grid-rows":1,"grid-row-align":"start | end | center | stretch","grid-row-span":"<integer>","grid-row-sizing":1,"hanging-punctuation":1,height:"<margin-width> | <content-sizing> | inherit","hyphenate-after":"<integer> | auto","hyphenate-before":"<integer> | auto","hyphenate-character":"<string> | auto","hyphenate-lines":"no-limit | <integer>","hyphenate-resource":1,hyphens:"none | manual | auto",icon:1,"image-orientation":"angle | auto","image-rendering":1,"image-resolution":1,"inline-box-align":"initial | last | <integer>","justify-content":"flex-start | flex-end | center | space-between | space-around","-webkit-justify-content":"flex-start | flex-end | center | space-between | space-around",left:"<margin-width> | inherit","letter-spacing":"<length> | normal | inherit","line-height":"<number> | <length> | <percentage> | normal | inherit","line-break":"auto | loose | normal | strict","line-stacking":1,"line-stacking-ruby":"exclude-ruby | include-ruby","line-stacking-shift":"consider-shifts | disregard-shifts","line-stacking-strategy":"inline-line-height | block-line-height | max-height | grid-height","list-style":1,"list-style-image":"<uri> | none | inherit","list-style-position":"inside | outside | inherit","list-style-type":"disc | circle | square | decimal | decimal-leading-zero | lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | lower-alpha | upper-alpha | none | inherit",margin:{multi:"<margin-width> | inherit",max:4},"margin-bottom":"<margin-width> | inherit","margin-left":"<margin-width> | inherit","margin-right":"<margin-width> | inherit","margin-top":"<margin-width> | inherit",mark:1,"mark-after":1,"mark-before":1,marks:1,"marquee-direction":1,"marquee-play-count":1,"marquee-speed":1,"marquee-style":1,"max-height":"<length> | <percentage> | <content-sizing> | none | inherit","max-width":"<length> | <percentage> | <content-sizing> | none | inherit","min-height":"<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats | inherit","min-width":"<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats | inherit","move-to":1,"nav-down":1,"nav-index":1,"nav-left":1,"nav-right":1,"nav-up":1,opacity:"<number> | inherit",order:"<integer>","-webkit-order":"<integer>",orphans:"<integer> | inherit",outline:1,"outline-color":"<color> | invert | inherit","outline-offset":1,"outline-style":"<border-style> | inherit","outline-width":"<border-width> | inherit",overflow:"visible | hidden | scroll | auto | inherit","overflow-style":1,"overflow-wrap":"normal | break-word","overflow-x":1,"overflow-y":1,padding:{multi:"<padding-width> | inherit",max:4},"padding-bottom":"<padding-width> | inherit","padding-left":"<padding-width> | inherit","padding-right":"<padding-width> | inherit","padding-top":"<padding-width> | inherit",page:1,"page-break-after":"auto | always | avoid | left | right | inherit","page-break-before":"auto | always | avoid | left | right | inherit","page-break-inside":"auto | avoid | inherit","page-policy":1,pause:1,"pause-after":1,"pause-before":1,perspective:1,"perspective-origin":1,phonemes:1,pitch:1,"pitch-range":1,"play-during":1,"pointer-events":"auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",position:"static | relative | absolute | fixed | inherit","presentation-level":1,"punctuation-trim":1,quotes:1,"rendering-intent":1,resize:1,rest:1,"rest-after":1,"rest-before":1,richness:1,right:"<margin-width> | inherit",rotation:1,"rotation-point":1,"ruby-align":1,"ruby-overhang":1,"ruby-position":1,"ruby-span":1,size:1,speak:"normal | none | spell-out | inherit","speak-header":"once | always | inherit","speak-numeral":"digits | continuous | inherit","speak-punctuation":"code | none | inherit","speech-rate":1,src:1,stress:1,"string-set":1,"table-layout":"auto | fixed | inherit","tab-size":"<integer> | <length>",target:1,"target-name":1,"target-new":1,"target-position":1,"text-align":"left | right | center | justify | inherit","text-align-last":1,"text-decoration":1,"text-emphasis":1,"text-height":1,"text-indent":"<length> | <percentage> | inherit","text-justify":"auto | none | inter-word | inter-ideograph | inter-cluster | distribute | kashida","text-outline":1,"text-overflow":1,"text-rendering":"auto | optimizeSpeed | optimizeLegibility | geometricPrecision | inherit","text-shadow":1,"text-transform":"capitalize | uppercase | lowercase | none | inherit","text-wrap":"normal | none | avoid",top:"<margin-width> | inherit","-ms-touch-action":"auto | none | pan-x | pan-y","touch-action":"auto | none | pan-x | pan-y",transform:1,"transform-origin":1,"transform-style":1,transition:1,"transition-delay":1,"transition-duration":1,"transition-property":1,"transition-timing-function":1,"unicode-bidi":"normal | embed | isolate | bidi-override | isolate-override | plaintext | inherit","user-modify":"read-only | read-write | write-only | inherit","user-select":"none | text | toggle | element | elements | all | inherit","vertical-align":"auto | use-script | baseline | sub | super | top | text-top | central | middle | bottom | text-bottom | <percentage> | <length>",visibility:"visible | hidden | collapse | inherit","voice-balance":1,"voice-duration":1,"voice-family":1,"voice-pitch":1,"voice-pitch-range":1,"voice-rate":1,"voice-stress":1,"voice-volume":1,volume:1,"white-space":"normal | pre | nowrap | pre-wrap | pre-line | inherit | -pre-wrap | -o-pre-wrap | -moz-pre-wrap | -hp-pre-wrap","white-space-collapse":1,widows:"<integer> | inherit",width:"<length> | <percentage> | <content-sizing> | auto | inherit","word-break":"normal | keep-all | break-all","word-spacing":"<length> | normal | inherit","word-wrap":"normal | break-word","writing-mode":"horizontal-tb | vertical-rl | vertical-lr | lr-tb | rl-tb | tb-rl | bt-rl | tb-lr | bt-lr | lr-bt | rl-bt | lr | rl | tb | inherit","z-index":"<integer> | auto | inherit",zoom:"<number> | <percentage> | normal"};PropertyName.prototype=new SyntaxUnit,PropertyName.prototype.constructor=PropertyName,PropertyName.prototype.toString=function(){return(this.hack?this.hack:"")+this.text},PropertyValue.prototype=new SyntaxUnit,PropertyValue.prototype.constructor=PropertyValue,PropertyValueIterator.prototype.count=function(){return this._parts.length},PropertyValueIterator.prototype.isFirst=function(){return 0===this._i},PropertyValueIterator.prototype.hasNext=function(){return this._i<this._parts.length},PropertyValueIterator.prototype.mark=function(){this._marks.push(this._i)},PropertyValueIterator.prototype.peek=function(count){return this.hasNext()?this._parts[this._i+(count||0)]:null},PropertyValueIterator.prototype.next=function(){return this.hasNext()?this._parts[this._i++]:null},PropertyValueIterator.prototype.previous=function(){return this._i>0?this._parts[--this._i]:null},PropertyValueIterator.prototype.restore=function(){this._marks.length&&(this._i=this._marks.pop())},PropertyValuePart.prototype=new SyntaxUnit,PropertyValuePart.prototype.constructor=PropertyValuePart,PropertyValuePart.fromToken=function(token){return new PropertyValuePart(token.value,token.startLine,token.startCol)};var Pseudos={":first-letter":1,":first-line":1,":before":1,":after":1};Pseudos.ELEMENT=1,Pseudos.CLASS=2,Pseudos.isElement=function(pseudo){return 0===pseudo.indexOf("::")||Pseudos[pseudo.toLowerCase()]==Pseudos.ELEMENT},Selector.prototype=new SyntaxUnit,Selector.prototype.constructor=Selector,SelectorPart.prototype=new SyntaxUnit,SelectorPart.prototype.constructor=SelectorPart,SelectorSubPart.prototype=new SyntaxUnit,SelectorSubPart.prototype.constructor=SelectorSubPart,Specificity.prototype={constructor:Specificity,compare:function(other){var i,len,comps=["a","b","c","d"];for(i=0,len=comps.length;len>i;i++){if(this[comps[i]]<other[comps[i]])return-1;if(this[comps[i]]>other[comps[i]])return 1}return 0},valueOf:function(){return 1e3*this.a+100*this.b+10*this.c+this.d},toString:function(){return this.a+","+this.b+","+this.c+","+this.d}},Specificity.calculate=function(selector){function updateValues(part){var i,j,len,num,modifier,elementName=part.elementName?part.elementName.text:"";for(elementName&&"*"!=elementName.charAt(elementName.length-1)&&d++,i=0,len=part.modifiers.length;len>i;i++)switch(modifier=part.modifiers[i],modifier.type){case"class":case"attribute":c++;break;case"id":b++;break;case"pseudo":Pseudos.isElement(modifier.text)?d++:c++;break;case"not":for(j=0,num=modifier.args.length;num>j;j++)updateValues(modifier.args[j])}}var i,len,part,b=0,c=0,d=0;for(i=0,len=selector.parts.length;len>i;i++)part=selector.parts[i],part instanceof SelectorPart&&updateValues(part);return new Specificity(0,b,c,d)};var h=/^[0-9a-fA-F]$/,nonascii=/^[\\u0080-\\uFFFF]$/,nl=/\\n|\\r\\n|\\r|\\f/;TokenStream.prototype=mix(new TokenStreamBase,{_getToken:function(){var c,reader=this._reader,token=null,startLine=reader.getLine(),startCol=reader.getCol();for(c=reader.read();c;){switch(c){case"/":token="*"==reader.peek()?this.commentToken(c,startLine,startCol):this.charToken(c,startLine,startCol);break;case"|":case"~":case"^":case"$":case"*":token="="==reader.peek()?this.comparisonToken(c,startLine,startCol):this.charToken(c,startLine,startCol);break;case'"':case"'":token=this.stringToken(c,startLine,startCol);break;case"#":token=isNameChar(reader.peek())?this.hashToken(c,startLine,startCol):this.charToken(c,startLine,startCol);break;case".":token=isDigit(reader.peek())?this.numberToken(c,startLine,startCol):this.charToken(c,startLine,startCol);break;case"-":token="-"==reader.peek()?this.htmlCommentEndToken(c,startLine,startCol):isNameStart(reader.peek())?this.identOrFunctionToken(c,startLine,startCol):this.charToken(c,startLine,startCol);break;case"!":token=this.importantToken(c,startLine,startCol);break;case"@":token=this.atRuleToken(c,startLine,startCol);break;case":":token=this.notToken(c,startLine,startCol);break;case"<":token=this.htmlCommentStartToken(c,startLine,startCol);break;case"U":case"u":if("+"==reader.peek()){token=this.unicodeRangeToken(c,startLine,startCol);break}default:token=isDigit(c)?this.numberToken(c,startLine,startCol):isWhitespace(c)?this.whitespaceToken(c,startLine,startCol):isIdentStart(c)?this.identOrFunctionToken(c,startLine,startCol):this.charToken(c,startLine,startCol)}break}return token||null!==c||(token=this.createToken(Tokens.EOF,null,startLine,startCol)),token},createToken:function(tt,value,startLine,startCol,options){var reader=this._reader;return options=options||{},{value:value,type:tt,channel:options.channel,endChar:options.endChar,hide:options.hide||!1,startLine:startLine,startCol:startCol,endLine:reader.getLine(),endCol:reader.getCol()}},atRuleToken:function(first,startLine,startCol){var ident,rule=first,reader=this._reader,tt=Tokens.CHAR;return reader.mark(),ident=this.readName(),rule=first+ident,tt=Tokens.type(rule.toLowerCase()),(tt==Tokens.CHAR||tt==Tokens.UNKNOWN)&&(rule.length>1?tt=Tokens.UNKNOWN_SYM:(tt=Tokens.CHAR,rule=first,reader.reset())),this.createToken(tt,rule,startLine,startCol)},charToken:function(c,startLine,startCol){var tt=Tokens.type(c),opts={};return-1==tt?tt=Tokens.CHAR:opts.endChar=Tokens[tt].endChar,this.createToken(tt,c,startLine,startCol,opts)},commentToken:function(first,startLine,startCol){var comment=(this._reader,this.readComment(first));return this.createToken(Tokens.COMMENT,comment,startLine,startCol)},comparisonToken:function(c,startLine,startCol){var reader=this._reader,comparison=c+reader.read(),tt=Tokens.type(comparison)||Tokens.CHAR;return this.createToken(tt,comparison,startLine,startCol)
},hashToken:function(first,startLine,startCol){var name=(this._reader,this.readName(first));return this.createToken(Tokens.HASH,name,startLine,startCol)},htmlCommentStartToken:function(first,startLine,startCol){var reader=this._reader,text=first;return reader.mark(),text+=reader.readCount(3),"<!--"==text?this.createToken(Tokens.CDO,text,startLine,startCol):(reader.reset(),this.charToken(first,startLine,startCol))},htmlCommentEndToken:function(first,startLine,startCol){var reader=this._reader,text=first;return reader.mark(),text+=reader.readCount(2),"-->"==text?this.createToken(Tokens.CDC,text,startLine,startCol):(reader.reset(),this.charToken(first,startLine,startCol))},identOrFunctionToken:function(first,startLine,startCol){var reader=this._reader,ident=this.readName(first),tt=Tokens.IDENT;return"("==reader.peek()?(ident+=reader.read(),"url("==ident.toLowerCase()?(tt=Tokens.URI,ident=this.readURI(ident),"url("==ident.toLowerCase()&&(tt=Tokens.FUNCTION)):tt=Tokens.FUNCTION):":"==reader.peek()&&"progid"==ident.toLowerCase()&&(ident+=reader.readTo("("),tt=Tokens.IE_FUNCTION),this.createToken(tt,ident,startLine,startCol)},importantToken:function(first,startLine,startCol){var temp,c,reader=this._reader,important=first,tt=Tokens.CHAR;for(reader.mark(),c=reader.read();c;){if("/"==c){if("*"!=reader.peek())break;if(temp=this.readComment(c),""===temp)break}else{if(!isWhitespace(c)){if(/i/i.test(c)){temp=reader.readCount(8),/mportant/i.test(temp)&&(important+=c+temp,tt=Tokens.IMPORTANT_SYM);break}break}important+=c+this.readWhitespace()}c=reader.read()}return tt==Tokens.CHAR?(reader.reset(),this.charToken(first,startLine,startCol)):this.createToken(tt,important,startLine,startCol)},notToken:function(first,startLine,startCol){var reader=this._reader,text=first;return reader.mark(),text+=reader.readCount(4),":not("==text.toLowerCase()?this.createToken(Tokens.NOT,text,startLine,startCol):(reader.reset(),this.charToken(first,startLine,startCol))},numberToken:function(first,startLine,startCol){var ident,reader=this._reader,value=this.readNumber(first),tt=Tokens.NUMBER,c=reader.peek();return isIdentStart(c)?(ident=this.readName(reader.read()),value+=ident,tt=/^em$|^ex$|^px$|^gd$|^rem$|^vw$|^vh$|^vmax$|^vmin$|^ch$|^cm$|^mm$|^in$|^pt$|^pc$/i.test(ident)?Tokens.LENGTH:/^deg|^rad$|^grad$/i.test(ident)?Tokens.ANGLE:/^ms$|^s$/i.test(ident)?Tokens.TIME:/^hz$|^khz$/i.test(ident)?Tokens.FREQ:/^dpi$|^dpcm$/i.test(ident)?Tokens.RESOLUTION:Tokens.DIMENSION):"%"==c&&(value+=reader.read(),tt=Tokens.PERCENTAGE),this.createToken(tt,value,startLine,startCol)},stringToken:function(first,startLine,startCol){for(var delim=first,string=first,reader=this._reader,prev=first,tt=Tokens.STRING,c=reader.read();c&&(string+=c,c!=delim||"\\\\"==prev);){if(isNewLine(reader.peek())&&"\\\\"!=c){tt=Tokens.INVALID;break}prev=c,c=reader.read()}return null===c&&(tt=Tokens.INVALID),this.createToken(tt,string,startLine,startCol)},unicodeRangeToken:function(first,startLine,startCol){var temp,reader=this._reader,value=first,tt=Tokens.CHAR;return"+"==reader.peek()&&(reader.mark(),value+=reader.read(),value+=this.readUnicodeRangePart(!0),2==value.length?reader.reset():(tt=Tokens.UNICODE_RANGE,-1==value.indexOf("?")&&"-"==reader.peek()&&(reader.mark(),temp=reader.read(),temp+=this.readUnicodeRangePart(!1),1==temp.length?reader.reset():value+=temp))),this.createToken(tt,value,startLine,startCol)},whitespaceToken:function(first,startLine,startCol){var value=(this._reader,first+this.readWhitespace());return this.createToken(Tokens.S,value,startLine,startCol)},readUnicodeRangePart:function(allowQuestionMark){for(var reader=this._reader,part="",c=reader.peek();isHexDigit(c)&&6>part.length;)reader.read(),part+=c,c=reader.peek();if(allowQuestionMark)for(;"?"==c&&6>part.length;)reader.read(),part+=c,c=reader.peek();return part},readWhitespace:function(){for(var reader=this._reader,whitespace="",c=reader.peek();isWhitespace(c);)reader.read(),whitespace+=c,c=reader.peek();return whitespace},readNumber:function(first){for(var reader=this._reader,number=first,hasDot="."==first,c=reader.peek();c;){if(isDigit(c))number+=reader.read();else{if("."!=c)break;if(hasDot)break;hasDot=!0,number+=reader.read()}c=reader.peek()}return number},readString:function(){for(var reader=this._reader,delim=reader.read(),string=delim,prev=delim,c=reader.peek();c&&(c=reader.read(),string+=c,c!=delim||"\\\\"==prev);){if(isNewLine(reader.peek())&&"\\\\"!=c){string="";break}prev=c,c=reader.peek()}return null===c&&(string=""),string},readURI:function(first){var reader=this._reader,uri=first,inner="",c=reader.peek();for(reader.mark();c&&isWhitespace(c);)reader.read(),c=reader.peek();for(inner="'"==c||'"'==c?this.readString():this.readURL(),c=reader.peek();c&&isWhitespace(c);)reader.read(),c=reader.peek();return""===inner||")"!=c?(uri=first,reader.reset()):uri+=inner+reader.read(),uri},readURL:function(){for(var reader=this._reader,url="",c=reader.peek();/^[!#$%&\\\\*-~]$/.test(c);)url+=reader.read(),c=reader.peek();return url},readName:function(first){for(var reader=this._reader,ident=first||"",c=reader.peek();;)if("\\\\"==c)ident+=this.readEscape(reader.read()),c=reader.peek();else{if(!c||!isNameChar(c))break;ident+=reader.read(),c=reader.peek()}return ident},readEscape:function(first){var reader=this._reader,cssEscape=first||"",i=0,c=reader.peek();if(isHexDigit(c))do cssEscape+=reader.read(),c=reader.peek();while(c&&isHexDigit(c)&&6>++i);return 3==cssEscape.length&&/\\s/.test(c)||7==cssEscape.length||1==cssEscape.length?reader.read():c="",cssEscape+c},readComment:function(first){var reader=this._reader,comment=first||"",c=reader.read();if("*"==c){for(;c;){if(comment+=c,comment.length>2&&"*"==c&&"/"==reader.peek()){comment+=reader.read();break}c=reader.read()}return comment}return""}});var Tokens=[{name:"CDO"},{name:"CDC"},{name:"S",whitespace:!0},{name:"COMMENT",comment:!0,hide:!0,channel:"comment"},{name:"INCLUDES",text:"~="},{name:"DASHMATCH",text:"|="},{name:"PREFIXMATCH",text:"^="},{name:"SUFFIXMATCH",text:"$="},{name:"SUBSTRINGMATCH",text:"*="},{name:"STRING"},{name:"IDENT"},{name:"HASH"},{name:"IMPORT_SYM",text:"@import"},{name:"PAGE_SYM",text:"@page"},{name:"MEDIA_SYM",text:"@media"},{name:"FONT_FACE_SYM",text:"@font-face"},{name:"CHARSET_SYM",text:"@charset"},{name:"NAMESPACE_SYM",text:"@namespace"},{name:"VIEWPORT_SYM",text:["@viewport","@-ms-viewport"]},{name:"UNKNOWN_SYM"},{name:"KEYFRAMES_SYM",text:["@keyframes","@-webkit-keyframes","@-moz-keyframes","@-o-keyframes"]},{name:"IMPORTANT_SYM"},{name:"LENGTH"},{name:"ANGLE"},{name:"TIME"},{name:"FREQ"},{name:"DIMENSION"},{name:"PERCENTAGE"},{name:"NUMBER"},{name:"URI"},{name:"FUNCTION"},{name:"UNICODE_RANGE"},{name:"INVALID"},{name:"PLUS",text:"+"},{name:"GREATER",text:">"},{name:"COMMA",text:","},{name:"TILDE",text:"~"},{name:"NOT"},{name:"TOPLEFTCORNER_SYM",text:"@top-left-corner"},{name:"TOPLEFT_SYM",text:"@top-left"},{name:"TOPCENTER_SYM",text:"@top-center"},{name:"TOPRIGHT_SYM",text:"@top-right"},{name:"TOPRIGHTCORNER_SYM",text:"@top-right-corner"},{name:"BOTTOMLEFTCORNER_SYM",text:"@bottom-left-corner"},{name:"BOTTOMLEFT_SYM",text:"@bottom-left"},{name:"BOTTOMCENTER_SYM",text:"@bottom-center"},{name:"BOTTOMRIGHT_SYM",text:"@bottom-right"},{name:"BOTTOMRIGHTCORNER_SYM",text:"@bottom-right-corner"},{name:"LEFTTOP_SYM",text:"@left-top"},{name:"LEFTMIDDLE_SYM",text:"@left-middle"},{name:"LEFTBOTTOM_SYM",text:"@left-bottom"},{name:"RIGHTTOP_SYM",text:"@right-top"},{name:"RIGHTMIDDLE_SYM",text:"@right-middle"},{name:"RIGHTBOTTOM_SYM",text:"@right-bottom"},{name:"RESOLUTION",state:"media"},{name:"IE_FUNCTION"},{name:"CHAR"},{name:"PIPE",text:"|"},{name:"SLASH",text:"/"},{name:"MINUS",text:"-"},{name:"STAR",text:"*"},{name:"LBRACE",endChar:"}",text:"{"},{name:"RBRACE",text:"}"},{name:"LBRACKET",endChar:"]",text:"["},{name:"RBRACKET",text:"]"},{name:"EQUALS",text:"="},{name:"COLON",text:":"},{name:"SEMICOLON",text:";"},{name:"LPAREN",endChar:")",text:"("},{name:"RPAREN",text:")"},{name:"DOT",text:"."}];(function(){var nameMap=[],typeMap={};Tokens.UNKNOWN=-1,Tokens.unshift({name:"EOF"});for(var i=0,len=Tokens.length;len>i;i++)if(nameMap.push(Tokens[i].name),Tokens[Tokens[i].name]=i,Tokens[i].text)if(Tokens[i].text instanceof Array)for(var j=0;Tokens[i].text.length>j;j++)typeMap[Tokens[i].text[j]]=i;else typeMap[Tokens[i].text]=i;Tokens.name=function(tt){return nameMap[tt]},Tokens.type=function(c){return typeMap[c]||-1}})();var Validation={validate:function(property,value){var name=(""+property).toLowerCase(),expression=(value.parts,new PropertyValueIterator(value)),spec=Properties[name];if(spec)"number"!=typeof spec&&("string"==typeof spec?spec.indexOf("||")>-1?this.groupProperty(spec,expression):this.singleProperty(spec,expression,1):spec.multi?this.multiProperty(spec.multi,expression,spec.comma,spec.max||1/0):"function"==typeof spec&&spec(expression));else if(0!==name.indexOf("-"))throw new ValidationError("Unknown property '"+property+"'.",property.line,property.col)},singleProperty:function(types,expression,max){for(var part,result=!1,value=expression.value,count=0;expression.hasNext()&&max>count&&(result=ValidationTypes.isAny(expression,types));)count++;if(!result)throw expression.hasNext()&&!expression.isFirst()?(part=expression.peek(),new ValidationError("Expected end of value but found '"+part+"'.",part.line,part.col)):new ValidationError("Expected ("+types+") but found '"+value+"'.",value.line,value.col);if(expression.hasNext())throw part=expression.next(),new ValidationError("Expected end of value but found '"+part+"'.",part.line,part.col)},multiProperty:function(types,expression,comma,max){for(var part,result=!1,value=expression.value,count=0;expression.hasNext()&&!result&&max>count&&ValidationTypes.isAny(expression,types);)if(count++,expression.hasNext()){if(comma){if(","!=expression.peek())break;part=expression.next()}}else result=!0;if(!result)throw expression.hasNext()&&!expression.isFirst()?(part=expression.peek(),new ValidationError("Expected end of value but found '"+part+"'.",part.line,part.col)):(part=expression.previous(),comma&&","==part?new ValidationError("Expected end of value but found '"+part+"'.",part.line,part.col):new ValidationError("Expected ("+types+") but found '"+value+"'.",value.line,value.col));if(expression.hasNext())throw part=expression.next(),new ValidationError("Expected end of value but found '"+part+"'.",part.line,part.col)},groupProperty:function(types,expression){for(var name,part,result=!1,value=expression.value,typeCount=types.split("||").length,groups={count:0},partial=!1;expression.hasNext()&&!result&&(name=ValidationTypes.isAnyOfGroup(expression,types))&&!groups[name];)groups[name]=1,groups.count++,partial=!0,groups.count!=typeCount&&expression.hasNext()||(result=!0);if(!result)throw partial&&expression.hasNext()?(part=expression.peek(),new ValidationError("Expected end of value but found '"+part+"'.",part.line,part.col)):new ValidationError("Expected ("+types+") but found '"+value+"'.",value.line,value.col);if(expression.hasNext())throw part=expression.next(),new ValidationError("Expected end of value but found '"+part+"'.",part.line,part.col)}};ValidationError.prototype=Error();var ValidationTypes={isLiteral:function(part,literals){var i,len,text=(""+part.text).toLowerCase(),args=literals.split(" | "),found=!1;for(i=0,len=args.length;len>i&&!found;i++)text==args[i].toLowerCase()&&(found=!0);return found},isSimple:function(type){return!!this.simple[type]},isComplex:function(type){return!!this.complex[type]},isAny:function(expression,types){var i,len,args=types.split(" | "),found=!1;for(i=0,len=args.length;len>i&&!found&&expression.hasNext();i++)found=this.isType(expression,args[i]);return found},isAnyOfGroup:function(expression,types){var i,len,args=types.split(" || "),found=!1;for(i=0,len=args.length;len>i&&!found;i++)found=this.isType(expression,args[i]);return found?args[i-1]:!1},isType:function(expression,type){var part=expression.peek(),result=!1;return"<"!=type.charAt(0)?(result=this.isLiteral(part,type),result&&expression.next()):this.simple[type]?(result=this.simple[type](part),result&&expression.next()):result=this.complex[type](expression),result},simple:{"<absolute-size>":function(part){return ValidationTypes.isLiteral(part,"xx-small | x-small | small | medium | large | x-large | xx-large")},"<attachment>":function(part){return ValidationTypes.isLiteral(part,"scroll | fixed | local")},"<attr>":function(part){return"function"==part.type&&"attr"==part.name},"<bg-image>":function(part){return this["<image>"](part)||this["<gradient>"](part)||"none"==part},"<gradient>":function(part){return"function"==part.type&&/^(?:\\-(?:ms|moz|o|webkit)\\-)?(?:repeating\\-)?(?:radial\\-|linear\\-)?gradient/i.test(part)},"<box>":function(part){return ValidationTypes.isLiteral(part,"padding-box | border-box | content-box")},"<content>":function(part){return"function"==part.type&&"content"==part.name},"<relative-size>":function(part){return ValidationTypes.isLiteral(part,"smaller | larger")},"<ident>":function(part){return"identifier"==part.type},"<length>":function(part){return"function"==part.type&&/^(?:\\-(?:ms|moz|o|webkit)\\-)?calc/i.test(part)?!0:"length"==part.type||"number"==part.type||"integer"==part.type||"0"==part},"<color>":function(part){return"color"==part.type||"transparent"==part},"<number>":function(part){return"number"==part.type||this["<integer>"](part)},"<integer>":function(part){return"integer"==part.type},"<line>":function(part){return"integer"==part.type},"<angle>":function(part){return"angle"==part.type},"<uri>":function(part){return"uri"==part.type},"<image>":function(part){return this["<uri>"](part)},"<percentage>":function(part){return"percentage"==part.type||"0"==part},"<border-width>":function(part){return this["<length>"](part)||ValidationTypes.isLiteral(part,"thin | medium | thick")},"<border-style>":function(part){return ValidationTypes.isLiteral(part,"none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset")},"<content-sizing>":function(part){return ValidationTypes.isLiteral(part,"fill-available | -moz-available | -webkit-fill-available | max-content | -moz-max-content | -webkit-max-content | min-content | -moz-min-content | -webkit-min-content | fit-content | -moz-fit-content | -webkit-fit-content")},"<margin-width>":function(part){return this["<length>"](part)||this["<percentage>"](part)||ValidationTypes.isLiteral(part,"auto")},"<padding-width>":function(part){return this["<length>"](part)||this["<percentage>"](part)},"<shape>":function(part){return"function"==part.type&&("rect"==part.name||"inset-rect"==part.name)},"<time>":function(part){return"time"==part.type},"<flex-grow>":function(part){return this["<number>"](part)},"<flex-shrink>":function(part){return this["<number>"](part)},"<width>":function(part){return this["<margin-width>"](part)},"<flex-basis>":function(part){return this["<width>"](part)},"<flex-direction>":function(part){return ValidationTypes.isLiteral(part,"row | row-reverse | column | column-reverse")},"<flex-wrap>":function(part){return ValidationTypes.isLiteral(part,"nowrap | wrap | wrap-reverse")}},complex:{"<bg-position>":function(expression){for(var result=!1,numeric="<percentage> | <length>",xDir="left | right",yDir="top | bottom",count=0;expression.peek(count)&&","!=expression.peek(count);)count++;return 3>count?ValidationTypes.isAny(expression,xDir+" | center | "+numeric)?(result=!0,ValidationTypes.isAny(expression,yDir+" | center | "+numeric)):ValidationTypes.isAny(expression,yDir)&&(result=!0,ValidationTypes.isAny(expression,xDir+" | center")):ValidationTypes.isAny(expression,xDir)?ValidationTypes.isAny(expression,yDir)?(result=!0,ValidationTypes.isAny(expression,numeric)):ValidationTypes.isAny(expression,numeric)&&(ValidationTypes.isAny(expression,yDir)?(result=!0,ValidationTypes.isAny(expression,numeric)):ValidationTypes.isAny(expression,"center")&&(result=!0)):ValidationTypes.isAny(expression,yDir)?ValidationTypes.isAny(expression,xDir)?(result=!0,ValidationTypes.isAny(expression,numeric)):ValidationTypes.isAny(expression,numeric)&&(ValidationTypes.isAny(expression,xDir)?(result=!0,ValidationTypes.isAny(expression,numeric)):ValidationTypes.isAny(expression,"center")&&(result=!0)):ValidationTypes.isAny(expression,"center")&&ValidationTypes.isAny(expression,xDir+" | "+yDir)&&(result=!0,ValidationTypes.isAny(expression,numeric)),result},"<bg-size>":function(expression){var result=!1,numeric="<percentage> | <length> | auto";return ValidationTypes.isAny(expression,"cover | contain")?result=!0:ValidationTypes.isAny(expression,numeric)&&(result=!0,ValidationTypes.isAny(expression,numeric)),result},"<repeat-style>":function(expression){var part,result=!1,values="repeat | space | round | no-repeat";return expression.hasNext()&&(part=expression.next(),ValidationTypes.isLiteral(part,"repeat-x | repeat-y")?result=!0:ValidationTypes.isLiteral(part,values)&&(result=!0,expression.hasNext()&&ValidationTypes.isLiteral(expression.peek(),values)&&expression.next())),result},"<shadow>":function(expression){var result=!1,count=0,inset=!1,color=!1;if(expression.hasNext()){for(ValidationTypes.isAny(expression,"inset")&&(inset=!0),ValidationTypes.isAny(expression,"<color>")&&(color=!0);ValidationTypes.isAny(expression,"<length>")&&4>count;)count++;expression.hasNext()&&(color||ValidationTypes.isAny(expression,"<color>"),inset||ValidationTypes.isAny(expression,"inset")),result=count>=2&&4>=count}return result},"<x-one-radius>":function(expression){var result=!1,simple="<length> | <percentage> | inherit";return ValidationTypes.isAny(expression,simple)&&(result=!0,ValidationTypes.isAny(expression,simple)),result},"<flex>":function(expression){var part,result=!1;if(ValidationTypes.isAny(expression,"none | inherit")?result=!0:ValidationTypes.isType(expression,"<flex-grow>")?expression.peek()?ValidationTypes.isType(expression,"<flex-shrink>")?result=expression.peek()?ValidationTypes.isType(expression,"<flex-basis>"):!0:ValidationTypes.isType(expression,"<flex-basis>")&&(result=null===expression.peek()):result=!0:ValidationTypes.isType(expression,"<flex-basis>")&&(result=!0),!result)throw part=expression.peek(),new ValidationError("Expected (none | [ <flex-grow> <flex-shrink>? || <flex-basis> ]) but found '"+expression.value.text+"'.",part.line,part.col);return result}}};parserlib.css={Colors:Colors,Combinator:Combinator,Parser:Parser,PropertyName:PropertyName,PropertyValue:PropertyValue,PropertyValuePart:PropertyValuePart,MediaFeature:MediaFeature,MediaQuery:MediaQuery,Selector:Selector,SelectorPart:SelectorPart,SelectorSubPart:SelectorSubPart,Specificity:Specificity,TokenStream:TokenStream,Tokens:Tokens,ValidationError:ValidationError}}(),function(){for(var prop in parserlib)exports[prop]=parserlib[prop]}();var util={isArray:function(ar){return Array.isArray(ar)||"object"==typeof ar&&"[object Array]"===objectToString(ar)},isDate:function(d){return"object"==typeof d&&"[object Date]"===objectToString(d)},isRegExp:function(re){return"object"==typeof re&&"[object RegExp]"===objectToString(re)},getRegExpFlags:function(re){var flags="";return re.global&&(flags+="g"),re.ignoreCase&&(flags+="i"),re.multiline&&(flags+="m"),flags}};"object"==typeof module&&(module.exports=clone),clone.clonePrototype=function(parent){if(null===parent)return null;var c=function(){};return c.prototype=parent,new c};var CSSLint=function(){function applyEmbeddedRuleset(text,ruleset){var valueMap,embedded=text&&text.match(embeddedRuleset),rules=embedded&&embedded[1];return rules&&(valueMap={"true":2,"":1,"false":0,2:2,1:1,0:0},rules.toLowerCase().split(",").forEach(function(rule){var pair=rule.split(":"),property=pair[0]||"",value=pair[1]||"";ruleset[property.trim()]=valueMap[value.trim()]})),ruleset}var rules=[],formatters=[],embeddedRuleset=/\\/\\*csslint([^\\*]*)\\*\\//,api=new parserlib.util.EventTarget;return api.version="@VERSION@",api.addRule=function(rule){rules.push(rule),rules[rule.id]=rule},api.clearRules=function(){rules=[]},api.getRules=function(){return[].concat(rules).sort(function(a,b){return a.id>b.id?1:0})},api.getRuleset=function(){for(var ruleset={},i=0,len=rules.length;len>i;)ruleset[rules[i++].id]=1;return ruleset},api.addFormatter=function(formatter){formatters[formatter.id]=formatter},api.getFormatter=function(formatId){return formatters[formatId]},api.format=function(results,filename,formatId,options){var formatter=this.getFormatter(formatId),result=null;return formatter&&(result=formatter.startFormat(),result+=formatter.formatResults(results,filename,options||{}),result+=formatter.endFormat()),result},api.hasFormat=function(formatId){return formatters.hasOwnProperty(formatId)},api.verify=function(text,ruleset){var reporter,lines,report,i=0,parser=new parserlib.css.Parser({starHack:!0,ieFilters:!0,underscoreHack:!0,strict:!1});lines=text.replace(/\\n\\r?/g,"$split$").split("$split$"),ruleset||(ruleset=this.getRuleset()),embeddedRuleset.test(text)&&(ruleset=clone(ruleset),ruleset=applyEmbeddedRuleset(text,ruleset)),reporter=new Reporter(lines,ruleset),ruleset.errors=2;for(i in ruleset)ruleset.hasOwnProperty(i)&&ruleset[i]&&rules[i]&&rules[i].init(parser,reporter);try{parser.parse(text)}catch(ex){reporter.error("Fatal error, cannot continue: "+ex.message,ex.line,ex.col,{})}return report={messages:reporter.messages,stats:reporter.stats,ruleset:reporter.ruleset},report.messages.sort(function(a,b){return a.rollup&&!b.rollup?1:!a.rollup&&b.rollup?-1:a.line-b.line}),report},api}();Reporter.prototype={constructor:Reporter,error:function(message,line,col,rule){this.messages.push({type:"error",line:line,col:col,message:message,evidence:this.lines[line-1],rule:rule||{}})},warn:function(message,line,col,rule){this.report(message,line,col,rule)},report:function(message,line,col,rule){this.messages.push({type:2===this.ruleset[rule.id]?"error":"warning",line:line,col:col,message:message,evidence:this.lines[line-1],rule:rule})},info:function(message,line,col,rule){this.messages.push({type:"info",line:line,col:col,message:message,evidence:this.lines[line-1],rule:rule})},rollupError:function(message,rule){this.messages.push({type:"error",rollup:!0,message:message,rule:rule})},rollupWarn:function(message,rule){this.messages.push({type:"warning",rollup:!0,message:message,rule:rule})},stat:function(name,value){this.stats[name]=value}},CSSLint._Reporter=Reporter,CSSLint.Util={mix:function(receiver,supplier){var prop;for(prop in supplier)supplier.hasOwnProperty(prop)&&(receiver[prop]=supplier[prop]);return prop},indexOf:function(values,value){if(values.indexOf)return values.indexOf(value);for(var i=0,len=values.length;len>i;i++)if(values[i]===value)return i;return-1},forEach:function(values,func){if(values.forEach)return values.forEach(func);for(var i=0,len=values.length;len>i;i++)func(values[i],i,values)}},CSSLint.addRule({id:"adjoining-classes",name:"Disallow adjoining classes",desc:"Don't use adjoining classes.",browsers:"IE6",init:function(parser,reporter){var rule=this;parser.addListener("startrule",function(event){var selector,part,modifier,classCount,i,j,k,selectors=event.selectors;for(i=0;selectors.length>i;i++)for(selector=selectors[i],j=0;selector.parts.length>j;j++)if(part=selector.parts[j],part.type===parser.SELECTOR_PART_TYPE)for(classCount=0,k=0;part.modifiers.length>k;k++)modifier=part.modifiers[k],"class"===modifier.type&&classCount++,classCount>1&&reporter.report("Don't use adjoining classes.",part.line,part.col,rule)})}}),CSSLint.addRule({id:"box-model",name:"Beware of broken box size",desc:"Don't use width or height when using padding or border.",browsers:"All",init:function(parser,reporter){function startRule(){properties={},boxSizing=!1}function endRule(){var prop,value;if(!boxSizing){if(properties.height)for(prop in heightProperties)heightProperties.hasOwnProperty(prop)&&properties[prop]&&(value=properties[prop].value,("padding"!==prop||2!==value.parts.length||0!==value.parts[0].value)&&reporter.report("Using height with "+prop+" can sometimes make elements larger than you expect.",properties[prop].line,properties[prop].col,rule));if(properties.width)for(prop in widthProperties)widthProperties.hasOwnProperty(prop)&&properties[prop]&&(value=properties[prop].value,("padding"!==prop||2!==value.parts.length||0!==value.parts[1].value)&&reporter.report("Using width with "+prop+" can sometimes make elements larger than you expect.",properties[prop].line,properties[prop].col,rule))}}var properties,rule=this,widthProperties={border:1,"border-left":1,"border-right":1,padding:1,"padding-left":1,"padding-right":1},heightProperties={border:1,"border-bottom":1,"border-top":1,padding:1,"padding-bottom":1,"padding-top":1},boxSizing=!1;parser.addListener("startrule",startRule),parser.addListener("startfontface",startRule),parser.addListener("startpage",startRule),parser.addListener("startpagemargin",startRule),parser.addListener("startkeyframerule",startRule),parser.addListener("property",function(event){var name=event.property.text.toLowerCase();heightProperties[name]||widthProperties[name]?/^0\\S*$/.test(event.value)||"border"===name&&"none"==""+event.value||(properties[name]={line:event.property.line,col:event.property.col,value:event.value}):/^(width|height)/i.test(name)&&/^(length|percentage)/.test(event.value.parts[0].type)?properties[name]=1:"box-sizing"===name&&(boxSizing=!0)}),parser.addListener("endrule",endRule),parser.addListener("endfontface",endRule),parser.addListener("endpage",endRule),parser.addListener("endpagemargin",endRule),parser.addListener("endkeyframerule",endRule)}}),CSSLint.addRule({id:"box-sizing",name:"Disallow use of box-sizing",desc:"The box-sizing properties isn't supported in IE6 and IE7.",browsers:"IE6, IE7",tags:["Compatibility"],init:function(parser,reporter){var rule=this;parser.addListener("property",function(event){var name=event.property.text.toLowerCase();"box-sizing"===name&&reporter.report("The box-sizing property isn't supported in IE6 and IE7.",event.line,event.col,rule)})}}),CSSLint.addRule({id:"bulletproof-font-face",name:"Use the bulletproof @font-face syntax",desc:"Use the bulletproof @font-face syntax to avoid 404's in old IE (http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax).",browsers:"All",init:function(parser,reporter){var line,col,rule=this,fontFaceRule=!1,firstSrc=!0,ruleFailed=!1;parser.addListener("startfontface",function(){fontFaceRule=!0}),parser.addListener("property",function(event){if(fontFaceRule){var propertyName=(""+event.property).toLowerCase(),value=""+event.value;if(line=event.line,col=event.col,"src"===propertyName){var regex=/^\\s?url\\(['"].+\\.eot\\?.*['"]\\)\\s*format\\(['"]embedded-opentype['"]\\).*$/i;!value.match(regex)&&firstSrc?(ruleFailed=!0,firstSrc=!1):value.match(regex)&&!firstSrc&&(ruleFailed=!1)}}}),parser.addListener("endfontface",function(){fontFaceRule=!1,ruleFailed&&reporter.report("@font-face declaration doesn't follow the fontspring bulletproof syntax.",line,col,rule)})}}),CSSLint.addRule({id:"compatible-vendor-prefixes",name:"Require compatible vendor prefixes",desc:"Include all compatible vendor prefixes to reach a wider range of users.",browsers:"All",init:function(parser,reporter){var compatiblePrefixes,properties,prop,variations,prefixed,i,len,rule=this,inKeyFrame=!1,arrayPush=Array.prototype.push,applyTo=[];compatiblePrefixes={animation:"webkit moz","animation-delay":"webkit moz","animation-direction":"webkit moz","animation-duration":"webkit moz","animation-fill-mode":"webkit moz","animation-iteration-count":"webkit moz","animation-name":"webkit moz","animation-play-state":"webkit moz","animation-timing-function":"webkit moz",appearance:"webkit moz","border-end":"webkit moz","border-end-color":"webkit moz","border-end-style":"webkit moz","border-end-width":"webkit moz","border-image":"webkit moz o","border-radius":"webkit","border-start":"webkit moz","border-start-color":"webkit moz","border-start-style":"webkit moz","border-start-width":"webkit moz","box-align":"webkit moz ms","box-direction":"webkit moz ms","box-flex":"webkit moz ms","box-lines":"webkit ms","box-ordinal-group":"webkit moz ms","box-orient":"webkit moz ms","box-pack":"webkit moz ms","box-sizing":"webkit moz","box-shadow":"webkit moz","column-count":"webkit moz ms","column-gap":"webkit moz ms","column-rule":"webkit moz ms","column-rule-color":"webkit moz ms","column-rule-style":"webkit moz ms","column-rule-width":"webkit moz ms","column-width":"webkit moz ms",hyphens:"epub moz","line-break":"webkit ms","margin-end":"webkit moz","margin-start":"webkit moz","marquee-speed":"webkit wap","marquee-style":"webkit wap","padding-end":"webkit moz","padding-start":"webkit moz","tab-size":"moz o","text-size-adjust":"webkit ms",transform:"webkit moz ms o","transform-origin":"webkit moz ms o",transition:"webkit moz o","transition-delay":"webkit moz o","transition-duration":"webkit moz o","transition-property":"webkit moz o","transition-timing-function":"webkit moz o","user-modify":"webkit moz","user-select":"webkit moz ms","word-break":"epub ms","writing-mode":"epub ms"};for(prop in compatiblePrefixes)if(compatiblePrefixes.hasOwnProperty(prop)){for(variations=[],prefixed=compatiblePrefixes[prop].split(" "),i=0,len=prefixed.length;len>i;i++)variations.push("-"+prefixed[i]+"-"+prop);compatiblePrefixes[prop]=variations,arrayPush.apply(applyTo,variations)}parser.addListener("startrule",function(){properties=[]}),parser.addListener("startkeyframes",function(event){inKeyFrame=event.prefix||!0}),parser.addListener("endkeyframes",function(){inKeyFrame=!1}),parser.addListener("property",function(event){var name=event.property;CSSLint.Util.indexOf(applyTo,name.text)>-1&&(inKeyFrame&&"string"==typeof inKeyFrame&&0===name.text.indexOf("-"+inKeyFrame+"-")||properties.push(name))}),parser.addListener("endrule",function(){if(properties.length){var i,len,name,prop,variations,value,full,actual,item,propertiesSpecified,propertyGroups={};for(i=0,len=properties.length;len>i;i++){name=properties[i];for(prop in compatiblePrefixes)compatiblePrefixes.hasOwnProperty(prop)&&(variations=compatiblePrefixes[prop],CSSLint.Util.indexOf(variations,name.text)>-1&&(propertyGroups[prop]||(propertyGroups[prop]={full:variations.slice(0),actual:[],actualNodes:[]}),-1===CSSLint.Util.indexOf(propertyGroups[prop].actual,name.text)&&(propertyGroups[prop].actual.push(name.text),propertyGroups[prop].actualNodes.push(name))))}for(prop in propertyGroups)if(propertyGroups.hasOwnProperty(prop)&&(value=propertyGroups[prop],full=value.full,actual=value.actual,full.length>actual.length))for(i=0,len=full.length;len>i;i++)item=full[i],-1===CSSLint.Util.indexOf(actual,item)&&(propertiesSpecified=1===actual.length?actual[0]:2===actual.length?actual.join(" and "):actual.join(", "),reporter.report("The property "+item+" is compatible with "+propertiesSpecified+" and should be included as well.",value.actualNodes[0].line,value.actualNodes[0].col,rule))}})}}),CSSLint.addRule({id:"display-property-grouping",name:"Require properties appropriate for display",desc:"Certain properties shouldn't be used with certain display property values.",browsers:"All",init:function(parser,reporter){function reportProperty(name,display,msg){properties[name]&&("string"!=typeof propertiesToCheck[name]||properties[name].value.toLowerCase()!==propertiesToCheck[name])&&reporter.report(msg||name+" can't be used with display: "+display+".",properties[name].line,properties[name].col,rule)}function startRule(){properties={}}function endRule(){var display=properties.display?properties.display.value:null;if(display)switch(display){case"inline":reportProperty("height",display),reportProperty("width",display),reportProperty("margin",display),reportProperty("margin-top",display),reportProperty("margin-bottom",display),reportProperty("float",display,"display:inline has no effect on floated elements (but may be used to fix the IE6 double-margin bug).");break;case"block":reportProperty("vertical-align",display);
break;case"inline-block":reportProperty("float",display);break;default:0===display.indexOf("table-")&&(reportProperty("margin",display),reportProperty("margin-left",display),reportProperty("margin-right",display),reportProperty("margin-top",display),reportProperty("margin-bottom",display),reportProperty("float",display))}}var properties,rule=this,propertiesToCheck={display:1,"float":"none",height:1,width:1,margin:1,"margin-left":1,"margin-right":1,"margin-bottom":1,"margin-top":1,padding:1,"padding-left":1,"padding-right":1,"padding-bottom":1,"padding-top":1,"vertical-align":1};parser.addListener("startrule",startRule),parser.addListener("startfontface",startRule),parser.addListener("startkeyframerule",startRule),parser.addListener("startpagemargin",startRule),parser.addListener("startpage",startRule),parser.addListener("property",function(event){var name=event.property.text.toLowerCase();propertiesToCheck[name]&&(properties[name]={value:event.value.text,line:event.property.line,col:event.property.col})}),parser.addListener("endrule",endRule),parser.addListener("endfontface",endRule),parser.addListener("endkeyframerule",endRule),parser.addListener("endpagemargin",endRule),parser.addListener("endpage",endRule)}}),CSSLint.addRule({id:"duplicate-background-images",name:"Disallow duplicate background images",desc:"Every background-image should be unique. Use a common class for e.g. sprites.",browsers:"All",init:function(parser,reporter){var rule=this,stack={};parser.addListener("property",function(event){var i,len,name=event.property.text,value=event.value;if(name.match(/background/i))for(i=0,len=value.parts.length;len>i;i++)"uri"===value.parts[i].type&&(stack[value.parts[i].uri]===void 0?stack[value.parts[i].uri]=event:reporter.report("Background image '"+value.parts[i].uri+"' was used multiple times, first declared at line "+stack[value.parts[i].uri].line+", col "+stack[value.parts[i].uri].col+".",event.line,event.col,rule))})}}),CSSLint.addRule({id:"duplicate-properties",name:"Disallow duplicate properties",desc:"Duplicate properties must appear one after the other.",browsers:"All",init:function(parser,reporter){function startRule(){properties={}}var properties,lastProperty,rule=this;parser.addListener("startrule",startRule),parser.addListener("startfontface",startRule),parser.addListener("startpage",startRule),parser.addListener("startpagemargin",startRule),parser.addListener("startkeyframerule",startRule),parser.addListener("property",function(event){var property=event.property,name=property.text.toLowerCase();!properties[name]||lastProperty===name&&properties[name]!==event.value.text||reporter.report("Duplicate property '"+event.property+"' found.",event.line,event.col,rule),properties[name]=event.value.text,lastProperty=name})}}),CSSLint.addRule({id:"empty-rules",name:"Disallow empty rules",desc:"Rules without any properties specified should be removed.",browsers:"All",init:function(parser,reporter){var rule=this,count=0;parser.addListener("startrule",function(){count=0}),parser.addListener("property",function(){count++}),parser.addListener("endrule",function(event){var selectors=event.selectors;0===count&&reporter.report("Rule is empty.",selectors[0].line,selectors[0].col,rule)})}}),CSSLint.addRule({id:"errors",name:"Parsing Errors",desc:"This rule looks for recoverable syntax errors.",browsers:"All",init:function(parser,reporter){var rule=this;parser.addListener("error",function(event){reporter.error(event.message,event.line,event.col,rule)})}}),CSSLint.addRule({id:"fallback-colors",name:"Require fallback colors",desc:"For older browsers that don't support RGBA, HSL, or HSLA, provide a fallback color.",browsers:"IE6,IE7,IE8",init:function(parser,reporter){function startRule(){properties={},lastProperty=null}var lastProperty,properties,rule=this,propertiesToCheck={color:1,background:1,"border-color":1,"border-top-color":1,"border-right-color":1,"border-bottom-color":1,"border-left-color":1,border:1,"border-top":1,"border-right":1,"border-bottom":1,"border-left":1,"background-color":1};parser.addListener("startrule",startRule),parser.addListener("startfontface",startRule),parser.addListener("startpage",startRule),parser.addListener("startpagemargin",startRule),parser.addListener("startkeyframerule",startRule),parser.addListener("property",function(event){var property=event.property,name=property.text.toLowerCase(),parts=event.value.parts,i=0,colorType="",len=parts.length;if(propertiesToCheck[name])for(;len>i;)"color"===parts[i].type&&("alpha"in parts[i]||"hue"in parts[i]?(/([^\\)]+)\\(/.test(parts[i])&&(colorType=RegExp.$1.toUpperCase()),lastProperty&&lastProperty.property.text.toLowerCase()===name&&"compat"===lastProperty.colorType||reporter.report("Fallback "+name+" (hex or RGB) should precede "+colorType+" "+name+".",event.line,event.col,rule)):event.colorType="compat"),i++;lastProperty=event})}}),CSSLint.addRule({id:"floats",name:"Disallow too many floats",desc:"This rule tests if the float property is used too many times",browsers:"All",init:function(parser,reporter){var rule=this,count=0;parser.addListener("property",function(event){"float"===event.property.text.toLowerCase()&&"none"!==event.value.text.toLowerCase()&&count++}),parser.addListener("endstylesheet",function(){reporter.stat("floats",count),count>=10&&reporter.rollupWarn("Too many floats ("+count+"), you're probably using them for layout. Consider using a grid system instead.",rule)})}}),CSSLint.addRule({id:"font-faces",name:"Don't use too many web fonts",desc:"Too many different web fonts in the same stylesheet.",browsers:"All",init:function(parser,reporter){var rule=this,count=0;parser.addListener("startfontface",function(){count++}),parser.addListener("endstylesheet",function(){count>5&&reporter.rollupWarn("Too many @font-face declarations ("+count+").",rule)})}}),CSSLint.addRule({id:"font-sizes",name:"Disallow too many font sizes",desc:"Checks the number of font-size declarations.",browsers:"All",init:function(parser,reporter){var rule=this,count=0;parser.addListener("property",function(event){"font-size"==""+event.property&&count++}),parser.addListener("endstylesheet",function(){reporter.stat("font-sizes",count),count>=10&&reporter.rollupWarn("Too many font-size declarations ("+count+"), abstraction needed.",rule)})}}),CSSLint.addRule({id:"gradients",name:"Require all gradient definitions",desc:"When using a vendor-prefixed gradient, make sure to use them all.",browsers:"All",init:function(parser,reporter){var gradients,rule=this;parser.addListener("startrule",function(){gradients={moz:0,webkit:0,oldWebkit:0,o:0}}),parser.addListener("property",function(event){/\\-(moz|o|webkit)(?:\\-(?:linear|radial))\\-gradient/i.test(event.value)?gradients[RegExp.$1]=1:/\\-webkit\\-gradient/i.test(event.value)&&(gradients.oldWebkit=1)}),parser.addListener("endrule",function(event){var missing=[];gradients.moz||missing.push("Firefox 3.6+"),gradients.webkit||missing.push("Webkit (Safari 5+, Chrome)"),gradients.oldWebkit||missing.push("Old Webkit (Safari 4+, Chrome)"),gradients.o||missing.push("Opera 11.1+"),missing.length&&4>missing.length&&reporter.report("Missing vendor-prefixed CSS gradients for "+missing.join(", ")+".",event.selectors[0].line,event.selectors[0].col,rule)})}}),CSSLint.addRule({id:"ids",name:"Disallow IDs in selectors",desc:"Selectors should not contain IDs.",browsers:"All",init:function(parser,reporter){var rule=this;parser.addListener("startrule",function(event){var selector,part,modifier,idCount,i,j,k,selectors=event.selectors;for(i=0;selectors.length>i;i++){for(selector=selectors[i],idCount=0,j=0;selector.parts.length>j;j++)if(part=selector.parts[j],part.type===parser.SELECTOR_PART_TYPE)for(k=0;part.modifiers.length>k;k++)modifier=part.modifiers[k],"id"===modifier.type&&idCount++;1===idCount?reporter.report("Don't use IDs in selectors.",selector.line,selector.col,rule):idCount>1&&reporter.report(idCount+" IDs in the selector, really?",selector.line,selector.col,rule)}})}}),CSSLint.addRule({id:"import",name:"Disallow @import",desc:"Don't use @import, use <link> instead.",browsers:"All",init:function(parser,reporter){var rule=this;parser.addListener("import",function(event){reporter.report("@import prevents parallel downloads, use <link> instead.",event.line,event.col,rule)})}}),CSSLint.addRule({id:"important",name:"Disallow !important",desc:"Be careful when using !important declaration",browsers:"All",init:function(parser,reporter){var rule=this,count=0;parser.addListener("property",function(event){event.important===!0&&(count++,reporter.report("Use of !important",event.line,event.col,rule))}),parser.addListener("endstylesheet",function(){reporter.stat("important",count),count>=10&&reporter.rollupWarn("Too many !important declarations ("+count+"), try to use less than 10 to avoid specificity issues.",rule)})}}),CSSLint.addRule({id:"known-properties",name:"Require use of known properties",desc:"Properties should be known (listed in CSS3 specification) or be a vendor-prefixed property.",browsers:"All",init:function(parser,reporter){var rule=this;parser.addListener("property",function(event){event.invalid&&reporter.report(event.invalid.message,event.line,event.col,rule)})}}),CSSLint.addRule({id:"order-alphabetical",name:"Alphabetical order",desc:"Assure properties are in alphabetical order",browsers:"All",init:function(parser,reporter){var properties,rule=this,startRule=function(){properties=[]};parser.addListener("startrule",startRule),parser.addListener("startfontface",startRule),parser.addListener("startpage",startRule),parser.addListener("startpagemargin",startRule),parser.addListener("startkeyframerule",startRule),parser.addListener("property",function(event){var name=event.property.text,lowerCasePrefixLessName=name.toLowerCase().replace(/^-.*?-/,"");properties.push(lowerCasePrefixLessName)}),parser.addListener("endrule",function(event){var currentProperties=properties.join(","),expectedProperties=properties.sort().join(",");currentProperties!==expectedProperties&&reporter.report("Rule doesn't have all its properties in alphabetical ordered.",event.line,event.col,rule)})}}),CSSLint.addRule({id:"outline-none",name:"Disallow outline: none",desc:"Use of outline: none or outline: 0 should be limited to :focus rules.",browsers:"All",tags:["Accessibility"],init:function(parser,reporter){function startRule(event){lastRule=event.selectors?{line:event.line,col:event.col,selectors:event.selectors,propCount:0,outline:!1}:null}function endRule(){lastRule&&lastRule.outline&&(-1===(""+lastRule.selectors).toLowerCase().indexOf(":focus")?reporter.report("Outlines should only be modified using :focus.",lastRule.line,lastRule.col,rule):1===lastRule.propCount&&reporter.report("Outlines shouldn't be hidden unless other visual changes are made.",lastRule.line,lastRule.col,rule))}var lastRule,rule=this;parser.addListener("startrule",startRule),parser.addListener("startfontface",startRule),parser.addListener("startpage",startRule),parser.addListener("startpagemargin",startRule),parser.addListener("startkeyframerule",startRule),parser.addListener("property",function(event){var name=event.property.text.toLowerCase(),value=event.value;lastRule&&(lastRule.propCount++,"outline"!==name||"none"!=""+value&&"0"!=""+value||(lastRule.outline=!0))}),parser.addListener("endrule",endRule),parser.addListener("endfontface",endRule),parser.addListener("endpage",endRule),parser.addListener("endpagemargin",endRule),parser.addListener("endkeyframerule",endRule)}}),CSSLint.addRule({id:"overqualified-elements",name:"Disallow overqualified elements",desc:"Don't use classes or IDs with elements (a.foo or a#foo).",browsers:"All",init:function(parser,reporter){var rule=this,classes={};parser.addListener("startrule",function(event){var selector,part,modifier,i,j,k,selectors=event.selectors;for(i=0;selectors.length>i;i++)for(selector=selectors[i],j=0;selector.parts.length>j;j++)if(part=selector.parts[j],part.type===parser.SELECTOR_PART_TYPE)for(k=0;part.modifiers.length>k;k++)modifier=part.modifiers[k],part.elementName&&"id"===modifier.type?reporter.report("Element ("+part+") is overqualified, just use "+modifier+" without element name.",part.line,part.col,rule):"class"===modifier.type&&(classes[modifier]||(classes[modifier]=[]),classes[modifier].push({modifier:modifier,part:part}))}),parser.addListener("endstylesheet",function(){var prop;for(prop in classes)classes.hasOwnProperty(prop)&&1===classes[prop].length&&classes[prop][0].part.elementName&&reporter.report("Element ("+classes[prop][0].part+") is overqualified, just use "+classes[prop][0].modifier+" without element name.",classes[prop][0].part.line,classes[prop][0].part.col,rule)})}}),CSSLint.addRule({id:"qualified-headings",name:"Disallow qualified headings",desc:"Headings should not be qualified (namespaced).",browsers:"All",init:function(parser,reporter){var rule=this;parser.addListener("startrule",function(event){var selector,part,i,j,selectors=event.selectors;for(i=0;selectors.length>i;i++)for(selector=selectors[i],j=0;selector.parts.length>j;j++)part=selector.parts[j],part.type===parser.SELECTOR_PART_TYPE&&part.elementName&&/h[1-6]/.test(""+part.elementName)&&j>0&&reporter.report("Heading ("+part.elementName+") should not be qualified.",part.line,part.col,rule)})}}),CSSLint.addRule({id:"regex-selectors",name:"Disallow selectors that look like regexs",desc:"Selectors that look like regular expressions are slow and should be avoided.",browsers:"All",init:function(parser,reporter){var rule=this;parser.addListener("startrule",function(event){var selector,part,modifier,i,j,k,selectors=event.selectors;for(i=0;selectors.length>i;i++)for(selector=selectors[i],j=0;selector.parts.length>j;j++)if(part=selector.parts[j],part.type===parser.SELECTOR_PART_TYPE)for(k=0;part.modifiers.length>k;k++)modifier=part.modifiers[k],"attribute"===modifier.type&&/([\\~\\|\\^\\$\\*]=)/.test(modifier)&&reporter.report("Attribute selectors with "+RegExp.$1+" are slow!",modifier.line,modifier.col,rule)})}}),CSSLint.addRule({id:"rules-count",name:"Rules Count",desc:"Track how many rules there are.",browsers:"All",init:function(parser,reporter){var count=0;parser.addListener("startrule",function(){count++}),parser.addListener("endstylesheet",function(){reporter.stat("rule-count",count)})}}),CSSLint.addRule({id:"selector-max-approaching",name:"Warn when approaching the 4095 selector limit for IE",desc:"Will warn when selector count is >= 3800 selectors.",browsers:"IE",init:function(parser,reporter){var rule=this,count=0;parser.addListener("startrule",function(event){count+=event.selectors.length}),parser.addListener("endstylesheet",function(){count>=3800&&reporter.report("You have "+count+" selectors. Internet Explorer supports a maximum of 4095 selectors per stylesheet. Consider refactoring.",0,0,rule)})}}),CSSLint.addRule({id:"selector-max",name:"Error when past the 4095 selector limit for IE",desc:"Will error when selector count is > 4095.",browsers:"IE",init:function(parser,reporter){var rule=this,count=0;parser.addListener("startrule",function(event){count+=event.selectors.length}),parser.addListener("endstylesheet",function(){count>4095&&reporter.report("You have "+count+" selectors. Internet Explorer supports a maximum of 4095 selectors per stylesheet. Consider refactoring.",0,0,rule)})}}),CSSLint.addRule({id:"selector-newline",name:"Disallow new-line characters in selectors",desc:"New-line characters in selectors are usually a forgotten comma and not a descendant combinator.",browsers:"All",init:function(parser,reporter){function startRule(event){var i,len,selector,p,n,pLen,part,part2,type,currentLine,nextLine,selectors=event.selectors;for(i=0,len=selectors.length;len>i;i++)for(selector=selectors[i],p=0,pLen=selector.parts.length;pLen>p;p++)for(n=p+1;pLen>n;n++)part=selector.parts[p],part2=selector.parts[n],type=part.type,currentLine=part.line,nextLine=part2.line,"descendant"===type&&nextLine>currentLine&&reporter.report("newline character found in selector (forgot a comma?)",currentLine,selectors[i].parts[0].col,rule)}var rule=this;parser.addListener("startrule",startRule)}}),CSSLint.addRule({id:"shorthand",name:"Require shorthand properties",desc:"Use shorthand properties where possible.",browsers:"All",init:function(parser,reporter){function startRule(){properties={}}function endRule(event){var prop,i,len,total;for(prop in mapping)if(mapping.hasOwnProperty(prop)){for(total=0,i=0,len=mapping[prop].length;len>i;i++)total+=properties[mapping[prop][i]]?1:0;total===mapping[prop].length&&reporter.report("The properties "+mapping[prop].join(", ")+" can be replaced by "+prop+".",event.line,event.col,rule)}}var prop,i,len,properties,rule=this,propertiesToCheck={},mapping={margin:["margin-top","margin-bottom","margin-left","margin-right"],padding:["padding-top","padding-bottom","padding-left","padding-right"]};for(prop in mapping)if(mapping.hasOwnProperty(prop))for(i=0,len=mapping[prop].length;len>i;i++)propertiesToCheck[mapping[prop][i]]=prop;parser.addListener("startrule",startRule),parser.addListener("startfontface",startRule),parser.addListener("property",function(event){var name=(""+event.property).toLowerCase();propertiesToCheck[name]&&(properties[name]=1)}),parser.addListener("endrule",endRule),parser.addListener("endfontface",endRule)}}),CSSLint.addRule({id:"star-property-hack",name:"Disallow properties with a star prefix",desc:"Checks for the star property hack (targets IE6/7)",browsers:"All",init:function(parser,reporter){var rule=this;parser.addListener("property",function(event){var property=event.property;"*"===property.hack&&reporter.report("Property with star prefix found.",event.property.line,event.property.col,rule)})}}),CSSLint.addRule({id:"text-indent",name:"Disallow negative text-indent",desc:"Checks for text indent less than -99px",browsers:"All",init:function(parser,reporter){function startRule(){textIndent=!1,direction="inherit"}function endRule(){textIndent&&"ltr"!==direction&&reporter.report("Negative text-indent doesn't work well with RTL. If you use text-indent for image replacement explicitly set direction for that item to ltr.",textIndent.line,textIndent.col,rule)}var textIndent,direction,rule=this;parser.addListener("startrule",startRule),parser.addListener("startfontface",startRule),parser.addListener("property",function(event){var name=(""+event.property).toLowerCase(),value=event.value;"text-indent"===name&&-99>value.parts[0].value?textIndent=event.property:"direction"===name&&"ltr"==""+value&&(direction="ltr")}),parser.addListener("endrule",endRule),parser.addListener("endfontface",endRule)}}),CSSLint.addRule({id:"underscore-property-hack",name:"Disallow properties with an underscore prefix",desc:"Checks for the underscore property hack (targets IE6)",browsers:"All",init:function(parser,reporter){var rule=this;parser.addListener("property",function(event){var property=event.property;"_"===property.hack&&reporter.report("Property with underscore prefix found.",event.property.line,event.property.col,rule)})}}),CSSLint.addRule({id:"unique-headings",name:"Headings should only be defined once",desc:"Headings should be defined only once.",browsers:"All",init:function(parser,reporter){var rule=this,headings={h1:0,h2:0,h3:0,h4:0,h5:0,h6:0};parser.addListener("startrule",function(event){var selector,part,pseudo,i,j,selectors=event.selectors;for(i=0;selectors.length>i;i++)if(selector=selectors[i],part=selector.parts[selector.parts.length-1],part.elementName&&/(h[1-6])/i.test(""+part.elementName)){for(j=0;part.modifiers.length>j;j++)if("pseudo"===part.modifiers[j].type){pseudo=!0;break}pseudo||(headings[RegExp.$1]++,headings[RegExp.$1]>1&&reporter.report("Heading ("+part.elementName+") has already been defined.",part.line,part.col,rule))}}),parser.addListener("endstylesheet",function(){var prop,messages=[];for(prop in headings)headings.hasOwnProperty(prop)&&headings[prop]>1&&messages.push(headings[prop]+" "+prop+"s");messages.length&&reporter.rollupWarn("You have "+messages.join(", ")+" defined in this stylesheet.",rule)})}}),CSSLint.addRule({id:"universal-selector",name:"Disallow universal selector",desc:"The universal selector (*) is known to be slow.",browsers:"All",init:function(parser,reporter){var rule=this;parser.addListener("startrule",function(event){var selector,part,i,selectors=event.selectors;for(i=0;selectors.length>i;i++)selector=selectors[i],part=selector.parts[selector.parts.length-1],"*"===part.elementName&&reporter.report(rule.desc,part.line,part.col,rule)})}}),CSSLint.addRule({id:"unqualified-attributes",name:"Disallow unqualified attribute selectors",desc:"Unqualified attribute selectors are known to be slow.",browsers:"All",init:function(parser,reporter){var rule=this;parser.addListener("startrule",function(event){var selector,part,modifier,i,k,selectors=event.selectors;for(i=0;selectors.length>i;i++)if(selector=selectors[i],part=selector.parts[selector.parts.length-1],part.type===parser.SELECTOR_PART_TYPE)for(k=0;part.modifiers.length>k;k++)modifier=part.modifiers[k],"attribute"!==modifier.type||part.elementName&&"*"!==part.elementName||reporter.report(rule.desc,part.line,part.col,rule)})}}),CSSLint.addRule({id:"vendor-prefix",name:"Require standard property with vendor prefix",desc:"When using a vendor-prefixed property, make sure to include the standard one.",browsers:"All",init:function(parser,reporter){function startRule(){properties={},num=1}function endRule(){var prop,i,len,needed,actual,needsStandard=[];for(prop in properties)propertiesToCheck[prop]&&needsStandard.push({actual:prop,needed:propertiesToCheck[prop]});for(i=0,len=needsStandard.length;len>i;i++)needed=needsStandard[i].needed,actual=needsStandard[i].actual,properties[needed]?properties[needed][0].pos<properties[actual][0].pos&&reporter.report("Standard property '"+needed+"' should come after vendor-prefixed property '"+actual+"'.",properties[actual][0].name.line,properties[actual][0].name.col,rule):reporter.report("Missing standard property '"+needed+"' to go along with '"+actual+"'.",properties[actual][0].name.line,properties[actual][0].name.col,rule)}var properties,num,rule=this,propertiesToCheck={"-webkit-border-radius":"border-radius","-webkit-border-top-left-radius":"border-top-left-radius","-webkit-border-top-right-radius":"border-top-right-radius","-webkit-border-bottom-left-radius":"border-bottom-left-radius","-webkit-border-bottom-right-radius":"border-bottom-right-radius","-o-border-radius":"border-radius","-o-border-top-left-radius":"border-top-left-radius","-o-border-top-right-radius":"border-top-right-radius","-o-border-bottom-left-radius":"border-bottom-left-radius","-o-border-bottom-right-radius":"border-bottom-right-radius","-moz-border-radius":"border-radius","-moz-border-radius-topleft":"border-top-left-radius","-moz-border-radius-topright":"border-top-right-radius","-moz-border-radius-bottomleft":"border-bottom-left-radius","-moz-border-radius-bottomright":"border-bottom-right-radius","-moz-column-count":"column-count","-webkit-column-count":"column-count","-moz-column-gap":"column-gap","-webkit-column-gap":"column-gap","-moz-column-rule":"column-rule","-webkit-column-rule":"column-rule","-moz-column-rule-style":"column-rule-style","-webkit-column-rule-style":"column-rule-style","-moz-column-rule-color":"column-rule-color","-webkit-column-rule-color":"column-rule-color","-moz-column-rule-width":"column-rule-width","-webkit-column-rule-width":"column-rule-width","-moz-column-width":"column-width","-webkit-column-width":"column-width","-webkit-column-span":"column-span","-webkit-columns":"columns","-moz-box-shadow":"box-shadow","-webkit-box-shadow":"box-shadow","-moz-transform":"transform","-webkit-transform":"transform","-o-transform":"transform","-ms-transform":"transform","-moz-transform-origin":"transform-origin","-webkit-transform-origin":"transform-origin","-o-transform-origin":"transform-origin","-ms-transform-origin":"transform-origin","-moz-box-sizing":"box-sizing","-webkit-box-sizing":"box-sizing"};parser.addListener("startrule",startRule),parser.addListener("startfontface",startRule),parser.addListener("startpage",startRule),parser.addListener("startpagemargin",startRule),parser.addListener("startkeyframerule",startRule),parser.addListener("property",function(event){var name=event.property.text.toLowerCase();properties[name]||(properties[name]=[]),properties[name].push({name:event.property,value:event.value,pos:num++})}),parser.addListener("endrule",endRule),parser.addListener("endfontface",endRule),parser.addListener("endpage",endRule),parser.addListener("endpagemargin",endRule),parser.addListener("endkeyframerule",endRule)}}),CSSLint.addRule({id:"zero-units",name:"Disallow units for 0 values",desc:"You don't need to specify units when a value is 0.",browsers:"All",init:function(parser,reporter){var rule=this;parser.addListener("property",function(event){for(var parts=event.value.parts,i=0,len=parts.length;len>i;)!parts[i].units&&"percentage"!==parts[i].type||0!==parts[i].value||"time"===parts[i].type||reporter.report("Values of 0 shouldn't have units specified.",parts[i].line,parts[i].col,rule),i++})}}),function(){var xmlEscape=function(str){return str&&str.constructor===String?str.replace(/[\\"&><]/g,function(match){switch(match){case'"':return"&quot;";case"&":return"&amp;";case"<":return"&lt;";case">":return"&gt;"}}):""};CSSLint.addFormatter({id:"checkstyle-xml",name:"Checkstyle XML format",startFormat:function(){return'<?xml version="1.0" encoding="utf-8"?><checkstyle>'},endFormat:function(){return"</checkstyle>"},readError:function(filename,message){return'<file name="'+xmlEscape(filename)+'"><error line="0" column="0" severty="error" message="'+xmlEscape(message)+'"></error></file>'},formatResults:function(results,filename){var messages=results.messages,output=[],generateSource=function(rule){return rule&&"name"in rule?"net.csslint."+rule.name.replace(/\\s/g,""):""};return messages.length>0&&(output.push('<file name="'+filename+'">'),CSSLint.Util.forEach(messages,function(message){message.rollup||output.push('<error line="'+message.line+'" column="'+message.col+'" severity="'+message.type+'"'+' message="'+xmlEscape(message.message)+'" source="'+generateSource(message.rule)+'"/>')}),output.push("</file>")),output.join("")}})}(),CSSLint.addFormatter({id:"compact",name:"Compact, 'porcelain' format",startFormat:function(){return""},endFormat:function(){return""},formatResults:function(results,filename,options){var messages=results.messages,output="";options=options||{};var capitalize=function(str){return str.charAt(0).toUpperCase()+str.slice(1)};return 0===messages.length?options.quiet?"":filename+": Lint Free!":(CSSLint.Util.forEach(messages,function(message){output+=message.rollup?filename+": "+capitalize(message.type)+" - "+message.message+"\\n":filename+": "+"line "+message.line+", col "+message.col+", "+capitalize(message.type)+" - "+message.message+" ("+message.rule.id+")\\n"}),output)}}),CSSLint.addFormatter({id:"csslint-xml",name:"CSSLint XML format",startFormat:function(){return'<?xml version="1.0" encoding="utf-8"?><csslint>'},endFormat:function(){return"</csslint>"},formatResults:function(results,filename){var messages=results.messages,output=[],escapeSpecialCharacters=function(str){return str&&str.constructor===String?str.replace(/\\"/g,"'").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;"):""};return messages.length>0&&(output.push('<file name="'+filename+'">'),CSSLint.Util.forEach(messages,function(message){message.rollup?output.push('<issue severity="'+message.type+'" reason="'+escapeSpecialCharacters(message.message)+'" evidence="'+escapeSpecialCharacters(message.evidence)+'"/>'):output.push('<issue line="'+message.line+'" char="'+message.col+'" severity="'+message.type+'"'+' reason="'+escapeSpecialCharacters(message.message)+'" evidence="'+escapeSpecialCharacters(message.evidence)+'"/>')}),output.push("</file>")),output.join("")}}),CSSLint.addFormatter({id:"junit-xml",name:"JUNIT XML format",startFormat:function(){return'<?xml version="1.0" encoding="utf-8"?><testsuites>'},endFormat:function(){return"</testsuites>"},formatResults:function(results,filename){var messages=results.messages,output=[],tests={error:0,failure:0},generateSource=function(rule){return rule&&"name"in rule?"net.csslint."+rule.name.replace(/\\s/g,""):""},escapeSpecialCharacters=function(str){return str&&str.constructor===String?str.replace(/\\"/g,"'").replace(/</g,"&lt;").replace(/>/g,"&gt;"):""};return messages.length>0&&(messages.forEach(function(message){var type="warning"===message.type?"error":message.type;message.rollup||(output.push('<testcase time="0" name="'+generateSource(message.rule)+'">'),output.push("<"+type+' message="'+escapeSpecialCharacters(message.message)+'"><![CDATA['+message.line+":"+message.col+":"+escapeSpecialCharacters(message.evidence)+"]]></"+type+">"),output.push("</testcase>"),tests[type]+=1)}),output.unshift('<testsuite time="0" tests="'+messages.length+'" skipped="0" errors="'+tests.error+'" failures="'+tests.failure+'" package="net.csslint" name="'+filename+'">'),output.push("</testsuite>")),output.join("")}}),CSSLint.addFormatter({id:"lint-xml",name:"Lint XML format",startFormat:function(){return'<?xml version="1.0" encoding="utf-8"?><lint>'},endFormat:function(){return"</lint>"},formatResults:function(results,filename){var messages=results.messages,output=[],escapeSpecialCharacters=function(str){return str&&str.constructor===String?str.replace(/\\"/g,"'").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;"):""};return messages.length>0&&(output.push('<file name="'+filename+'">'),CSSLint.Util.forEach(messages,function(message){message.rollup?output.push('<issue severity="'+message.type+'" reason="'+escapeSpecialCharacters(message.message)+'" evidence="'+escapeSpecialCharacters(message.evidence)+'"/>'):output.push('<issue line="'+message.line+'" char="'+message.col+'" severity="'+message.type+'"'+' reason="'+escapeSpecialCharacters(message.message)+'" evidence="'+escapeSpecialCharacters(message.evidence)+'"/>')}),output.push("</file>")),output.join("")}}),CSSLint.addFormatter({id:"text",name:"Plain Text",startFormat:function(){return""},endFormat:function(){return""},formatResults:function(results,filename,options){var messages=results.messages,output="";if(options=options||{},0===messages.length)return options.quiet?"":"\\n\\ncsslint: No errors in "+filename+".";output="\\n\\ncsslint: There ",output+=1===messages.length?"is 1 problem":"are "+messages.length+" problems",output+=" in "+filename+".";var pos=filename.lastIndexOf("/"),shortFilename=filename;return-1===pos&&(pos=filename.lastIndexOf("\\\\")),pos>-1&&(shortFilename=filename.substring(pos+1)),CSSLint.Util.forEach(messages,function(message,i){output=output+"\\n\\n"+shortFilename,message.rollup?(output+="\\n"+(i+1)+": "+message.type,output+="\\n"+message.message):(output+="\\n"+(i+1)+": "+message.type+" at line "+message.line+", col "+message.col,output+="\\n"+message.message,output+="\\n"+message.evidence)}),output}}),module.exports.CSSLint=CSSLint}),ace.define("ace/mode/css_worker",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/worker/mirror","ace/mode/css/csslint"],function(acequire,exports){"use strict";var oop=acequire("../lib/oop"),lang=acequire("../lib/lang"),Mirror=acequire("../worker/mirror").Mirror,CSSLint=acequire("./css/csslint").CSSLint,Worker=exports.Worker=function(sender){Mirror.call(this,sender),this.setTimeout(400),this.ruleset=null,this.setDisabledRules("ids|order-alphabetical"),this.setInfoRules("adjoining-classes|qualified-headings|zero-units|gradients|import|outline-none|vendor-prefix")};oop.inherits(Worker,Mirror),function(){this.setInfoRules=function(ruleNames){"string"==typeof ruleNames&&(ruleNames=ruleNames.split("|")),this.infoRules=lang.arrayToMap(ruleNames),this.doc.getValue()&&this.deferredUpdate.schedule(100)},this.setDisabledRules=function(ruleNames){if(ruleNames){"string"==typeof ruleNames&&(ruleNames=ruleNames.split("|"));
var all={};CSSLint.getRules().forEach(function(x){all[x.id]=!0}),ruleNames.forEach(function(x){delete all[x]}),this.ruleset=all}else this.ruleset=null;this.doc.getValue()&&this.deferredUpdate.schedule(100)},this.onUpdate=function(){var value=this.doc.getValue();if(!value)return this.sender.emit("annotate",[]);var infoRules=this.infoRules,result=CSSLint.verify(value,this.ruleset);this.sender.emit("annotate",result.messages.map(function(msg){return{row:msg.line-1,column:msg.col-1,text:msg.message,type:infoRules[msg.rule.id]?"info":msg.type,rule:msg.rule.name}}))}}.call(Worker.prototype)}),ace.define("ace/lib/es5-shim",["require","exports","module"],function(){function Empty(){}function doesDefinePropertyWork(object){try{return Object.defineProperty(object,"sentinel",{}),"sentinel"in object}catch(exception){}}function toInteger(n){return n=+n,n!==n?n=0:0!==n&&n!==1/0&&n!==-(1/0)&&(n=(n>0||-1)*Math.floor(Math.abs(n))),n}Function.prototype.bind||(Function.prototype.bind=function(that){var target=this;if("function"!=typeof target)throw new TypeError("Function.prototype.bind called on incompatible "+target);var args=slice.call(arguments,1),bound=function(){if(this instanceof bound){var result=target.apply(this,args.concat(slice.call(arguments)));return Object(result)===result?result:this}return target.apply(that,args.concat(slice.call(arguments)))};return target.prototype&&(Empty.prototype=target.prototype,bound.prototype=new Empty,Empty.prototype=null),bound});var defineGetter,defineSetter,lookupGetter,lookupSetter,supportsAccessors,call=Function.prototype.call,prototypeOfArray=Array.prototype,prototypeOfObject=Object.prototype,slice=prototypeOfArray.slice,_toString=call.bind(prototypeOfObject.toString),owns=call.bind(prototypeOfObject.hasOwnProperty);if((supportsAccessors=owns(prototypeOfObject,"__defineGetter__"))&&(defineGetter=call.bind(prototypeOfObject.__defineGetter__),defineSetter=call.bind(prototypeOfObject.__defineSetter__),lookupGetter=call.bind(prototypeOfObject.__lookupGetter__),lookupSetter=call.bind(prototypeOfObject.__lookupSetter__)),2!=[1,2].splice(0).length)if(function(){function makeArray(l){var a=Array(l+2);return a[0]=a[1]=0,a}var lengthBefore,array=[];return array.splice.apply(array,makeArray(20)),array.splice.apply(array,makeArray(26)),lengthBefore=array.length,array.splice(5,0,"XXX"),lengthBefore+1==array.length,lengthBefore+1==array.length?!0:void 0}()){var array_splice=Array.prototype.splice;Array.prototype.splice=function(start,deleteCount){return arguments.length?array_splice.apply(this,[void 0===start?0:start,void 0===deleteCount?this.length-start:deleteCount].concat(slice.call(arguments,2))):[]}}else Array.prototype.splice=function(pos,removeCount){var length=this.length;pos>0?pos>length&&(pos=length):void 0==pos?pos=0:0>pos&&(pos=Math.max(length+pos,0)),length>pos+removeCount||(removeCount=length-pos);var removed=this.slice(pos,pos+removeCount),insert=slice.call(arguments,2),add=insert.length;if(pos===length)add&&this.push.apply(this,insert);else{var remove=Math.min(removeCount,length-pos),tailOldPos=pos+remove,tailNewPos=tailOldPos+add-remove,tailCount=length-tailOldPos,lengthAfterRemove=length-remove;if(tailOldPos>tailNewPos)for(var i=0;tailCount>i;++i)this[tailNewPos+i]=this[tailOldPos+i];else if(tailNewPos>tailOldPos)for(i=tailCount;i--;)this[tailNewPos+i]=this[tailOldPos+i];if(add&&pos===lengthAfterRemove)this.length=lengthAfterRemove,this.push.apply(this,insert);else for(this.length=lengthAfterRemove+add,i=0;add>i;++i)this[pos+i]=insert[i]}return removed};Array.isArray||(Array.isArray=function(obj){return"[object Array]"==_toString(obj)});var boxedString=Object("a"),splitString="a"!=boxedString[0]||!(0 in boxedString);if(Array.prototype.forEach||(Array.prototype.forEach=function(fun){var object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,thisp=arguments[1],i=-1,length=self.length>>>0;if("[object Function]"!=_toString(fun))throw new TypeError;for(;length>++i;)i in self&&fun.call(thisp,self[i],i,object)}),Array.prototype.map||(Array.prototype.map=function(fun){var object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,length=self.length>>>0,result=Array(length),thisp=arguments[1];if("[object Function]"!=_toString(fun))throw new TypeError(fun+" is not a function");for(var i=0;length>i;i++)i in self&&(result[i]=fun.call(thisp,self[i],i,object));return result}),Array.prototype.filter||(Array.prototype.filter=function(fun){var value,object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,length=self.length>>>0,result=[],thisp=arguments[1];if("[object Function]"!=_toString(fun))throw new TypeError(fun+" is not a function");for(var i=0;length>i;i++)i in self&&(value=self[i],fun.call(thisp,value,i,object)&&result.push(value));return result}),Array.prototype.every||(Array.prototype.every=function(fun){var object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,length=self.length>>>0,thisp=arguments[1];if("[object Function]"!=_toString(fun))throw new TypeError(fun+" is not a function");for(var i=0;length>i;i++)if(i in self&&!fun.call(thisp,self[i],i,object))return!1;return!0}),Array.prototype.some||(Array.prototype.some=function(fun){var object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,length=self.length>>>0,thisp=arguments[1];if("[object Function]"!=_toString(fun))throw new TypeError(fun+" is not a function");for(var i=0;length>i;i++)if(i in self&&fun.call(thisp,self[i],i,object))return!0;return!1}),Array.prototype.reduce||(Array.prototype.reduce=function(fun){var object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,length=self.length>>>0;if("[object Function]"!=_toString(fun))throw new TypeError(fun+" is not a function");if(!length&&1==arguments.length)throw new TypeError("reduce of empty array with no initial value");var result,i=0;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i++];break}if(++i>=length)throw new TypeError("reduce of empty array with no initial value")}for(;length>i;i++)i in self&&(result=fun.call(void 0,result,self[i],i,object));return result}),Array.prototype.reduceRight||(Array.prototype.reduceRight=function(fun){var object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,length=self.length>>>0;if("[object Function]"!=_toString(fun))throw new TypeError(fun+" is not a function");if(!length&&1==arguments.length)throw new TypeError("reduceRight of empty array with no initial value");var result,i=length-1;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i--];break}if(0>--i)throw new TypeError("reduceRight of empty array with no initial value")}do i in this&&(result=fun.call(void 0,result,self[i],i,object));while(i--);return result}),Array.prototype.indexOf&&-1==[0,1].indexOf(1,2)||(Array.prototype.indexOf=function(sought){var self=splitString&&"[object String]"==_toString(this)?this.split(""):toObject(this),length=self.length>>>0;if(!length)return-1;var i=0;for(arguments.length>1&&(i=toInteger(arguments[1])),i=i>=0?i:Math.max(0,length+i);length>i;i++)if(i in self&&self[i]===sought)return i;return-1}),Array.prototype.lastIndexOf&&-1==[0,1].lastIndexOf(0,-3)||(Array.prototype.lastIndexOf=function(sought){var self=splitString&&"[object String]"==_toString(this)?this.split(""):toObject(this),length=self.length>>>0;if(!length)return-1;var i=length-1;for(arguments.length>1&&(i=Math.min(i,toInteger(arguments[1]))),i=i>=0?i:length-Math.abs(i);i>=0;i--)if(i in self&&sought===self[i])return i;return-1}),Object.getPrototypeOf||(Object.getPrototypeOf=function(object){return object.__proto__||(object.constructor?object.constructor.prototype:prototypeOfObject)}),!Object.getOwnPropertyDescriptor){var ERR_NON_OBJECT="Object.getOwnPropertyDescriptor called on a non-object: ";Object.getOwnPropertyDescriptor=function(object,property){if("object"!=typeof object&&"function"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT+object);if(owns(object,property)){var descriptor,getter,setter;if(descriptor={enumerable:!0,configurable:!0},supportsAccessors){var prototype=object.__proto__;object.__proto__=prototypeOfObject;var getter=lookupGetter(object,property),setter=lookupSetter(object,property);if(object.__proto__=prototype,getter||setter)return getter&&(descriptor.get=getter),setter&&(descriptor.set=setter),descriptor}return descriptor.value=object[property],descriptor}}}if(Object.getOwnPropertyNames||(Object.getOwnPropertyNames=function(object){return Object.keys(object)}),!Object.create){var createEmpty;createEmpty=null===Object.prototype.__proto__?function(){return{__proto__:null}}:function(){var empty={};for(var i in empty)empty[i]=null;return empty.constructor=empty.hasOwnProperty=empty.propertyIsEnumerable=empty.isPrototypeOf=empty.toLocaleString=empty.toString=empty.valueOf=empty.__proto__=null,empty},Object.create=function(prototype,properties){var object;if(null===prototype)object=createEmpty();else{if("object"!=typeof prototype)throw new TypeError("typeof prototype["+typeof prototype+"] != 'object'");var Type=function(){};Type.prototype=prototype,object=new Type,object.__proto__=prototype}return void 0!==properties&&Object.defineProperties(object,properties),object}}if(Object.defineProperty){var definePropertyWorksOnObject=doesDefinePropertyWork({}),definePropertyWorksOnDom="undefined"==typeof document||doesDefinePropertyWork(document.createElement("div"));if(!definePropertyWorksOnObject||!definePropertyWorksOnDom)var definePropertyFallback=Object.defineProperty}if(!Object.defineProperty||definePropertyFallback){var ERR_NON_OBJECT_DESCRIPTOR="Property description must be an object: ",ERR_NON_OBJECT_TARGET="Object.defineProperty called on non-object: ",ERR_ACCESSORS_NOT_SUPPORTED="getters & setters can not be defined on this javascript engine";Object.defineProperty=function(object,property,descriptor){if("object"!=typeof object&&"function"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT_TARGET+object);if("object"!=typeof descriptor&&"function"!=typeof descriptor||null===descriptor)throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR+descriptor);if(definePropertyFallback)try{return definePropertyFallback.call(Object,object,property,descriptor)}catch(exception){}if(owns(descriptor,"value"))if(supportsAccessors&&(lookupGetter(object,property)||lookupSetter(object,property))){var prototype=object.__proto__;object.__proto__=prototypeOfObject,delete object[property],object[property]=descriptor.value,object.__proto__=prototype}else object[property]=descriptor.value;else{if(!supportsAccessors)throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);owns(descriptor,"get")&&defineGetter(object,property,descriptor.get),owns(descriptor,"set")&&defineSetter(object,property,descriptor.set)}return object}}Object.defineProperties||(Object.defineProperties=function(object,properties){for(var property in properties)owns(properties,property)&&Object.defineProperty(object,property,properties[property]);return object}),Object.seal||(Object.seal=function(object){return object}),Object.freeze||(Object.freeze=function(object){return object});try{Object.freeze(function(){})}catch(exception){Object.freeze=function(freezeObject){return function(object){return"function"==typeof object?object:freezeObject(object)}}(Object.freeze)}if(Object.preventExtensions||(Object.preventExtensions=function(object){return object}),Object.isSealed||(Object.isSealed=function(){return!1}),Object.isFrozen||(Object.isFrozen=function(){return!1}),Object.isExtensible||(Object.isExtensible=function(object){if(Object(object)===object)throw new TypeError;for(var name="";owns(object,name);)name+="?";object[name]=!0;var returnValue=owns(object,name);return delete object[name],returnValue}),!Object.keys){var hasDontEnumBug=!0,dontEnums=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],dontEnumsLength=dontEnums.length;for(var key in{toString:null})hasDontEnumBug=!1;Object.keys=function(object){if("object"!=typeof object&&"function"!=typeof object||null===object)throw new TypeError("Object.keys called on a non-object");var keys=[];for(var name in object)owns(object,name)&&keys.push(name);if(hasDontEnumBug)for(var i=0,ii=dontEnumsLength;ii>i;i++){var dontEnum=dontEnums[i];owns(object,dontEnum)&&keys.push(dontEnum)}return keys}}Date.now||(Date.now=function(){return(new Date).getTime()});var ws="	\\n\v\\f\\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\\u2028\\u2029\uFEFF";if(!String.prototype.trim||ws.trim()){ws="["+ws+"]";var trimBeginRegexp=RegExp("^"+ws+ws+"*"),trimEndRegexp=RegExp(ws+ws+"*$");String.prototype.trim=function(){return(this+"").replace(trimBeginRegexp,"").replace(trimEndRegexp,"")}}var toObject=function(o){if(null==o)throw new TypeError("can't convert "+o+" to object");return Object(o)}});`;
    }
  });

  // node_modules/brace/mode/css.js
  var require_css2 = __commonJS({
    "node_modules/brace/mode/css.js"() {
      ace.define("ace/mode/css_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/mode/text_highlight_rules"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("../lib/oop");
        var lang = acequire("../lib/lang");
        var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;
        var supportType = exports2.supportType = "align-content|align-items|align-self|all|animation|animation-delay|animation-direction|animation-duration|animation-fill-mode|animation-iteration-count|animation-name|animation-play-state|animation-timing-function|backface-visibility|background|background-attachment|background-blend-mode|background-clip|background-color|background-image|background-origin|background-position|background-repeat|background-size|border|border-bottom|border-bottom-color|border-bottom-left-radius|border-bottom-right-radius|border-bottom-style|border-bottom-width|border-collapse|border-color|border-image|border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-left|border-left-color|border-left-style|border-left-width|border-radius|border-right|border-right-color|border-right-style|border-right-width|border-spacing|border-style|border-top|border-top-color|border-top-left-radius|border-top-right-radius|border-top-style|border-top-width|border-width|bottom|box-shadow|box-sizing|caption-side|clear|clip|color|column-count|column-fill|column-gap|column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columns|content|counter-increment|counter-reset|cursor|direction|display|empty-cells|filter|flex|flex-basis|flex-direction|flex-flow|flex-grow|flex-shrink|flex-wrap|float|font|font-family|font-size|font-size-adjust|font-stretch|font-style|font-variant|font-weight|hanging-punctuation|height|justify-content|left|letter-spacing|line-height|list-style|list-style-image|list-style-position|list-style-type|margin|margin-bottom|margin-left|margin-right|margin-top|max-height|max-width|min-height|min-width|nav-down|nav-index|nav-left|nav-right|nav-up|opacity|order|outline|outline-color|outline-offset|outline-style|outline-width|overflow|overflow-x|overflow-y|padding|padding-bottom|padding-left|padding-right|padding-top|page-break-after|page-break-before|page-break-inside|perspective|perspective-origin|position|quotes|resize|right|tab-size|table-layout|text-align|text-align-last|text-decoration|text-decoration-color|text-decoration-line|text-decoration-style|text-indent|text-justify|text-overflow|text-shadow|text-transform|top|transform|transform-origin|transform-style|transition|transition-delay|transition-duration|transition-property|transition-timing-function|unicode-bidi|vertical-align|visibility|white-space|width|word-break|word-spacing|word-wrap|z-index";
        var supportFunction = exports2.supportFunction = "rgb|rgba|url|attr|counter|counters";
        var supportConstant = exports2.supportConstant = "absolute|after-edge|after|all-scroll|all|alphabetic|always|antialiased|armenian|auto|avoid-column|avoid-page|avoid|balance|baseline|before-edge|before|below|bidi-override|block-line-height|block|bold|bolder|border-box|both|bottom|box|break-all|break-word|capitalize|caps-height|caption|center|central|char|circle|cjk-ideographic|clone|close-quote|col-resize|collapse|column|consider-shifts|contain|content-box|cover|crosshair|cubic-bezier|dashed|decimal-leading-zero|decimal|default|disabled|disc|disregard-shifts|distribute-all-lines|distribute-letter|distribute-space|distribute|dotted|double|e-resize|ease-in|ease-in-out|ease-out|ease|ellipsis|end|exclude-ruby|fill|fixed|georgian|glyphs|grid-height|groove|hand|hanging|hebrew|help|hidden|hiragana-iroha|hiragana|horizontal|icon|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space|ideographic|inactive|include-ruby|inherit|initial|inline-block|inline-box|inline-line-height|inline-table|inline|inset|inside|inter-ideograph|inter-word|invert|italic|justify|katakana-iroha|katakana|keep-all|last|left|lighter|line-edge|line-through|line|linear|list-item|local|loose|lower-alpha|lower-greek|lower-latin|lower-roman|lowercase|lr-tb|ltr|mathematical|max-height|max-size|medium|menu|message-box|middle|move|n-resize|ne-resize|newspaper|no-change|no-close-quote|no-drop|no-open-quote|no-repeat|none|normal|not-allowed|nowrap|nw-resize|oblique|open-quote|outset|outside|overline|padding-box|page|pointer|pre-line|pre-wrap|pre|preserve-3d|progress|relative|repeat-x|repeat-y|repeat|replaced|reset-size|ridge|right|round|row-resize|rtl|s-resize|scroll|se-resize|separate|slice|small-caps|small-caption|solid|space|square|start|static|status-bar|step-end|step-start|steps|stretch|strict|sub|super|sw-resize|table-caption|table-cell|table-column-group|table-column|table-footer-group|table-header-group|table-row-group|table-row|table|tb-rl|text-after-edge|text-before-edge|text-bottom|text-size|text-top|text|thick|thin|transparent|underline|upper-alpha|upper-latin|upper-roman|uppercase|use-script|vertical-ideographic|vertical-text|visible|w-resize|wait|whitespace|z-index|zero";
        var supportConstantColor = exports2.supportConstantColor = "aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen";
        var supportConstantFonts = exports2.supportConstantFonts = "arial|century|comic|courier|cursive|fantasy|garamond|georgia|helvetica|impact|lucida|symbol|system|tahoma|times|trebuchet|utopia|verdana|webdings|sans-serif|serif|monospace";
        var numRe = exports2.numRe = "\\-?(?:(?:[0-9]+(?:\\.[0-9]+)?)|(?:\\.[0-9]+))";
        var pseudoElements = exports2.pseudoElements = "(\\:+)\\b(after|before|first-letter|first-line|moz-selection|selection)\\b";
        var pseudoClasses = exports2.pseudoClasses = "(:)\\b(active|checked|disabled|empty|enabled|first-child|first-of-type|focus|hover|indeterminate|invalid|last-child|last-of-type|link|not|nth-child|nth-last-child|nth-last-of-type|nth-of-type|only-child|only-of-type|acequired|root|target|valid|visited)\\b";
        var CssHighlightRules = function() {
          var keywordMapper = this.createKeywordMapper({
            "support.function": supportFunction,
            "support.constant": supportConstant,
            "support.type": supportType,
            "support.constant.color": supportConstantColor,
            "support.constant.fonts": supportConstantFonts
          }, "text", true);
          this.$rules = {
            "start": [{
              include: ["strings", "url", "comments"]
            }, {
              token: "paren.lparen",
              regex: "\\{",
              next: "ruleset"
            }, {
              token: "paren.rparen",
              regex: "\\}"
            }, {
              token: "string",
              regex: "@",
              next: "media"
            }, {
              token: "keyword",
              regex: "#[a-z0-9-_]+"
            }, {
              token: "keyword",
              regex: "%"
            }, {
              token: "variable",
              regex: "\\.[a-z0-9-_]+"
            }, {
              token: "string",
              regex: ":[a-z0-9-_]+"
            }, {
              token: "constant.numeric",
              regex: numRe
            }, {
              token: "constant",
              regex: "[a-z0-9-_]+"
            }, {
              caseInsensitive: true
            }],
            "media": [{
              include: ["strings", "url", "comments"]
            }, {
              token: "paren.lparen",
              regex: "\\{",
              next: "start"
            }, {
              token: "paren.rparen",
              regex: "\\}",
              next: "start"
            }, {
              token: "string",
              regex: ";",
              next: "start"
            }, {
              token: "keyword",
              regex: "(?:media|supports|document|charset|import|namespace|media|supports|document|page|font|keyframes|viewport|counter-style|font-feature-values|swash|ornaments|annotation|stylistic|styleset|character-variant)"
            }],
            "comments": [{
              token: "comment",
              // multi line comment
              regex: "\\/\\*",
              push: [{
                token: "comment",
                regex: "\\*\\/",
                next: "pop"
              }, {
                defaultToken: "comment"
              }]
            }],
            "ruleset": [{
              regex: "-(webkit|ms|moz|o)-",
              token: "text"
            }, {
              token: "paren.rparen",
              regex: "\\}",
              next: "start"
            }, {
              include: ["strings", "url", "comments"]
            }, {
              token: ["constant.numeric", "keyword"],
              regex: "(" + numRe + ")(ch|cm|deg|em|ex|fr|gd|grad|Hz|in|kHz|mm|ms|pc|pt|px|rad|rem|s|turn|vh|vm|vw|%)"
            }, {
              token: "constant.numeric",
              regex: numRe
            }, {
              token: "constant.numeric",
              // hex6 color
              regex: "#[a-f0-9]{6}"
            }, {
              token: "constant.numeric",
              // hex3 color
              regex: "#[a-f0-9]{3}"
            }, {
              token: ["punctuation", "entity.other.attribute-name.pseudo-element.css"],
              regex: pseudoElements
            }, {
              token: ["punctuation", "entity.other.attribute-name.pseudo-class.css"],
              regex: pseudoClasses
            }, {
              include: "url"
            }, {
              token: keywordMapper,
              regex: "\\-?[a-zA-Z_][a-zA-Z0-9_\\-]*"
            }, {
              caseInsensitive: true
            }],
            url: [{
              token: "support.function",
              regex: "(?:url(:?-prefix)?|domain|regexp)\\(",
              push: [{
                token: "support.function",
                regex: "\\)",
                next: "pop"
              }, {
                defaultToken: "string"
              }]
            }],
            strings: [{
              token: "string.start",
              regex: "'",
              push: [{
                token: "string.end",
                regex: "'|$",
                next: "pop"
              }, {
                include: "escapes"
              }, {
                token: "constant.language.escape",
                regex: /\\$/,
                consumeLineEnd: true
              }, {
                defaultToken: "string"
              }]
            }, {
              token: "string.start",
              regex: '"',
              push: [{
                token: "string.end",
                regex: '"|$',
                next: "pop"
              }, {
                include: "escapes"
              }, {
                token: "constant.language.escape",
                regex: /\\$/,
                consumeLineEnd: true
              }, {
                defaultToken: "string"
              }]
            }],
            escapes: [{
              token: "constant.language.escape",
              regex: /\\([a-fA-F\d]{1,6}|[^a-fA-F\d])/
            }]
          };
          this.normalizeRules();
        };
        oop.inherits(CssHighlightRules, TextHighlightRules);
        exports2.CssHighlightRules = CssHighlightRules;
      });
      ace.define("ace/mode/matching_brace_outdent", ["require", "exports", "module", "ace/range"], function(acequire, exports2, module2) {
        "use strict";
        var Range = acequire("../range").Range;
        var MatchingBraceOutdent = function() {
        };
        (function() {
          this.checkOutdent = function(line, input) {
            if (!/^\s+$/.test(line))
              return false;
            return /^\s*\}/.test(input);
          };
          this.autoOutdent = function(doc, row) {
            var line = doc.getLine(row);
            var match = line.match(/^(\s*\})/);
            if (!match)
              return 0;
            var column = match[1].length;
            var openBracePos = doc.findMatchingBracket({ row, column });
            if (!openBracePos || openBracePos.row == row)
              return 0;
            var indent = this.$getIndent(doc.getLine(openBracePos.row));
            doc.replace(new Range(row, 0, row, column - 1), indent);
          };
          this.$getIndent = function(line) {
            return line.match(/^\s*/)[0];
          };
        }).call(MatchingBraceOutdent.prototype);
        exports2.MatchingBraceOutdent = MatchingBraceOutdent;
      });
      ace.define("ace/mode/css_completions", ["require", "exports", "module"], function(acequire, exports2, module2) {
        "use strict";
        var propertyMap = {
          "background": { "#$0": 1 },
          "background-color": { "#$0": 1, "transparent": 1, "fixed": 1 },
          "background-image": { "url('/$0')": 1 },
          "background-repeat": { "repeat": 1, "repeat-x": 1, "repeat-y": 1, "no-repeat": 1, "inherit": 1 },
          "background-position": { "bottom": 2, "center": 2, "left": 2, "right": 2, "top": 2, "inherit": 2 },
          "background-attachment": { "scroll": 1, "fixed": 1 },
          "background-size": { "cover": 1, "contain": 1 },
          "background-clip": { "border-box": 1, "padding-box": 1, "content-box": 1 },
          "background-origin": { "border-box": 1, "padding-box": 1, "content-box": 1 },
          "border": { "solid $0": 1, "dashed $0": 1, "dotted $0": 1, "#$0": 1 },
          "border-color": { "#$0": 1 },
          "border-style": { "solid": 2, "dashed": 2, "dotted": 2, "double": 2, "groove": 2, "hidden": 2, "inherit": 2, "inset": 2, "none": 2, "outset": 2, "ridged": 2 },
          "border-collapse": { "collapse": 1, "separate": 1 },
          "bottom": { "px": 1, "em": 1, "%": 1 },
          "clear": { "left": 1, "right": 1, "both": 1, "none": 1 },
          "color": { "#$0": 1, "rgb(#$00,0,0)": 1 },
          "cursor": { "default": 1, "pointer": 1, "move": 1, "text": 1, "wait": 1, "help": 1, "progress": 1, "n-resize": 1, "ne-resize": 1, "e-resize": 1, "se-resize": 1, "s-resize": 1, "sw-resize": 1, "w-resize": 1, "nw-resize": 1 },
          "display": { "none": 1, "block": 1, "inline": 1, "inline-block": 1, "table-cell": 1 },
          "empty-cells": { "show": 1, "hide": 1 },
          "float": { "left": 1, "right": 1, "none": 1 },
          "font-family": { "Arial": 2, "Comic Sans MS": 2, "Consolas": 2, "Courier New": 2, "Courier": 2, "Georgia": 2, "Monospace": 2, "Sans-Serif": 2, "Segoe UI": 2, "Tahoma": 2, "Times New Roman": 2, "Trebuchet MS": 2, "Verdana": 1 },
          "font-size": { "px": 1, "em": 1, "%": 1 },
          "font-weight": { "bold": 1, "normal": 1 },
          "font-style": { "italic": 1, "normal": 1 },
          "font-variant": { "normal": 1, "small-caps": 1 },
          "height": { "px": 1, "em": 1, "%": 1 },
          "left": { "px": 1, "em": 1, "%": 1 },
          "letter-spacing": { "normal": 1 },
          "line-height": { "normal": 1 },
          "list-style-type": { "none": 1, "disc": 1, "circle": 1, "square": 1, "decimal": 1, "decimal-leading-zero": 1, "lower-roman": 1, "upper-roman": 1, "lower-greek": 1, "lower-latin": 1, "upper-latin": 1, "georgian": 1, "lower-alpha": 1, "upper-alpha": 1 },
          "margin": { "px": 1, "em": 1, "%": 1 },
          "margin-right": { "px": 1, "em": 1, "%": 1 },
          "margin-left": { "px": 1, "em": 1, "%": 1 },
          "margin-top": { "px": 1, "em": 1, "%": 1 },
          "margin-bottom": { "px": 1, "em": 1, "%": 1 },
          "max-height": { "px": 1, "em": 1, "%": 1 },
          "max-width": { "px": 1, "em": 1, "%": 1 },
          "min-height": { "px": 1, "em": 1, "%": 1 },
          "min-width": { "px": 1, "em": 1, "%": 1 },
          "overflow": { "hidden": 1, "visible": 1, "auto": 1, "scroll": 1 },
          "overflow-x": { "hidden": 1, "visible": 1, "auto": 1, "scroll": 1 },
          "overflow-y": { "hidden": 1, "visible": 1, "auto": 1, "scroll": 1 },
          "padding": { "px": 1, "em": 1, "%": 1 },
          "padding-top": { "px": 1, "em": 1, "%": 1 },
          "padding-right": { "px": 1, "em": 1, "%": 1 },
          "padding-bottom": { "px": 1, "em": 1, "%": 1 },
          "padding-left": { "px": 1, "em": 1, "%": 1 },
          "page-break-after": { "auto": 1, "always": 1, "avoid": 1, "left": 1, "right": 1 },
          "page-break-before": { "auto": 1, "always": 1, "avoid": 1, "left": 1, "right": 1 },
          "position": { "absolute": 1, "relative": 1, "fixed": 1, "static": 1 },
          "right": { "px": 1, "em": 1, "%": 1 },
          "table-layout": { "fixed": 1, "auto": 1 },
          "text-decoration": { "none": 1, "underline": 1, "line-through": 1, "blink": 1 },
          "text-align": { "left": 1, "right": 1, "center": 1, "justify": 1 },
          "text-transform": { "capitalize": 1, "uppercase": 1, "lowercase": 1, "none": 1 },
          "top": { "px": 1, "em": 1, "%": 1 },
          "vertical-align": { "top": 1, "bottom": 1 },
          "visibility": { "hidden": 1, "visible": 1 },
          "white-space": { "nowrap": 1, "normal": 1, "pre": 1, "pre-line": 1, "pre-wrap": 1 },
          "width": { "px": 1, "em": 1, "%": 1 },
          "word-spacing": { "normal": 1 },
          "filter": { "alpha(opacity=$0100)": 1 },
          "text-shadow": { "$02px 2px 2px #777": 1 },
          "text-overflow": { "ellipsis-word": 1, "clip": 1, "ellipsis": 1 },
          "-moz-border-radius": 1,
          "-moz-border-radius-topright": 1,
          "-moz-border-radius-bottomright": 1,
          "-moz-border-radius-topleft": 1,
          "-moz-border-radius-bottomleft": 1,
          "-webkit-border-radius": 1,
          "-webkit-border-top-right-radius": 1,
          "-webkit-border-top-left-radius": 1,
          "-webkit-border-bottom-right-radius": 1,
          "-webkit-border-bottom-left-radius": 1,
          "-moz-box-shadow": 1,
          "-webkit-box-shadow": 1,
          "transform": { "rotate($00deg)": 1, "skew($00deg)": 1 },
          "-moz-transform": { "rotate($00deg)": 1, "skew($00deg)": 1 },
          "-webkit-transform": { "rotate($00deg)": 1, "skew($00deg)": 1 }
        };
        var CssCompletions = function() {
        };
        (function() {
          this.completionsDefined = false;
          this.defineCompletions = function() {
            if (document) {
              var style = document.createElement("c").style;
              for (var i in style) {
                if (typeof style[i] !== "string")
                  continue;
                var name = i.replace(/[A-Z]/g, function(x) {
                  return "-" + x.toLowerCase();
                });
                if (!propertyMap.hasOwnProperty(name))
                  propertyMap[name] = 1;
              }
            }
            this.completionsDefined = true;
          };
          this.getCompletions = function(state, session, pos, prefix) {
            if (!this.completionsDefined) {
              this.defineCompletions();
            }
            var token = session.getTokenAt(pos.row, pos.column);
            if (!token)
              return [];
            if (state === "ruleset") {
              var line = session.getLine(pos.row).substr(0, pos.column);
              if (/:[^;]+$/.test(line)) {
                /([\w\-]+):[^:]*$/.test(line);
                return this.getPropertyValueCompletions(state, session, pos, prefix);
              } else {
                return this.getPropertyCompletions(state, session, pos, prefix);
              }
            }
            return [];
          };
          this.getPropertyCompletions = function(state, session, pos, prefix) {
            var properties = Object.keys(propertyMap);
            return properties.map(function(property) {
              return {
                caption: property,
                snippet: property + ": $0;",
                meta: "property",
                score: Number.MAX_VALUE
              };
            });
          };
          this.getPropertyValueCompletions = function(state, session, pos, prefix) {
            var line = session.getLine(pos.row).substr(0, pos.column);
            var property = (/([\w\-]+):[^:]*$/.exec(line) || {})[1];
            if (!property)
              return [];
            var values = [];
            if (property in propertyMap && typeof propertyMap[property] === "object") {
              values = Object.keys(propertyMap[property]);
            }
            return values.map(function(value) {
              return {
                caption: value,
                snippet: value,
                meta: "property value",
                score: Number.MAX_VALUE
              };
            });
          };
        }).call(CssCompletions.prototype);
        exports2.CssCompletions = CssCompletions;
      });
      ace.define("ace/mode/behaviour/css", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/mode/behaviour/cstyle", "ace/token_iterator"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("../../lib/oop");
        var Behaviour = acequire("../behaviour").Behaviour;
        var CstyleBehaviour = acequire("./cstyle").CstyleBehaviour;
        var TokenIterator = acequire("../../token_iterator").TokenIterator;
        var CssBehaviour = function() {
          this.inherit(CstyleBehaviour);
          this.add("colon", "insertion", function(state, action, editor, session, text) {
            if (text === ":") {
              var cursor = editor.getCursorPosition();
              var iterator = new TokenIterator(session, cursor.row, cursor.column);
              var token = iterator.getCurrentToken();
              if (token && token.value.match(/\s+/)) {
                token = iterator.stepBackward();
              }
              if (token && token.type === "support.type") {
                var line = session.doc.getLine(cursor.row);
                var rightChar = line.substring(cursor.column, cursor.column + 1);
                if (rightChar === ":") {
                  return {
                    text: "",
                    selection: [1, 1]
                  };
                }
                if (!line.substring(cursor.column).match(/^\s*;/)) {
                  return {
                    text: ":;",
                    selection: [1, 1]
                  };
                }
              }
            }
          });
          this.add("colon", "deletion", function(state, action, editor, session, range) {
            var selected = session.doc.getTextRange(range);
            if (!range.isMultiLine() && selected === ":") {
              var cursor = editor.getCursorPosition();
              var iterator = new TokenIterator(session, cursor.row, cursor.column);
              var token = iterator.getCurrentToken();
              if (token && token.value.match(/\s+/)) {
                token = iterator.stepBackward();
              }
              if (token && token.type === "support.type") {
                var line = session.doc.getLine(range.start.row);
                var rightChar = line.substring(range.end.column, range.end.column + 1);
                if (rightChar === ";") {
                  range.end.column++;
                  return range;
                }
              }
            }
          });
          this.add("semicolon", "insertion", function(state, action, editor, session, text) {
            if (text === ";") {
              var cursor = editor.getCursorPosition();
              var line = session.doc.getLine(cursor.row);
              var rightChar = line.substring(cursor.column, cursor.column + 1);
              if (rightChar === ";") {
                return {
                  text: "",
                  selection: [1, 1]
                };
              }
            }
          });
        };
        oop.inherits(CssBehaviour, CstyleBehaviour);
        exports2.CssBehaviour = CssBehaviour;
      });
      ace.define("ace/mode/folding/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/range", "ace/mode/folding/fold_mode"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("../../lib/oop");
        var Range = acequire("../../range").Range;
        var BaseFoldMode = acequire("./fold_mode").FoldMode;
        var FoldMode = exports2.FoldMode = function(commentRegex) {
          if (commentRegex) {
            this.foldingStartMarker = new RegExp(
              this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start)
            );
            this.foldingStopMarker = new RegExp(
              this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end)
            );
          }
        };
        oop.inherits(FoldMode, BaseFoldMode);
        (function() {
          this.foldingStartMarker = /([\{\[\(])[^\}\]\)]*$|^\s*(\/\*)/;
          this.foldingStopMarker = /^[^\[\{\(]*([\}\]\)])|^[\s\*]*(\*\/)/;
          this.singleLineBlockCommentRe = /^\s*(\/\*).*\*\/\s*$/;
          this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
          this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
          this._getFoldWidgetBase = this.getFoldWidget;
          this.getFoldWidget = function(session, foldStyle, row) {
            var line = session.getLine(row);
            if (this.singleLineBlockCommentRe.test(line)) {
              if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))
                return "";
            }
            var fw = this._getFoldWidgetBase(session, foldStyle, row);
            if (!fw && this.startRegionRe.test(line))
              return "start";
            return fw;
          };
          this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
            var line = session.getLine(row);
            if (this.startRegionRe.test(line))
              return this.getCommentRegionBlock(session, line, row);
            var match = line.match(this.foldingStartMarker);
            if (match) {
              var i = match.index;
              if (match[1])
                return this.openingBracketBlock(session, match[1], row, i);
              var range = session.getCommentFoldRange(row, i + match[0].length, 1);
              if (range && !range.isMultiLine()) {
                if (forceMultiline) {
                  range = this.getSectionRange(session, row);
                } else if (foldStyle != "all")
                  range = null;
              }
              return range;
            }
            if (foldStyle === "markbegin")
              return;
            var match = line.match(this.foldingStopMarker);
            if (match) {
              var i = match.index + match[0].length;
              if (match[1])
                return this.closingBracketBlock(session, match[1], row, i);
              return session.getCommentFoldRange(row, i, -1);
            }
          };
          this.getSectionRange = function(session, row) {
            var line = session.getLine(row);
            var startIndent = line.search(/\S/);
            var startRow = row;
            var startColumn = line.length;
            row = row + 1;
            var endRow = row;
            var maxRow = session.getLength();
            while (++row < maxRow) {
              line = session.getLine(row);
              var indent = line.search(/\S/);
              if (indent === -1)
                continue;
              if (startIndent > indent)
                break;
              var subRange = this.getFoldWidgetRange(session, "all", row);
              if (subRange) {
                if (subRange.start.row <= startRow) {
                  break;
                } else if (subRange.isMultiLine()) {
                  row = subRange.end.row;
                } else if (startIndent == indent) {
                  break;
                }
              }
              endRow = row;
            }
            return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
          };
          this.getCommentRegionBlock = function(session, line, row) {
            var startColumn = line.search(/\s*$/);
            var maxRow = session.getLength();
            var startRow = row;
            var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
            var depth = 1;
            while (++row < maxRow) {
              line = session.getLine(row);
              var m = re.exec(line);
              if (!m)
                continue;
              if (m[1])
                depth--;
              else
                depth++;
              if (!depth)
                break;
            }
            var endRow = row;
            if (endRow > startRow) {
              return new Range(startRow, startColumn, endRow, line.length);
            }
          };
        }).call(FoldMode.prototype);
      });
      ace.define("ace/mode/css", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/css_highlight_rules", "ace/mode/matching_brace_outdent", "ace/worker/worker_client", "ace/mode/css_completions", "ace/mode/behaviour/css", "ace/mode/folding/cstyle"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("../lib/oop");
        var TextMode = acequire("./text").Mode;
        var CssHighlightRules = acequire("./css_highlight_rules").CssHighlightRules;
        var MatchingBraceOutdent = acequire("./matching_brace_outdent").MatchingBraceOutdent;
        var WorkerClient = acequire("../worker/worker_client").WorkerClient;
        var CssCompletions = acequire("./css_completions").CssCompletions;
        var CssBehaviour = acequire("./behaviour/css").CssBehaviour;
        var CStyleFoldMode = acequire("./folding/cstyle").FoldMode;
        var Mode = function() {
          this.HighlightRules = CssHighlightRules;
          this.$outdent = new MatchingBraceOutdent();
          this.$behaviour = new CssBehaviour();
          this.$completer = new CssCompletions();
          this.foldingRules = new CStyleFoldMode();
        };
        oop.inherits(Mode, TextMode);
        (function() {
          this.foldingRules = "cStyle";
          this.blockComment = { start: "/*", end: "*/" };
          this.getNextLineIndent = function(state, line, tab) {
            var indent = this.$getIndent(line);
            var tokens = this.getTokenizer().getLineTokens(line, state).tokens;
            if (tokens.length && tokens[tokens.length - 1].type == "comment") {
              return indent;
            }
            var match = line.match(/^.*\{\s*$/);
            if (match) {
              indent += tab;
            }
            return indent;
          };
          this.checkOutdent = function(state, line, input) {
            return this.$outdent.checkOutdent(line, input);
          };
          this.autoOutdent = function(state, doc, row) {
            this.$outdent.autoOutdent(doc, row);
          };
          this.getCompletions = function(state, session, pos, prefix) {
            return this.$completer.getCompletions(state, session, pos, prefix);
          };
          this.createWorker = function(session) {
            var worker = new WorkerClient(["ace"], require_css(), "Worker");
            worker.attachToDocument(session.getDocument());
            worker.on("annotate", function(e) {
              session.setAnnotations(e.data);
            });
            worker.on("terminate", function() {
              session.clearAnnotations();
            });
            return worker;
          };
          this.$id = "ace/mode/css";
        }).call(Mode.prototype);
        exports2.Mode = Mode;
      });
    }
  });

  // node_modules/brace/worker/javascript.js
  var require_javascript = __commonJS({
    "node_modules/brace/worker/javascript.js"(exports, module) {
      module.exports.id = "ace/mode/javascript_worker";
      module.exports.src = `"no use strict";!function(window){function resolveModuleId(id,paths){for(var testPath=id,tail="";testPath;){var alias=paths[testPath];if("string"==typeof alias)return alias+tail;if(alias)return alias.location.replace(/\\/*$/,"/")+(tail||alias.main||alias.name);if(alias===!1)return"";var i=testPath.lastIndexOf("/");if(-1===i)break;tail=testPath.substr(i)+tail,testPath=testPath.slice(0,i)}return id}if(!(void 0!==window.window&&window.document||window.acequire&&window.define)){window.console||(window.console=function(){var msgs=Array.prototype.slice.call(arguments,0);postMessage({type:"log",data:msgs})},window.console.error=window.console.warn=window.console.log=window.console.trace=window.console),window.window=window,window.ace=window,window.onerror=function(message,file,line,col,err){postMessage({type:"error",data:{message:message,data:err.data,file:file,line:line,col:col,stack:err.stack}})},window.normalizeModule=function(parentId,moduleName){if(-1!==moduleName.indexOf("!")){var chunks=moduleName.split("!");return window.normalizeModule(parentId,chunks[0])+"!"+window.normalizeModule(parentId,chunks[1])}if("."==moduleName.charAt(0)){var base=parentId.split("/").slice(0,-1).join("/");for(moduleName=(base?base+"/":"")+moduleName;-1!==moduleName.indexOf(".")&&previous!=moduleName;){var previous=moduleName;moduleName=moduleName.replace(/^\\.\\//,"").replace(/\\/\\.\\//,"/").replace(/[^\\/]+\\/\\.\\.\\//,"")}}return moduleName},window.acequire=function acequire(parentId,id){if(id||(id=parentId,parentId=null),!id.charAt)throw Error("worker.js acequire() accepts only (parentId, id) as arguments");id=window.normalizeModule(parentId,id);var module=window.acequire.modules[id];if(module)return module.initialized||(module.initialized=!0,module.exports=module.factory().exports),module.exports;if(!window.acequire.tlns)return console.log("unable to load "+id);var path=resolveModuleId(id,window.acequire.tlns);return".js"!=path.slice(-3)&&(path+=".js"),window.acequire.id=id,window.acequire.modules[id]={},importScripts(path),window.acequire(parentId,id)},window.acequire.modules={},window.acequire.tlns={},window.define=function(id,deps,factory){if(2==arguments.length?(factory=deps,"string"!=typeof id&&(deps=id,id=window.acequire.id)):1==arguments.length&&(factory=id,deps=[],id=window.acequire.id),"function"!=typeof factory)return window.acequire.modules[id]={exports:factory,initialized:!0},void 0;deps.length||(deps=["require","exports","module"]);var req=function(childId){return window.acequire(id,childId)};window.acequire.modules[id]={exports:{},factory:function(){var module=this,returnExports=factory.apply(this,deps.map(function(dep){switch(dep){case"require":return req;case"exports":return module.exports;case"module":return module;default:return req(dep)}}));return returnExports&&(module.exports=returnExports),module}}},window.define.amd={},acequire.tlns={},window.initBaseUrls=function(topLevelNamespaces){for(var i in topLevelNamespaces)acequire.tlns[i]=topLevelNamespaces[i]},window.initSender=function(){var EventEmitter=window.acequire("ace/lib/event_emitter").EventEmitter,oop=window.acequire("ace/lib/oop"),Sender=function(){};return function(){oop.implement(this,EventEmitter),this.callback=function(data,callbackId){postMessage({type:"call",id:callbackId,data:data})},this.emit=function(name,data){postMessage({type:"event",name:name,data:data})}}.call(Sender.prototype),new Sender};var main=window.main=null,sender=window.sender=null;window.onmessage=function(e){var msg=e.data;if(msg.event&&sender)sender._signal(msg.event,msg.data);else if(msg.command)if(main[msg.command])main[msg.command].apply(main,msg.args);else{if(!window[msg.command])throw Error("Unknown command:"+msg.command);window[msg.command].apply(window,msg.args)}else if(msg.init){window.initBaseUrls(msg.tlns),acequire("ace/lib/es5-shim"),sender=window.sender=window.initSender();var clazz=acequire(msg.module)[msg.classname];main=window.main=new clazz(sender)}}}}(this),ace.define("ace/lib/oop",["require","exports","module"],function(acequire,exports){"use strict";exports.inherits=function(ctor,superCtor){ctor.super_=superCtor,ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:!1,writable:!0,configurable:!0}})},exports.mixin=function(obj,mixin){for(var key in mixin)obj[key]=mixin[key];return obj},exports.implement=function(proto,mixin){exports.mixin(proto,mixin)}}),ace.define("ace/range",["require","exports","module"],function(acequire,exports){"use strict";var comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},Range=function(startRow,startColumn,endRow,endColumn){this.start={row:startRow,column:startColumn},this.end={row:endRow,column:endColumn}};(function(){this.isEqual=function(range){return this.start.row===range.start.row&&this.end.row===range.end.row&&this.start.column===range.start.column&&this.end.column===range.end.column},this.toString=function(){return"Range: ["+this.start.row+"/"+this.start.column+"] -> ["+this.end.row+"/"+this.end.column+"]"},this.contains=function(row,column){return 0==this.compare(row,column)},this.compareRange=function(range){var cmp,end=range.end,start=range.start;return cmp=this.compare(end.row,end.column),1==cmp?(cmp=this.compare(start.row,start.column),1==cmp?2:0==cmp?1:0):-1==cmp?-2:(cmp=this.compare(start.row,start.column),-1==cmp?-1:1==cmp?42:0)},this.comparePoint=function(p){return this.compare(p.row,p.column)},this.containsRange=function(range){return 0==this.comparePoint(range.start)&&0==this.comparePoint(range.end)},this.intersects=function(range){var cmp=this.compareRange(range);return-1==cmp||0==cmp||1==cmp},this.isEnd=function(row,column){return this.end.row==row&&this.end.column==column},this.isStart=function(row,column){return this.start.row==row&&this.start.column==column},this.setStart=function(row,column){"object"==typeof row?(this.start.column=row.column,this.start.row=row.row):(this.start.row=row,this.start.column=column)},this.setEnd=function(row,column){"object"==typeof row?(this.end.column=row.column,this.end.row=row.row):(this.end.row=row,this.end.column=column)},this.inside=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)||this.isStart(row,column)?!1:!0:!1},this.insideStart=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)?!1:!0:!1},this.insideEnd=function(row,column){return 0==this.compare(row,column)?this.isStart(row,column)?!1:!0:!1},this.compare=function(row,column){return this.isMultiLine()||row!==this.start.row?this.start.row>row?-1:row>this.end.row?1:this.start.row===row?column>=this.start.column?0:-1:this.end.row===row?this.end.column>=column?0:1:0:this.start.column>column?-1:column>this.end.column?1:0},this.compareStart=function(row,column){return this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.compareEnd=function(row,column){return this.end.row==row&&this.end.column==column?1:this.compare(row,column)},this.compareInside=function(row,column){return this.end.row==row&&this.end.column==column?1:this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.clipRows=function(firstRow,lastRow){if(this.end.row>lastRow)var end={row:lastRow+1,column:0};else if(firstRow>this.end.row)var end={row:firstRow,column:0};if(this.start.row>lastRow)var start={row:lastRow+1,column:0};else if(firstRow>this.start.row)var start={row:firstRow,column:0};return Range.fromPoints(start||this.start,end||this.end)},this.extend=function(row,column){var cmp=this.compare(row,column);if(0==cmp)return this;if(-1==cmp)var start={row:row,column:column};else var end={row:row,column:column};return Range.fromPoints(start||this.start,end||this.end)},this.isEmpty=function(){return this.start.row===this.end.row&&this.start.column===this.end.column},this.isMultiLine=function(){return this.start.row!==this.end.row},this.clone=function(){return Range.fromPoints(this.start,this.end)},this.collapseRows=function(){return 0==this.end.column?new Range(this.start.row,0,Math.max(this.start.row,this.end.row-1),0):new Range(this.start.row,0,this.end.row,0)},this.toScreenRange=function(session){var screenPosStart=session.documentToScreenPosition(this.start),screenPosEnd=session.documentToScreenPosition(this.end);return new Range(screenPosStart.row,screenPosStart.column,screenPosEnd.row,screenPosEnd.column)},this.moveBy=function(row,column){this.start.row+=row,this.start.column+=column,this.end.row+=row,this.end.column+=column}}).call(Range.prototype),Range.fromPoints=function(start,end){return new Range(start.row,start.column,end.row,end.column)},Range.comparePoints=comparePoints,Range.comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},exports.Range=Range}),ace.define("ace/apply_delta",["require","exports","module"],function(acequire,exports){"use strict";exports.applyDelta=function(docLines,delta){var row=delta.start.row,startColumn=delta.start.column,line=docLines[row]||"";switch(delta.action){case"insert":var lines=delta.lines;if(1===lines.length)docLines[row]=line.substring(0,startColumn)+delta.lines[0]+line.substring(startColumn);else{var args=[row,1].concat(delta.lines);docLines.splice.apply(docLines,args),docLines[row]=line.substring(0,startColumn)+docLines[row],docLines[row+delta.lines.length-1]+=line.substring(startColumn)}break;case"remove":var endColumn=delta.end.column,endRow=delta.end.row;row===endRow?docLines[row]=line.substring(0,startColumn)+line.substring(endColumn):docLines.splice(row,endRow-row+1,line.substring(0,startColumn)+docLines[endRow].substring(endColumn))}}}),ace.define("ace/lib/event_emitter",["require","exports","module"],function(acequire,exports){"use strict";var EventEmitter={},stopPropagation=function(){this.propagationStopped=!0},preventDefault=function(){this.defaultPrevented=!0};EventEmitter._emit=EventEmitter._dispatchEvent=function(eventName,e){this._eventRegistry||(this._eventRegistry={}),this._defaultHandlers||(this._defaultHandlers={});var listeners=this._eventRegistry[eventName]||[],defaultHandler=this._defaultHandlers[eventName];if(listeners.length||defaultHandler){"object"==typeof e&&e||(e={}),e.type||(e.type=eventName),e.stopPropagation||(e.stopPropagation=stopPropagation),e.preventDefault||(e.preventDefault=preventDefault),listeners=listeners.slice();for(var i=0;listeners.length>i&&(listeners[i](e,this),!e.propagationStopped);i++);return defaultHandler&&!e.defaultPrevented?defaultHandler(e,this):void 0}},EventEmitter._signal=function(eventName,e){var listeners=(this._eventRegistry||{})[eventName];if(listeners){listeners=listeners.slice();for(var i=0;listeners.length>i;i++)listeners[i](e,this)}},EventEmitter.once=function(eventName,callback){var _self=this;callback&&this.addEventListener(eventName,function newCallback(){_self.removeEventListener(eventName,newCallback),callback.apply(null,arguments)})},EventEmitter.setDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers||(handlers=this._defaultHandlers={_disabled_:{}}),handlers[eventName]){var old=handlers[eventName],disabled=handlers._disabled_[eventName];disabled||(handlers._disabled_[eventName]=disabled=[]),disabled.push(old);var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}handlers[eventName]=callback},EventEmitter.removeDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers){var disabled=handlers._disabled_[eventName];if(handlers[eventName]==callback)handlers[eventName],disabled&&this.setDefaultHandler(eventName,disabled.pop());else if(disabled){var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}}},EventEmitter.on=EventEmitter.addEventListener=function(eventName,callback,capturing){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];return listeners||(listeners=this._eventRegistry[eventName]=[]),-1==listeners.indexOf(callback)&&listeners[capturing?"unshift":"push"](callback),callback},EventEmitter.off=EventEmitter.removeListener=EventEmitter.removeEventListener=function(eventName,callback){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];if(listeners){var index=listeners.indexOf(callback);-1!==index&&listeners.splice(index,1)}},EventEmitter.removeAllListeners=function(eventName){this._eventRegistry&&(this._eventRegistry[eventName]=[])},exports.EventEmitter=EventEmitter}),ace.define("ace/anchor",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"],function(acequire,exports){"use strict";var oop=acequire("./lib/oop"),EventEmitter=acequire("./lib/event_emitter").EventEmitter,Anchor=exports.Anchor=function(doc,row,column){this.$onChange=this.onChange.bind(this),this.attach(doc),column===void 0?this.setPosition(row.row,row.column):this.setPosition(row,column)};(function(){function $pointsInOrder(point1,point2,equalPointsInOrder){var bColIsAfter=equalPointsInOrder?point1.column<=point2.column:point1.column<point2.column;return point1.row<point2.row||point1.row==point2.row&&bColIsAfter}function $getTransformedPoint(delta,point,moveIfEqual){var deltaIsInsert="insert"==delta.action,deltaRowShift=(deltaIsInsert?1:-1)*(delta.end.row-delta.start.row),deltaColShift=(deltaIsInsert?1:-1)*(delta.end.column-delta.start.column),deltaStart=delta.start,deltaEnd=deltaIsInsert?deltaStart:delta.end;return $pointsInOrder(point,deltaStart,moveIfEqual)?{row:point.row,column:point.column}:$pointsInOrder(deltaEnd,point,!moveIfEqual)?{row:point.row+deltaRowShift,column:point.column+(point.row==deltaEnd.row?deltaColShift:0)}:{row:deltaStart.row,column:deltaStart.column}}oop.implement(this,EventEmitter),this.getPosition=function(){return this.$clipPositionToDocument(this.row,this.column)},this.getDocument=function(){return this.document},this.$insertRight=!1,this.onChange=function(delta){if(!(delta.start.row==delta.end.row&&delta.start.row!=this.row||delta.start.row>this.row)){var point=$getTransformedPoint(delta,{row:this.row,column:this.column},this.$insertRight);this.setPosition(point.row,point.column,!0)}},this.setPosition=function(row,column,noClip){var pos;if(pos=noClip?{row:row,column:column}:this.$clipPositionToDocument(row,column),this.row!=pos.row||this.column!=pos.column){var old={row:this.row,column:this.column};this.row=pos.row,this.column=pos.column,this._signal("change",{old:old,value:pos})}},this.detach=function(){this.document.removeEventListener("change",this.$onChange)},this.attach=function(doc){this.document=doc||this.document,this.document.on("change",this.$onChange)},this.$clipPositionToDocument=function(row,column){var pos={};return row>=this.document.getLength()?(pos.row=Math.max(0,this.document.getLength()-1),pos.column=this.document.getLine(pos.row).length):0>row?(pos.row=0,pos.column=0):(pos.row=row,pos.column=Math.min(this.document.getLine(pos.row).length,Math.max(0,column))),0>column&&(pos.column=0),pos}}).call(Anchor.prototype)}),ace.define("ace/document",["require","exports","module","ace/lib/oop","ace/apply_delta","ace/lib/event_emitter","ace/range","ace/anchor"],function(acequire,exports){"use strict";var oop=acequire("./lib/oop"),applyDelta=acequire("./apply_delta").applyDelta,EventEmitter=acequire("./lib/event_emitter").EventEmitter,Range=acequire("./range").Range,Anchor=acequire("./anchor").Anchor,Document=function(textOrLines){this.$lines=[""],0===textOrLines.length?this.$lines=[""]:Array.isArray(textOrLines)?this.insertMergedLines({row:0,column:0},textOrLines):this.insert({row:0,column:0},textOrLines)};(function(){oop.implement(this,EventEmitter),this.setValue=function(text){var len=this.getLength()-1;this.remove(new Range(0,0,len,this.getLine(len).length)),this.insert({row:0,column:0},text)},this.getValue=function(){return this.getAllLines().join(this.getNewLineCharacter())},this.createAnchor=function(row,column){return new Anchor(this,row,column)},this.$split=0==="aaa".split(/a/).length?function(text){return text.replace(/\\r\\n|\\r/g,"\\n").split("\\n")}:function(text){return text.split(/\\r\\n|\\r|\\n/)},this.$detectNewLine=function(text){var match=text.match(/^.*?(\\r\\n|\\r|\\n)/m);this.$autoNewLine=match?match[1]:"\\n",this._signal("changeNewLineMode")},this.getNewLineCharacter=function(){switch(this.$newLineMode){case"windows":return"\\r\\n";case"unix":return"\\n";default:return this.$autoNewLine||"\\n"}},this.$autoNewLine="",this.$newLineMode="auto",this.setNewLineMode=function(newLineMode){this.$newLineMode!==newLineMode&&(this.$newLineMode=newLineMode,this._signal("changeNewLineMode"))},this.getNewLineMode=function(){return this.$newLineMode},this.isNewLine=function(text){return"\\r\\n"==text||"\\r"==text||"\\n"==text},this.getLine=function(row){return this.$lines[row]||""},this.getLines=function(firstRow,lastRow){return this.$lines.slice(firstRow,lastRow+1)},this.getAllLines=function(){return this.getLines(0,this.getLength())},this.getLength=function(){return this.$lines.length},this.getTextRange=function(range){return this.getLinesForRange(range).join(this.getNewLineCharacter())},this.getLinesForRange=function(range){var lines;if(range.start.row===range.end.row)lines=[this.getLine(range.start.row).substring(range.start.column,range.end.column)];else{lines=this.getLines(range.start.row,range.end.row),lines[0]=(lines[0]||"").substring(range.start.column);var l=lines.length-1;range.end.row-range.start.row==l&&(lines[l]=lines[l].substring(0,range.end.column))}return lines},this.insertLines=function(row,lines){return console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead."),this.insertFullLines(row,lines)},this.removeLines=function(firstRow,lastRow){return console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead."),this.removeFullLines(firstRow,lastRow)},this.insertNewLine=function(position){return console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead."),this.insertMergedLines(position,["",""])},this.insert=function(position,text){return 1>=this.getLength()&&this.$detectNewLine(text),this.insertMergedLines(position,this.$split(text))},this.insertInLine=function(position,text){var start=this.clippedPos(position.row,position.column),end=this.pos(position.row,position.column+text.length);return this.applyDelta({start:start,end:end,action:"insert",lines:[text]},!0),this.clonePos(end)},this.clippedPos=function(row,column){var length=this.getLength();void 0===row?row=length:0>row?row=0:row>=length&&(row=length-1,column=void 0);var line=this.getLine(row);return void 0==column&&(column=line.length),column=Math.min(Math.max(column,0),line.length),{row:row,column:column}},this.clonePos=function(pos){return{row:pos.row,column:pos.column}},this.pos=function(row,column){return{row:row,column:column}},this.$clipPosition=function(position){var length=this.getLength();return position.row>=length?(position.row=Math.max(0,length-1),position.column=this.getLine(length-1).length):(position.row=Math.max(0,position.row),position.column=Math.min(Math.max(position.column,0),this.getLine(position.row).length)),position},this.insertFullLines=function(row,lines){row=Math.min(Math.max(row,0),this.getLength());var column=0;this.getLength()>row?(lines=lines.concat([""]),column=0):(lines=[""].concat(lines),row--,column=this.$lines[row].length),this.insertMergedLines({row:row,column:column},lines)},this.insertMergedLines=function(position,lines){var start=this.clippedPos(position.row,position.column),end={row:start.row+lines.length-1,column:(1==lines.length?start.column:0)+lines[lines.length-1].length};return this.applyDelta({start:start,end:end,action:"insert",lines:lines}),this.clonePos(end)},this.remove=function(range){var start=this.clippedPos(range.start.row,range.start.column),end=this.clippedPos(range.end.row,range.end.column);return this.applyDelta({start:start,end:end,action:"remove",lines:this.getLinesForRange({start:start,end:end})}),this.clonePos(start)},this.removeInLine=function(row,startColumn,endColumn){var start=this.clippedPos(row,startColumn),end=this.clippedPos(row,endColumn);return this.applyDelta({start:start,end:end,action:"remove",lines:this.getLinesForRange({start:start,end:end})},!0),this.clonePos(start)},this.removeFullLines=function(firstRow,lastRow){firstRow=Math.min(Math.max(0,firstRow),this.getLength()-1),lastRow=Math.min(Math.max(0,lastRow),this.getLength()-1);var deleteFirstNewLine=lastRow==this.getLength()-1&&firstRow>0,deleteLastNewLine=this.getLength()-1>lastRow,startRow=deleteFirstNewLine?firstRow-1:firstRow,startCol=deleteFirstNewLine?this.getLine(startRow).length:0,endRow=deleteLastNewLine?lastRow+1:lastRow,endCol=deleteLastNewLine?0:this.getLine(endRow).length,range=new Range(startRow,startCol,endRow,endCol),deletedLines=this.$lines.slice(firstRow,lastRow+1);return this.applyDelta({start:range.start,end:range.end,action:"remove",lines:this.getLinesForRange(range)}),deletedLines},this.removeNewLine=function(row){this.getLength()-1>row&&row>=0&&this.applyDelta({start:this.pos(row,this.getLine(row).length),end:this.pos(row+1,0),action:"remove",lines:["",""]})},this.replace=function(range,text){if(range instanceof Range||(range=Range.fromPoints(range.start,range.end)),0===text.length&&range.isEmpty())return range.start;if(text==this.getTextRange(range))return range.end;this.remove(range);var end;return end=text?this.insert(range.start,text):range.start},this.applyDeltas=function(deltas){for(var i=0;deltas.length>i;i++)this.applyDelta(deltas[i])},this.revertDeltas=function(deltas){for(var i=deltas.length-1;i>=0;i--)this.revertDelta(deltas[i])},this.applyDelta=function(delta,doNotValidate){var isInsert="insert"==delta.action;(isInsert?1>=delta.lines.length&&!delta.lines[0]:!Range.comparePoints(delta.start,delta.end))||(isInsert&&delta.lines.length>2e4&&this.$splitAndapplyLargeDelta(delta,2e4),applyDelta(this.$lines,delta,doNotValidate),this._signal("change",delta))},this.$splitAndapplyLargeDelta=function(delta,MAX){for(var lines=delta.lines,l=lines.length,row=delta.start.row,column=delta.start.column,from=0,to=0;;){from=to,to+=MAX-1;var chunk=lines.slice(from,to);if(to>l){delta.lines=chunk,delta.start.row=row+from,delta.start.column=column;break}chunk.push(""),this.applyDelta({start:this.pos(row+from,column),end:this.pos(row+to,column=0),action:delta.action,lines:chunk},!0)}},this.revertDelta=function(delta){this.applyDelta({start:this.clonePos(delta.start),end:this.clonePos(delta.end),action:"insert"==delta.action?"remove":"insert",lines:delta.lines.slice()})},this.indexToPosition=function(index,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,i=startRow||0,l=lines.length;l>i;i++)if(index-=lines[i].length+newlineLength,0>index)return{row:i,column:index+lines[i].length+newlineLength};return{row:l-1,column:lines[l-1].length}},this.positionToIndex=function(pos,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,index=0,row=Math.min(pos.row,lines.length),i=startRow||0;row>i;++i)index+=lines[i].length+newlineLength;return index+pos.column}}).call(Document.prototype),exports.Document=Document}),ace.define("ace/lib/lang",["require","exports","module"],function(acequire,exports){"use strict";exports.last=function(a){return a[a.length-1]},exports.stringReverse=function(string){return string.split("").reverse().join("")},exports.stringRepeat=function(string,count){for(var result="";count>0;)1&count&&(result+=string),(count>>=1)&&(string+=string);return result};var trimBeginRegexp=/^\\s\\s*/,trimEndRegexp=/\\s\\s*$/;exports.stringTrimLeft=function(string){return string.replace(trimBeginRegexp,"")},exports.stringTrimRight=function(string){return string.replace(trimEndRegexp,"")},exports.copyObject=function(obj){var copy={};for(var key in obj)copy[key]=obj[key];return copy},exports.copyArray=function(array){for(var copy=[],i=0,l=array.length;l>i;i++)copy[i]=array[i]&&"object"==typeof array[i]?this.copyObject(array[i]):array[i];return copy},exports.deepCopy=function deepCopy(obj){if("object"!=typeof obj||!obj)return obj;var copy;if(Array.isArray(obj)){copy=[];for(var key=0;obj.length>key;key++)copy[key]=deepCopy(obj[key]);return copy}if("[object Object]"!==Object.prototype.toString.call(obj))return obj;copy={};for(var key in obj)copy[key]=deepCopy(obj[key]);return copy},exports.arrayToMap=function(arr){for(var map={},i=0;arr.length>i;i++)map[arr[i]]=1;return map},exports.createMap=function(props){var map=Object.create(null);for(var i in props)map[i]=props[i];return map},exports.arrayRemove=function(array,value){for(var i=0;array.length>=i;i++)value===array[i]&&array.splice(i,1)},exports.escapeRegExp=function(str){return str.replace(/([.*+?^\${}()|[\\]\\/\\\\])/g,"\\\\$1")},exports.escapeHTML=function(str){return str.replace(/&/g,"&#38;").replace(/"/g,"&#34;").replace(/'/g,"&#39;").replace(/</g,"&#60;")},exports.getMatchOffsets=function(string,regExp){var matches=[];return string.replace(regExp,function(str){matches.push({offset:arguments[arguments.length-2],length:str.length})}),matches},exports.deferredCall=function(fcn){var timer=null,callback=function(){timer=null,fcn()},deferred=function(timeout){return deferred.cancel(),timer=setTimeout(callback,timeout||0),deferred};return deferred.schedule=deferred,deferred.call=function(){return this.cancel(),fcn(),deferred},deferred.cancel=function(){return clearTimeout(timer),timer=null,deferred},deferred.isPending=function(){return timer},deferred},exports.delayedCall=function(fcn,defaultTimeout){var timer=null,callback=function(){timer=null,fcn()},_self=function(timeout){null==timer&&(timer=setTimeout(callback,timeout||defaultTimeout))};return _self.delay=function(timeout){timer&&clearTimeout(timer),timer=setTimeout(callback,timeout||defaultTimeout)},_self.schedule=_self,_self.call=function(){this.cancel(),fcn()},_self.cancel=function(){timer&&clearTimeout(timer),timer=null},_self.isPending=function(){return timer},_self}}),ace.define("ace/worker/mirror",["require","exports","module","ace/range","ace/document","ace/lib/lang"],function(acequire,exports){"use strict";acequire("../range").Range;var Document=acequire("../document").Document,lang=acequire("../lib/lang"),Mirror=exports.Mirror=function(sender){this.sender=sender;var doc=this.doc=new Document(""),deferredUpdate=this.deferredUpdate=lang.delayedCall(this.onUpdate.bind(this)),_self=this;sender.on("change",function(e){var data=e.data;if(data[0].start)doc.applyDeltas(data);else for(var i=0;data.length>i;i+=2){if(Array.isArray(data[i+1]))var d={action:"insert",start:data[i],lines:data[i+1]};else var d={action:"remove",start:data[i],end:data[i+1]};doc.applyDelta(d,!0)}return _self.$timeout?deferredUpdate.schedule(_self.$timeout):(_self.onUpdate(),void 0)})};(function(){this.$timeout=500,this.setTimeout=function(timeout){this.$timeout=timeout},this.setValue=function(value){this.doc.setValue(value),this.deferredUpdate.schedule(this.$timeout)},this.getValue=function(callbackId){this.sender.callback(this.doc.getValue(),callbackId)},this.onUpdate=function(){},this.isPending=function(){return this.deferredUpdate.isPending()}}).call(Mirror.prototype)}),ace.define("ace/mode/javascript/jshint",["require","exports","module"],function(acequire,exports,module){module.exports=function outer(modules,cache,entry){function newRequire(name,jumped){if(!cache[name]){if(!modules[name]){var currentRequire="function"==typeof acequire&&acequire;if(!jumped&&currentRequire)return currentRequire(name,!0);if(previousRequire)return previousRequire(name,!0);var err=Error("Cannot find module '"+name+"'");throw err.code="MODULE_NOT_FOUND",err}var m=cache[name]={exports:{}};modules[name][0].call(m.exports,function(x){var id=modules[name][1][x];return newRequire(id?id:x)},m,m.exports,outer,modules,cache,entry)}return cache[name].exports}for(var previousRequire="function"==typeof acequire&&acequire,i=0;entry.length>i;i++)newRequire(entry[i]);return newRequire(entry[0])}({"/node_modules/browserify/node_modules/events/events.js":[function(_dereq_,module){function EventEmitter(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}function isFunction(arg){return"function"==typeof arg}function isNumber(arg){return"number"==typeof arg}function isObject(arg){return"object"==typeof arg&&null!==arg}function isUndefined(arg){return void 0===arg}module.exports=EventEmitter,EventEmitter.EventEmitter=EventEmitter,EventEmitter.prototype._events=void 0,EventEmitter.prototype._maxListeners=void 0,EventEmitter.defaultMaxListeners=10,EventEmitter.prototype.setMaxListeners=function(n){if(!isNumber(n)||0>n||isNaN(n))throw TypeError("n must be a positive number");return this._maxListeners=n,this},EventEmitter.prototype.emit=function(type){var er,handler,len,args,i,listeners;if(this._events||(this._events={}),"error"===type&&(!this._events.error||isObject(this._events.error)&&!this._events.error.length)){if(er=arguments[1],er instanceof Error)throw er;throw TypeError('Uncaught, unspecified "error" event.')}if(handler=this._events[type],isUndefined(handler))return!1;if(isFunction(handler))switch(arguments.length){case 1:handler.call(this);break;case 2:handler.call(this,arguments[1]);break;case 3:handler.call(this,arguments[1],arguments[2]);break;default:for(len=arguments.length,args=Array(len-1),i=1;len>i;i++)args[i-1]=arguments[i];handler.apply(this,args)}else if(isObject(handler)){for(len=arguments.length,args=Array(len-1),i=1;len>i;i++)args[i-1]=arguments[i];for(listeners=handler.slice(),len=listeners.length,i=0;len>i;i++)listeners[i].apply(this,args)}return!0},EventEmitter.prototype.addListener=function(type,listener){var m;if(!isFunction(listener))throw TypeError("listener must be a function");if(this._events||(this._events={}),this._events.newListener&&this.emit("newListener",type,isFunction(listener.listener)?listener.listener:listener),this._events[type]?isObject(this._events[type])?this._events[type].push(listener):this._events[type]=[this._events[type],listener]:this._events[type]=listener,isObject(this._events[type])&&!this._events[type].warned){var m;m=isUndefined(this._maxListeners)?EventEmitter.defaultMaxListeners:this._maxListeners,m&&m>0&&this._events[type].length>m&&(this._events[type].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[type].length),"function"==typeof console.trace&&console.trace())}return this},EventEmitter.prototype.on=EventEmitter.prototype.addListener,EventEmitter.prototype.once=function(type,listener){function g(){this.removeListener(type,g),fired||(fired=!0,listener.apply(this,arguments))}if(!isFunction(listener))throw TypeError("listener must be a function");var fired=!1;return g.listener=listener,this.on(type,g),this},EventEmitter.prototype.removeListener=function(type,listener){var list,position,length,i;if(!isFunction(listener))throw TypeError("listener must be a function");if(!this._events||!this._events[type])return this;if(list=this._events[type],length=list.length,position=-1,list===listener||isFunction(list.listener)&&list.listener===listener)delete this._events[type],this._events.removeListener&&this.emit("removeListener",type,listener);else if(isObject(list)){for(i=length;i-->0;)if(list[i]===listener||list[i].listener&&list[i].listener===listener){position=i;break}if(0>position)return this;1===list.length?(list.length=0,delete this._events[type]):list.splice(position,1),this._events.removeListener&&this.emit("removeListener",type,listener)}return this},EventEmitter.prototype.removeAllListeners=function(type){var key,listeners;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[type]&&delete this._events[type],this;if(0===arguments.length){for(key in this._events)"removeListener"!==key&&this.removeAllListeners(key);return this.removeAllListeners("removeListener"),this._events={},this
}if(listeners=this._events[type],isFunction(listeners))this.removeListener(type,listeners);else for(;listeners.length;)this.removeListener(type,listeners[listeners.length-1]);return delete this._events[type],this},EventEmitter.prototype.listeners=function(type){var ret;return ret=this._events&&this._events[type]?isFunction(this._events[type])?[this._events[type]]:this._events[type].slice():[]},EventEmitter.listenerCount=function(emitter,type){var ret;return ret=emitter._events&&emitter._events[type]?isFunction(emitter._events[type])?1:emitter._events[type].length:0}},{}],"/node_modules/jshint/data/ascii-identifier-data.js":[function(_dereq_,module){for(var identifierStartTable=[],i=0;128>i;i++)identifierStartTable[i]=36===i||i>=65&&90>=i||95===i||i>=97&&122>=i;for(var identifierPartTable=[],i=0;128>i;i++)identifierPartTable[i]=identifierStartTable[i]||i>=48&&57>=i;module.exports={asciiIdentifierStartTable:identifierStartTable,asciiIdentifierPartTable:identifierPartTable}},{}],"/node_modules/jshint/lodash.js":[function(_dereq_,module,exports){(function(global){(function(){function baseFindIndex(array,predicate,fromRight){for(var length=array.length,index=fromRight?length:-1;fromRight?index--:length>++index;)if(predicate(array[index],index,array))return index;return-1}function baseIndexOf(array,value,fromIndex){if(value!==value)return indexOfNaN(array,fromIndex);for(var index=fromIndex-1,length=array.length;length>++index;)if(array[index]===value)return index;return-1}function baseIsFunction(value){return"function"==typeof value||!1}function baseToString(value){return"string"==typeof value?value:null==value?"":value+""}function indexOfNaN(array,fromIndex,fromRight){for(var length=array.length,index=fromIndex+(fromRight?0:-1);fromRight?index--:length>++index;){var other=array[index];if(other!==other)return index}return-1}function isObjectLike(value){return!!value&&"object"==typeof value}function lodash(){}function arrayCopy(source,array){var index=-1,length=source.length;for(array||(array=Array(length));length>++index;)array[index]=source[index];return array}function arrayEach(array,iteratee){for(var index=-1,length=array.length;length>++index&&iteratee(array[index],index,array)!==!1;);return array}function arrayFilter(array,predicate){for(var index=-1,length=array.length,resIndex=-1,result=[];length>++index;){var value=array[index];predicate(value,index,array)&&(result[++resIndex]=value)}return result}function arrayMap(array,iteratee){for(var index=-1,length=array.length,result=Array(length);length>++index;)result[index]=iteratee(array[index],index,array);return result}function arrayMax(array){for(var index=-1,length=array.length,result=NEGATIVE_INFINITY;length>++index;){var value=array[index];value>result&&(result=value)}return result}function arraySome(array,predicate){for(var index=-1,length=array.length;length>++index;)if(predicate(array[index],index,array))return!0;return!1}function assignWith(object,source,customizer){var props=keys(source);push.apply(props,getSymbols(source));for(var index=-1,length=props.length;length>++index;){var key=props[index],value=object[key],result=customizer(value,source[key],key,object,source);(result===result?result===value:value!==value)&&(value!==undefined||key in object)||(object[key]=result)}return object}function baseCopy(source,props,object){object||(object={});for(var index=-1,length=props.length;length>++index;){var key=props[index];object[key]=source[key]}return object}function baseCallback(func,thisArg,argCount){var type=typeof func;return"function"==type?thisArg===undefined?func:bindCallback(func,thisArg,argCount):null==func?identity:"object"==type?baseMatches(func):thisArg===undefined?property(func):baseMatchesProperty(func,thisArg)}function baseClone(value,isDeep,customizer,key,object,stackA,stackB){var result;if(customizer&&(result=object?customizer(value,key,object):customizer(value)),result!==undefined)return result;if(!isObject(value))return value;var isArr=isArray(value);if(isArr){if(result=initCloneArray(value),!isDeep)return arrayCopy(value,result)}else{var tag=objToString.call(value),isFunc=tag==funcTag;if(tag!=objectTag&&tag!=argsTag&&(!isFunc||object))return cloneableTags[tag]?initCloneByTag(value,tag,isDeep):object?value:{};if(result=initCloneObject(isFunc?{}:value),!isDeep)return baseAssign(result,value)}stackA||(stackA=[]),stackB||(stackB=[]);for(var length=stackA.length;length--;)if(stackA[length]==value)return stackB[length];return stackA.push(value),stackB.push(result),(isArr?arrayEach:baseForOwn)(value,function(subValue,key){result[key]=baseClone(subValue,isDeep,customizer,key,value,stackA,stackB)}),result}function baseFilter(collection,predicate){var result=[];return baseEach(collection,function(value,index,collection){predicate(value,index,collection)&&result.push(value)}),result}function baseForIn(object,iteratee){return baseFor(object,iteratee,keysIn)}function baseForOwn(object,iteratee){return baseFor(object,iteratee,keys)}function baseGet(object,path,pathKey){if(null!=object){pathKey!==undefined&&pathKey in toObject(object)&&(path=[pathKey]);for(var index=-1,length=path.length;null!=object&&length>++index;)var result=object=object[path[index]];return result}}function baseIsEqual(value,other,customizer,isLoose,stackA,stackB){if(value===other)return 0!==value||1/value==1/other;var valType=typeof value,othType=typeof other;return"function"!=valType&&"object"!=valType&&"function"!=othType&&"object"!=othType||null==value||null==other?value!==value&&other!==other:baseIsEqualDeep(value,other,baseIsEqual,customizer,isLoose,stackA,stackB)}function baseIsEqualDeep(object,other,equalFunc,customizer,isLoose,stackA,stackB){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=arrayTag,othTag=arrayTag;objIsArr||(objTag=objToString.call(object),objTag==argsTag?objTag=objectTag:objTag!=objectTag&&(objIsArr=isTypedArray(object))),othIsArr||(othTag=objToString.call(other),othTag==argsTag?othTag=objectTag:othTag!=objectTag&&(othIsArr=isTypedArray(other)));var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&!objIsArr&&!objIsObj)return equalByTag(object,other,objTag);if(!isLoose){var valWrapped=objIsObj&&hasOwnProperty.call(object,"__wrapped__"),othWrapped=othIsObj&&hasOwnProperty.call(other,"__wrapped__");if(valWrapped||othWrapped)return equalFunc(valWrapped?object.value():object,othWrapped?other.value():other,customizer,isLoose,stackA,stackB)}if(!isSameTag)return!1;stackA||(stackA=[]),stackB||(stackB=[]);for(var length=stackA.length;length--;)if(stackA[length]==object)return stackB[length]==other;stackA.push(object),stackB.push(other);var result=(objIsArr?equalArrays:equalObjects)(object,other,equalFunc,customizer,isLoose,stackA,stackB);return stackA.pop(),stackB.pop(),result}function baseIsMatch(object,props,values,strictCompareFlags,customizer){for(var index=-1,length=props.length,noCustomizer=!customizer;length>++index;)if(noCustomizer&&strictCompareFlags[index]?values[index]!==object[props[index]]:!(props[index]in object))return!1;for(index=-1;length>++index;){var key=props[index],objValue=object[key],srcValue=values[index];if(noCustomizer&&strictCompareFlags[index])var result=objValue!==undefined||key in object;else result=customizer?customizer(objValue,srcValue,key):undefined,result===undefined&&(result=baseIsEqual(srcValue,objValue,customizer,!0));if(!result)return!1}return!0}function baseMatches(source){var props=keys(source),length=props.length;if(!length)return constant(!0);if(1==length){var key=props[0],value=source[key];if(isStrictComparable(value))return function(object){return null==object?!1:object[key]===value&&(value!==undefined||key in toObject(object))}}for(var values=Array(length),strictCompareFlags=Array(length);length--;)value=source[props[length]],values[length]=value,strictCompareFlags[length]=isStrictComparable(value);return function(object){return null!=object&&baseIsMatch(toObject(object),props,values,strictCompareFlags)}}function baseMatchesProperty(path,value){var isArr=isArray(path),isCommon=isKey(path)&&isStrictComparable(value),pathKey=path+"";return path=toPath(path),function(object){if(null==object)return!1;var key=pathKey;if(object=toObject(object),!(!isArr&&isCommon||key in object)){if(object=1==path.length?object:baseGet(object,baseSlice(path,0,-1)),null==object)return!1;key=last(path),object=toObject(object)}return object[key]===value?value!==undefined||key in object:baseIsEqual(value,object[key],null,!0)}}function baseMerge(object,source,customizer,stackA,stackB){if(!isObject(object))return object;var isSrcArr=isLength(source.length)&&(isArray(source)||isTypedArray(source));if(!isSrcArr){var props=keys(source);push.apply(props,getSymbols(source))}return arrayEach(props||source,function(srcValue,key){if(props&&(key=srcValue,srcValue=source[key]),isObjectLike(srcValue))stackA||(stackA=[]),stackB||(stackB=[]),baseMergeDeep(object,source,key,baseMerge,customizer,stackA,stackB);else{var value=object[key],result=customizer?customizer(value,srcValue,key,object,source):undefined,isCommon=result===undefined;isCommon&&(result=srcValue),!isSrcArr&&result===undefined||!isCommon&&(result===result?result===value:value!==value)||(object[key]=result)}}),object}function baseMergeDeep(object,source,key,mergeFunc,customizer,stackA,stackB){for(var length=stackA.length,srcValue=source[key];length--;)if(stackA[length]==srcValue)return object[key]=stackB[length],undefined;var value=object[key],result=customizer?customizer(value,srcValue,key,object,source):undefined,isCommon=result===undefined;isCommon&&(result=srcValue,isLength(srcValue.length)&&(isArray(srcValue)||isTypedArray(srcValue))?result=isArray(value)?value:getLength(value)?arrayCopy(value):[]:isPlainObject(srcValue)||isArguments(srcValue)?result=isArguments(value)?toPlainObject(value):isPlainObject(value)?value:{}:isCommon=!1),stackA.push(srcValue),stackB.push(result),isCommon?object[key]=mergeFunc(result,srcValue,customizer,stackA,stackB):(result===result?result!==value:value===value)&&(object[key]=result)}function baseProperty(key){return function(object){return null==object?undefined:object[key]}}function basePropertyDeep(path){var pathKey=path+"";return path=toPath(path),function(object){return baseGet(object,path,pathKey)}}function baseSlice(array,start,end){var index=-1,length=array.length;start=null==start?0:+start||0,0>start&&(start=-start>length?0:length+start),end=end===undefined||end>length?length:+end||0,0>end&&(end+=length),length=start>end?0:end-start>>>0,start>>>=0;for(var result=Array(length);length>++index;)result[index]=array[index+start];return result}function baseSome(collection,predicate){var result;return baseEach(collection,function(value,index,collection){return result=predicate(value,index,collection),!result}),!!result}function baseValues(object,props){for(var index=-1,length=props.length,result=Array(length);length>++index;)result[index]=object[props[index]];return result}function binaryIndex(array,value,retHighest){var low=0,high=array?array.length:low;if("number"==typeof value&&value===value&&HALF_MAX_ARRAY_LENGTH>=high){for(;high>low;){var mid=low+high>>>1,computed=array[mid];(retHighest?value>=computed:value>computed)?low=mid+1:high=mid}return high}return binaryIndexBy(array,value,identity,retHighest)}function binaryIndexBy(array,value,iteratee,retHighest){value=iteratee(value);for(var low=0,high=array?array.length:0,valIsNaN=value!==value,valIsUndef=value===undefined;high>low;){var mid=floor((low+high)/2),computed=iteratee(array[mid]),isReflexive=computed===computed;if(valIsNaN)var setLow=isReflexive||retHighest;else setLow=valIsUndef?isReflexive&&(retHighest||computed!==undefined):retHighest?value>=computed:value>computed;setLow?low=mid+1:high=mid}return nativeMin(high,MAX_ARRAY_INDEX)}function bindCallback(func,thisArg,argCount){if("function"!=typeof func)return identity;if(thisArg===undefined)return func;switch(argCount){case 1:return function(value){return func.call(thisArg,value)};case 3:return function(value,index,collection){return func.call(thisArg,value,index,collection)};case 4:return function(accumulator,value,index,collection){return func.call(thisArg,accumulator,value,index,collection)};case 5:return function(value,other,key,object,source){return func.call(thisArg,value,other,key,object,source)}}return function(){return func.apply(thisArg,arguments)}}function bufferClone(buffer){return bufferSlice.call(buffer,0)}function createAssigner(assigner){return restParam(function(object,sources){var index=-1,length=null==object?0:sources.length,customizer=length>2&&sources[length-2],guard=length>2&&sources[2],thisArg=length>1&&sources[length-1];for("function"==typeof customizer?(customizer=bindCallback(customizer,thisArg,5),length-=2):(customizer="function"==typeof thisArg?thisArg:null,length-=customizer?1:0),guard&&isIterateeCall(sources[0],sources[1],guard)&&(customizer=3>length?null:customizer,length=1);length>++index;){var source=sources[index];source&&assigner(object,source,customizer)}return object})}function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){var length=collection?getLength(collection):0;if(!isLength(length))return eachFunc(collection,iteratee);for(var index=fromRight?length:-1,iterable=toObject(collection);(fromRight?index--:length>++index)&&iteratee(iterable[index],index,iterable)!==!1;);return collection}}function createBaseFor(fromRight){return function(object,iteratee,keysFunc){for(var iterable=toObject(object),props=keysFunc(object),length=props.length,index=fromRight?length:-1;fromRight?index--:length>++index;){var key=props[index];if(iteratee(iterable[key],key,iterable)===!1)break}return object}}function createFindIndex(fromRight){return function(array,predicate,thisArg){return array&&array.length?(predicate=getCallback(predicate,thisArg,3),baseFindIndex(array,predicate,fromRight)):-1}}function createForEach(arrayFunc,eachFunc){return function(collection,iteratee,thisArg){return"function"==typeof iteratee&&thisArg===undefined&&isArray(collection)?arrayFunc(collection,iteratee):eachFunc(collection,bindCallback(iteratee,thisArg,3))}}function equalArrays(array,other,equalFunc,customizer,isLoose,stackA,stackB){var index=-1,arrLength=array.length,othLength=other.length,result=!0;if(arrLength!=othLength&&!(isLoose&&othLength>arrLength))return!1;for(;result&&arrLength>++index;){var arrValue=array[index],othValue=other[index];if(result=undefined,customizer&&(result=isLoose?customizer(othValue,arrValue,index):customizer(arrValue,othValue,index)),result===undefined)if(isLoose)for(var othIndex=othLength;othIndex--&&(othValue=other[othIndex],!(result=arrValue&&arrValue===othValue||equalFunc(arrValue,othValue,customizer,isLoose,stackA,stackB))););else result=arrValue&&arrValue===othValue||equalFunc(arrValue,othValue,customizer,isLoose,stackA,stackB)}return!!result}function equalByTag(object,other,tag){switch(tag){case boolTag:case dateTag:return+object==+other;case errorTag:return object.name==other.name&&object.message==other.message;case numberTag:return object!=+object?other!=+other:0==object?1/object==1/other:object==+other;case regexpTag:case stringTag:return object==other+""}return!1}function equalObjects(object,other,equalFunc,customizer,isLoose,stackA,stackB){var objProps=keys(object),objLength=objProps.length,othProps=keys(other),othLength=othProps.length;if(objLength!=othLength&&!isLoose)return!1;for(var skipCtor=isLoose,index=-1;objLength>++index;){var key=objProps[index],result=isLoose?key in other:hasOwnProperty.call(other,key);if(result){var objValue=object[key],othValue=other[key];result=undefined,customizer&&(result=isLoose?customizer(othValue,objValue,key):customizer(objValue,othValue,key)),result===undefined&&(result=objValue&&objValue===othValue||equalFunc(objValue,othValue,customizer,isLoose,stackA,stackB))}if(!result)return!1;skipCtor||(skipCtor="constructor"==key)}if(!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;if(objCtor!=othCtor&&"constructor"in object&&"constructor"in other&&!("function"==typeof objCtor&&objCtor instanceof objCtor&&"function"==typeof othCtor&&othCtor instanceof othCtor))return!1}return!0}function getCallback(func,thisArg,argCount){var result=lodash.callback||callback;return result=result===callback?baseCallback:result,argCount?result(func,thisArg,argCount):result}function getIndexOf(collection,target,fromIndex){var result=lodash.indexOf||indexOf;return result=result===indexOf?baseIndexOf:result,collection?result(collection,target,fromIndex):result}function initCloneArray(array){var length=array.length,result=new array.constructor(length);return length&&"string"==typeof array[0]&&hasOwnProperty.call(array,"index")&&(result.index=array.index,result.input=array.input),result}function initCloneObject(object){var Ctor=object.constructor;return"function"==typeof Ctor&&Ctor instanceof Ctor||(Ctor=Object),new Ctor}function initCloneByTag(object,tag,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return bufferClone(object);case boolTag:case dateTag:return new Ctor(+object);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:var buffer=object.buffer;return new Ctor(isDeep?bufferClone(buffer):buffer,object.byteOffset,object.length);case numberTag:case stringTag:return new Ctor(object);case regexpTag:var result=new Ctor(object.source,reFlags.exec(object));result.lastIndex=object.lastIndex}return result}function isIndex(value,length){return value=+value,length=null==length?MAX_SAFE_INTEGER:length,value>-1&&0==value%1&&length>value}function isIterateeCall(value,index,object){if(!isObject(object))return!1;var type=typeof index;if("number"==type)var length=getLength(object),prereq=isLength(length)&&isIndex(index,length);else prereq="string"==type&&index in object;if(prereq){var other=object[index];return value===value?value===other:other!==other}return!1}function isKey(value,object){var type=typeof value;if("string"==type&&reIsPlainProp.test(value)||"number"==type)return!0;if(isArray(value))return!1;var result=!reIsDeepProp.test(value);return result||null!=object&&value in toObject(object)}function isLength(value){return"number"==typeof value&&value>-1&&0==value%1&&MAX_SAFE_INTEGER>=value}function isStrictComparable(value){return value===value&&(0===value?1/value>0:!isObject(value))}function shimIsPlainObject(value){var Ctor;if(lodash.support,!isObjectLike(value)||objToString.call(value)!=objectTag||!hasOwnProperty.call(value,"constructor")&&(Ctor=value.constructor,"function"==typeof Ctor&&!(Ctor instanceof Ctor)))return!1;var result;return baseForIn(value,function(subValue,key){result=key}),result===undefined||hasOwnProperty.call(value,result)}function shimKeys(object){for(var props=keysIn(object),propsLength=props.length,length=propsLength&&object.length,support=lodash.support,allowIndexes=length&&isLength(length)&&(isArray(object)||support.nonEnumArgs&&isArguments(object)),index=-1,result=[];propsLength>++index;){var key=props[index];(allowIndexes&&isIndex(key,length)||hasOwnProperty.call(object,key))&&result.push(key)}return result}function toObject(value){return isObject(value)?value:Object(value)}function toPath(value){if(isArray(value))return value;var result=[];return baseToString(value).replace(rePropName,function(match,number,quote,string){result.push(quote?string.replace(reEscapeChar,"$1"):number||match)}),result}function indexOf(array,value,fromIndex){var length=array?array.length:0;if(!length)return-1;if("number"==typeof fromIndex)fromIndex=0>fromIndex?nativeMax(length+fromIndex,0):fromIndex;else if(fromIndex){var index=binaryIndex(array,value),other=array[index];return(value===value?value===other:other!==other)?index:-1}return baseIndexOf(array,value,fromIndex||0)}function last(array){var length=array?array.length:0;return length?array[length-1]:undefined}function slice(array,start,end){var length=array?array.length:0;return length?(end&&"number"!=typeof end&&isIterateeCall(array,start,end)&&(start=0,end=length),baseSlice(array,start,end)):[]}function unzip(array){for(var index=-1,length=(array&&array.length&&arrayMax(arrayMap(array,getLength)))>>>0,result=Array(length);length>++index;)result[index]=arrayMap(array,baseProperty(index));return result}function includes(collection,target,fromIndex,guard){var length=collection?getLength(collection):0;return isLength(length)||(collection=values(collection),length=collection.length),length?(fromIndex="number"!=typeof fromIndex||guard&&isIterateeCall(target,fromIndex,guard)?0:0>fromIndex?nativeMax(length+fromIndex,0):fromIndex||0,"string"==typeof collection||!isArray(collection)&&isString(collection)?length>fromIndex&&collection.indexOf(target,fromIndex)>-1:getIndexOf(collection,target,fromIndex)>-1):!1}function reject(collection,predicate,thisArg){var func=isArray(collection)?arrayFilter:baseFilter;return predicate=getCallback(predicate,thisArg,3),func(collection,function(value,index,collection){return!predicate(value,index,collection)})}function some(collection,predicate,thisArg){var func=isArray(collection)?arraySome:baseSome;return thisArg&&isIterateeCall(collection,predicate,thisArg)&&(predicate=null),("function"!=typeof predicate||thisArg!==undefined)&&(predicate=getCallback(predicate,thisArg,3)),func(collection,predicate)}function restParam(func,start){if("function"!=typeof func)throw new TypeError(FUNC_ERROR_TEXT);return start=nativeMax(start===undefined?func.length-1:+start||0,0),function(){for(var args=arguments,index=-1,length=nativeMax(args.length-start,0),rest=Array(length);length>++index;)rest[index]=args[start+index];switch(start){case 0:return func.call(this,rest);case 1:return func.call(this,args[0],rest);case 2:return func.call(this,args[0],args[1],rest)}var otherArgs=Array(start+1);for(index=-1;start>++index;)otherArgs[index]=args[index];return otherArgs[start]=rest,func.apply(this,otherArgs)}}function clone(value,isDeep,customizer,thisArg){return isDeep&&"boolean"!=typeof isDeep&&isIterateeCall(value,isDeep,customizer)?isDeep=!1:"function"==typeof isDeep&&(thisArg=customizer,customizer=isDeep,isDeep=!1),customizer="function"==typeof customizer&&bindCallback(customizer,thisArg,1),baseClone(value,isDeep,customizer)}function isArguments(value){var length=isObjectLike(value)?value.length:undefined;return isLength(length)&&objToString.call(value)==argsTag}function isEmpty(value){if(null==value)return!0;var length=getLength(value);return isLength(length)&&(isArray(value)||isString(value)||isArguments(value)||isObjectLike(value)&&isFunction(value.splice))?!length:!keys(value).length}function isObject(value){var type=typeof value;return"function"==type||!!value&&"object"==type}function isNative(value){return null==value?!1:objToString.call(value)==funcTag?reIsNative.test(fnToString.call(value)):isObjectLike(value)&&reIsHostCtor.test(value)}function isNumber(value){return"number"==typeof value||isObjectLike(value)&&objToString.call(value)==numberTag}function isString(value){return"string"==typeof value||isObjectLike(value)&&objToString.call(value)==stringTag}function isTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[objToString.call(value)]}function toPlainObject(value){return baseCopy(value,keysIn(value))}function has(object,path){if(null==object)return!1;var result=hasOwnProperty.call(object,path);return result||isKey(path)||(path=toPath(path),object=1==path.length?object:baseGet(object,baseSlice(path,0,-1)),path=last(path),result=null!=object&&hasOwnProperty.call(object,path)),result}function keysIn(object){if(null==object)return[];isObject(object)||(object=Object(object));var length=object.length;length=length&&isLength(length)&&(isArray(object)||support.nonEnumArgs&&isArguments(object))&&length||0;for(var Ctor=object.constructor,index=-1,isProto="function"==typeof Ctor&&Ctor.prototype===object,result=Array(length),skipIndexes=length>0;length>++index;)result[index]=index+"";for(var key in object)skipIndexes&&isIndex(key,length)||"constructor"==key&&(isProto||!hasOwnProperty.call(object,key))||result.push(key);return result}function values(object){return baseValues(object,keys(object))}function escapeRegExp(string){return string=baseToString(string),string&&reHasRegExpChars.test(string)?string.replace(reRegExpChars,"\\\\$&"):string}function callback(func,thisArg,guard){return guard&&isIterateeCall(func,thisArg,guard)&&(thisArg=null),baseCallback(func,thisArg)}function constant(value){return function(){return value}}function identity(value){return value}function property(path){return isKey(path)?baseProperty(path):basePropertyDeep(path)}var undefined,VERSION="3.7.0",FUNC_ERROR_TEXT="Expected a function",argsTag="[object Arguments]",arrayTag="[object Array]",boolTag="[object Boolean]",dateTag="[object Date]",errorTag="[object Error]",funcTag="[object Function]",mapTag="[object Map]",numberTag="[object Number]",objectTag="[object Object]",regexpTag="[object RegExp]",setTag="[object Set]",stringTag="[object String]",weakMapTag="[object WeakMap]",arrayBufferTag="[object ArrayBuffer]",float32Tag="[object Float32Array]",float64Tag="[object Float64Array]",int8Tag="[object Int8Array]",int16Tag="[object Int16Array]",int32Tag="[object Int32Array]",uint8Tag="[object Uint8Array]",uint8ClampedTag="[object Uint8ClampedArray]",uint16Tag="[object Uint16Array]",uint32Tag="[object Uint32Array]",reIsDeepProp=/\\.|\\[(?:[^[\\]]+|(["'])(?:(?!\\1)[^\\n\\\\]|\\\\.)*?)\\1\\]/,reIsPlainProp=/^\\w*$/,rePropName=/[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|(["'])((?:(?!\\2)[^\\n\\\\]|\\\\.)*?)\\2)\\]/g,reRegExpChars=/[.*+?^\${}()|[\\]\\/\\\\]/g,reHasRegExpChars=RegExp(reRegExpChars.source),reEscapeChar=/\\\\(\\\\)?/g,reFlags=/\\w*$/,reIsHostCtor=/^\\[object .+?Constructor\\]$/,typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=!0,typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=!1;var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[stringTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=!0,cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[mapTag]=cloneableTags[setTag]=cloneableTags[weakMapTag]=!1;var objectTypes={"function":!0,object:!0},freeExports=objectTypes[typeof exports]&&exports&&!exports.nodeType&&exports,freeModule=objectTypes[typeof module]&&module&&!module.nodeType&&module,freeGlobal=freeExports&&freeModule&&"object"==typeof global&&global&&global.Object&&global,freeSelf=objectTypes[typeof self]&&self&&self.Object&&self,freeWindow=objectTypes[typeof window]&&window&&window.Object&&window,moduleExports=freeModule&&freeModule.exports===freeExports&&freeExports,root=freeGlobal||freeWindow!==(this&&this.window)&&freeWindow||freeSelf||this,arrayProto=Array.prototype,objectProto=Object.prototype,fnToString=Function.prototype.toString,hasOwnProperty=objectProto.hasOwnProperty,objToString=objectProto.toString,reIsNative=RegExp("^"+escapeRegExp(objToString).replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g,"$1.*?")+"$"),ArrayBuffer=isNative(ArrayBuffer=root.ArrayBuffer)&&ArrayBuffer,bufferSlice=isNative(bufferSlice=ArrayBuffer&&new ArrayBuffer(0).slice)&&bufferSlice,floor=Math.floor,getOwnPropertySymbols=isNative(getOwnPropertySymbols=Object.getOwnPropertySymbols)&&getOwnPropertySymbols,getPrototypeOf=isNative(getPrototypeOf=Object.getPrototypeOf)&&getPrototypeOf,push=arrayProto.push,preventExtensions=isNative(Object.preventExtensions=Object.preventExtensions)&&preventExtensions,propertyIsEnumerable=objectProto.propertyIsEnumerable,Uint8Array=isNative(Uint8Array=root.Uint8Array)&&Uint8Array,Float64Array=function(){try{var func=isNative(func=root.Float64Array)&&func,result=new func(new ArrayBuffer(10),0,1)&&func}catch(e){}return result}(),nativeAssign=function(){var object={1:0},func=preventExtensions&&isNative(func=Object.assign)&&func;try{func(preventExtensions(object),"xo")}catch(e){}return!object[1]&&func}(),nativeIsArray=isNative(nativeIsArray=Array.isArray)&&nativeIsArray,nativeKeys=isNative(nativeKeys=Object.keys)&&nativeKeys,nativeMax=Math.max,nativeMin=Math.min,NEGATIVE_INFINITY=Number.NEGATIVE_INFINITY,MAX_ARRAY_LENGTH=Math.pow(2,32)-1,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1,FLOAT64_BYTES_PER_ELEMENT=Float64Array?Float64Array.BYTES_PER_ELEMENT:0,MAX_SAFE_INTEGER=Math.pow(2,53)-1,support=lodash.support={};(function(x){var Ctor=function(){this.x=x},props=[];Ctor.prototype={valueOf:x,y:x};for(var key in new Ctor)props.push(key);support.funcDecomp=/\\bthis\\b/.test(function(){return this}),support.funcNames="string"==typeof Function.name;try{support.nonEnumArgs=!propertyIsEnumerable.call(arguments,1)}catch(e){support.nonEnumArgs=!0}})(1,0);var baseAssign=nativeAssign||function(object,source){return null==source?object:baseCopy(source,getSymbols(source),baseCopy(source,keys(source),object))},baseEach=createBaseEach(baseForOwn),baseFor=createBaseFor();bufferSlice||(bufferClone=ArrayBuffer&&Uint8Array?function(buffer){var byteLength=buffer.byteLength,floatLength=Float64Array?floor(byteLength/FLOAT64_BYTES_PER_ELEMENT):0,offset=floatLength*FLOAT64_BYTES_PER_ELEMENT,result=new ArrayBuffer(byteLength);if(floatLength){var view=new Float64Array(result,0,floatLength);view.set(new Float64Array(buffer,0,floatLength))}return byteLength!=offset&&(view=new Uint8Array(result,offset),view.set(new Uint8Array(buffer,offset))),result}:constant(null));var getLength=baseProperty("length"),getSymbols=getOwnPropertySymbols?function(object){return getOwnPropertySymbols(toObject(object))}:constant([]),findLastIndex=createFindIndex(!0),zip=restParam(unzip),forEach=createForEach(arrayEach,baseEach),isArray=nativeIsArray||function(value){return isObjectLike(value)&&isLength(value.length)&&objToString.call(value)==arrayTag},isFunction=baseIsFunction(/x/)||Uint8Array&&!baseIsFunction(Uint8Array)?function(value){return objToString.call(value)==funcTag}:baseIsFunction,isPlainObject=getPrototypeOf?function(value){if(!value||objToString.call(value)!=objectTag)return!1;var valueOf=value.valueOf,objProto=isNative(valueOf)&&(objProto=getPrototypeOf(valueOf))&&getPrototypeOf(objProto);return objProto?value==objProto||getPrototypeOf(value)==objProto:shimIsPlainObject(value)}:shimIsPlainObject,assign=createAssigner(function(object,source,customizer){return customizer?assignWith(object,source,customizer):baseAssign(object,source)}),keys=nativeKeys?function(object){if(object)var Ctor=object.constructor,length=object.length;return"function"==typeof Ctor&&Ctor.prototype===object||"function"!=typeof object&&isLength(length)?shimKeys(object):isObject(object)?nativeKeys(object):[]}:shimKeys,merge=createAssigner(baseMerge);lodash.assign=assign,lodash.callback=callback,lodash.constant=constant,lodash.forEach=forEach,lodash.keys=keys,lodash.keysIn=keysIn,lodash.merge=merge,lodash.property=property,lodash.reject=reject,lodash.restParam=restParam,lodash.slice=slice,lodash.toPlainObject=toPlainObject,lodash.unzip=unzip,lodash.values=values,lodash.zip=zip,lodash.each=forEach,lodash.extend=assign,lodash.iteratee=callback,lodash.clone=clone,lodash.escapeRegExp=escapeRegExp,lodash.findLastIndex=findLastIndex,lodash.has=has,lodash.identity=identity,lodash.includes=includes,lodash.indexOf=indexOf,lodash.isArguments=isArguments,lodash.isArray=isArray,lodash.isEmpty=isEmpty,lodash.isFunction=isFunction,lodash.isNative=isNative,lodash.isNumber=isNumber,lodash.isObject=isObject,lodash.isPlainObject=isPlainObject,lodash.isString=isString,lodash.isTypedArray=isTypedArray,lodash.last=last,lodash.some=some,lodash.any=some,lodash.contains=includes,lodash.include=includes,lodash.VERSION=VERSION,freeExports&&freeModule?moduleExports?(freeModule.exports=lodash)._=lodash:freeExports._=lodash:root._=lodash
}).call(this)}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],"/node_modules/jshint/src/jshint.js":[function(_dereq_,module,exports){var _=_dereq_("../lodash"),events=_dereq_("events"),vars=_dereq_("./vars.js"),messages=_dereq_("./messages.js"),Lexer=_dereq_("./lex.js").Lexer,reg=_dereq_("./reg.js"),state=_dereq_("./state.js").state,style=_dereq_("./style.js"),options=_dereq_("./options.js"),scopeManager=_dereq_("./scope-manager.js"),JSHINT=function(){"use strict";function checkOption(name,t){return name=name.trim(),/^[+-]W\\d{3}$/g.test(name)?!0:-1!==options.validNames.indexOf(name)||"jslint"===t.type||_.has(options.removed,name)?!0:(error("E001",t,name),!1)}function isString(obj){return"[object String]"===Object.prototype.toString.call(obj)}function isIdentifier(tkn,value){return tkn?tkn.identifier&&tkn.value===value?!0:!1:!1}function isReserved(token){if(!token.reserved)return!1;var meta=token.meta;if(meta&&meta.isFutureReservedWord&&state.inES5()){if(!meta.es5)return!1;if(meta.strictOnly&&!state.option.strict&&!state.isStrict())return!1;if(token.isProperty)return!1}return!0}function supplant(str,data){return str.replace(/\\{([^{}]*)\\}/g,function(a,b){var r=data[b];return"string"==typeof r||"number"==typeof r?r:a})}function combine(dest,src){Object.keys(src).forEach(function(name){_.has(JSHINT.blacklist,name)||(dest[name]=src[name])})}function processenforceall(){if(state.option.enforceall){for(var enforceopt in options.bool.enforcing)void 0!==state.option[enforceopt]||options.noenforceall[enforceopt]||(state.option[enforceopt]=!0);for(var relaxopt in options.bool.relaxing)void 0===state.option[relaxopt]&&(state.option[relaxopt]=!1)}}function assume(){processenforceall(),state.option.esversion||state.option.moz||(state.option.esversion=state.option.es3?3:state.option.esnext?6:5),state.inES5()&&combine(predefined,vars.ecmaIdentifiers[5]),state.inES6()&&combine(predefined,vars.ecmaIdentifiers[6]),state.option.module&&(state.option.strict===!0&&(state.option.strict="global"),state.inES6()||warning("W134",state.tokens.next,"module",6)),state.option.couch&&combine(predefined,vars.couch),state.option.qunit&&combine(predefined,vars.qunit),state.option.rhino&&combine(predefined,vars.rhino),state.option.shelljs&&(combine(predefined,vars.shelljs),combine(predefined,vars.node)),state.option.typed&&combine(predefined,vars.typed),state.option.phantom&&(combine(predefined,vars.phantom),state.option.strict===!0&&(state.option.strict="global")),state.option.prototypejs&&combine(predefined,vars.prototypejs),state.option.node&&(combine(predefined,vars.node),combine(predefined,vars.typed),state.option.strict===!0&&(state.option.strict="global")),state.option.devel&&combine(predefined,vars.devel),state.option.dojo&&combine(predefined,vars.dojo),state.option.browser&&(combine(predefined,vars.browser),combine(predefined,vars.typed)),state.option.browserify&&(combine(predefined,vars.browser),combine(predefined,vars.typed),combine(predefined,vars.browserify),state.option.strict===!0&&(state.option.strict="global")),state.option.nonstandard&&combine(predefined,vars.nonstandard),state.option.jasmine&&combine(predefined,vars.jasmine),state.option.jquery&&combine(predefined,vars.jquery),state.option.mootools&&combine(predefined,vars.mootools),state.option.worker&&combine(predefined,vars.worker),state.option.wsh&&combine(predefined,vars.wsh),state.option.globalstrict&&state.option.strict!==!1&&(state.option.strict="global"),state.option.yui&&combine(predefined,vars.yui),state.option.mocha&&combine(predefined,vars.mocha)}function quit(code,line,chr){var percentage=Math.floor(100*(line/state.lines.length)),message=messages.errors[code].desc;throw{name:"JSHintError",line:line,character:chr,message:message+" ("+percentage+"% scanned).",raw:message,code:code}}function removeIgnoredMessages(){var ignored=state.ignoredLines;_.isEmpty(ignored)||(JSHINT.errors=_.reject(JSHINT.errors,function(err){return ignored[err.line]}))}function warning(code,t,a,b,c,d){var ch,l,w,msg;if(/^W\\d{3}$/.test(code)){if(state.ignored[code])return;msg=messages.warnings[code]}else/E\\d{3}/.test(code)?msg=messages.errors[code]:/I\\d{3}/.test(code)&&(msg=messages.info[code]);return t=t||state.tokens.next||{},"(end)"===t.id&&(t=state.tokens.curr),l=t.line||0,ch=t.from||0,w={id:"(error)",raw:msg.desc,code:msg.code,evidence:state.lines[l-1]||"",line:l,character:ch,scope:JSHINT.scope,a:a,b:b,c:c,d:d},w.reason=supplant(msg.desc,w),JSHINT.errors.push(w),removeIgnoredMessages(),JSHINT.errors.length>=state.option.maxerr&&quit("E043",l,ch),w}function warningAt(m,l,ch,a,b,c,d){return warning(m,{line:l,from:ch},a,b,c,d)}function error(m,t,a,b,c,d){warning(m,t,a,b,c,d)}function errorAt(m,l,ch,a,b,c,d){return error(m,{line:l,from:ch},a,b,c,d)}function addInternalSrc(elem,src){var i;return i={id:"(internal)",elem:elem,value:src},JSHINT.internals.push(i),i}function doOption(){var nt=state.tokens.next,body=nt.body.match(/(-\\s+)?[^\\s,:]+(?:\\s*:\\s*(-\\s+)?[^\\s,]+)?/g)||[],predef={};if("globals"===nt.type){body.forEach(function(g,idx){g=g.split(":");var key=(g[0]||"").trim(),val=(g[1]||"").trim();if("-"===key||!key.length){if(idx>0&&idx===body.length-1)return;return error("E002",nt),void 0}"-"===key.charAt(0)?(key=key.slice(1),val=!1,JSHINT.blacklist[key]=key,delete predefined[key]):predef[key]="true"===val}),combine(predefined,predef);for(var key in predef)_.has(predef,key)&&(declared[key]=nt)}"exported"===nt.type&&body.forEach(function(e,idx){if(!e.length){if(idx>0&&idx===body.length-1)return;return error("E002",nt),void 0}state.funct["(scope)"].addExported(e)}),"members"===nt.type&&(membersOnly=membersOnly||{},body.forEach(function(m){var ch1=m.charAt(0),ch2=m.charAt(m.length-1);ch1!==ch2||'"'!==ch1&&"'"!==ch1||(m=m.substr(1,m.length-2).replace('\\\\"','"')),membersOnly[m]=!1}));var numvals=["maxstatements","maxparams","maxdepth","maxcomplexity","maxerr","maxlen","indent"];("jshint"===nt.type||"jslint"===nt.type)&&(body.forEach(function(g){g=g.split(":");var key=(g[0]||"").trim(),val=(g[1]||"").trim();if(checkOption(key,nt))if(numvals.indexOf(key)>=0)if("false"!==val){if(val=+val,"number"!=typeof val||!isFinite(val)||0>=val||Math.floor(val)!==val)return error("E032",nt,g[1].trim()),void 0;state.option[key]=val}else state.option[key]="indent"===key?4:!1;else{if("validthis"===key)return state.funct["(global)"]?void error("E009"):"true"!==val&&"false"!==val?void error("E002",nt):(state.option.validthis="true"===val,void 0);if("quotmark"!==key)if("shadow"!==key)if("unused"!==key)if("latedef"!==key)if("ignore"!==key)if("strict"!==key){"module"===key&&(hasParsedCode(state.funct)||error("E055",state.tokens.next,"module"));var esversions={es3:3,es5:5,esnext:6};if(!_.has(esversions,key)){if("esversion"===key){switch(val){case"5":state.inES5(!0)&&warning("I003");case"3":case"6":state.option.moz=!1,state.option.esversion=+val;break;case"2015":state.option.moz=!1,state.option.esversion=6;break;default:error("E002",nt)}return hasParsedCode(state.funct)||error("E055",state.tokens.next,"esversion"),void 0}var match=/^([+-])(W\\d{3})$/g.exec(key);if(match)return state.ignored[match[2]]="-"===match[1],void 0;var tn;return"true"===val||"false"===val?("jslint"===nt.type?(tn=options.renamed[key]||key,state.option[tn]="true"===val,void 0!==options.inverted[tn]&&(state.option[tn]=!state.option[tn])):state.option[key]="true"===val,"newcap"===key&&(state.option["(explicitNewcap)"]=!0),void 0):(error("E002",nt),void 0)}switch(val){case"true":state.option.moz=!1,state.option.esversion=esversions[key];break;case"false":state.option.moz||(state.option.esversion=5);break;default:error("E002",nt)}}else switch(val){case"true":state.option.strict=!0;break;case"false":state.option.strict=!1;break;case"func":case"global":case"implied":state.option.strict=val;break;default:error("E002",nt)}else switch(val){case"line":state.ignoredLines[nt.line]=!0,removeIgnoredMessages();break;default:error("E002",nt)}else switch(val){case"true":state.option.latedef=!0;break;case"false":state.option.latedef=!1;break;case"nofunc":state.option.latedef="nofunc";break;default:error("E002",nt)}else switch(val){case"true":state.option.unused=!0;break;case"false":state.option.unused=!1;break;case"vars":case"strict":state.option.unused=val;break;default:error("E002",nt)}else switch(val){case"true":state.option.shadow=!0;break;case"outer":state.option.shadow="outer";break;case"false":case"inner":state.option.shadow="inner";break;default:error("E002",nt)}else switch(val){case"true":case"false":state.option.quotmark="true"===val;break;case"double":case"single":state.option.quotmark=val;break;default:error("E002",nt)}}}),assume())}function peek(p){var t,i=p||0,j=lookahead.length;if(j>i)return lookahead[i];for(;i>=j;)t=lookahead[j],t||(t=lookahead[j]=lex.token()),j+=1;return t||"(end)"!==state.tokens.next.id?t:state.tokens.next}function peekIgnoreEOL(){var t,i=0;do t=peek(i++);while("(endline)"===t.id);return t}function advance(id,t){switch(state.tokens.curr.id){case"(number)":"."===state.tokens.next.id&&warning("W005",state.tokens.curr);break;case"-":("-"===state.tokens.next.id||"--"===state.tokens.next.id)&&warning("W006");break;case"+":("+"===state.tokens.next.id||"++"===state.tokens.next.id)&&warning("W007")}for(id&&state.tokens.next.id!==id&&(t?"(end)"===state.tokens.next.id?error("E019",t,t.id):error("E020",state.tokens.next,id,t.id,t.line,state.tokens.next.value):("(identifier)"!==state.tokens.next.type||state.tokens.next.value!==id)&&warning("W116",state.tokens.next,id,state.tokens.next.value)),state.tokens.prev=state.tokens.curr,state.tokens.curr=state.tokens.next;;){if(state.tokens.next=lookahead.shift()||lex.token(),state.tokens.next||quit("E041",state.tokens.curr.line),"(end)"===state.tokens.next.id||"(error)"===state.tokens.next.id)return;if(state.tokens.next.check&&state.tokens.next.check(),state.tokens.next.isSpecial)"falls through"===state.tokens.next.type?state.tokens.curr.caseFallsThrough=!0:doOption();else if("(endline)"!==state.tokens.next.id)break}}function isInfix(token){return token.infix||!token.identifier&&!token.template&&!!token.led}function isEndOfExpr(){var curr=state.tokens.curr,next=state.tokens.next;return";"===next.id||"}"===next.id||":"===next.id?!0:isInfix(next)===isInfix(curr)||"yield"===curr.id&&state.inMoz()?curr.line!==startLine(next):!1}function isBeginOfExpr(prev){return!prev.left&&"unary"!==prev.arity}function expression(rbp,initial){var left,isArray=!1,isObject=!1,isLetExpr=!1;state.nameStack.push(),initial||"let"!==state.tokens.next.value||"("!==peek(0).value||(state.inMoz()||warning("W118",state.tokens.next,"let expressions"),isLetExpr=!0,state.funct["(scope)"].stack(),advance("let"),advance("("),state.tokens.prev.fud(),advance(")")),"(end)"===state.tokens.next.id&&error("E006",state.tokens.curr);var isDangerous=state.option.asi&&state.tokens.prev.line!==startLine(state.tokens.curr)&&_.contains(["]",")"],state.tokens.prev.id)&&_.contains(["[","("],state.tokens.curr.id);if(isDangerous&&warning("W014",state.tokens.curr,state.tokens.curr.id),advance(),initial&&(state.funct["(verb)"]=state.tokens.curr.value,state.tokens.curr.beginsStmt=!0),initial===!0&&state.tokens.curr.fud)left=state.tokens.curr.fud();else for(state.tokens.curr.nud?left=state.tokens.curr.nud():error("E030",state.tokens.curr,state.tokens.curr.id);(state.tokens.next.lbp>rbp||"(template)"===state.tokens.next.type)&&!isEndOfExpr();)isArray="Array"===state.tokens.curr.value,isObject="Object"===state.tokens.curr.value,left&&(left.value||left.first&&left.first.value)&&("new"!==left.value||left.first&&left.first.value&&"."===left.first.value)&&(isArray=!1,left.value!==state.tokens.curr.value&&(isObject=!1)),advance(),isArray&&"("===state.tokens.curr.id&&")"===state.tokens.next.id&&warning("W009",state.tokens.curr),isObject&&"("===state.tokens.curr.id&&")"===state.tokens.next.id&&warning("W010",state.tokens.curr),left&&state.tokens.curr.led?left=state.tokens.curr.led(left):error("E033",state.tokens.curr,state.tokens.curr.id);return isLetExpr&&state.funct["(scope)"].unstack(),state.nameStack.pop(),left}function startLine(token){return token.startLine||token.line}function nobreaknonadjacent(left,right){left=left||state.tokens.curr,right=right||state.tokens.next,state.option.laxbreak||left.line===startLine(right)||warning("W014",right,right.value)}function nolinebreak(t){t=t||state.tokens.curr,t.line!==startLine(state.tokens.next)&&warning("E022",t,t.value)}function nobreakcomma(left,right){left.line!==startLine(right)&&(state.option.laxcomma||(comma.first&&(warning("I001"),comma.first=!1),warning("W014",left,right.value)))}function comma(opts){if(opts=opts||{},opts.peek?nobreakcomma(state.tokens.prev,state.tokens.curr):(nobreakcomma(state.tokens.curr,state.tokens.next),advance(",")),state.tokens.next.identifier&&(!opts.property||!state.inES5()))switch(state.tokens.next.value){case"break":case"case":case"catch":case"continue":case"default":case"do":case"else":case"finally":case"for":case"if":case"in":case"instanceof":case"return":case"switch":case"throw":case"try":case"var":case"let":case"while":case"with":return error("E024",state.tokens.next,state.tokens.next.value),!1}if("(punctuator)"===state.tokens.next.type)switch(state.tokens.next.value){case"}":case"]":case",":if(opts.allowTrailing)return!0;case")":return error("E024",state.tokens.next,state.tokens.next.value),!1}return!0}function symbol(s,p){var x=state.syntax[s];return x&&"object"==typeof x||(state.syntax[s]=x={id:s,lbp:p,value:s}),x}function delim(s){var x=symbol(s,0);return x.delim=!0,x}function stmt(s,f){var x=delim(s);return x.identifier=x.reserved=!0,x.fud=f,x}function blockstmt(s,f){var x=stmt(s,f);return x.block=!0,x}function reserveName(x){var c=x.id.charAt(0);return(c>="a"&&"z">=c||c>="A"&&"Z">=c)&&(x.identifier=x.reserved=!0),x}function prefix(s,f){var x=symbol(s,150);return reserveName(x),x.nud="function"==typeof f?f:function(){return this.arity="unary",this.right=expression(150),("++"===this.id||"--"===this.id)&&(state.option.plusplus?warning("W016",this,this.id):!this.right||this.right.identifier&&!isReserved(this.right)||"."===this.right.id||"["===this.right.id||warning("W017",this),this.right&&this.right.isMetaProperty?error("E031",this):this.right&&this.right.identifier&&state.funct["(scope)"].block.modify(this.right.value,this)),this},x}function type(s,f){var x=delim(s);return x.type=s,x.nud=f,x}function reserve(name,func){var x=type(name,func);return x.identifier=!0,x.reserved=!0,x}function FutureReservedWord(name,meta){var x=type(name,meta&&meta.nud||function(){return this});return meta=meta||{},meta.isFutureReservedWord=!0,x.value=name,x.identifier=!0,x.reserved=!0,x.meta=meta,x}function reservevar(s,v){return reserve(s,function(){return"function"==typeof v&&v(this),this})}function infix(s,f,p,w){var x=symbol(s,p);return reserveName(x),x.infix=!0,x.led=function(left){return w||nobreaknonadjacent(state.tokens.prev,state.tokens.curr),"in"!==s&&"instanceof"!==s||"!"!==left.id||warning("W018",left,"!"),"function"==typeof f?f(left,this):(this.left=left,this.right=expression(p),this)},x}function application(s){var x=symbol(s,42);return x.led=function(left){return nobreaknonadjacent(state.tokens.prev,state.tokens.curr),this.left=left,this.right=doFunction({type:"arrow",loneArg:left}),this},x}function relation(s,f){var x=symbol(s,100);return x.led=function(left){nobreaknonadjacent(state.tokens.prev,state.tokens.curr),this.left=left;var right=this.right=expression(100);return isIdentifier(left,"NaN")||isIdentifier(right,"NaN")?warning("W019",this):f&&f.apply(this,[left,right]),left&&right||quit("E041",state.tokens.curr.line),"!"===left.id&&warning("W018",left,"!"),"!"===right.id&&warning("W018",right,"!"),this},x}function isPoorRelation(node){return node&&("(number)"===node.type&&0===+node.value||"(string)"===node.type&&""===node.value||"null"===node.type&&!state.option.eqnull||"true"===node.type||"false"===node.type||"undefined"===node.type)}function isTypoTypeof(left,right,state){var values;return state.option.notypeof?!1:left&&right?(values=state.inES6()?typeofValues.es6:typeofValues.es3,"(identifier)"===right.type&&"typeof"===right.value&&"(string)"===left.type?!_.contains(values,left.value):!1):!1}function isGlobalEval(left,state){var isGlobal=!1;return"this"===left.type&&null===state.funct["(context)"]?isGlobal=!0:"(identifier)"===left.type&&(state.option.node&&"global"===left.value?isGlobal=!0:!state.option.browser||"window"!==left.value&&"document"!==left.value||(isGlobal=!0)),isGlobal}function findNativePrototype(left){function walkPrototype(obj){return"object"==typeof obj?"prototype"===obj.right?obj:walkPrototype(obj.left):void 0}function walkNative(obj){for(;!obj.identifier&&"object"==typeof obj.left;)obj=obj.left;return obj.identifier&&natives.indexOf(obj.value)>=0?obj.value:void 0}var natives=["Array","ArrayBuffer","Boolean","Collator","DataView","Date","DateTimeFormat","Error","EvalError","Float32Array","Float64Array","Function","Infinity","Intl","Int16Array","Int32Array","Int8Array","Iterator","Number","NumberFormat","Object","RangeError","ReferenceError","RegExp","StopIteration","String","SyntaxError","TypeError","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray","URIError"],prototype=walkPrototype(left);return prototype?walkNative(prototype):void 0}function checkLeftSideAssign(left,assignToken,options){var allowDestructuring=options&&options.allowDestructuring;if(assignToken=assignToken||left,state.option.freeze){var nativeObject=findNativePrototype(left);nativeObject&&warning("W121",left,nativeObject)}return left.identifier&&!left.isMetaProperty&&state.funct["(scope)"].block.reassign(left.value,left),"."===left.id?((!left.left||"arguments"===left.left.value&&!state.isStrict())&&warning("E031",assignToken),state.nameStack.set(state.tokens.prev),!0):"{"===left.id||"["===left.id?(allowDestructuring&&state.tokens.curr.left.destructAssign?state.tokens.curr.left.destructAssign.forEach(function(t){t.id&&state.funct["(scope)"].block.modify(t.id,t.token)}):"{"!==left.id&&left.left?"arguments"!==left.left.value||state.isStrict()||warning("E031",assignToken):warning("E031",assignToken),"["===left.id&&state.nameStack.set(left.right),!0):left.isMetaProperty?(error("E031",assignToken),!0):left.identifier&&!isReserved(left)?("exception"===state.funct["(scope)"].labeltype(left.value)&&warning("W022",left),state.nameStack.set(left),!0):(left===state.syntax["function"]&&warning("W023",state.tokens.curr),!1)}function assignop(s,f,p){var x=infix(s,"function"==typeof f?f:function(left,that){return that.left=left,left&&checkLeftSideAssign(left,that,{allowDestructuring:!0})?(that.right=expression(10),that):(error("E031",that),void 0)},p);return x.exps=!0,x.assign=!0,x}function bitwise(s,f,p){var x=symbol(s,p);return reserveName(x),x.led="function"==typeof f?f:function(left){return state.option.bitwise&&warning("W016",this,this.id),this.left=left,this.right=expression(p),this},x}function bitwiseassignop(s){return assignop(s,function(left,that){return state.option.bitwise&&warning("W016",that,that.id),left&&checkLeftSideAssign(left,that)?(that.right=expression(10),that):(error("E031",that),void 0)},20)}function suffix(s){var x=symbol(s,150);return x.led=function(left){return state.option.plusplus?warning("W016",this,this.id):left.identifier&&!isReserved(left)||"."===left.id||"["===left.id||warning("W017",this),left.isMetaProperty?error("E031",this):left&&left.identifier&&state.funct["(scope)"].block.modify(left.value,left),this.left=left,this},x}function optionalidentifier(fnparam,prop,preserve){if(state.tokens.next.identifier){preserve||advance();var curr=state.tokens.curr,val=state.tokens.curr.value;return isReserved(curr)?prop&&state.inES5()?val:fnparam&&"undefined"===val?val:(warning("W024",state.tokens.curr,state.tokens.curr.id),val):val}}function identifier(fnparam,prop){var i=optionalidentifier(fnparam,prop,!1);if(i)return i;if("..."===state.tokens.next.value){if(state.inES6(!0)||warning("W119",state.tokens.next,"spread/rest operator","6"),advance(),checkPunctuator(state.tokens.next,"..."))for(warning("E024",state.tokens.next,"...");checkPunctuator(state.tokens.next,"...");)advance();return state.tokens.next.identifier?identifier(fnparam,prop):(warning("E024",state.tokens.curr,"..."),void 0)}error("E030",state.tokens.next,state.tokens.next.value),";"!==state.tokens.next.id&&advance()}function reachable(controlToken){var t,i=0;if(";"===state.tokens.next.id&&!controlToken.inBracelessBlock)for(;;){do t=peek(i),i+=1;while("(end)"!==t.id&&"(comment)"===t.id);if(t.reach)return;if("(endline)"!==t.id){if("function"===t.id){state.option.latedef===!0&&warning("W026",t);break}warning("W027",t,t.value,controlToken.value);break}}}function parseFinalSemicolon(){if(";"!==state.tokens.next.id){if(state.tokens.next.isUnclosed)return advance();var sameLine=startLine(state.tokens.next)===state.tokens.curr.line&&"(end)"!==state.tokens.next.id,blockEnd=checkPunctuator(state.tokens.next,"}");sameLine&&!blockEnd?errorAt("E058",state.tokens.curr.line,state.tokens.curr.character):state.option.asi||(blockEnd&&!state.option.lastsemic||!sameLine)&&warningAt("W033",state.tokens.curr.line,state.tokens.curr.character)}else advance(";")}function statement(){var r,i=indent,t=state.tokens.next,hasOwnScope=!1;if(";"===t.id)return advance(";"),void 0;var res=isReserved(t);if(res&&t.meta&&t.meta.isFutureReservedWord&&":"===peek().id&&(warning("W024",t,t.id),res=!1),t.identifier&&!res&&":"===peek().id&&(advance(),advance(":"),hasOwnScope=!0,state.funct["(scope)"].stack(),state.funct["(scope)"].block.addBreakLabel(t.value,{token:state.tokens.curr}),state.tokens.next.labelled||"{"===state.tokens.next.value||warning("W028",state.tokens.next,t.value,state.tokens.next.value),state.tokens.next.label=t.value,t=state.tokens.next),"{"===t.id){var iscase="case"===state.funct["(verb)"]&&":"===state.tokens.curr.value;return block(!0,!0,!1,!1,iscase),void 0}return r=expression(0,!0),!r||r.identifier&&"function"===r.value||"(punctuator)"===r.type&&r.left&&r.left.identifier&&"function"===r.left.value||state.isStrict()||"global"!==state.option.strict||warning("E007"),t.block||(state.option.expr||r&&r.exps?state.option.nonew&&r&&r.left&&"("===r.id&&"new"===r.left.id&&warning("W031",t):warning("W030",state.tokens.curr),parseFinalSemicolon()),indent=i,hasOwnScope&&state.funct["(scope)"].unstack(),r}function statements(){for(var p,a=[];!state.tokens.next.reach&&"(end)"!==state.tokens.next.id;)";"===state.tokens.next.id?(p=peek(),(!p||"("!==p.id&&"["!==p.id)&&warning("W032"),advance(";")):a.push(statement());return a}function directives(){for(var i,p,pn;"(string)"===state.tokens.next.id;){if(p=peek(0),"(endline)"===p.id){i=1;do pn=peek(i++);while("(endline)"===pn.id);if(";"===pn.id)p=pn;else{if("["===pn.value||"."===pn.value)break;state.option.asi&&"("!==pn.value||warning("W033",state.tokens.next)}}else{if("."===p.id||"["===p.id)break;";"!==p.id&&warning("W033",p)}advance();var directive=state.tokens.curr.value;(state.directive[directive]||"use strict"===directive&&"implied"===state.option.strict)&&warning("W034",state.tokens.curr,directive),state.directive[directive]=!0,";"===p.id&&advance(";")}state.isStrict()&&(state.option["(explicitNewcap)"]||(state.option.newcap=!0),state.option.undef=!0)}function block(ordinary,stmt,isfunc,isfatarrow,iscase){var a,m,t,line,d,b=inblock,old_indent=indent;inblock=ordinary,t=state.tokens.next;var metrics=state.funct["(metrics)"];if(metrics.nestedBlockDepth+=1,metrics.verifyMaxNestedBlockDepthPerFunction(),"{"===state.tokens.next.id){if(advance("{"),state.funct["(scope)"].stack(),line=state.tokens.curr.line,"}"!==state.tokens.next.id){for(indent+=state.option.indent;!ordinary&&state.tokens.next.from>indent;)indent+=state.option.indent;if(isfunc){m={};for(d in state.directive)_.has(state.directive,d)&&(m[d]=state.directive[d]);directives(),state.option.strict&&state.funct["(context)"]["(global)"]&&(m["use strict"]||state.isStrict()||warning("E007"))}a=statements(),metrics.statementCount+=a.length,indent-=state.option.indent}advance("}",t),isfunc&&(state.funct["(scope)"].validateParams(),m&&(state.directive=m)),state.funct["(scope)"].unstack(),indent=old_indent}else if(ordinary)state.funct["(noblockscopedvar)"]="for"!==state.tokens.next.id,state.funct["(scope)"].stack(),(!stmt||state.option.curly)&&warning("W116",state.tokens.next,"{",state.tokens.next.value),state.tokens.next.inBracelessBlock=!0,indent+=state.option.indent,a=[statement()],indent-=state.option.indent,state.funct["(scope)"].unstack(),delete state.funct["(noblockscopedvar)"];else if(isfunc){if(state.funct["(scope)"].stack(),m={},!stmt||isfatarrow||state.inMoz()||error("W118",state.tokens.curr,"function closure expressions"),!stmt)for(d in state.directive)_.has(state.directive,d)&&(m[d]=state.directive[d]);expression(10),state.option.strict&&state.funct["(context)"]["(global)"]&&(m["use strict"]||state.isStrict()||warning("E007")),state.funct["(scope)"].unstack()}else error("E021",state.tokens.next,"{",state.tokens.next.value);switch(state.funct["(verb)"]){case"break":case"continue":case"return":case"throw":if(iscase)break;default:state.funct["(verb)"]=null}return inblock=b,!ordinary||!state.option.noempty||a&&0!==a.length||warning("W035",state.tokens.prev),metrics.nestedBlockDepth-=1,a}function countMember(m){membersOnly&&"boolean"!=typeof membersOnly[m]&&warning("W036",state.tokens.curr,m),"number"==typeof member[m]?member[m]+=1:member[m]=1}function comprehensiveArrayExpression(){var res={};res.exps=!0,state.funct["(comparray)"].stack();var reversed=!1;return"for"!==state.tokens.next.value&&(reversed=!0,state.inMoz()||warning("W116",state.tokens.next,"for",state.tokens.next.value),state.funct["(comparray)"].setState("use"),res.right=expression(10)),advance("for"),"each"===state.tokens.next.value&&(advance("each"),state.inMoz()||warning("W118",state.tokens.curr,"for each")),advance("("),state.funct["(comparray)"].setState("define"),res.left=expression(130),_.contains(["in","of"],state.tokens.next.value)?advance():error("E045",state.tokens.curr),state.funct["(comparray)"].setState("generate"),expression(10),advance(")"),"if"===state.tokens.next.value&&(advance("if"),advance("("),state.funct["(comparray)"].setState("filter"),res.filter=expression(10),advance(")")),reversed||(state.funct["(comparray)"].setState("use"),res.right=expression(10)),advance("]"),state.funct["(comparray)"].unstack(),res}function isMethod(){return state.funct["(statement)"]&&"class"===state.funct["(statement)"].type||state.funct["(context)"]&&"class"===state.funct["(context)"]["(verb)"]}function isPropertyName(token){return token.identifier||"(string)"===token.id||"(number)"===token.id}function propertyName(preserveOrToken){var id,preserve=!0;return"object"==typeof preserveOrToken?id=preserveOrToken:(preserve=preserveOrToken,id=optionalidentifier(!1,!0,preserve)),id?"object"==typeof id&&("(string)"===id.id||"(identifier)"===id.id?id=id.value:"(number)"===id.id&&(id=""+id.value)):"(string)"===state.tokens.next.id?(id=state.tokens.next.value,preserve||advance()):"(number)"===state.tokens.next.id&&(id=""+state.tokens.next.value,preserve||advance()),"hasOwnProperty"===id&&warning("W001"),id}function functionparams(options){function addParam(addParamArgs){state.funct["(scope)"].addParam.apply(state.funct["(scope)"],addParamArgs)}var next,ident,t,paramsIds=[],tokens=[],pastDefault=!1,pastRest=!1,arity=0,loneArg=options&&options.loneArg;if(loneArg&&loneArg.identifier===!0)return state.funct["(scope)"].addParam(loneArg.value,loneArg),{arity:1,params:[loneArg.value]};if(next=state.tokens.next,options&&options.parsedOpening||advance("("),")"===state.tokens.next.id)return advance(")"),void 0;for(;;){arity++;var currentParams=[];if(_.contains(["{","["],state.tokens.next.id)){tokens=destructuringPattern();for(t in tokens)t=tokens[t],t.id&&(paramsIds.push(t.id),currentParams.push([t.id,t.token]))}else if(checkPunctuator(state.tokens.next,"...")&&(pastRest=!0),ident=identifier(!0))paramsIds.push(ident),currentParams.push([ident,state.tokens.curr]);else for(;!checkPunctuators(state.tokens.next,[",",")"]);)advance();if(pastDefault&&"="!==state.tokens.next.id&&error("W138",state.tokens.current),"="===state.tokens.next.id&&(state.inES6()||warning("W119",state.tokens.next,"default parameters","6"),advance("="),pastDefault=!0,expression(10)),currentParams.forEach(addParam),","!==state.tokens.next.id)return advance(")",next),{arity:arity,params:paramsIds};pastRest&&warning("W131",state.tokens.next),comma()}}function functor(name,token,overwrites){var funct={"(name)":name,"(breakage)":0,"(loopage)":0,"(tokens)":{},"(properties)":{},"(catch)":!1,"(global)":!1,"(line)":null,"(character)":null,"(metrics)":null,"(statement)":null,"(context)":null,"(scope)":null,"(comparray)":null,"(generator)":null,"(arrow)":null,"(params)":null};return token&&_.extend(funct,{"(line)":token.line,"(character)":token.character,"(metrics)":createMetrics(token)}),_.extend(funct,overwrites),funct["(context)"]&&(funct["(scope)"]=funct["(context)"]["(scope)"],funct["(comparray)"]=funct["(context)"]["(comparray)"]),funct}function isFunctor(token){return"(scope)"in token}function hasParsedCode(funct){return funct["(global)"]&&!funct["(verb)"]}function doTemplateLiteral(left){function end(){if(state.tokens.curr.template&&state.tokens.curr.tail&&state.tokens.curr.context===ctx)return!0;var complete=state.tokens.next.template&&state.tokens.next.tail&&state.tokens.next.context===ctx;return complete&&advance(),complete||state.tokens.next.isUnclosed}var ctx=this.context,noSubst=this.noSubst,depth=this.depth;if(!noSubst)for(;!end();)!state.tokens.next.template||state.tokens.next.depth>depth?expression(0):advance();return{id:"(template)",type:"(template)",tag:left}}function doFunction(options){var f,token,name,statement,classExprBinding,isGenerator,isArrow,ignoreLoopFunc,oldOption=state.option,oldIgnored=state.ignored;options&&(name=options.name,statement=options.statement,classExprBinding=options.classExprBinding,isGenerator="generator"===options.type,isArrow="arrow"===options.type,ignoreLoopFunc=options.ignoreLoopFunc),state.option=Object.create(state.option),state.ignored=Object.create(state.ignored),state.funct=functor(name||state.nameStack.infer(),state.tokens.next,{"(statement)":statement,"(context)":state.funct,"(arrow)":isArrow,"(generator)":isGenerator}),f=state.funct,token=state.tokens.curr,token.funct=state.funct,functions.push(state.funct),state.funct["(scope)"].stack("functionouter");var internallyAccessibleName=name||classExprBinding;internallyAccessibleName&&state.funct["(scope)"].block.add(internallyAccessibleName,classExprBinding?"class":"function",state.tokens.curr,!1),state.funct["(scope)"].stack("functionparams");var paramsInfo=functionparams(options);return paramsInfo?(state.funct["(params)"]=paramsInfo.params,state.funct["(metrics)"].arity=paramsInfo.arity,state.funct["(metrics)"].verifyMaxParametersPerFunction()):state.funct["(metrics)"].arity=0,isArrow&&(state.inES6(!0)||warning("W119",state.tokens.curr,"arrow function syntax (=>)","6"),options.loneArg||advance("=>")),block(!1,!0,!0,isArrow),!state.option.noyield&&isGenerator&&"yielded"!==state.funct["(generator)"]&&warning("W124",state.tokens.curr),state.funct["(metrics)"].verifyMaxStatementsPerFunction(),state.funct["(metrics)"].verifyMaxComplexityPerFunction(),state.funct["(unusedOption)"]=state.option.unused,state.option=oldOption,state.ignored=oldIgnored,state.funct["(last)"]=state.tokens.curr.line,state.funct["(lastcharacter)"]=state.tokens.curr.character,state.funct["(scope)"].unstack(),state.funct["(scope)"].unstack(),state.funct=state.funct["(context)"],ignoreLoopFunc||state.option.loopfunc||!state.funct["(loopage)"]||f["(isCapturing)"]&&warning("W083",token),f}function createMetrics(functionStartToken){return{statementCount:0,nestedBlockDepth:-1,ComplexityCount:1,arity:0,verifyMaxStatementsPerFunction:function(){state.option.maxstatements&&this.statementCount>state.option.maxstatements&&warning("W071",functionStartToken,this.statementCount)
},verifyMaxParametersPerFunction:function(){_.isNumber(state.option.maxparams)&&this.arity>state.option.maxparams&&warning("W072",functionStartToken,this.arity)},verifyMaxNestedBlockDepthPerFunction:function(){state.option.maxdepth&&this.nestedBlockDepth>0&&this.nestedBlockDepth===state.option.maxdepth+1&&warning("W073",null,this.nestedBlockDepth)},verifyMaxComplexityPerFunction:function(){var max=state.option.maxcomplexity,cc=this.ComplexityCount;max&&cc>max&&warning("W074",functionStartToken,cc)}}}function increaseComplexityCount(){state.funct["(metrics)"].ComplexityCount+=1}function checkCondAssignment(expr){var id,paren;switch(expr&&(id=expr.id,paren=expr.paren,","===id&&(expr=expr.exprs[expr.exprs.length-1])&&(id=expr.id,paren=paren||expr.paren)),id){case"=":case"+=":case"-=":case"*=":case"%=":case"&=":case"|=":case"^=":case"/=":paren||state.option.boss||warning("W084")}}function checkProperties(props){if(state.inES5())for(var name in props)props[name]&&props[name].setterToken&&!props[name].getterToken&&warning("W078",props[name].setterToken)}function metaProperty(name,c){if(checkPunctuator(state.tokens.next,".")){var left=state.tokens.curr.id;advance(".");var id=identifier();return state.tokens.curr.isMetaProperty=!0,name!==id?error("E057",state.tokens.prev,left,id):c(),state.tokens.curr}}function destructuringPattern(options){var isAssignment=options&&options.assignment;return state.inES6()||warning("W104",state.tokens.curr,isAssignment?"destructuring assignment":"destructuring binding","6"),destructuringPatternRecursive(options)}function destructuringPatternRecursive(options){var ids,identifiers=[],openingParsed=options&&options.openingParsed,isAssignment=options&&options.assignment,recursiveOptions=isAssignment?{assignment:isAssignment}:null,firstToken=openingParsed?state.tokens.curr:state.tokens.next,nextInnerDE=function(){var ident;if(checkPunctuators(state.tokens.next,["[","{"])){ids=destructuringPatternRecursive(recursiveOptions);for(var id in ids)id=ids[id],identifiers.push({id:id.id,token:id.token})}else if(checkPunctuator(state.tokens.next,","))identifiers.push({id:null,token:state.tokens.curr});else{if(!checkPunctuator(state.tokens.next,"(")){var is_rest=checkPunctuator(state.tokens.next,"...");if(isAssignment){var identifierToken=is_rest?peek(0):state.tokens.next;identifierToken.identifier||warning("E030",identifierToken,identifierToken.value);var assignTarget=expression(155);assignTarget&&(checkLeftSideAssign(assignTarget),assignTarget.identifier&&(ident=assignTarget.value))}else ident=identifier();return ident&&identifiers.push({id:ident,token:state.tokens.curr}),is_rest}advance("("),nextInnerDE(),advance(")")}return!1},assignmentProperty=function(){var id;checkPunctuator(state.tokens.next,"[")?(advance("["),expression(10),advance("]"),advance(":"),nextInnerDE()):"(string)"===state.tokens.next.id||"(number)"===state.tokens.next.id?(advance(),advance(":"),nextInnerDE()):(id=identifier(),checkPunctuator(state.tokens.next,":")?(advance(":"),nextInnerDE()):id&&(isAssignment&&checkLeftSideAssign(state.tokens.curr),identifiers.push({id:id,token:state.tokens.curr})))};if(checkPunctuator(firstToken,"[")){openingParsed||advance("["),checkPunctuator(state.tokens.next,"]")&&warning("W137",state.tokens.curr);for(var element_after_rest=!1;!checkPunctuator(state.tokens.next,"]");)nextInnerDE()&&!element_after_rest&&checkPunctuator(state.tokens.next,",")&&(warning("W130",state.tokens.next),element_after_rest=!0),checkPunctuator(state.tokens.next,"=")&&(checkPunctuator(state.tokens.prev,"...")?advance("]"):advance("="),"undefined"===state.tokens.next.id&&warning("W080",state.tokens.prev,state.tokens.prev.value),expression(10)),checkPunctuator(state.tokens.next,"]")||advance(",");advance("]")}else if(checkPunctuator(firstToken,"{")){for(openingParsed||advance("{"),checkPunctuator(state.tokens.next,"}")&&warning("W137",state.tokens.curr);!checkPunctuator(state.tokens.next,"}")&&(assignmentProperty(),checkPunctuator(state.tokens.next,"=")&&(advance("="),"undefined"===state.tokens.next.id&&warning("W080",state.tokens.prev,state.tokens.prev.value),expression(10)),checkPunctuator(state.tokens.next,"}")||(advance(","),!checkPunctuator(state.tokens.next,"}"))););advance("}")}return identifiers}function destructuringPatternMatch(tokens,value){var first=value.first;first&&_.zip(tokens,Array.isArray(first)?first:[first]).forEach(function(val){var token=val[0],value=val[1];token&&value?token.first=value:token&&token.first&&!value&&warning("W080",token.first,token.first.value)})}function blockVariableStatement(type,statement,context){var tokens,lone,value,letblock,prefix=context&&context.prefix,inexport=context&&context.inexport,isLet="let"===type,isConst="const"===type;for(state.inES6()||warning("W104",state.tokens.curr,type,"6"),isLet&&"("===state.tokens.next.value?(state.inMoz()||warning("W118",state.tokens.next,"let block"),advance("("),state.funct["(scope)"].stack(),letblock=!0):state.funct["(noblockscopedvar)"]&&error("E048",state.tokens.curr,isConst?"Const":"Let"),statement.first=[];;){var names=[];_.contains(["{","["],state.tokens.next.value)?(tokens=destructuringPattern(),lone=!1):(tokens=[{id:identifier(),token:state.tokens.curr}],lone=!0),!prefix&&isConst&&"="!==state.tokens.next.id&&warning("E012",state.tokens.curr,state.tokens.curr.value);for(var t in tokens)tokens.hasOwnProperty(t)&&(t=tokens[t],state.funct["(scope)"].block.isGlobal()&&predefined[t.id]===!1&&warning("W079",t.token,t.id),t.id&&!state.funct["(noblockscopedvar)"]&&(state.funct["(scope)"].addlabel(t.id,{type:type,token:t.token}),names.push(t.token),lone&&inexport&&state.funct["(scope)"].setExported(t.token.value,t.token)));if("="===state.tokens.next.id&&(advance("="),prefix||"undefined"!==state.tokens.next.id||warning("W080",state.tokens.prev,state.tokens.prev.value),!prefix&&"="===peek(0).id&&state.tokens.next.identifier&&warning("W120",state.tokens.next,state.tokens.next.value),value=expression(prefix?120:10),lone?tokens[0].first=value:destructuringPatternMatch(names,value)),statement.first=statement.first.concat(names),","!==state.tokens.next.id)break;comma()}return letblock&&(advance(")"),block(!0,!0),statement.block=!0,state.funct["(scope)"].unstack()),statement}function classdef(isStatement){return state.inES6()||warning("W104",state.tokens.curr,"class","6"),isStatement?(this.name=identifier(),state.funct["(scope)"].addlabel(this.name,{type:"class",token:state.tokens.curr})):state.tokens.next.identifier&&"extends"!==state.tokens.next.value?(this.name=identifier(),this.namedExpr=!0):this.name=state.nameStack.infer(),classtail(this),this}function classtail(c){var wasInClassBody=state.inClassBody;"extends"===state.tokens.next.value&&(advance("extends"),c.heritage=expression(10)),state.inClassBody=!0,advance("{"),c.body=classbody(c),advance("}"),state.inClassBody=wasInClassBody}function classbody(c){for(var name,isStatic,isGenerator,getset,computed,props=Object.create(null),staticProps=Object.create(null),i=0;"}"!==state.tokens.next.id;++i)if(name=state.tokens.next,isStatic=!1,isGenerator=!1,getset=null,";"!==name.id){if("*"===name.id&&(isGenerator=!0,advance("*"),name=state.tokens.next),"["===name.id)name=computedPropertyName(),computed=!0;else{if(!isPropertyName(name)){warning("W052",state.tokens.next,state.tokens.next.value||state.tokens.next.type),advance();continue}advance(),computed=!1,name.identifier&&"static"===name.value&&(checkPunctuator(state.tokens.next,"*")&&(isGenerator=!0,advance("*")),(isPropertyName(state.tokens.next)||"["===state.tokens.next.id)&&(computed="["===state.tokens.next.id,isStatic=!0,name=state.tokens.next,"["===state.tokens.next.id?name=computedPropertyName():advance())),!name.identifier||"get"!==name.value&&"set"!==name.value||(isPropertyName(state.tokens.next)||"["===state.tokens.next.id)&&(computed="["===state.tokens.next.id,getset=name,name=state.tokens.next,"["===state.tokens.next.id?name=computedPropertyName():advance())}if(!checkPunctuator(state.tokens.next,"(")){for(error("E054",state.tokens.next,state.tokens.next.value);"}"!==state.tokens.next.id&&!checkPunctuator(state.tokens.next,"(");)advance();"("!==state.tokens.next.value&&doFunction({statement:c})}if(computed||(getset?saveAccessor(getset.value,isStatic?staticProps:props,name.value,name,!0,isStatic):("constructor"===name.value?state.nameStack.set(c):state.nameStack.set(name),saveProperty(isStatic?staticProps:props,name.value,name,!0,isStatic))),getset&&"constructor"===name.value){var propDesc="get"===getset.value?"class getter method":"class setter method";error("E049",name,propDesc,"constructor")}else"prototype"===name.value&&error("E049",name,"class method","prototype");propertyName(name),doFunction({statement:c,type:isGenerator?"generator":null,classExprBinding:c.namedExpr?c.name:null})}else warning("W032"),advance(";");checkProperties(props)}function saveProperty(props,name,tkn,isClass,isStatic){var msg=["key","class method","static class method"];msg=msg[(isClass||!1)+(isStatic||!1)],tkn.identifier&&(name=tkn.value),props[name]&&"__proto__"!==name?warning("W075",state.tokens.next,msg,name):props[name]=Object.create(null),props[name].basic=!0,props[name].basictkn=tkn}function saveAccessor(accessorType,props,name,tkn,isClass,isStatic){var flagName="get"===accessorType?"getterToken":"setterToken",msg="";isClass?(isStatic&&(msg+="static "),msg+=accessorType+"ter method"):msg="key",state.tokens.curr.accessorType=accessorType,state.nameStack.set(tkn),props[name]?(props[name].basic||props[name][flagName])&&"__proto__"!==name&&warning("W075",state.tokens.next,msg,name):props[name]=Object.create(null),props[name][flagName]=tkn}function computedPropertyName(){advance("["),state.inES6()||warning("W119",state.tokens.curr,"computed property names","6");var value=expression(10);return advance("]"),value}function checkPunctuators(token,values){return"(punctuator)"===token.type?_.contains(values,token.value):!1}function checkPunctuator(token,value){return"(punctuator)"===token.type&&token.value===value}function destructuringAssignOrJsonValue(){var block=lookupBlockType();block.notJson?(!state.inES6()&&block.isDestAssign&&warning("W104",state.tokens.curr,"destructuring assignment","6"),statements()):(state.option.laxbreak=!0,state.jsonMode=!0,jsonValue())}function jsonValue(){function jsonObject(){var o={},t=state.tokens.next;if(advance("{"),"}"!==state.tokens.next.id)for(;;){if("(end)"===state.tokens.next.id)error("E026",state.tokens.next,t.line);else{if("}"===state.tokens.next.id){warning("W094",state.tokens.curr);break}","===state.tokens.next.id?error("E028",state.tokens.next):"(string)"!==state.tokens.next.id&&warning("W095",state.tokens.next,state.tokens.next.value)}if(o[state.tokens.next.value]===!0?warning("W075",state.tokens.next,"key",state.tokens.next.value):"__proto__"===state.tokens.next.value&&!state.option.proto||"__iterator__"===state.tokens.next.value&&!state.option.iterator?warning("W096",state.tokens.next,state.tokens.next.value):o[state.tokens.next.value]=!0,advance(),advance(":"),jsonValue(),","!==state.tokens.next.id)break;advance(",")}advance("}")}function jsonArray(){var t=state.tokens.next;if(advance("["),"]"!==state.tokens.next.id)for(;;){if("(end)"===state.tokens.next.id)error("E027",state.tokens.next,t.line);else{if("]"===state.tokens.next.id){warning("W094",state.tokens.curr);break}","===state.tokens.next.id&&error("E028",state.tokens.next)}if(jsonValue(),","!==state.tokens.next.id)break;advance(",")}advance("]")}switch(state.tokens.next.id){case"{":jsonObject();break;case"[":jsonArray();break;case"true":case"false":case"null":case"(number)":case"(string)":advance();break;case"-":advance("-"),advance("(number)");break;default:error("E003",state.tokens.next)}}var api,declared,functions,inblock,indent,lookahead,lex,member,membersOnly,predefined,stack,urls,bang={"<":!0,"<=":!0,"==":!0,"===":!0,"!==":!0,"!=":!0,">":!0,">=":!0,"+":!0,"-":!0,"*":!0,"/":!0,"%":!0},functionicity=["closure","exception","global","label","outer","unused","var"],extraModules=[],emitter=new events.EventEmitter,typeofValues={};typeofValues.legacy=["xml","unknown"],typeofValues.es3=["undefined","boolean","number","string","function","object"],typeofValues.es3=typeofValues.es3.concat(typeofValues.legacy),typeofValues.es6=typeofValues.es3.concat("symbol"),type("(number)",function(){return this}),type("(string)",function(){return this}),state.syntax["(identifier)"]={type:"(identifier)",lbp:0,identifier:!0,nud:function(){var v=this.value;return"=>"===state.tokens.next.id?this:(state.funct["(comparray)"].check(v)||state.funct["(scope)"].block.use(v,state.tokens.curr),this)},led:function(){error("E033",state.tokens.next,state.tokens.next.value)}};var baseTemplateSyntax={lbp:0,identifier:!1,template:!0};state.syntax["(template)"]=_.extend({type:"(template)",nud:doTemplateLiteral,led:doTemplateLiteral,noSubst:!1},baseTemplateSyntax),state.syntax["(template middle)"]=_.extend({type:"(template middle)",middle:!0,noSubst:!1},baseTemplateSyntax),state.syntax["(template tail)"]=_.extend({type:"(template tail)",tail:!0,noSubst:!1},baseTemplateSyntax),state.syntax["(no subst template)"]=_.extend({type:"(template)",nud:doTemplateLiteral,led:doTemplateLiteral,noSubst:!0,tail:!0},baseTemplateSyntax),type("(regexp)",function(){return this}),delim("(endline)"),delim("(begin)"),delim("(end)").reach=!0,delim("(error)").reach=!0,delim("}").reach=!0,delim(")"),delim("]"),delim('"').reach=!0,delim("'").reach=!0,delim(";"),delim(":").reach=!0,delim("#"),reserve("else"),reserve("case").reach=!0,reserve("catch"),reserve("default").reach=!0,reserve("finally"),reservevar("arguments",function(x){state.isStrict()&&state.funct["(global)"]&&warning("E008",x)}),reservevar("eval"),reservevar("false"),reservevar("Infinity"),reservevar("null"),reservevar("this",function(x){state.isStrict()&&!isMethod()&&!state.option.validthis&&(state.funct["(statement)"]&&state.funct["(name)"].charAt(0)>"Z"||state.funct["(global)"])&&warning("W040",x)}),reservevar("true"),reservevar("undefined"),assignop("=","assign",20),assignop("+=","assignadd",20),assignop("-=","assignsub",20),assignop("*=","assignmult",20),assignop("/=","assigndiv",20).nud=function(){error("E014")},assignop("%=","assignmod",20),bitwiseassignop("&="),bitwiseassignop("|="),bitwiseassignop("^="),bitwiseassignop("<<="),bitwiseassignop(">>="),bitwiseassignop(">>>="),infix(",",function(left,that){var expr;if(that.exprs=[left],state.option.nocomma&&warning("W127"),!comma({peek:!0}))return that;for(;;){if(!(expr=expression(10)))break;if(that.exprs.push(expr),","!==state.tokens.next.value||!comma())break}return that},10,!0),infix("?",function(left,that){return increaseComplexityCount(),that.left=left,that.right=expression(10),advance(":"),that["else"]=expression(10),that},30);var orPrecendence=40;infix("||",function(left,that){return increaseComplexityCount(),that.left=left,that.right=expression(orPrecendence),that},orPrecendence),infix("&&","and",50),bitwise("|","bitor",70),bitwise("^","bitxor",80),bitwise("&","bitand",90),relation("==",function(left,right){var eqnull=state.option.eqnull&&("null"===(left&&left.value)||"null"===(right&&right.value));switch(!0){case!eqnull&&state.option.eqeqeq:this.from=this.character,warning("W116",this,"===","==");break;case isPoorRelation(left):warning("W041",this,"===",left.value);break;case isPoorRelation(right):warning("W041",this,"===",right.value);break;case isTypoTypeof(right,left,state):warning("W122",this,right.value);break;case isTypoTypeof(left,right,state):warning("W122",this,left.value)}return this}),relation("===",function(left,right){return isTypoTypeof(right,left,state)?warning("W122",this,right.value):isTypoTypeof(left,right,state)&&warning("W122",this,left.value),this}),relation("!=",function(left,right){var eqnull=state.option.eqnull&&("null"===(left&&left.value)||"null"===(right&&right.value));return!eqnull&&state.option.eqeqeq?(this.from=this.character,warning("W116",this,"!==","!=")):isPoorRelation(left)?warning("W041",this,"!==",left.value):isPoorRelation(right)?warning("W041",this,"!==",right.value):isTypoTypeof(right,left,state)?warning("W122",this,right.value):isTypoTypeof(left,right,state)&&warning("W122",this,left.value),this}),relation("!==",function(left,right){return isTypoTypeof(right,left,state)?warning("W122",this,right.value):isTypoTypeof(left,right,state)&&warning("W122",this,left.value),this}),relation("<"),relation(">"),relation("<="),relation(">="),bitwise("<<","shiftleft",120),bitwise(">>","shiftright",120),bitwise(">>>","shiftrightunsigned",120),infix("in","in",120),infix("instanceof","instanceof",120),infix("+",function(left,that){var right;return that.left=left,that.right=right=expression(130),left&&right&&"(string)"===left.id&&"(string)"===right.id?(left.value+=right.value,left.character=right.character,!state.option.scripturl&&reg.javascriptURL.test(left.value)&&warning("W050",left),left):that},130),prefix("+","num"),prefix("+++",function(){return warning("W007"),this.arity="unary",this.right=expression(150),this}),infix("+++",function(left){return warning("W007"),this.left=left,this.right=expression(130),this},130),infix("-","sub",130),prefix("-","neg"),prefix("---",function(){return warning("W006"),this.arity="unary",this.right=expression(150),this}),infix("---",function(left){return warning("W006"),this.left=left,this.right=expression(130),this},130),infix("*","mult",140),infix("/","div",140),infix("%","mod",140),suffix("++"),prefix("++","preinc"),state.syntax["++"].exps=!0,suffix("--"),prefix("--","predec"),state.syntax["--"].exps=!0,prefix("delete",function(){var p=expression(10);return p?("."!==p.id&&"["!==p.id&&warning("W051"),this.first=p,p.identifier&&!state.isStrict()&&(p.forgiveUndef=!0),this):this}).exps=!0,prefix("~",function(){return state.option.bitwise&&warning("W016",this,"~"),this.arity="unary",this.right=expression(150),this}),prefix("...",function(){return state.inES6(!0)||warning("W119",this,"spread/rest operator","6"),state.tokens.next.identifier||"(string)"===state.tokens.next.type||checkPunctuators(state.tokens.next,["[","("])||error("E030",state.tokens.next,state.tokens.next.value),expression(150),this}),prefix("!",function(){return this.arity="unary",this.right=expression(150),this.right||quit("E041",this.line||0),bang[this.right.id]===!0&&warning("W018",this,"!"),this}),prefix("typeof",function(){var p=expression(150);return this.first=this.right=p,p||quit("E041",this.line||0,this.character||0),p.identifier&&(p.forgiveUndef=!0),this}),prefix("new",function(){var mp=metaProperty("target",function(){state.inES6(!0)||warning("W119",state.tokens.prev,"new.target","6");for(var inFunction,c=state.funct;c&&(inFunction=!c["(global)"],c["(arrow)"]);)c=c["(context)"];inFunction||warning("W136",state.tokens.prev,"new.target")});if(mp)return mp;var i,c=expression(155);if(c&&"function"!==c.id)if(c.identifier)switch(c["new"]=!0,c.value){case"Number":case"String":case"Boolean":case"Math":case"JSON":warning("W053",state.tokens.prev,c.value);break;case"Symbol":state.inES6()&&warning("W053",state.tokens.prev,c.value);break;case"Function":state.option.evil||warning("W054");break;case"Date":case"RegExp":case"this":break;default:"function"!==c.id&&(i=c.value.substr(0,1),state.option.newcap&&("A">i||i>"Z")&&!state.funct["(scope)"].isPredefined(c.value)&&warning("W055",state.tokens.curr))}else"."!==c.id&&"["!==c.id&&"("!==c.id&&warning("W056",state.tokens.curr);else state.option.supernew||warning("W057",this);return"("===state.tokens.next.id||state.option.supernew||warning("W058",state.tokens.curr,state.tokens.curr.value),this.first=this.right=c,this}),state.syntax["new"].exps=!0,prefix("void").exps=!0,infix(".",function(left,that){var m=identifier(!1,!0);return"string"==typeof m&&countMember(m),that.left=left,that.right=m,m&&"hasOwnProperty"===m&&"="===state.tokens.next.value&&warning("W001"),!left||"arguments"!==left.value||"callee"!==m&&"caller"!==m?state.option.evil||!left||"document"!==left.value||"write"!==m&&"writeln"!==m||warning("W060",left):state.option.noarg?warning("W059",left,m):state.isStrict()&&error("E008"),state.option.evil||"eval"!==m&&"execScript"!==m||isGlobalEval(left,state)&&warning("W061"),that},160,!0),infix("(",function(left,that){state.option.immed&&left&&!left.immed&&"function"===left.id&&warning("W062");var n=0,p=[];if(left&&"(identifier)"===left.type&&left.value.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)&&-1==="Array Number String Boolean Date Object Error Symbol".indexOf(left.value)&&("Math"===left.value?warning("W063",left):state.option.newcap&&warning("W064",left)),")"!==state.tokens.next.id)for(;p[p.length]=expression(10),n+=1,","===state.tokens.next.id;)comma();return advance(")"),"object"==typeof left&&(state.inES5()||"parseInt"!==left.value||1!==n||warning("W065",state.tokens.curr),state.option.evil||("eval"===left.value||"Function"===left.value||"execScript"===left.value?(warning("W061",left),p[0]&&"(string)"===[0].id&&addInternalSrc(left,p[0].value)):!p[0]||"(string)"!==p[0].id||"setTimeout"!==left.value&&"setInterval"!==left.value?!p[0]||"(string)"!==p[0].id||"."!==left.value||"window"!==left.left.value||"setTimeout"!==left.right&&"setInterval"!==left.right||(warning("W066",left),addInternalSrc(left,p[0].value)):(warning("W066",left),addInternalSrc(left,p[0].value))),left.identifier||"."===left.id||"["===left.id||"=>"===left.id||"("===left.id||"&&"===left.id||"||"===left.id||"?"===left.id||state.inES6()&&left["(name)"]||warning("W067",that)),that.left=left,that},155,!0).exps=!0,prefix("(",function(){var pn1,ret,triggerFnExpr,first,last,pn=state.tokens.next,i=-1,parens=1,opening=state.tokens.curr,preceeding=state.tokens.prev,isNecessary=!state.option.singleGroups;do"("===pn.value?parens+=1:")"===pn.value&&(parens-=1),i+=1,pn1=pn,pn=peek(i);while((0!==parens||")"!==pn1.value)&&";"!==pn.value&&"(end)"!==pn.type);if("function"===state.tokens.next.id&&(triggerFnExpr=state.tokens.next.immed=!0),"=>"===pn.value)return doFunction({type:"arrow",parsedOpening:!0});var exprs=[];if(")"!==state.tokens.next.id)for(;exprs.push(expression(10)),","===state.tokens.next.id;)state.option.nocomma&&warning("W127"),comma();return advance(")",this),state.option.immed&&exprs[0]&&"function"===exprs[0].id&&"("!==state.tokens.next.id&&"."!==state.tokens.next.id&&"["!==state.tokens.next.id&&warning("W068",this),exprs.length?(exprs.length>1?(ret=Object.create(state.syntax[","]),ret.exprs=exprs,first=exprs[0],last=exprs[exprs.length-1],isNecessary||(isNecessary=preceeding.assign||preceeding.delim)):(ret=first=last=exprs[0],isNecessary||(isNecessary=opening.beginsStmt&&("{"===ret.id||triggerFnExpr||isFunctor(ret))||triggerFnExpr&&(!isEndOfExpr()||"}"!==state.tokens.prev.id)||isFunctor(ret)&&!isEndOfExpr()||"{"===ret.id&&"=>"===preceeding.id||"(number)"===ret.type&&checkPunctuator(pn,".")&&/^\\d+$/.test(ret.value))),ret&&(!isNecessary&&(first.left||first.right||ret.exprs)&&(isNecessary=!isBeginOfExpr(preceeding)&&first.lbp<=preceeding.lbp||!isEndOfExpr()&&last.lbp<state.tokens.next.lbp),isNecessary||warning("W126",opening),ret.paren=!0),ret):void 0}),application("=>"),infix("[",function(left,that){var s,e=expression(10);return e&&"(string)"===e.type&&(state.option.evil||"eval"!==e.value&&"execScript"!==e.value||isGlobalEval(left,state)&&warning("W061"),countMember(e.value),!state.option.sub&&reg.identifier.test(e.value)&&(s=state.syntax[e.value],s&&isReserved(s)||warning("W069",state.tokens.prev,e.value))),advance("]",that),e&&"hasOwnProperty"===e.value&&"="===state.tokens.next.value&&warning("W001"),that.left=left,that.right=e,that},160,!0),prefix("[",function(){var blocktype=lookupBlockType();if(blocktype.isCompArray)return state.option.esnext||state.inMoz()||warning("W118",state.tokens.curr,"array comprehension"),comprehensiveArrayExpression();if(blocktype.isDestAssign)return this.destructAssign=destructuringPattern({openingParsed:!0,assignment:!0}),this;var b=state.tokens.curr.line!==startLine(state.tokens.next);for(this.first=[],b&&(indent+=state.option.indent,state.tokens.next.from===indent+state.option.indent&&(indent+=state.option.indent));"(end)"!==state.tokens.next.id;){for(;","===state.tokens.next.id;){if(!state.option.elision){if(state.inES5()){warning("W128");do advance(",");while(","===state.tokens.next.id);continue}warning("W070")}advance(",")}if("]"===state.tokens.next.id)break;if(this.first.push(expression(10)),","!==state.tokens.next.id)break;if(comma({allowTrailing:!0}),"]"===state.tokens.next.id&&!state.inES5()){warning("W070",state.tokens.curr);break}}return b&&(indent-=state.option.indent),advance("]",this),this}),function(x){x.nud=function(){var b,f,i,p,t,nextVal,isGeneratorMethod=!1,props=Object.create(null);b=state.tokens.curr.line!==startLine(state.tokens.next),b&&(indent+=state.option.indent,state.tokens.next.from===indent+state.option.indent&&(indent+=state.option.indent));var blocktype=lookupBlockType();if(blocktype.isDestAssign)return this.destructAssign=destructuringPattern({openingParsed:!0,assignment:!0}),this;for(;"}"!==state.tokens.next.id;){if(nextVal=state.tokens.next.value,!state.tokens.next.identifier||","!==peekIgnoreEOL().id&&"}"!==peekIgnoreEOL().id)if(":"===peek().id||"get"!==nextVal&&"set"!==nextVal){if("*"===state.tokens.next.value&&"(punctuator)"===state.tokens.next.type?(state.inES6()||warning("W104",state.tokens.next,"generator functions","6"),advance("*"),isGeneratorMethod=!0):isGeneratorMethod=!1,"["===state.tokens.next.id)i=computedPropertyName(),state.nameStack.set(i);else if(state.nameStack.set(state.tokens.next),i=propertyName(),saveProperty(props,i,state.tokens.next),"string"!=typeof i)break;"("===state.tokens.next.value?(state.inES6()||warning("W104",state.tokens.curr,"concise methods","6"),doFunction({type:isGeneratorMethod?"generator":null})):(advance(":"),expression(10))}else advance(nextVal),state.inES5()||error("E034"),i=propertyName(),i||state.inES6()||error("E035"),i&&saveAccessor(nextVal,props,i,state.tokens.curr),t=state.tokens.next,f=doFunction(),p=f["(params)"],"get"===nextVal&&i&&p?warning("W076",t,p[0],i):"set"!==nextVal||!i||p&&1===p.length||warning("W077",t,i);else state.inES6()||warning("W104",state.tokens.next,"object short notation","6"),i=propertyName(!0),saveProperty(props,i,state.tokens.next),expression(10);if(countMember(i),","!==state.tokens.next.id)break;comma({allowTrailing:!0,property:!0}),","===state.tokens.next.id?warning("W070",state.tokens.curr):"}"!==state.tokens.next.id||state.inES5()||warning("W070",state.tokens.curr)}return b&&(indent-=state.option.indent),advance("}",this),checkProperties(props),this},x.fud=function(){error("E036",state.tokens.curr)}}(delim("{"));var conststatement=stmt("const",function(context){return blockVariableStatement("const",this,context)});conststatement.exps=!0;var letstatement=stmt("let",function(context){return blockVariableStatement("let",this,context)});letstatement.exps=!0;var varstatement=stmt("var",function(context){var tokens,lone,value,prefix=context&&context.prefix,inexport=context&&context.inexport,implied=context&&context.implied,report=!(context&&context.ignore);for(this.first=[];;){var names=[];_.contains(["{","["],state.tokens.next.value)?(tokens=destructuringPattern(),lone=!1):(tokens=[{id:identifier(),token:state.tokens.curr}],lone=!0),prefix&&implied||!report||!state.option.varstmt||warning("W132",this),this.first=this.first.concat(names);for(var t in tokens)tokens.hasOwnProperty(t)&&(t=tokens[t],!implied&&state.funct["(global)"]&&(predefined[t.id]===!1?warning("W079",t.token,t.id):state.option.futurehostile===!1&&(!state.inES5()&&vars.ecmaIdentifiers[5][t.id]===!1||!state.inES6()&&vars.ecmaIdentifiers[6][t.id]===!1)&&warning("W129",t.token,t.id)),t.id&&("for"===implied?(state.funct["(scope)"].has(t.id)||report&&warning("W088",t.token,t.id),state.funct["(scope)"].block.use(t.id,t.token)):(state.funct["(scope)"].addlabel(t.id,{type:"var",token:t.token}),lone&&inexport&&state.funct["(scope)"].setExported(t.id,t.token)),names.push(t.token)));if("="===state.tokens.next.id&&(state.nameStack.set(state.tokens.curr),advance("="),prefix||!report||state.funct["(loopage)"]||"undefined"!==state.tokens.next.id||warning("W080",state.tokens.prev,state.tokens.prev.value),"="===peek(0).id&&state.tokens.next.identifier&&(!prefix&&report&&!state.funct["(params)"]||-1===state.funct["(params)"].indexOf(state.tokens.next.value))&&warning("W120",state.tokens.next,state.tokens.next.value),value=expression(prefix?120:10),lone?tokens[0].first=value:destructuringPatternMatch(names,value)),","!==state.tokens.next.id)break;comma()}return this});varstatement.exps=!0,blockstmt("class",function(){return classdef.call(this,!0)}),blockstmt("function",function(context){var inexport=context&&context.inexport,generator=!1;"*"===state.tokens.next.value&&(advance("*"),state.inES6({strict:!0})?generator=!0:warning("W119",state.tokens.curr,"function*","6")),inblock&&warning("W082",state.tokens.curr);var i=optionalidentifier();return state.funct["(scope)"].addlabel(i,{type:"function",token:state.tokens.curr}),void 0===i?warning("W025"):inexport&&state.funct["(scope)"].setExported(i,state.tokens.prev),doFunction({name:i,statement:this,type:generator?"generator":null,ignoreLoopFunc:inblock}),"("===state.tokens.next.id&&state.tokens.next.line===state.tokens.curr.line&&error("E039"),this}),prefix("function",function(){var generator=!1;"*"===state.tokens.next.value&&(state.inES6()||warning("W119",state.tokens.curr,"function*","6"),advance("*"),generator=!0);var i=optionalidentifier();return doFunction({name:i,type:generator?"generator":null}),this}),blockstmt("if",function(){var t=state.tokens.next;increaseComplexityCount(),state.condition=!0,advance("(");var expr=expression(0);checkCondAssignment(expr);var forinifcheck=null;state.option.forin&&state.forinifcheckneeded&&(state.forinifcheckneeded=!1,forinifcheck=state.forinifchecks[state.forinifchecks.length-1],forinifcheck.type="(punctuator)"===expr.type&&"!"===expr.value?"(negative)":"(positive)"),advance(")",t),state.condition=!1;var s=block(!0,!0);return forinifcheck&&"(negative)"===forinifcheck.type&&s&&s[0]&&"(identifier)"===s[0].type&&"continue"===s[0].value&&(forinifcheck.type="(negative-with-continue)"),"else"===state.tokens.next.id&&(advance("else"),"if"===state.tokens.next.id||"switch"===state.tokens.next.id?statement():block(!0,!0)),this}),blockstmt("try",function(){function doCatch(){if(advance("catch"),advance("("),state.funct["(scope)"].stack("catchparams"),checkPunctuators(state.tokens.next,["[","{"])){var tokens=destructuringPattern();_.each(tokens,function(token){token.id&&state.funct["(scope)"].addParam(token.id,token,"exception")})}else"(identifier)"!==state.tokens.next.type?warning("E030",state.tokens.next,state.tokens.next.value):state.funct["(scope)"].addParam(identifier(),state.tokens.curr,"exception");"if"===state.tokens.next.value&&(state.inMoz()||warning("W118",state.tokens.curr,"catch filter"),advance("if"),expression(0)),advance(")"),block(!1),state.funct["(scope)"].unstack()}var b;for(block(!0);"catch"===state.tokens.next.id;)increaseComplexityCount(),b&&!state.inMoz()&&warning("W118",state.tokens.next,"multiple catch blocks"),doCatch(),b=!0;return"finally"===state.tokens.next.id?(advance("finally"),block(!0),void 0):(b||error("E021",state.tokens.next,"catch",state.tokens.next.value),this)}),blockstmt("while",function(){var t=state.tokens.next;return state.funct["(breakage)"]+=1,state.funct["(loopage)"]+=1,increaseComplexityCount(),advance("("),checkCondAssignment(expression(0)),advance(")",t),block(!0,!0),state.funct["(breakage)"]-=1,state.funct["(loopage)"]-=1,this}).labelled=!0,blockstmt("with",function(){var t=state.tokens.next;return state.isStrict()?error("E010",state.tokens.curr):state.option.withstmt||warning("W085",state.tokens.curr),advance("("),expression(0),advance(")",t),block(!0,!0),this}),blockstmt("switch",function(){var t=state.tokens.next,g=!1,noindent=!1;
for(state.funct["(breakage)"]+=1,advance("("),checkCondAssignment(expression(0)),advance(")",t),t=state.tokens.next,advance("{"),state.tokens.next.from===indent&&(noindent=!0),noindent||(indent+=state.option.indent),this.cases=[];;)switch(state.tokens.next.id){case"case":switch(state.funct["(verb)"]){case"yield":case"break":case"case":case"continue":case"return":case"switch":case"throw":break;default:state.tokens.curr.caseFallsThrough||warning("W086",state.tokens.curr,"case")}advance("case"),this.cases.push(expression(0)),increaseComplexityCount(),g=!0,advance(":"),state.funct["(verb)"]="case";break;case"default":switch(state.funct["(verb)"]){case"yield":case"break":case"continue":case"return":case"throw":break;default:this.cases.length&&(state.tokens.curr.caseFallsThrough||warning("W086",state.tokens.curr,"default"))}advance("default"),g=!0,advance(":");break;case"}":return noindent||(indent-=state.option.indent),advance("}",t),state.funct["(breakage)"]-=1,state.funct["(verb)"]=void 0,void 0;case"(end)":return error("E023",state.tokens.next,"}"),void 0;default:if(indent+=state.option.indent,g)switch(state.tokens.curr.id){case",":return error("E040"),void 0;case":":g=!1,statements();break;default:return error("E025",state.tokens.curr),void 0}else{if(":"!==state.tokens.curr.id)return error("E021",state.tokens.next,"case",state.tokens.next.value),void 0;advance(":"),error("E024",state.tokens.curr,":"),statements()}indent-=state.option.indent}return this}).labelled=!0,stmt("debugger",function(){return state.option.debug||warning("W087",this),this}).exps=!0,function(){var x=stmt("do",function(){state.funct["(breakage)"]+=1,state.funct["(loopage)"]+=1,increaseComplexityCount(),this.first=block(!0,!0),advance("while");var t=state.tokens.next;return advance("("),checkCondAssignment(expression(0)),advance(")",t),state.funct["(breakage)"]-=1,state.funct["(loopage)"]-=1,this});x.labelled=!0,x.exps=!0}(),blockstmt("for",function(){var s,t=state.tokens.next,letscope=!1,foreachtok=null;"each"===t.value&&(foreachtok=t,advance("each"),state.inMoz()||warning("W118",state.tokens.curr,"for each")),increaseComplexityCount(),advance("(");var nextop,comma,initializer,i=0,inof=["in","of"],level=0;checkPunctuators(state.tokens.next,["{","["])&&++level;do{if(nextop=peek(i),++i,checkPunctuators(nextop,["{","["])?++level:checkPunctuators(nextop,["}","]"])&&--level,0>level)break;0===level&&(!comma&&checkPunctuator(nextop,",")?comma=nextop:!initializer&&checkPunctuator(nextop,"=")&&(initializer=nextop))}while(level>0||!_.contains(inof,nextop.value)&&";"!==nextop.value&&"(end)"!==nextop.type);if(_.contains(inof,nextop.value)){state.inES6()||"of"!==nextop.value||warning("W104",nextop,"for of","6");var ok=!(initializer||comma);if(initializer&&error("W133",comma,nextop.value,"initializer is forbidden"),comma&&error("W133",comma,nextop.value,"more than one ForBinding"),"var"===state.tokens.next.id?(advance("var"),state.tokens.curr.fud({prefix:!0})):"let"===state.tokens.next.id||"const"===state.tokens.next.id?(advance(state.tokens.next.id),letscope=!0,state.funct["(scope)"].stack(),state.tokens.curr.fud({prefix:!0})):Object.create(varstatement).fud({prefix:!0,implied:"for",ignore:!ok}),advance(nextop.value),expression(20),advance(")",t),"in"===nextop.value&&state.option.forin&&(state.forinifcheckneeded=!0,void 0===state.forinifchecks&&(state.forinifchecks=[]),state.forinifchecks.push({type:"(none)"})),state.funct["(breakage)"]+=1,state.funct["(loopage)"]+=1,s=block(!0,!0),"in"===nextop.value&&state.option.forin){if(state.forinifchecks&&state.forinifchecks.length>0){var check=state.forinifchecks.pop();(s&&s.length>0&&("object"!=typeof s[0]||"if"!==s[0].value)||"(positive)"===check.type&&s.length>1||"(negative)"===check.type)&&warning("W089",this)}state.forinifcheckneeded=!1}state.funct["(breakage)"]-=1,state.funct["(loopage)"]-=1}else{if(foreachtok&&error("E045",foreachtok),";"!==state.tokens.next.id)if("var"===state.tokens.next.id)advance("var"),state.tokens.curr.fud();else if("let"===state.tokens.next.id)advance("let"),letscope=!0,state.funct["(scope)"].stack(),state.tokens.curr.fud();else for(;expression(0,"for"),","===state.tokens.next.id;)comma();if(nolinebreak(state.tokens.curr),advance(";"),state.funct["(loopage)"]+=1,";"!==state.tokens.next.id&&checkCondAssignment(expression(0)),nolinebreak(state.tokens.curr),advance(";"),";"===state.tokens.next.id&&error("E021",state.tokens.next,")",";"),")"!==state.tokens.next.id)for(;expression(0,"for"),","===state.tokens.next.id;)comma();advance(")",t),state.funct["(breakage)"]+=1,block(!0,!0),state.funct["(breakage)"]-=1,state.funct["(loopage)"]-=1}return letscope&&state.funct["(scope)"].unstack(),this}).labelled=!0,stmt("break",function(){var v=state.tokens.next.value;return state.option.asi||nolinebreak(this),";"===state.tokens.next.id||state.tokens.next.reach||state.tokens.curr.line!==startLine(state.tokens.next)?0===state.funct["(breakage)"]&&warning("W052",state.tokens.next,this.value):(state.funct["(scope)"].funct.hasBreakLabel(v)||warning("W090",state.tokens.next,v),this.first=state.tokens.next,advance()),reachable(this),this}).exps=!0,stmt("continue",function(){var v=state.tokens.next.value;return 0===state.funct["(breakage)"]&&warning("W052",state.tokens.next,this.value),state.funct["(loopage)"]||warning("W052",state.tokens.next,this.value),state.option.asi||nolinebreak(this),";"===state.tokens.next.id||state.tokens.next.reach||state.tokens.curr.line===startLine(state.tokens.next)&&(state.funct["(scope)"].funct.hasBreakLabel(v)||warning("W090",state.tokens.next,v),this.first=state.tokens.next,advance()),reachable(this),this}).exps=!0,stmt("return",function(){return this.line===startLine(state.tokens.next)?";"===state.tokens.next.id||state.tokens.next.reach||(this.first=expression(0),!this.first||"(punctuator)"!==this.first.type||"="!==this.first.value||this.first.paren||state.option.boss||warningAt("W093",this.first.line,this.first.character)):"(punctuator)"===state.tokens.next.type&&["[","{","+","-"].indexOf(state.tokens.next.value)>-1&&nolinebreak(this),reachable(this),this}).exps=!0,function(x){x.exps=!0,x.lbp=25}(prefix("yield",function(){var prev=state.tokens.prev;state.inES6(!0)&&!state.funct["(generator)"]?"(catch)"===state.funct["(name)"]&&state.funct["(context)"]["(generator)"]||error("E046",state.tokens.curr,"yield"):state.inES6()||warning("W104",state.tokens.curr,"yield","6"),state.funct["(generator)"]="yielded";var delegatingYield=!1;return"*"===state.tokens.next.value&&(delegatingYield=!0,advance("*")),this.line!==startLine(state.tokens.next)&&state.inMoz()?state.option.asi||nolinebreak(this):((delegatingYield||";"!==state.tokens.next.id&&!state.option.asi&&!state.tokens.next.reach&&state.tokens.next.nud)&&(nobreaknonadjacent(state.tokens.curr,state.tokens.next),this.first=expression(10),"(punctuator)"!==this.first.type||"="!==this.first.value||this.first.paren||state.option.boss||warningAt("W093",this.first.line,this.first.character)),state.inMoz()&&")"!==state.tokens.next.id&&(prev.lbp>30||!prev.assign&&!isEndOfExpr()||"yield"===prev.id)&&error("E050",this)),this})),stmt("throw",function(){return nolinebreak(this),this.first=expression(20),reachable(this),this}).exps=!0,stmt("import",function(){if(state.inES6()||warning("W119",state.tokens.curr,"import","6"),"(string)"===state.tokens.next.type)return advance("(string)"),this;if(state.tokens.next.identifier){if(this.name=identifier(),state.funct["(scope)"].addlabel(this.name,{type:"const",token:state.tokens.curr}),","!==state.tokens.next.value)return advance("from"),advance("(string)"),this;advance(",")}if("*"===state.tokens.next.id)advance("*"),advance("as"),state.tokens.next.identifier&&(this.name=identifier(),state.funct["(scope)"].addlabel(this.name,{type:"const",token:state.tokens.curr}));else for(advance("{");;){if("}"===state.tokens.next.value){advance("}");break}var importName;if("default"===state.tokens.next.type?(importName="default",advance("default")):importName=identifier(),"as"===state.tokens.next.value&&(advance("as"),importName=identifier()),state.funct["(scope)"].addlabel(importName,{type:"const",token:state.tokens.curr}),","!==state.tokens.next.value){if("}"===state.tokens.next.value){advance("}");break}error("E024",state.tokens.next,state.tokens.next.value);break}advance(",")}return advance("from"),advance("(string)"),this}).exps=!0,stmt("export",function(){var token,identifier,ok=!0;if(state.inES6()||(warning("W119",state.tokens.curr,"export","6"),ok=!1),state.funct["(scope)"].block.isGlobal()||(error("E053",state.tokens.curr),ok=!1),"*"===state.tokens.next.value)return advance("*"),advance("from"),advance("(string)"),this;if("default"===state.tokens.next.type){state.nameStack.set(state.tokens.next),advance("default");var exportType=state.tokens.next.id;return("function"===exportType||"class"===exportType)&&(this.block=!0),token=peek(),expression(10),identifier=token.value,this.block&&(state.funct["(scope)"].addlabel(identifier,{type:exportType,token:token}),state.funct["(scope)"].setExported(identifier,token)),this}if("{"===state.tokens.next.value){advance("{");for(var exportedTokens=[];;){if(state.tokens.next.identifier||error("E030",state.tokens.next,state.tokens.next.value),advance(),exportedTokens.push(state.tokens.curr),"as"===state.tokens.next.value&&(advance("as"),state.tokens.next.identifier||error("E030",state.tokens.next,state.tokens.next.value),advance()),","!==state.tokens.next.value){if("}"===state.tokens.next.value){advance("}");break}error("E024",state.tokens.next,state.tokens.next.value);break}advance(",")}return"from"===state.tokens.next.value?(advance("from"),advance("(string)")):ok&&exportedTokens.forEach(function(token){state.funct["(scope)"].setExported(token.value,token)}),this}if("var"===state.tokens.next.id)advance("var"),state.tokens.curr.fud({inexport:!0});else if("let"===state.tokens.next.id)advance("let"),state.tokens.curr.fud({inexport:!0});else if("const"===state.tokens.next.id)advance("const"),state.tokens.curr.fud({inexport:!0});else if("function"===state.tokens.next.id)this.block=!0,advance("function"),state.syntax["function"].fud({inexport:!0});else if("class"===state.tokens.next.id){this.block=!0,advance("class");var classNameToken=state.tokens.next;state.syntax["class"].fud(),state.funct["(scope)"].setExported(classNameToken.value,classNameToken)}else error("E024",state.tokens.next,state.tokens.next.value);return this}).exps=!0,FutureReservedWord("abstract"),FutureReservedWord("boolean"),FutureReservedWord("byte"),FutureReservedWord("char"),FutureReservedWord("class",{es5:!0,nud:classdef}),FutureReservedWord("double"),FutureReservedWord("enum",{es5:!0}),FutureReservedWord("export",{es5:!0}),FutureReservedWord("extends",{es5:!0}),FutureReservedWord("final"),FutureReservedWord("float"),FutureReservedWord("goto"),FutureReservedWord("implements",{es5:!0,strictOnly:!0}),FutureReservedWord("import",{es5:!0}),FutureReservedWord("int"),FutureReservedWord("interface",{es5:!0,strictOnly:!0}),FutureReservedWord("long"),FutureReservedWord("native"),FutureReservedWord("package",{es5:!0,strictOnly:!0}),FutureReservedWord("private",{es5:!0,strictOnly:!0}),FutureReservedWord("protected",{es5:!0,strictOnly:!0}),FutureReservedWord("public",{es5:!0,strictOnly:!0}),FutureReservedWord("short"),FutureReservedWord("static",{es5:!0,strictOnly:!0}),FutureReservedWord("super",{es5:!0}),FutureReservedWord("synchronized"),FutureReservedWord("transient"),FutureReservedWord("volatile");var lookupBlockType=function(){var pn,pn1,prev,i=-1,bracketStack=0,ret={};checkPunctuators(state.tokens.curr,["[","{"])&&(bracketStack+=1);do{if(prev=-1===i?state.tokens.curr:pn,pn=-1===i?state.tokens.next:peek(i),pn1=peek(i+1),i+=1,checkPunctuators(pn,["[","{"])?bracketStack+=1:checkPunctuators(pn,["]","}"])&&(bracketStack-=1),1===bracketStack&&pn.identifier&&"for"===pn.value&&!checkPunctuator(prev,".")){ret.isCompArray=!0,ret.notJson=!0;break}if(0===bracketStack&&checkPunctuators(pn,["}","]"])){if("="===pn1.value){ret.isDestAssign=!0,ret.notJson=!0;break}if("."===pn1.value){ret.notJson=!0;break}}checkPunctuator(pn,";")&&(ret.isBlock=!0,ret.notJson=!0)}while(bracketStack>0&&"(end)"!==pn.id);return ret},arrayComprehension=function(){function declare(v){var l=_current.variables.filter(function(elt){return elt.value===v?(elt.undef=!1,v):void 0}).length;return 0!==l}function use(v){var l=_current.variables.filter(function(elt){return elt.value!==v||elt.undef?void 0:(elt.unused===!0&&(elt.unused=!1),v)}).length;return 0===l}var _current,CompArray=function(){this.mode="use",this.variables=[]},_carrays=[];return{stack:function(){_current=new CompArray,_carrays.push(_current)},unstack:function(){_current.variables.filter(function(v){v.unused&&warning("W098",v.token,v.raw_text||v.value),v.undef&&state.funct["(scope)"].block.use(v.value,v.token)}),_carrays.splice(-1,1),_current=_carrays[_carrays.length-1]},setState:function(s){_.contains(["use","define","generate","filter"],s)&&(_current.mode=s)},check:function(v){return _current?_current&&"use"===_current.mode?(use(v)&&_current.variables.push({funct:state.funct,token:state.tokens.curr,value:v,undef:!0,unused:!1}),!0):_current&&"define"===_current.mode?(declare(v)||_current.variables.push({funct:state.funct,token:state.tokens.curr,value:v,undef:!1,unused:!0}),!0):_current&&"generate"===_current.mode?(state.funct["(scope)"].block.use(v,state.tokens.curr),!0):_current&&"filter"===_current.mode?(use(v)&&state.funct["(scope)"].block.use(v,state.tokens.curr),!0):!1:void 0}}},escapeRegex=function(str){return str.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g,"\\\\$&")},itself=function(s,o,g){function each(obj,cb){obj&&(Array.isArray(obj)||"object"!=typeof obj||(obj=Object.keys(obj)),obj.forEach(cb))}var i,k,x,reIgnoreStr,reIgnore,optionKeys,newOptionObj={},newIgnoredObj={};o=_.clone(o),state.reset(),o&&o.scope?JSHINT.scope=o.scope:(JSHINT.errors=[],JSHINT.undefs=[],JSHINT.internals=[],JSHINT.blacklist={},JSHINT.scope="(main)"),predefined=Object.create(null),combine(predefined,vars.ecmaIdentifiers[3]),combine(predefined,vars.reservedVars),combine(predefined,g||{}),declared=Object.create(null);var exported=Object.create(null);if(o)for(each(o.predef||null,function(item){var slice,prop;"-"===item[0]?(slice=item.slice(1),JSHINT.blacklist[slice]=slice,delete predefined[slice]):(prop=Object.getOwnPropertyDescriptor(o.predef,item),predefined[item]=prop?prop.value:!1)}),each(o.exported||null,function(item){exported[item]=!0}),delete o.predef,delete o.exported,optionKeys=Object.keys(o),x=0;optionKeys.length>x;x++)if(/^-W\\d{3}$/g.test(optionKeys[x]))newIgnoredObj[optionKeys[x].slice(1)]=!0;else{var optionKey=optionKeys[x];newOptionObj[optionKey]=o[optionKey],("esversion"===optionKey&&5===o[optionKey]||"es5"===optionKey&&o[optionKey])&&warning("I003"),"newcap"===optionKeys[x]&&o[optionKey]===!1&&(newOptionObj["(explicitNewcap)"]=!0)}state.option=newOptionObj,state.ignored=newIgnoredObj,state.option.indent=state.option.indent||4,state.option.maxerr=state.option.maxerr||50,indent=1;var scopeManagerInst=scopeManager(state,predefined,exported,declared);if(scopeManagerInst.on("warning",function(ev){warning.apply(null,[ev.code,ev.token].concat(ev.data))}),scopeManagerInst.on("error",function(ev){error.apply(null,[ev.code,ev.token].concat(ev.data))}),state.funct=functor("(global)",null,{"(global)":!0,"(scope)":scopeManagerInst,"(comparray)":arrayComprehension(),"(metrics)":createMetrics(state.tokens.next)}),functions=[state.funct],urls=[],stack=null,member={},membersOnly=null,inblock=!1,lookahead=[],!isString(s)&&!Array.isArray(s))return errorAt("E004",0),!1;api={get isJSON(){return state.jsonMode},getOption:function(name){return state.option[name]||null},getCache:function(name){return state.cache[name]},setCache:function(name,value){state.cache[name]=value},warn:function(code,data){warningAt.apply(null,[code,data.line,data.char].concat(data.data))},on:function(names,listener){names.split(" ").forEach(function(name){emitter.on(name,listener)}.bind(this))}},emitter.removeAllListeners(),(extraModules||[]).forEach(function(func){func(api)}),state.tokens.prev=state.tokens.curr=state.tokens.next=state.syntax["(begin)"],o&&o.ignoreDelimiters&&(Array.isArray(o.ignoreDelimiters)||(o.ignoreDelimiters=[o.ignoreDelimiters]),o.ignoreDelimiters.forEach(function(delimiterPair){delimiterPair.start&&delimiterPair.end&&(reIgnoreStr=escapeRegex(delimiterPair.start)+"[\\\\s\\\\S]*?"+escapeRegex(delimiterPair.end),reIgnore=RegExp(reIgnoreStr,"ig"),s=s.replace(reIgnore,function(match){return match.replace(/./g," ")}))})),lex=new Lexer(s),lex.on("warning",function(ev){warningAt.apply(null,[ev.code,ev.line,ev.character].concat(ev.data))}),lex.on("error",function(ev){errorAt.apply(null,[ev.code,ev.line,ev.character].concat(ev.data))}),lex.on("fatal",function(ev){quit("E041",ev.line,ev.from)}),lex.on("Identifier",function(ev){emitter.emit("Identifier",ev)}),lex.on("String",function(ev){emitter.emit("String",ev)}),lex.on("Number",function(ev){emitter.emit("Number",ev)}),lex.start();for(var name in o)_.has(o,name)&&checkOption(name,state.tokens.curr);assume(),combine(predefined,g||{}),comma.first=!0;try{switch(advance(),state.tokens.next.id){case"{":case"[":destructuringAssignOrJsonValue();break;default:directives(),state.directive["use strict"]&&"global"!==state.option.strict&&warning("W097",state.tokens.prev),statements()}"(end)"!==state.tokens.next.id&&quit("E041",state.tokens.curr.line),state.funct["(scope)"].unstack()}catch(err){if(!err||"JSHintError"!==err.name)throw err;var nt=state.tokens.next||{};JSHINT.errors.push({scope:"(main)",raw:err.raw,code:err.code,reason:err.message,line:err.line||nt.line,character:err.character||nt.from},null)}if("(main)"===JSHINT.scope)for(o=o||{},i=0;JSHINT.internals.length>i;i+=1)k=JSHINT.internals[i],o.scope=k.elem,itself(k.value,o,g);return 0===JSHINT.errors.length};return itself.addModule=function(func){extraModules.push(func)},itself.addModule(style.register),itself.data=function(){var fu,f,i,j,n,globals,data={functions:[],options:state.option};itself.errors.length&&(data.errors=itself.errors),state.jsonMode&&(data.json=!0);var impliedGlobals=state.funct["(scope)"].getImpliedGlobals();for(impliedGlobals.length>0&&(data.implieds=impliedGlobals),urls.length>0&&(data.urls=urls),globals=state.funct["(scope)"].getUsedOrDefinedGlobals(),globals.length>0&&(data.globals=globals),i=1;functions.length>i;i+=1){for(f=functions[i],fu={},j=0;functionicity.length>j;j+=1)fu[functionicity[j]]=[];for(j=0;functionicity.length>j;j+=1)0===fu[functionicity[j]].length&&delete fu[functionicity[j]];fu.name=f["(name)"],fu.param=f["(params)"],fu.line=f["(line)"],fu.character=f["(character)"],fu.last=f["(last)"],fu.lastcharacter=f["(lastcharacter)"],fu.metrics={complexity:f["(metrics)"].ComplexityCount,parameters:f["(metrics)"].arity,statements:f["(metrics)"].statementCount},data.functions.push(fu)}var unuseds=state.funct["(scope)"].getUnuseds();unuseds.length>0&&(data.unused=unuseds);for(n in member)if("number"==typeof member[n]){data.member=member;break}return data},itself.jshint=itself,itself}();"object"==typeof exports&&exports&&(exports.JSHINT=JSHINT)},{"../lodash":"/node_modules/jshint/lodash.js","./lex.js":"/node_modules/jshint/src/lex.js","./messages.js":"/node_modules/jshint/src/messages.js","./options.js":"/node_modules/jshint/src/options.js","./reg.js":"/node_modules/jshint/src/reg.js","./scope-manager.js":"/node_modules/jshint/src/scope-manager.js","./state.js":"/node_modules/jshint/src/state.js","./style.js":"/node_modules/jshint/src/style.js","./vars.js":"/node_modules/jshint/src/vars.js",events:"/node_modules/browserify/node_modules/events/events.js"}],"/node_modules/jshint/src/lex.js":[function(_dereq_,module,exports){"use strict";function asyncTrigger(){var _checks=[];return{push:function(fn){_checks.push(fn)},check:function(){for(var check=0;_checks.length>check;++check)_checks[check]();_checks.splice(0,_checks.length)}}}function Lexer(source){var lines=source;"string"==typeof lines&&(lines=lines.replace(/\\r\\n/g,"\\n").replace(/\\r/g,"\\n").split("\\n")),lines[0]&&"#!"===lines[0].substr(0,2)&&(-1!==lines[0].indexOf("node")&&(state.option.node=!0),lines[0]=""),this.emitter=new events.EventEmitter,this.source=source,this.setLines(lines),this.prereg=!0,this.line=0,this.char=1,this.from=1,this.input="",this.inComment=!1,this.context=[],this.templateStarts=[];for(var i=0;state.option.indent>i;i+=1)state.tab+=" ";this.ignoreLinterErrors=!1}var _=_dereq_("../lodash"),events=_dereq_("events"),reg=_dereq_("./reg.js"),state=_dereq_("./state.js").state,unicodeData=_dereq_("../data/ascii-identifier-data.js"),asciiIdentifierStartTable=unicodeData.asciiIdentifierStartTable,asciiIdentifierPartTable=unicodeData.asciiIdentifierPartTable,Token={Identifier:1,Punctuator:2,NumericLiteral:3,StringLiteral:4,Comment:5,Keyword:6,NullLiteral:7,BooleanLiteral:8,RegExp:9,TemplateHead:10,TemplateMiddle:11,TemplateTail:12,NoSubstTemplate:13},Context={Block:1,Template:2};Lexer.prototype={_lines:[],inContext:function(ctxType){return this.context.length>0&&this.context[this.context.length-1].type===ctxType},pushContext:function(ctxType){this.context.push({type:ctxType})},popContext:function(){return this.context.pop()},isContext:function(context){return this.context.length>0&&this.context[this.context.length-1]===context},currentContext:function(){return this.context.length>0&&this.context[this.context.length-1]},getLines:function(){return this._lines=state.lines,this._lines},setLines:function(val){this._lines=val,state.lines=this._lines},peek:function(i){return this.input.charAt(i||0)},skip:function(i){i=i||1,this.char+=i,this.input=this.input.slice(i)},on:function(names,listener){names.split(" ").forEach(function(name){this.emitter.on(name,listener)}.bind(this))},trigger:function(){this.emitter.emit.apply(this.emitter,Array.prototype.slice.call(arguments))},triggerAsync:function(type,args,checks,fn){checks.push(function(){fn()&&this.trigger(type,args)}.bind(this))},scanPunctuator:function(){var ch2,ch3,ch4,ch1=this.peek();switch(ch1){case".":if(/^[0-9]$/.test(this.peek(1)))return null;if("."===this.peek(1)&&"."===this.peek(2))return{type:Token.Punctuator,value:"..."};case"(":case")":case";":case",":case"[":case"]":case":":case"~":case"?":return{type:Token.Punctuator,value:ch1};case"{":return this.pushContext(Context.Block),{type:Token.Punctuator,value:ch1};case"}":return this.inContext(Context.Block)&&this.popContext(),{type:Token.Punctuator,value:ch1};case"#":return{type:Token.Punctuator,value:ch1};case"":return null}return ch2=this.peek(1),ch3=this.peek(2),ch4=this.peek(3),">"===ch1&&">"===ch2&&">"===ch3&&"="===ch4?{type:Token.Punctuator,value:">>>="}:"="===ch1&&"="===ch2&&"="===ch3?{type:Token.Punctuator,value:"==="}:"!"===ch1&&"="===ch2&&"="===ch3?{type:Token.Punctuator,value:"!=="}:">"===ch1&&">"===ch2&&">"===ch3?{type:Token.Punctuator,value:">>>"}:"<"===ch1&&"<"===ch2&&"="===ch3?{type:Token.Punctuator,value:"<<="}:">"===ch1&&">"===ch2&&"="===ch3?{type:Token.Punctuator,value:">>="}:"="===ch1&&">"===ch2?{type:Token.Punctuator,value:ch1+ch2}:ch1===ch2&&"+-<>&|".indexOf(ch1)>=0?{type:Token.Punctuator,value:ch1+ch2}:"<>=!+-*%&|^".indexOf(ch1)>=0?"="===ch2?{type:Token.Punctuator,value:ch1+ch2}:{type:Token.Punctuator,value:ch1}:"/"===ch1?"="===ch2?{type:Token.Punctuator,value:"/="}:{type:Token.Punctuator,value:"/"}:null},scanComments:function(){function commentToken(label,body,opt){var special=["jshint","jslint","members","member","globals","global","exported"],isSpecial=!1,value=label+body,commentType="plain";return opt=opt||{},opt.isMultiline&&(value+="*/"),body=body.replace(/\\n/g," "),"/*"===label&&reg.fallsThrough.test(body)&&(isSpecial=!0,commentType="falls through"),special.forEach(function(str){if(!isSpecial&&("//"!==label||"jshint"===str)&&(" "===body.charAt(str.length)&&body.substr(0,str.length)===str&&(isSpecial=!0,label+=str,body=body.substr(str.length)),isSpecial||" "!==body.charAt(0)||" "!==body.charAt(str.length+1)||body.substr(1,str.length)!==str||(isSpecial=!0,label=label+" "+str,body=body.substr(str.length+1)),isSpecial))switch(str){case"member":commentType="members";break;case"global":commentType="globals";break;default:var options=body.split(":").map(function(v){return v.replace(/^\\s+/,"").replace(/\\s+$/,"")});if(2===options.length)switch(options[0]){case"ignore":switch(options[1]){case"start":self.ignoringLinterErrors=!0,isSpecial=!1;break;case"end":self.ignoringLinterErrors=!1,isSpecial=!1}}commentType=str}}),{type:Token.Comment,commentType:commentType,value:value,body:body,isSpecial:isSpecial,isMultiline:opt.isMultiline||!1,isMalformed:opt.isMalformed||!1}}var ch1=this.peek(),ch2=this.peek(1),rest=this.input.substr(2),startLine=this.line,startChar=this.char,self=this;if("*"===ch1&&"/"===ch2)return this.trigger("error",{code:"E018",line:startLine,character:startChar}),this.skip(2),null;if("/"!==ch1||"*"!==ch2&&"/"!==ch2)return null;if("/"===ch2)return this.skip(this.input.length),commentToken("//",rest);var body="";if("*"===ch2){for(this.inComment=!0,this.skip(2);"*"!==this.peek()||"/"!==this.peek(1);)if(""===this.peek()){if(body+="\\n",!this.nextLine())return this.trigger("error",{code:"E017",line:startLine,character:startChar}),this.inComment=!1,commentToken("/*",body,{isMultiline:!0,isMalformed:!0})}else body+=this.peek(),this.skip();return this.skip(2),this.inComment=!1,commentToken("/*",body,{isMultiline:!0})}},scanKeyword:function(){var result=/^[a-zA-Z_$][a-zA-Z0-9_$]*/.exec(this.input),keywords=["if","in","do","var","for","new","try","let","this","else","case","void","with","enum","while","break","catch","throw","const","yield","class","super","return","typeof","delete","switch","export","import","default","finally","extends","function","continue","debugger","instanceof"];return result&&keywords.indexOf(result[0])>=0?{type:Token.Keyword,value:result[0]}:null},scanIdentifier:function(){function isNonAsciiIdentifierStart(code){return code>256}function isNonAsciiIdentifierPart(code){return code>256}function isHexDigit(str){return/^[0-9a-fA-F]$/.test(str)}function removeEscapeSequences(id){return id.replace(/\\\\u([0-9a-fA-F]{4})/g,function(m0,codepoint){return String.fromCharCode(parseInt(codepoint,16))})}var type,char,id="",index=0,readUnicodeEscapeSequence=function(){if(index+=1,"u"!==this.peek(index))return null;var code,ch1=this.peek(index+1),ch2=this.peek(index+2),ch3=this.peek(index+3),ch4=this.peek(index+4);return isHexDigit(ch1)&&isHexDigit(ch2)&&isHexDigit(ch3)&&isHexDigit(ch4)?(code=parseInt(ch1+ch2+ch3+ch4,16),asciiIdentifierPartTable[code]||isNonAsciiIdentifierPart(code)?(index+=5,"\\\\u"+ch1+ch2+ch3+ch4):null):null}.bind(this),getIdentifierStart=function(){var chr=this.peek(index),code=chr.charCodeAt(0);return 92===code?readUnicodeEscapeSequence():128>code?asciiIdentifierStartTable[code]?(index+=1,chr):null:isNonAsciiIdentifierStart(code)?(index+=1,chr):null}.bind(this),getIdentifierPart=function(){var chr=this.peek(index),code=chr.charCodeAt(0);return 92===code?readUnicodeEscapeSequence():128>code?asciiIdentifierPartTable[code]?(index+=1,chr):null:isNonAsciiIdentifierPart(code)?(index+=1,chr):null}.bind(this);if(char=getIdentifierStart(),null===char)return null;for(id=char;char=getIdentifierPart(),null!==char;)id+=char;switch(id){case"true":case"false":type=Token.BooleanLiteral;break;case"null":type=Token.NullLiteral;break;default:type=Token.Identifier}return{type:type,value:removeEscapeSequences(id),text:id,tokenLength:id.length}},scanNumericLiteral:function(){function isDecimalDigit(str){return/^[0-9]$/.test(str)}function isOctalDigit(str){return/^[0-7]$/.test(str)}function isBinaryDigit(str){return/^[01]$/.test(str)}function isHexDigit(str){return/^[0-9a-fA-F]$/.test(str)}function isIdentifierStart(ch){return"$"===ch||"_"===ch||"\\\\"===ch||ch>="a"&&"z">=ch||ch>="A"&&"Z">=ch}var bad,index=0,value="",length=this.input.length,char=this.peek(index),isAllowedDigit=isDecimalDigit,base=10,isLegacy=!1;if("."!==char&&!isDecimalDigit(char))return null;if("."!==char){for(value=this.peek(index),index+=1,char=this.peek(index),"0"===value&&(("x"===char||"X"===char)&&(isAllowedDigit=isHexDigit,base=16,index+=1,value+=char),("o"===char||"O"===char)&&(isAllowedDigit=isOctalDigit,base=8,state.inES6(!0)||this.trigger("warning",{code:"W119",line:this.line,character:this.char,data:["Octal integer literal","6"]}),index+=1,value+=char),("b"===char||"B"===char)&&(isAllowedDigit=isBinaryDigit,base=2,state.inES6(!0)||this.trigger("warning",{code:"W119",line:this.line,character:this.char,data:["Binary integer literal","6"]}),index+=1,value+=char),isOctalDigit(char)&&(isAllowedDigit=isOctalDigit,base=8,isLegacy=!0,bad=!1,index+=1,value+=char),!isOctalDigit(char)&&isDecimalDigit(char)&&(index+=1,value+=char));length>index;){if(char=this.peek(index),isLegacy&&isDecimalDigit(char))bad=!0;else if(!isAllowedDigit(char))break;value+=char,index+=1}if(isAllowedDigit!==isDecimalDigit)return!isLegacy&&2>=value.length?{type:Token.NumericLiteral,value:value,isMalformed:!0}:length>index&&(char=this.peek(index),isIdentifierStart(char))?null:{type:Token.NumericLiteral,value:value,base:base,isLegacy:isLegacy,isMalformed:!1}}if("."===char)for(value+=char,index+=1;length>index&&(char=this.peek(index),isDecimalDigit(char));)value+=char,index+=1;if("e"===char||"E"===char){if(value+=char,index+=1,char=this.peek(index),("+"===char||"-"===char)&&(value+=this.peek(index),index+=1),char=this.peek(index),!isDecimalDigit(char))return null;for(value+=char,index+=1;length>index&&(char=this.peek(index),isDecimalDigit(char));)value+=char,index+=1}return length>index&&(char=this.peek(index),isIdentifierStart(char))?null:{type:Token.NumericLiteral,value:value,base:base,isMalformed:!isFinite(value)}},scanEscapeSequence:function(checks){var allowNewLine=!1,jump=1;this.skip();var char=this.peek();switch(char){case"'":this.triggerAsync("warning",{code:"W114",line:this.line,character:this.char,data:["\\\\'"]},checks,function(){return state.jsonMode});break;case"b":char="\\\\b";break;case"f":char="\\\\f";break;case"n":char="\\\\n";break;case"r":char="\\\\r";break;case"t":char="\\\\t";break;case"0":char="\\\\0";var n=parseInt(this.peek(1),10);this.triggerAsync("warning",{code:"W115",line:this.line,character:this.char},checks,function(){return n>=0&&7>=n&&state.isStrict()});break;case"u":var hexCode=this.input.substr(1,4),code=parseInt(hexCode,16);isNaN(code)&&this.trigger("warning",{code:"W052",line:this.line,character:this.char,data:["u"+hexCode]}),char=String.fromCharCode(code),jump=5;break;case"v":this.triggerAsync("warning",{code:"W114",line:this.line,character:this.char,data:["\\\\v"]},checks,function(){return state.jsonMode}),char="\v";break;case"x":var x=parseInt(this.input.substr(1,2),16);this.triggerAsync("warning",{code:"W114",line:this.line,character:this.char,data:["\\\\x-"]},checks,function(){return state.jsonMode}),char=String.fromCharCode(x),jump=3;break;case"\\\\":char="\\\\\\\\";break;case'"':char='\\\\"';break;case"/":break;case"":allowNewLine=!0,char=""}return{"char":char,jump:jump,allowNewLine:allowNewLine}},scanTemplateLiteral:function(checks){var tokenType,ch,value="",startLine=this.line,startChar=this.char,depth=this.templateStarts.length;if(!state.inES6(!0))return null;if("\`"===this.peek())tokenType=Token.TemplateHead,this.templateStarts.push({line:this.line,"char":this.char}),depth=this.templateStarts.length,this.skip(1),this.pushContext(Context.Template);else{if(!this.inContext(Context.Template)||"}"!==this.peek())return null;tokenType=Token.TemplateMiddle}for(;"\`"!==this.peek();){for(;""===(ch=this.peek());)if(value+="\\n",!this.nextLine()){var startPos=this.templateStarts.pop();return this.trigger("error",{code:"E052",line:startPos.line,character:startPos.char}),{type:tokenType,value:value,startLine:startLine,startChar:startChar,isUnclosed:!0,depth:depth,context:this.popContext()}}if("$"===ch&&"{"===this.peek(1))return value+="\${",this.skip(2),{type:tokenType,value:value,startLine:startLine,startChar:startChar,isUnclosed:!1,depth:depth,context:this.currentContext()};
if("\\\\"===ch){var escape=this.scanEscapeSequence(checks);value+=escape.char,this.skip(escape.jump)}else"\`"!==ch&&(value+=ch,this.skip(1))}return tokenType=tokenType===Token.TemplateHead?Token.NoSubstTemplate:Token.TemplateTail,this.skip(1),this.templateStarts.pop(),{type:tokenType,value:value,startLine:startLine,startChar:startChar,isUnclosed:!1,depth:depth,context:this.popContext()}},scanStringLiteral:function(checks){var quote=this.peek();if('"'!==quote&&"'"!==quote)return null;this.triggerAsync("warning",{code:"W108",line:this.line,character:this.char},checks,function(){return state.jsonMode&&'"'!==quote});var value="",startLine=this.line,startChar=this.char,allowNewLine=!1;for(this.skip();this.peek()!==quote;)if(""===this.peek()){if(allowNewLine?(allowNewLine=!1,this.triggerAsync("warning",{code:"W043",line:this.line,character:this.char},checks,function(){return!state.option.multistr}),this.triggerAsync("warning",{code:"W042",line:this.line,character:this.char},checks,function(){return state.jsonMode&&state.option.multistr})):this.trigger("warning",{code:"W112",line:this.line,character:this.char}),!this.nextLine())return this.trigger("error",{code:"E029",line:startLine,character:startChar}),{type:Token.StringLiteral,value:value,startLine:startLine,startChar:startChar,isUnclosed:!0,quote:quote}}else{allowNewLine=!1;var char=this.peek(),jump=1;if(" ">char&&this.trigger("warning",{code:"W113",line:this.line,character:this.char,data:["<non-printable>"]}),"\\\\"===char){var parsed=this.scanEscapeSequence(checks);char=parsed.char,jump=parsed.jump,allowNewLine=parsed.allowNewLine}value+=char,this.skip(jump)}return this.skip(),{type:Token.StringLiteral,value:value,startLine:startLine,startChar:startChar,isUnclosed:!1,quote:quote}},scanRegExp:function(){var terminated,index=0,length=this.input.length,char=this.peek(),value=char,body="",flags=[],malformed=!1,isCharSet=!1,scanUnexpectedChars=function(){" ">char&&(malformed=!0,this.trigger("warning",{code:"W048",line:this.line,character:this.char})),"<"===char&&(malformed=!0,this.trigger("warning",{code:"W049",line:this.line,character:this.char,data:[char]}))}.bind(this);if(!this.prereg||"/"!==char)return null;for(index+=1,terminated=!1;length>index;)if(char=this.peek(index),value+=char,body+=char,isCharSet)"]"===char&&("\\\\"!==this.peek(index-1)||"\\\\"===this.peek(index-2))&&(isCharSet=!1),"\\\\"===char&&(index+=1,char=this.peek(index),body+=char,value+=char,scanUnexpectedChars()),index+=1;else{if("\\\\"===char){if(index+=1,char=this.peek(index),body+=char,value+=char,scanUnexpectedChars(),"/"===char){index+=1;continue}if("["===char){index+=1;continue}}if("["!==char){if("/"===char){body=body.substr(0,body.length-1),terminated=!0,index+=1;break}index+=1}else isCharSet=!0,index+=1}if(!terminated)return this.trigger("error",{code:"E015",line:this.line,character:this.from}),void this.trigger("fatal",{line:this.line,from:this.from});for(;length>index&&(char=this.peek(index),/[gim]/.test(char));)flags.push(char),value+=char,index+=1;try{RegExp(body,flags.join(""))}catch(err){malformed=!0,this.trigger("error",{code:"E016",line:this.line,character:this.char,data:[err.message]})}return{type:Token.RegExp,value:value,flags:flags,isMalformed:malformed}},scanNonBreakingSpaces:function(){return state.option.nonbsp?this.input.search(/(\\u00A0)/):-1},scanUnsafeChars:function(){return this.input.search(reg.unsafeChars)},next:function(checks){this.from=this.char;var start;if(/\\s/.test(this.peek()))for(start=this.char;/\\s/.test(this.peek());)this.from+=1,this.skip();var match=this.scanComments()||this.scanStringLiteral(checks)||this.scanTemplateLiteral(checks);return match?match:(match=this.scanRegExp()||this.scanPunctuator()||this.scanKeyword()||this.scanIdentifier()||this.scanNumericLiteral(),match?(this.skip(match.tokenLength||match.value.length),match):null)},nextLine:function(){var char;if(this.line>=this.getLines().length)return!1;this.input=this.getLines()[this.line],this.line+=1,this.char=1,this.from=1;var inputTrimmed=this.input.trim(),startsWith=function(){return _.some(arguments,function(prefix){return 0===inputTrimmed.indexOf(prefix)})},endsWith=function(){return _.some(arguments,function(suffix){return-1!==inputTrimmed.indexOf(suffix,inputTrimmed.length-suffix.length)})};if(this.ignoringLinterErrors===!0&&(startsWith("/*","//")||this.inComment&&endsWith("*/")||(this.input="")),char=this.scanNonBreakingSpaces(),char>=0&&this.trigger("warning",{code:"W125",line:this.line,character:char+1}),this.input=this.input.replace(/\\t/g,state.tab),char=this.scanUnsafeChars(),char>=0&&this.trigger("warning",{code:"W100",line:this.line,character:char}),!this.ignoringLinterErrors&&state.option.maxlen&&state.option.maxlen<this.input.length){var inComment=this.inComment||startsWith.call(inputTrimmed,"//")||startsWith.call(inputTrimmed,"/*"),shouldTriggerError=!inComment||!reg.maxlenException.test(inputTrimmed);shouldTriggerError&&this.trigger("warning",{code:"W101",line:this.line,character:this.input.length})}return!0},start:function(){this.nextLine()},token:function(){function isReserved(token,isProperty){if(!token.reserved)return!1;var meta=token.meta;if(meta&&meta.isFutureReservedWord&&state.inES5()){if(!meta.es5)return!1;if(meta.strictOnly&&!state.option.strict&&!state.isStrict())return!1;if(isProperty)return!1}return!0}for(var token,checks=asyncTrigger(),create=function(type,value,isProperty,token){var obj;if("(endline)"!==type&&"(end)"!==type&&(this.prereg=!1),"(punctuator)"===type){switch(value){case".":case")":case"~":case"#":case"]":case"++":case"--":this.prereg=!1;break;default:this.prereg=!0}obj=Object.create(state.syntax[value]||state.syntax["(error)"])}return"(identifier)"===type&&(("return"===value||"case"===value||"typeof"===value)&&(this.prereg=!0),_.has(state.syntax,value)&&(obj=Object.create(state.syntax[value]||state.syntax["(error)"]),isReserved(obj,isProperty&&"(identifier)"===type)||(obj=null))),obj||(obj=Object.create(state.syntax[type])),obj.identifier="(identifier)"===type,obj.type=obj.type||type,obj.value=value,obj.line=this.line,obj.character=this.char,obj.from=this.from,obj.identifier&&token&&(obj.raw_text=token.text||token.value),token&&token.startLine&&token.startLine!==this.line&&(obj.startLine=token.startLine),token&&token.context&&(obj.context=token.context),token&&token.depth&&(obj.depth=token.depth),token&&token.isUnclosed&&(obj.isUnclosed=token.isUnclosed),isProperty&&obj.identifier&&(obj.isProperty=isProperty),obj.check=checks.check,obj}.bind(this);;){if(!this.input.length)return this.nextLine()?create("(endline)",""):this.exhausted?null:(this.exhausted=!0,create("(end)",""));if(token=this.next(checks))switch(token.type){case Token.StringLiteral:return this.triggerAsync("String",{line:this.line,"char":this.char,from:this.from,startLine:token.startLine,startChar:token.startChar,value:token.value,quote:token.quote},checks,function(){return!0}),create("(string)",token.value,null,token);case Token.TemplateHead:return this.trigger("TemplateHead",{line:this.line,"char":this.char,from:this.from,startLine:token.startLine,startChar:token.startChar,value:token.value}),create("(template)",token.value,null,token);case Token.TemplateMiddle:return this.trigger("TemplateMiddle",{line:this.line,"char":this.char,from:this.from,startLine:token.startLine,startChar:token.startChar,value:token.value}),create("(template middle)",token.value,null,token);case Token.TemplateTail:return this.trigger("TemplateTail",{line:this.line,"char":this.char,from:this.from,startLine:token.startLine,startChar:token.startChar,value:token.value}),create("(template tail)",token.value,null,token);case Token.NoSubstTemplate:return this.trigger("NoSubstTemplate",{line:this.line,"char":this.char,from:this.from,startLine:token.startLine,startChar:token.startChar,value:token.value}),create("(no subst template)",token.value,null,token);case Token.Identifier:this.triggerAsync("Identifier",{line:this.line,"char":this.char,from:this.form,name:token.value,raw_name:token.text,isProperty:"."===state.tokens.curr.id},checks,function(){return!0});case Token.Keyword:case Token.NullLiteral:case Token.BooleanLiteral:return create("(identifier)",token.value,"."===state.tokens.curr.id,token);case Token.NumericLiteral:return token.isMalformed&&this.trigger("warning",{code:"W045",line:this.line,character:this.char,data:[token.value]}),this.triggerAsync("warning",{code:"W114",line:this.line,character:this.char,data:["0x-"]},checks,function(){return 16===token.base&&state.jsonMode}),this.triggerAsync("warning",{code:"W115",line:this.line,character:this.char},checks,function(){return state.isStrict()&&8===token.base&&token.isLegacy}),this.trigger("Number",{line:this.line,"char":this.char,from:this.from,value:token.value,base:token.base,isMalformed:token.malformed}),create("(number)",token.value);case Token.RegExp:return create("(regexp)",token.value);case Token.Comment:if(state.tokens.curr.comment=!0,token.isSpecial)return{id:"(comment)",value:token.value,body:token.body,type:token.commentType,isSpecial:token.isSpecial,line:this.line,character:this.char,from:this.from};break;case"":break;default:return create("(punctuator)",token.value)}else this.input.length&&(this.trigger("error",{code:"E024",line:this.line,character:this.char,data:[this.peek()]}),this.input="")}}},exports.Lexer=Lexer,exports.Context=Context},{"../data/ascii-identifier-data.js":"/node_modules/jshint/data/ascii-identifier-data.js","../lodash":"/node_modules/jshint/lodash.js","./reg.js":"/node_modules/jshint/src/reg.js","./state.js":"/node_modules/jshint/src/state.js",events:"/node_modules/browserify/node_modules/events/events.js"}],"/node_modules/jshint/src/messages.js":[function(_dereq_,module,exports){"use strict";var _=_dereq_("../lodash"),errors={E001:"Bad option: '{a}'.",E002:"Bad option value.",E003:"Expected a JSON value.",E004:"Input is neither a string nor an array of strings.",E005:"Input is empty.",E006:"Unexpected early end of program.",E007:'Missing "use strict" statement.',E008:"Strict violation.",E009:"Option 'validthis' can't be used in a global scope.",E010:"'with' is not allowed in strict mode.",E011:"'{a}' has already been declared.",E012:"const '{a}' is initialized to 'undefined'.",E013:"Attempting to override '{a}' which is a constant.",E014:"A regular expression literal can be confused with '/='.",E015:"Unclosed regular expression.",E016:"Invalid regular expression.",E017:"Unclosed comment.",E018:"Unbegun comment.",E019:"Unmatched '{a}'.",E020:"Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'.",E021:"Expected '{a}' and instead saw '{b}'.",E022:"Line breaking error '{a}'.",E023:"Missing '{a}'.",E024:"Unexpected '{a}'.",E025:"Missing ':' on a case clause.",E026:"Missing '}' to match '{' from line {a}.",E027:"Missing ']' to match '[' from line {a}.",E028:"Illegal comma.",E029:"Unclosed string.",E030:"Expected an identifier and instead saw '{a}'.",E031:"Bad assignment.",E032:"Expected a small integer or 'false' and instead saw '{a}'.",E033:"Expected an operator and instead saw '{a}'.",E034:"get/set are ES5 features.",E035:"Missing property name.",E036:"Expected to see a statement and instead saw a block.",E037:null,E038:null,E039:"Function declarations are not invocable. Wrap the whole function invocation in parens.",E040:"Each value should have its own case label.",E041:"Unrecoverable syntax error.",E042:"Stopping.",E043:"Too many errors.",E044:null,E045:"Invalid for each loop.",E046:"A yield statement shall be within a generator function (with syntax: \`function*\`)",E047:null,E048:"{a} declaration not directly within block.",E049:"A {a} cannot be named '{b}'.",E050:"Mozilla acequires the yield expression to be parenthesized here.",E051:null,E052:"Unclosed template literal.",E053:"Export declaration must be in global scope.",E054:"Class properties must be methods. Expected '(' but instead saw '{a}'.",E055:"The '{a}' option cannot be set after any executable code.",E056:"'{a}' was used before it was declared, which is illegal for '{b}' variables.",E057:"Invalid meta property: '{a}.{b}'.",E058:"Missing semicolon."},warnings={W001:"'hasOwnProperty' is a really bad name.",W002:"Value of '{a}' may be overwritten in IE 8 and earlier.",W003:"'{a}' was used before it was defined.",W004:"'{a}' is already defined.",W005:"A dot following a number can be confused with a decimal point.",W006:"Confusing minuses.",W007:"Confusing plusses.",W008:"A leading decimal point can be confused with a dot: '{a}'.",W009:"The array literal notation [] is preferable.",W010:"The object literal notation {} is preferable.",W011:null,W012:null,W013:null,W014:"Bad line breaking before '{a}'.",W015:null,W016:"Unexpected use of '{a}'.",W017:"Bad operand.",W018:"Confusing use of '{a}'.",W019:"Use the isNaN function to compare with NaN.",W020:"Read only.",W021:"Reassignment of '{a}', which is is a {b}. Use 'var' or 'let' to declare bindings that may change.",W022:"Do not assign to the exception parameter.",W023:"Expected an identifier in an assignment and instead saw a function invocation.",W024:"Expected an identifier and instead saw '{a}' (a reserved word).",W025:"Missing name in function declaration.",W026:"Inner functions should be listed at the top of the outer function.",W027:"Unreachable '{a}' after '{b}'.",W028:"Label '{a}' on {b} statement.",W030:"Expected an assignment or function call and instead saw an expression.",W031:"Do not use 'new' for side effects.",W032:"Unnecessary semicolon.",W033:"Missing semicolon.",W034:'Unnecessary directive "{a}".',W035:"Empty block.",W036:"Unexpected /*member '{a}'.",W037:"'{a}' is a statement label.",W038:"'{a}' used out of scope.",W039:"'{a}' is not allowed.",W040:"Possible strict violation.",W041:"Use '{a}' to compare with '{b}'.",W042:"Avoid EOL escaping.",W043:"Bad escaping of EOL. Use option multistr if needed.",W044:"Bad or unnecessary escaping.",W045:"Bad number '{a}'.",W046:"Don't use extra leading zeros '{a}'.",W047:"A trailing decimal point can be confused with a dot: '{a}'.",W048:"Unexpected control character in regular expression.",W049:"Unexpected escaped character '{a}' in regular expression.",W050:"JavaScript URL.",W051:"Variables should not be deleted.",W052:"Unexpected '{a}'.",W053:"Do not use {a} as a constructor.",W054:"The Function constructor is a form of eval.",W055:"A constructor name should start with an uppercase letter.",W056:"Bad constructor.",W057:"Weird construction. Is 'new' necessary?",W058:"Missing '()' invoking a constructor.",W059:"Avoid arguments.{a}.",W060:"document.write can be a form of eval.",W061:"eval can be harmful.",W062:"Wrap an immediate function invocation in parens to assist the reader in understanding that the expression is the result of a function, and not the function itself.",W063:"Math is not a function.",W064:"Missing 'new' prefix when invoking a constructor.",W065:"Missing radix parameter.",W066:"Implied eval. Consider passing a function instead of a string.",W067:"Bad invocation.",W068:"Wrapping non-IIFE function literals in parens is unnecessary.",W069:"['{a}'] is better written in dot notation.",W070:"Extra comma. (it breaks older versions of IE)",W071:"This function has too many statements. ({a})",W072:"This function has too many parameters. ({a})",W073:"Blocks are nested too deeply. ({a})",W074:"This function's cyclomatic complexity is too high. ({a})",W075:"Duplicate {a} '{b}'.",W076:"Unexpected parameter '{a}' in get {b} function.",W077:"Expected a single parameter in set {a} function.",W078:"Setter is defined without getter.",W079:"Redefinition of '{a}'.",W080:"It's not necessary to initialize '{a}' to 'undefined'.",W081:null,W082:"Function declarations should not be placed in blocks. Use a function expression or move the statement to the top of the outer function.",W083:"Don't make functions within a loop.",W084:"Assignment in conditional expression",W085:"Don't use 'with'.",W086:"Expected a 'break' statement before '{a}'.",W087:"Forgotten 'debugger' statement?",W088:"Creating global 'for' variable. Should be 'for (var {a} ...'.",W089:"The body of a for in should be wrapped in an if statement to filter unwanted properties from the prototype.",W090:"'{a}' is not a statement label.",W091:null,W093:"Did you mean to return a conditional instead of an assignment?",W094:"Unexpected comma.",W095:"Expected a string and instead saw {a}.",W096:"The '{a}' key may produce unexpected results.",W097:'Use the function form of "use strict".',W098:"'{a}' is defined but never used.",W099:null,W100:"This character may get silently deleted by one or more browsers.",W101:"Line is too long.",W102:null,W103:"The '{a}' property is deprecated.",W104:"'{a}' is available in ES{b} (use 'esversion: {b}') or Mozilla JS extensions (use moz).",W105:"Unexpected {a} in '{b}'.",W106:"Identifier '{a}' is not in camel case.",W107:"Script URL.",W108:"Strings must use doublequote.",W109:"Strings must use singlequote.",W110:"Mixed double and single quotes.",W112:"Unclosed string.",W113:"Control character in string: {a}.",W114:"Avoid {a}.",W115:"Octal literals are not allowed in strict mode.",W116:"Expected '{a}' and instead saw '{b}'.",W117:"'{a}' is not defined.",W118:"'{a}' is only available in Mozilla JavaScript extensions (use moz option).",W119:"'{a}' is only available in ES{b} (use 'esversion: {b}').",W120:"You might be leaking a variable ({a}) here.",W121:"Extending prototype of native object: '{a}'.",W122:"Invalid typeof value '{a}'",W123:"'{a}' is already defined in outer scope.",W124:"A generator function shall contain a yield statement.",W125:"This line contains non-breaking spaces: http://jshint.com/doc/options/#nonbsp",W126:"Unnecessary grouping operator.",W127:"Unexpected use of a comma operator.",W128:"Empty array elements acequire elision=true.",W129:"'{a}' is defined in a future version of JavaScript. Use a different variable name to avoid migration issues.",W130:"Invalid element after rest element.",W131:"Invalid parameter after rest parameter.",W132:"\`var\` declarations are forbidden. Use \`let\` or \`const\` instead.",W133:"Invalid for-{a} loop left-hand-side: {b}.",W134:"The '{a}' option is only available when linting ECMAScript {b} code.",W135:"{a} may not be supported by non-browser environments.",W136:"'{a}' must be in function scope.",W137:"Empty destructuring.",W138:"Regular parameters should not come after default parameters."},info={I001:"Comma warnings can be turned off with 'laxcomma'.",I002:null,I003:"ES5 option is now set per default"};exports.errors={},exports.warnings={},exports.info={},_.each(errors,function(desc,code){exports.errors[code]={code:code,desc:desc}}),_.each(warnings,function(desc,code){exports.warnings[code]={code:code,desc:desc}}),_.each(info,function(desc,code){exports.info[code]={code:code,desc:desc}})},{"../lodash":"/node_modules/jshint/lodash.js"}],"/node_modules/jshint/src/name-stack.js":[function(_dereq_,module){"use strict";function NameStack(){this._stack=[]}Object.defineProperty(NameStack.prototype,"length",{get:function(){return this._stack.length}}),NameStack.prototype.push=function(){this._stack.push(null)},NameStack.prototype.pop=function(){this._stack.pop()},NameStack.prototype.set=function(token){this._stack[this.length-1]=token},NameStack.prototype.infer=function(){var type,nameToken=this._stack[this.length-1],prefix="";return nameToken&&"class"!==nameToken.type||(nameToken=this._stack[this.length-2]),nameToken?(type=nameToken.type,"(string)"!==type&&"(number)"!==type&&"(identifier)"!==type&&"default"!==type?"(expression)":(nameToken.accessorType&&(prefix=nameToken.accessorType+" "),prefix+nameToken.value)):"(empty)"},module.exports=NameStack},{}],"/node_modules/jshint/src/options.js":[function(_dereq_,module,exports){"use strict";exports.bool={enforcing:{bitwise:!0,freeze:!0,camelcase:!0,curly:!0,eqeqeq:!0,futurehostile:!0,notypeof:!0,es3:!0,es5:!0,forin:!0,funcscope:!0,immed:!0,iterator:!0,newcap:!0,noarg:!0,nocomma:!0,noempty:!0,nonbsp:!0,nonew:!0,undef:!0,singleGroups:!1,varstmt:!1,enforceall:!1},relaxing:{asi:!0,multistr:!0,debug:!0,boss:!0,evil:!0,globalstrict:!0,plusplus:!0,proto:!0,scripturl:!0,sub:!0,supernew:!0,laxbreak:!0,laxcomma:!0,validthis:!0,withstmt:!0,moz:!0,noyield:!0,eqnull:!0,lastsemic:!0,loopfunc:!0,expr:!0,esnext:!0,elision:!0},environments:{mootools:!0,couch:!0,jasmine:!0,jquery:!0,node:!0,qunit:!0,rhino:!0,shelljs:!0,prototypejs:!0,yui:!0,mocha:!0,module:!0,wsh:!0,worker:!0,nonstandard:!0,browser:!0,browserify:!0,devel:!0,dojo:!0,typed:!0,phantom:!0},obsolete:{onecase:!0,regexp:!0,regexdash:!0}},exports.val={maxlen:!1,indent:!1,maxerr:!1,predef:!1,globals:!1,quotmark:!1,scope:!1,maxstatements:!1,maxdepth:!1,maxparams:!1,maxcomplexity:!1,shadow:!1,strict:!0,unused:!0,latedef:!1,ignore:!1,ignoreDelimiters:!1,esversion:5},exports.inverted={bitwise:!0,forin:!0,newcap:!0,plusplus:!0,regexp:!0,undef:!0,eqeqeq:!0,strict:!0},exports.validNames=Object.keys(exports.val).concat(Object.keys(exports.bool.relaxing)).concat(Object.keys(exports.bool.enforcing)).concat(Object.keys(exports.bool.obsolete)).concat(Object.keys(exports.bool.environments)),exports.renamed={eqeq:"eqeqeq",windows:"wsh",sloppy:"strict"},exports.removed={nomen:!0,onevar:!0,passfail:!0,white:!0,gcl:!0,smarttabs:!0,trailing:!0},exports.noenforceall={varstmt:!0,strict:!0}},{}],"/node_modules/jshint/src/reg.js":[function(_dereq_,module,exports){"use strict";exports.unsafeString=/@cc|<\\/?|script|\\]\\s*\\]|<\\s*!|&lt/i,exports.unsafeChars=/[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,exports.needEsc=/[\\u0000-\\u001f&<"\\/\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,exports.needEscGlobal=/[\\u0000-\\u001f&<"\\/\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,exports.starSlash=/\\*\\//,exports.identifier=/^([a-zA-Z_$][a-zA-Z0-9_$]*)$/,exports.javascriptURL=/^(?:javascript|jscript|ecmascript|vbscript|livescript)\\s*:/i,exports.fallsThrough=/^\\s*falls?\\sthrough\\s*$/,exports.maxlenException=/^(?:(?:\\/\\/|\\/\\*|\\*) ?)?[^ ]+$/},{}],"/node_modules/jshint/src/scope-manager.js":[function(_dereq_,module){"use strict";var _=_dereq_("../lodash"),events=_dereq_("events"),marker={},scopeManager=function(state,predefined,exported,declared){function _newScope(type){_current={"(labels)":Object.create(null),"(usages)":Object.create(null),"(breakLabels)":Object.create(null),"(parent)":_current,"(type)":type,"(params)":"functionparams"===type||"catchparams"===type?[]:null},_scopeStack.push(_current)}function warning(code,token){emitter.emit("warning",{code:code,token:token,data:_.slice(arguments,2)})}function error(code,token){emitter.emit("warning",{code:code,token:token,data:_.slice(arguments,2)})}function _setupUsages(labelName){_current["(usages)"][labelName]||(_current["(usages)"][labelName]={"(modified)":[],"(reassigned)":[],"(tokens)":[]})}function _checkForUnused(){if("functionparams"===_current["(type)"])return _checkParams(),void 0;var curentLabels=_current["(labels)"];for(var labelName in curentLabels)curentLabels[labelName]&&"exception"!==curentLabels[labelName]["(type)"]&&curentLabels[labelName]["(unused)"]&&_warnUnused(labelName,curentLabels[labelName]["(token)"],"var")}function _checkParams(){var params=_current["(params)"];if(params)for(var unused_opt,param=params.pop();param;){var label=_current["(labels)"][param];if(unused_opt=_getUnusedOption(state.funct["(unusedOption)"]),"undefined"===param)return;if(label["(unused)"])_warnUnused(param,label["(token)"],"param",state.funct["(unusedOption)"]);else if("last-param"===unused_opt)return;param=params.pop()}}function _getLabel(labelName){for(var i=_scopeStack.length-1;i>=0;--i){var scopeLabels=_scopeStack[i]["(labels)"];if(scopeLabels[labelName])return scopeLabels}}function usedSoFarInCurrentFunction(labelName){for(var i=_scopeStack.length-1;i>=0;i--){var current=_scopeStack[i];if(current["(usages)"][labelName])return current["(usages)"][labelName];if(current===_currentFunctBody)break}return!1}function _checkOuterShadow(labelName,token){if("outer"===state.option.shadow)for(var isGlobal="global"===_currentFunctBody["(type)"],isNewFunction="functionparams"===_current["(type)"],outsideCurrentFunction=!isGlobal,i=0;_scopeStack.length>i;i++){var stackItem=_scopeStack[i];isNewFunction||_scopeStack[i+1]!==_currentFunctBody||(outsideCurrentFunction=!1),outsideCurrentFunction&&stackItem["(labels)"][labelName]&&warning("W123",token,labelName),stackItem["(breakLabels)"][labelName]&&warning("W123",token,labelName)}}function _latedefWarning(type,labelName,token){state.option.latedef&&(state.option.latedef===!0&&"function"===type||"function"!==type)&&warning("W003",token,labelName)}var _current,_scopeStack=[];_newScope("global"),_current["(predefined)"]=predefined;var _currentFunctBody=_current,usedPredefinedAndGlobals=Object.create(null),impliedGlobals=Object.create(null),unuseds=[],emitter=new events.EventEmitter,_getUnusedOption=function(unused_opt){return void 0===unused_opt&&(unused_opt=state.option.unused),unused_opt===!0&&(unused_opt="last-param"),unused_opt},_warnUnused=function(name,tkn,type,unused_opt){var line=tkn.line,chr=tkn.from,raw_name=tkn.raw_text||name;unused_opt=_getUnusedOption(unused_opt);var warnable_types={vars:["var"],"last-param":["var","param"],strict:["var","param","last-param"]};unused_opt&&warnable_types[unused_opt]&&-1!==warnable_types[unused_opt].indexOf(type)&&warning("W098",{line:line,from:chr},raw_name),(unused_opt||"var"===type)&&unuseds.push({name:name,line:line,character:chr})},scopeManagerInst={on:function(names,listener){names.split(" ").forEach(function(name){emitter.on(name,listener)})},isPredefined:function(labelName){return!this.has(labelName)&&_.has(_scopeStack[0]["(predefined)"],labelName)},stack:function(type){var previousScope=_current;_newScope(type),type||"functionparams"!==previousScope["(type)"]||(_current["(isFuncBody)"]=!0,_current["(context)"]=_currentFunctBody,_currentFunctBody=_current)},unstack:function(){var i,j,subScope=_scopeStack.length>1?_scopeStack[_scopeStack.length-2]:null,isUnstackingFunctionBody=_current===_currentFunctBody,isUnstackingFunctionParams="functionparams"===_current["(type)"],isUnstackingFunctionOuter="functionouter"===_current["(type)"],currentUsages=_current["(usages)"],currentLabels=_current["(labels)"],usedLabelNameList=Object.keys(currentUsages);for(currentUsages.__proto__&&-1===usedLabelNameList.indexOf("__proto__")&&usedLabelNameList.push("__proto__"),i=0;usedLabelNameList.length>i;i++){var usedLabelName=usedLabelNameList[i],usage=currentUsages[usedLabelName],usedLabel=currentLabels[usedLabelName];if(usedLabel){var usedLabelType=usedLabel["(type)"];if(usedLabel["(useOutsideOfScope)"]&&!state.option.funcscope){var usedTokens=usage["(tokens)"];if(usedTokens)for(j=0;usedTokens.length>j;j++)usedLabel["(function)"]===usedTokens[j]["(function)"]&&error("W038",usedTokens[j],usedLabelName)}if(_current["(labels)"][usedLabelName]["(unused)"]=!1,"const"===usedLabelType&&usage["(modified)"])for(j=0;usage["(modified)"].length>j;j++)error("E013",usage["(modified)"][j],usedLabelName);if(("function"===usedLabelType||"class"===usedLabelType)&&usage["(reassigned)"])for(j=0;usage["(reassigned)"].length>j;j++)error("W021",usage["(reassigned)"][j],usedLabelName,usedLabelType)}else if(isUnstackingFunctionOuter&&(state.funct["(isCapturing)"]=!0),subScope)if(subScope["(usages)"][usedLabelName]){var subScopeUsage=subScope["(usages)"][usedLabelName];subScopeUsage["(modified)"]=subScopeUsage["(modified)"].concat(usage["(modified)"]),subScopeUsage["(tokens)"]=subScopeUsage["(tokens)"].concat(usage["(tokens)"]),subScopeUsage["(reassigned)"]=subScopeUsage["(reassigned)"].concat(usage["(reassigned)"]),subScopeUsage["(onlyUsedSubFunction)"]=!1}else subScope["(usages)"][usedLabelName]=usage,isUnstackingFunctionBody&&(subScope["(usages)"][usedLabelName]["(onlyUsedSubFunction)"]=!0);else if("boolean"==typeof _current["(predefined)"][usedLabelName]){if(delete declared[usedLabelName],usedPredefinedAndGlobals[usedLabelName]=marker,_current["(predefined)"][usedLabelName]===!1&&usage["(reassigned)"])for(j=0;usage["(reassigned)"].length>j;j++)warning("W020",usage["(reassigned)"][j])}else if(usage["(tokens)"])for(j=0;usage["(tokens)"].length>j;j++){var undefinedToken=usage["(tokens)"][j];undefinedToken.forgiveUndef||(state.option.undef&&!undefinedToken.ignoreUndef&&warning("W117",undefinedToken,usedLabelName),impliedGlobals[usedLabelName]?impliedGlobals[usedLabelName].line.push(undefinedToken.line):impliedGlobals[usedLabelName]={name:usedLabelName,line:[undefinedToken.line]})}}if(subScope||Object.keys(declared).forEach(function(labelNotUsed){_warnUnused(labelNotUsed,declared[labelNotUsed],"var")}),subScope&&!isUnstackingFunctionBody&&!isUnstackingFunctionParams&&!isUnstackingFunctionOuter){var labelNames=Object.keys(currentLabels);for(i=0;labelNames.length>i;i++){var defLabelName=labelNames[i];currentLabels[defLabelName]["(blockscoped)"]||"exception"===currentLabels[defLabelName]["(type)"]||this.funct.has(defLabelName,{excludeCurrent:!0})||(subScope["(labels)"][defLabelName]=currentLabels[defLabelName],"global"!==_currentFunctBody["(type)"]&&(subScope["(labels)"][defLabelName]["(useOutsideOfScope)"]=!0),delete currentLabels[defLabelName])}}_checkForUnused(),_scopeStack.pop(),isUnstackingFunctionBody&&(_currentFunctBody=_scopeStack[_.findLastIndex(_scopeStack,function(scope){return scope["(isFuncBody)"]||"global"===scope["(type)"]})]),_current=subScope},addParam:function(labelName,token,type){if(type=type||"param","exception"===type){var previouslyDefinedLabelType=this.funct.labeltype(labelName);previouslyDefinedLabelType&&"exception"!==previouslyDefinedLabelType&&(state.option.node||warning("W002",state.tokens.next,labelName))}if(_.has(_current["(labels)"],labelName)?_current["(labels)"][labelName].duplicated=!0:(_checkOuterShadow(labelName,token,type),_current["(labels)"][labelName]={"(type)":type,"(token)":token,"(unused)":!0},_current["(params)"].push(labelName)),_.has(_current["(usages)"],labelName)){var usage=_current["(usages)"][labelName];usage["(onlyUsedSubFunction)"]?_latedefWarning(type,labelName,token):warning("E056",token,labelName,type)}},validateParams:function(){if("global"!==_currentFunctBody["(type)"]){var isStrict=state.isStrict(),currentFunctParamScope=_currentFunctBody["(parent)"];currentFunctParamScope["(params)"]&&currentFunctParamScope["(params)"].forEach(function(labelName){var label=currentFunctParamScope["(labels)"][labelName];label&&label.duplicated&&(isStrict?warning("E011",label["(token)"],labelName):state.option.shadow!==!0&&warning("W004",label["(token)"],labelName))})}},getUsedOrDefinedGlobals:function(){var list=Object.keys(usedPredefinedAndGlobals);return usedPredefinedAndGlobals.__proto__===marker&&-1===list.indexOf("__proto__")&&list.push("__proto__"),list},getImpliedGlobals:function(){var values=_.values(impliedGlobals),hasProto=!1;return impliedGlobals.__proto__&&(hasProto=values.some(function(value){return"__proto__"===value.name}),hasProto||values.push(impliedGlobals.__proto__)),values},getUnuseds:function(){return unuseds},has:function(labelName){return Boolean(_getLabel(labelName))},labeltype:function(labelName){var scopeLabels=_getLabel(labelName);return scopeLabels?scopeLabels[labelName]["(type)"]:null},addExported:function(labelName){var globalLabels=_scopeStack[0]["(labels)"];if(_.has(declared,labelName))delete declared[labelName];else if(_.has(globalLabels,labelName))globalLabels[labelName]["(unused)"]=!1;else{for(var i=1;_scopeStack.length>i;i++){var scope=_scopeStack[i];if(scope["(type)"])break;if(_.has(scope["(labels)"],labelName)&&!scope["(labels)"][labelName]["(blockscoped)"])return scope["(labels)"][labelName]["(unused)"]=!1,void 0}exported[labelName]=!0}},setExported:function(labelName,token){this.block.use(labelName,token)
},addlabel:function(labelName,opts){var type=opts.type,token=opts.token,isblockscoped="let"===type||"const"===type||"class"===type,isexported="global"===(isblockscoped?_current:_currentFunctBody)["(type)"]&&_.has(exported,labelName);if(_checkOuterShadow(labelName,token,type),isblockscoped){var declaredInCurrentScope=_current["(labels)"][labelName];if(declaredInCurrentScope||_current!==_currentFunctBody||"global"===_current["(type)"]||(declaredInCurrentScope=!!_currentFunctBody["(parent)"]["(labels)"][labelName]),!declaredInCurrentScope&&_current["(usages)"][labelName]){var usage=_current["(usages)"][labelName];usage["(onlyUsedSubFunction)"]?_latedefWarning(type,labelName,token):warning("E056",token,labelName,type)}declaredInCurrentScope?warning("E011",token,labelName):"outer"===state.option.shadow&&scopeManagerInst.funct.has(labelName)&&warning("W004",token,labelName),scopeManagerInst.block.add(labelName,type,token,!isexported)}else{var declaredInCurrentFunctionScope=scopeManagerInst.funct.has(labelName);!declaredInCurrentFunctionScope&&usedSoFarInCurrentFunction(labelName)&&_latedefWarning(type,labelName,token),scopeManagerInst.funct.has(labelName,{onlyBlockscoped:!0})?warning("E011",token,labelName):state.option.shadow!==!0&&declaredInCurrentFunctionScope&&"__proto__"!==labelName&&"global"!==_currentFunctBody["(type)"]&&warning("W004",token,labelName),scopeManagerInst.funct.add(labelName,type,token,!isexported),"global"===_currentFunctBody["(type)"]&&(usedPredefinedAndGlobals[labelName]=marker)}},funct:{labeltype:function(labelName,options){for(var onlyBlockscoped=options&&options.onlyBlockscoped,excludeParams=options&&options.excludeParams,currentScopeIndex=_scopeStack.length-(options&&options.excludeCurrent?2:1),i=currentScopeIndex;i>=0;i--){var current=_scopeStack[i];if(current["(labels)"][labelName]&&(!onlyBlockscoped||current["(labels)"][labelName]["(blockscoped)"]))return current["(labels)"][labelName]["(type)"];var scopeCheck=excludeParams?_scopeStack[i-1]:current;if(scopeCheck&&"functionparams"===scopeCheck["(type)"])return null}return null},hasBreakLabel:function(labelName){for(var i=_scopeStack.length-1;i>=0;i--){var current=_scopeStack[i];if(current["(breakLabels)"][labelName])return!0;if("functionparams"===current["(type)"])return!1}return!1},has:function(labelName,options){return Boolean(this.labeltype(labelName,options))},add:function(labelName,type,tok,unused){_current["(labels)"][labelName]={"(type)":type,"(token)":tok,"(blockscoped)":!1,"(function)":_currentFunctBody,"(unused)":unused}}},block:{isGlobal:function(){return"global"===_current["(type)"]},use:function(labelName,token){var paramScope=_currentFunctBody["(parent)"];paramScope&&paramScope["(labels)"][labelName]&&"param"===paramScope["(labels)"][labelName]["(type)"]&&(scopeManagerInst.funct.has(labelName,{excludeParams:!0,onlyBlockscoped:!0})||(paramScope["(labels)"][labelName]["(unused)"]=!1)),token&&(state.ignored.W117||state.option.undef===!1)&&(token.ignoreUndef=!0),_setupUsages(labelName),token&&(token["(function)"]=_currentFunctBody,_current["(usages)"][labelName]["(tokens)"].push(token))},reassign:function(labelName,token){this.modify(labelName,token),_current["(usages)"][labelName]["(reassigned)"].push(token)},modify:function(labelName,token){_setupUsages(labelName),_current["(usages)"][labelName]["(modified)"].push(token)},add:function(labelName,type,tok,unused){_current["(labels)"][labelName]={"(type)":type,"(token)":tok,"(blockscoped)":!0,"(unused)":unused}},addBreakLabel:function(labelName,opts){var token=opts.token;scopeManagerInst.funct.hasBreakLabel(labelName)?warning("E011",token,labelName):"outer"===state.option.shadow&&(scopeManagerInst.funct.has(labelName)?warning("W004",token,labelName):_checkOuterShadow(labelName,token)),_current["(breakLabels)"][labelName]=token}}};return scopeManagerInst};module.exports=scopeManager},{"../lodash":"/node_modules/jshint/lodash.js",events:"/node_modules/browserify/node_modules/events/events.js"}],"/node_modules/jshint/src/state.js":[function(_dereq_,module,exports){"use strict";var NameStack=_dereq_("./name-stack.js"),state={syntax:{},isStrict:function(){return this.directive["use strict"]||this.inClassBody||this.option.module||"implied"===this.option.strict},inMoz:function(){return this.option.moz},inES6:function(){return this.option.moz||this.option.esversion>=6},inES5:function(strict){return strict?!(this.option.esversion&&5!==this.option.esversion||this.option.moz):!this.option.esversion||this.option.esversion>=5||this.option.moz},reset:function(){this.tokens={prev:null,next:null,curr:null},this.option={},this.funct=null,this.ignored={},this.directive={},this.jsonMode=!1,this.jsonWarnings=[],this.lines=[],this.tab="",this.cache={},this.ignoredLines={},this.forinifcheckneeded=!1,this.nameStack=new NameStack,this.inClassBody=!1}};exports.state=state},{"./name-stack.js":"/node_modules/jshint/src/name-stack.js"}],"/node_modules/jshint/src/style.js":[function(_dereq_,module,exports){"use strict";exports.register=function(linter){linter.on("Identifier",function(data){linter.getOption("proto")||"__proto__"===data.name&&linter.warn("W103",{line:data.line,"char":data.char,data:[data.name,"6"]})}),linter.on("Identifier",function(data){linter.getOption("iterator")||"__iterator__"===data.name&&linter.warn("W103",{line:data.line,"char":data.char,data:[data.name]})}),linter.on("Identifier",function(data){linter.getOption("camelcase")&&data.name.replace(/^_+|_+$/g,"").indexOf("_")>-1&&!data.name.match(/^[A-Z0-9_]*$/)&&linter.warn("W106",{line:data.line,"char":data.from,data:[data.name]})}),linter.on("String",function(data){var code,quotmark=linter.getOption("quotmark");quotmark&&("single"===quotmark&&"'"!==data.quote&&(code="W109"),"double"===quotmark&&'"'!==data.quote&&(code="W108"),quotmark===!0&&(linter.getCache("quotmark")||linter.setCache("quotmark",data.quote),linter.getCache("quotmark")!==data.quote&&(code="W110")),code&&linter.warn(code,{line:data.line,"char":data.char}))}),linter.on("Number",function(data){"."===data.value.charAt(0)&&linter.warn("W008",{line:data.line,"char":data.char,data:[data.value]}),"."===data.value.substr(data.value.length-1)&&linter.warn("W047",{line:data.line,"char":data.char,data:[data.value]}),/^00+/.test(data.value)&&linter.warn("W046",{line:data.line,"char":data.char,data:[data.value]})}),linter.on("String",function(data){var re=/^(?:javascript|jscript|ecmascript|vbscript|livescript)\\s*:/i;linter.getOption("scripturl")||re.test(data.value)&&linter.warn("W107",{line:data.line,"char":data.char})})}},{}],"/node_modules/jshint/src/vars.js":[function(_dereq_,module,exports){"use strict";exports.reservedVars={arguments:!1,NaN:!1},exports.ecmaIdentifiers={3:{Array:!1,Boolean:!1,Date:!1,decodeURI:!1,decodeURIComponent:!1,encodeURI:!1,encodeURIComponent:!1,Error:!1,eval:!1,EvalError:!1,Function:!1,hasOwnProperty:!1,isFinite:!1,isNaN:!1,Math:!1,Number:!1,Object:!1,parseInt:!1,parseFloat:!1,RangeError:!1,ReferenceError:!1,RegExp:!1,String:!1,SyntaxError:!1,TypeError:!1,URIError:!1},5:{JSON:!1},6:{Map:!1,Promise:!1,Proxy:!1,Reflect:!1,Set:!1,Symbol:!1,WeakMap:!1,WeakSet:!1}},exports.browser={Audio:!1,Blob:!1,addEventListener:!1,applicationCache:!1,atob:!1,blur:!1,btoa:!1,cancelAnimationFrame:!1,CanvasGradient:!1,CanvasPattern:!1,CanvasRenderingContext2D:!1,CSS:!1,clearInterval:!1,clearTimeout:!1,close:!1,closed:!1,Comment:!1,CustomEvent:!1,DOMParser:!1,defaultStatus:!1,Document:!1,document:!1,DocumentFragment:!1,Element:!1,ElementTimeControl:!1,Event:!1,event:!1,fetch:!1,FileReader:!1,FormData:!1,focus:!1,frames:!1,getComputedStyle:!1,HTMLElement:!1,HTMLAnchorElement:!1,HTMLBaseElement:!1,HTMLBlockquoteElement:!1,HTMLBodyElement:!1,HTMLBRElement:!1,HTMLButtonElement:!1,HTMLCanvasElement:!1,HTMLCollection:!1,HTMLDirectoryElement:!1,HTMLDivElement:!1,HTMLDListElement:!1,HTMLFieldSetElement:!1,HTMLFontElement:!1,HTMLFormElement:!1,HTMLFrameElement:!1,HTMLFrameSetElement:!1,HTMLHeadElement:!1,HTMLHeadingElement:!1,HTMLHRElement:!1,HTMLHtmlElement:!1,HTMLIFrameElement:!1,HTMLImageElement:!1,HTMLInputElement:!1,HTMLIsIndexElement:!1,HTMLLabelElement:!1,HTMLLayerElement:!1,HTMLLegendElement:!1,HTMLLIElement:!1,HTMLLinkElement:!1,HTMLMapElement:!1,HTMLMenuElement:!1,HTMLMetaElement:!1,HTMLModElement:!1,HTMLObjectElement:!1,HTMLOListElement:!1,HTMLOptGroupElement:!1,HTMLOptionElement:!1,HTMLParagraphElement:!1,HTMLParamElement:!1,HTMLPreElement:!1,HTMLQuoteElement:!1,HTMLScriptElement:!1,HTMLSelectElement:!1,HTMLStyleElement:!1,HTMLTableCaptionElement:!1,HTMLTableCellElement:!1,HTMLTableColElement:!1,HTMLTableElement:!1,HTMLTableRowElement:!1,HTMLTableSectionElement:!1,HTMLTemplateElement:!1,HTMLTextAreaElement:!1,HTMLTitleElement:!1,HTMLUListElement:!1,HTMLVideoElement:!1,history:!1,Image:!1,Intl:!1,length:!1,localStorage:!1,location:!1,matchMedia:!1,MessageChannel:!1,MessageEvent:!1,MessagePort:!1,MouseEvent:!1,moveBy:!1,moveTo:!1,MutationObserver:!1,name:!1,Node:!1,NodeFilter:!1,NodeList:!1,Notification:!1,navigator:!1,onbeforeunload:!0,onblur:!0,onerror:!0,onfocus:!0,onload:!0,onresize:!0,onunload:!0,open:!1,openDatabase:!1,opener:!1,Option:!1,parent:!1,performance:!1,print:!1,Range:!1,requestAnimationFrame:!1,removeEventListener:!1,resizeBy:!1,resizeTo:!1,screen:!1,scroll:!1,scrollBy:!1,scrollTo:!1,sessionStorage:!1,setInterval:!1,setTimeout:!1,SharedWorker:!1,status:!1,SVGAElement:!1,SVGAltGlyphDefElement:!1,SVGAltGlyphElement:!1,SVGAltGlyphItemElement:!1,SVGAngle:!1,SVGAnimateColorElement:!1,SVGAnimateElement:!1,SVGAnimateMotionElement:!1,SVGAnimateTransformElement:!1,SVGAnimatedAngle:!1,SVGAnimatedBoolean:!1,SVGAnimatedEnumeration:!1,SVGAnimatedInteger:!1,SVGAnimatedLength:!1,SVGAnimatedLengthList:!1,SVGAnimatedNumber:!1,SVGAnimatedNumberList:!1,SVGAnimatedPathData:!1,SVGAnimatedPoints:!1,SVGAnimatedPreserveAspectRatio:!1,SVGAnimatedRect:!1,SVGAnimatedString:!1,SVGAnimatedTransformList:!1,SVGAnimationElement:!1,SVGCSSRule:!1,SVGCircleElement:!1,SVGClipPathElement:!1,SVGColor:!1,SVGColorProfileElement:!1,SVGColorProfileRule:!1,SVGComponentTransferFunctionElement:!1,SVGCursorElement:!1,SVGDefsElement:!1,SVGDescElement:!1,SVGDocument:!1,SVGElement:!1,SVGElementInstance:!1,SVGElementInstanceList:!1,SVGEllipseElement:!1,SVGExternalResourcesRequired:!1,SVGFEBlendElement:!1,SVGFEColorMatrixElement:!1,SVGFEComponentTransferElement:!1,SVGFECompositeElement:!1,SVGFEConvolveMatrixElement:!1,SVGFEDiffuseLightingElement:!1,SVGFEDisplacementMapElement:!1,SVGFEDistantLightElement:!1,SVGFEFloodElement:!1,SVGFEFuncAElement:!1,SVGFEFuncBElement:!1,SVGFEFuncGElement:!1,SVGFEFuncRElement:!1,SVGFEGaussianBlurElement:!1,SVGFEImageElement:!1,SVGFEMergeElement:!1,SVGFEMergeNodeElement:!1,SVGFEMorphologyElement:!1,SVGFEOffsetElement:!1,SVGFEPointLightElement:!1,SVGFESpecularLightingElement:!1,SVGFESpotLightElement:!1,SVGFETileElement:!1,SVGFETurbulenceElement:!1,SVGFilterElement:!1,SVGFilterPrimitiveStandardAttributes:!1,SVGFitToViewBox:!1,SVGFontElement:!1,SVGFontFaceElement:!1,SVGFontFaceFormatElement:!1,SVGFontFaceNameElement:!1,SVGFontFaceSrcElement:!1,SVGFontFaceUriElement:!1,SVGForeignObjectElement:!1,SVGGElement:!1,SVGGlyphElement:!1,SVGGlyphRefElement:!1,SVGGradientElement:!1,SVGHKernElement:!1,SVGICCColor:!1,SVGImageElement:!1,SVGLangSpace:!1,SVGLength:!1,SVGLengthList:!1,SVGLineElement:!1,SVGLinearGradientElement:!1,SVGLocatable:!1,SVGMPathElement:!1,SVGMarkerElement:!1,SVGMaskElement:!1,SVGMatrix:!1,SVGMetadataElement:!1,SVGMissingGlyphElement:!1,SVGNumber:!1,SVGNumberList:!1,SVGPaint:!1,SVGPathElement:!1,SVGPathSeg:!1,SVGPathSegArcAbs:!1,SVGPathSegArcRel:!1,SVGPathSegClosePath:!1,SVGPathSegCurvetoCubicAbs:!1,SVGPathSegCurvetoCubicRel:!1,SVGPathSegCurvetoCubicSmoothAbs:!1,SVGPathSegCurvetoCubicSmoothRel:!1,SVGPathSegCurvetoQuadraticAbs:!1,SVGPathSegCurvetoQuadraticRel:!1,SVGPathSegCurvetoQuadraticSmoothAbs:!1,SVGPathSegCurvetoQuadraticSmoothRel:!1,SVGPathSegLinetoAbs:!1,SVGPathSegLinetoHorizontalAbs:!1,SVGPathSegLinetoHorizontalRel:!1,SVGPathSegLinetoRel:!1,SVGPathSegLinetoVerticalAbs:!1,SVGPathSegLinetoVerticalRel:!1,SVGPathSegList:!1,SVGPathSegMovetoAbs:!1,SVGPathSegMovetoRel:!1,SVGPatternElement:!1,SVGPoint:!1,SVGPointList:!1,SVGPolygonElement:!1,SVGPolylineElement:!1,SVGPreserveAspectRatio:!1,SVGRadialGradientElement:!1,SVGRect:!1,SVGRectElement:!1,SVGRenderingIntent:!1,SVGSVGElement:!1,SVGScriptElement:!1,SVGSetElement:!1,SVGStopElement:!1,SVGStringList:!1,SVGStylable:!1,SVGStyleElement:!1,SVGSwitchElement:!1,SVGSymbolElement:!1,SVGTRefElement:!1,SVGTSpanElement:!1,SVGTests:!1,SVGTextContentElement:!1,SVGTextElement:!1,SVGTextPathElement:!1,SVGTextPositioningElement:!1,SVGTitleElement:!1,SVGTransform:!1,SVGTransformList:!1,SVGTransformable:!1,SVGURIReference:!1,SVGUnitTypes:!1,SVGUseElement:!1,SVGVKernElement:!1,SVGViewElement:!1,SVGViewSpec:!1,SVGZoomAndPan:!1,Text:!1,TextDecoder:!1,TextEncoder:!1,TimeEvent:!1,top:!1,URL:!1,WebGLActiveInfo:!1,WebGLBuffer:!1,WebGLContextEvent:!1,WebGLFramebuffer:!1,WebGLProgram:!1,WebGLRenderbuffer:!1,WebGLRenderingContext:!1,WebGLShader:!1,WebGLShaderPrecisionFormat:!1,WebGLTexture:!1,WebGLUniformLocation:!1,WebSocket:!1,window:!1,Window:!1,Worker:!1,XDomainRequest:!1,XMLHttpRequest:!1,XMLSerializer:!1,XPathEvaluator:!1,XPathException:!1,XPathExpression:!1,XPathNamespace:!1,XPathNSResolver:!1,XPathResult:!1},exports.devel={alert:!1,confirm:!1,console:!1,Debug:!1,opera:!1,prompt:!1},exports.worker={importScripts:!0,postMessage:!0,self:!0,FileReaderSync:!0},exports.nonstandard={escape:!1,unescape:!1},exports.couch={require:!1,respond:!1,getRow:!1,emit:!1,send:!1,start:!1,sum:!1,log:!1,exports:!1,module:!1,provides:!1},exports.node={__filename:!1,__dirname:!1,GLOBAL:!1,global:!1,module:!1,acequire:!1,Buffer:!0,console:!0,exports:!0,process:!0,setTimeout:!0,clearTimeout:!0,setInterval:!0,clearInterval:!0,setImmediate:!0,clearImmediate:!0},exports.browserify={__filename:!1,__dirname:!1,global:!1,module:!1,acequire:!1,Buffer:!0,exports:!0,process:!0},exports.phantom={phantom:!0,acequire:!0,WebPage:!0,console:!0,exports:!0},exports.qunit={asyncTest:!1,deepEqual:!1,equal:!1,expect:!1,module:!1,notDeepEqual:!1,notEqual:!1,notPropEqual:!1,notStrictEqual:!1,ok:!1,propEqual:!1,QUnit:!1,raises:!1,start:!1,stop:!1,strictEqual:!1,test:!1,"throws":!1},exports.rhino={defineClass:!1,deserialize:!1,gc:!1,help:!1,importClass:!1,importPackage:!1,java:!1,load:!1,loadClass:!1,Packages:!1,print:!1,quit:!1,readFile:!1,readUrl:!1,runCommand:!1,seal:!1,serialize:!1,spawn:!1,sync:!1,toint32:!1,version:!1},exports.shelljs={target:!1,echo:!1,exit:!1,cd:!1,pwd:!1,ls:!1,find:!1,cp:!1,rm:!1,mv:!1,mkdir:!1,test:!1,cat:!1,sed:!1,grep:!1,which:!1,dirs:!1,pushd:!1,popd:!1,env:!1,exec:!1,chmod:!1,config:!1,error:!1,tempdir:!1},exports.typed={ArrayBuffer:!1,ArrayBufferView:!1,DataView:!1,Float32Array:!1,Float64Array:!1,Int16Array:!1,Int32Array:!1,Int8Array:!1,Uint16Array:!1,Uint32Array:!1,Uint8Array:!1,Uint8ClampedArray:!1},exports.wsh={ActiveXObject:!0,Enumerator:!0,GetObject:!0,ScriptEngine:!0,ScriptEngineBuildVersion:!0,ScriptEngineMajorVersion:!0,ScriptEngineMinorVersion:!0,VBArray:!0,WSH:!0,WScript:!0,XDomainRequest:!0},exports.dojo={dojo:!1,dijit:!1,dojox:!1,define:!1,require:!1},exports.jquery={$:!1,jQuery:!1},exports.mootools={$:!1,$$:!1,Asset:!1,Browser:!1,Chain:!1,Class:!1,Color:!1,Cookie:!1,Core:!1,Document:!1,DomReady:!1,DOMEvent:!1,DOMReady:!1,Drag:!1,Element:!1,Elements:!1,Event:!1,Events:!1,Fx:!1,Group:!1,Hash:!1,HtmlTable:!1,IFrame:!1,IframeShim:!1,InputValidator:!1,instanceOf:!1,Keyboard:!1,Locale:!1,Mask:!1,MooTools:!1,Native:!1,Options:!1,OverText:!1,Request:!1,Scroller:!1,Slick:!1,Slider:!1,Sortables:!1,Spinner:!1,Swiff:!1,Tips:!1,Type:!1,typeOf:!1,URI:!1,Window:!1},exports.prototypejs={$:!1,$$:!1,$A:!1,$F:!1,$H:!1,$R:!1,$break:!1,$continue:!1,$w:!1,Abstract:!1,Ajax:!1,Class:!1,Enumerable:!1,Element:!1,Event:!1,Field:!1,Form:!1,Hash:!1,Insertion:!1,ObjectRange:!1,PeriodicalExecuter:!1,Position:!1,Prototype:!1,Selector:!1,Template:!1,Toggle:!1,Try:!1,Autocompleter:!1,Builder:!1,Control:!1,Draggable:!1,Draggables:!1,Droppables:!1,Effect:!1,Sortable:!1,SortableObserver:!1,Sound:!1,Scriptaculous:!1},exports.yui={YUI:!1,Y:!1,YUI_config:!1},exports.mocha={mocha:!1,describe:!1,xdescribe:!1,it:!1,xit:!1,context:!1,xcontext:!1,before:!1,after:!1,beforeEach:!1,afterEach:!1,suite:!1,test:!1,setup:!1,teardown:!1,suiteSetup:!1,suiteTeardown:!1},exports.jasmine={jasmine:!1,describe:!1,xdescribe:!1,it:!1,xit:!1,beforeEach:!1,afterEach:!1,setFixtures:!1,loadFixtures:!1,spyOn:!1,expect:!1,runs:!1,waitsFor:!1,waits:!1,beforeAll:!1,afterAll:!1,fail:!1,fdescribe:!1,fit:!1,pending:!1}},{}]},{},["/node_modules/jshint/src/jshint.js"])}),ace.define("ace/mode/javascript_worker",["require","exports","module","ace/lib/oop","ace/worker/mirror","ace/mode/javascript/jshint"],function(acequire,exports,module){"use strict";function startRegex(arr){return RegExp("^("+arr.join("|")+")")}var oop=acequire("../lib/oop"),Mirror=acequire("../worker/mirror").Mirror,lint=acequire("./javascript/jshint").JSHINT,disabledWarningsRe=startRegex(["Bad for in variable '(.+)'.",'Missing "use strict"']),errorsRe=startRegex(["Unexpected","Expected ","Confusing (plus|minus)","\\\\{a\\\\} unterminated regular expression","Unclosed ","Unmatched ","Unbegun comment","Bad invocation","Missing space after","Missing operator at"]),infoRe=startRegex(["Expected an assignment","Bad escapement of EOL","Unexpected comma","Unexpected space","Missing radix parameter.","A leading decimal point can","\\\\['{a}'\\\\] is better written in dot notation.","'{a}' used out of scope"]),JavaScriptWorker=exports.JavaScriptWorker=function(sender){Mirror.call(this,sender),this.setTimeout(500),this.setOptions()};oop.inherits(JavaScriptWorker,Mirror),function(){this.setOptions=function(options){this.options=options||{esnext:!0,moz:!0,devel:!0,browser:!0,node:!0,laxcomma:!0,laxbreak:!0,lastsemic:!0,onevar:!1,passfail:!1,maxerr:100,expr:!0,multistr:!0,globalstrict:!0},this.doc.getValue()&&this.deferredUpdate.schedule(100)},this.changeOptions=function(newOptions){oop.mixin(this.options,newOptions),this.doc.getValue()&&this.deferredUpdate.schedule(100)},this.isValidJS=function(str){try{eval("throw 0;"+str)}catch(e){if(0===e)return!0}return!1},this.onUpdate=function(){var value=this.doc.getValue();if(value=value.replace(/^#!.*\\n/,"\\n"),!value)return this.sender.emit("annotate",[]);var errors=[],maxErrorLevel=this.isValidJS(value)?"warning":"error";lint(value,this.options,this.options.globals);for(var results=lint.errors,errorAdded=!1,i=0;results.length>i;i++){var error=results[i];if(error){var raw=error.raw,type="warning";if("Missing semicolon."==raw){var str=error.evidence.substr(error.character);str=str.charAt(str.search(/\\S/)),"error"==maxErrorLevel&&str&&/[\\w\\d{(['"]/.test(str)?(error.reason='Missing ";" before statement',type="error"):type="info"}else{if(disabledWarningsRe.test(raw))continue;infoRe.test(raw)?type="info":errorsRe.test(raw)?(errorAdded=!0,type=maxErrorLevel):"'{a}' is not defined."==raw?type="warning":"'{a}' is defined but never used."==raw&&(type="info")}errors.push({row:error.line-1,column:error.character-1,text:error.reason,type:type,raw:raw})}}this.sender.emit("annotate",errors)}}.call(JavaScriptWorker.prototype)}),ace.define("ace/lib/es5-shim",["require","exports","module"],function(){function Empty(){}function doesDefinePropertyWork(object){try{return Object.defineProperty(object,"sentinel",{}),"sentinel"in object}catch(exception){}}function toInteger(n){return n=+n,n!==n?n=0:0!==n&&n!==1/0&&n!==-(1/0)&&(n=(n>0||-1)*Math.floor(Math.abs(n))),n}Function.prototype.bind||(Function.prototype.bind=function(that){var target=this;if("function"!=typeof target)throw new TypeError("Function.prototype.bind called on incompatible "+target);var args=slice.call(arguments,1),bound=function(){if(this instanceof bound){var result=target.apply(this,args.concat(slice.call(arguments)));return Object(result)===result?result:this}return target.apply(that,args.concat(slice.call(arguments)))};return target.prototype&&(Empty.prototype=target.prototype,bound.prototype=new Empty,Empty.prototype=null),bound});var defineGetter,defineSetter,lookupGetter,lookupSetter,supportsAccessors,call=Function.prototype.call,prototypeOfArray=Array.prototype,prototypeOfObject=Object.prototype,slice=prototypeOfArray.slice,_toString=call.bind(prototypeOfObject.toString),owns=call.bind(prototypeOfObject.hasOwnProperty);if((supportsAccessors=owns(prototypeOfObject,"__defineGetter__"))&&(defineGetter=call.bind(prototypeOfObject.__defineGetter__),defineSetter=call.bind(prototypeOfObject.__defineSetter__),lookupGetter=call.bind(prototypeOfObject.__lookupGetter__),lookupSetter=call.bind(prototypeOfObject.__lookupSetter__)),2!=[1,2].splice(0).length)if(function(){function makeArray(l){var a=Array(l+2);return a[0]=a[1]=0,a}var lengthBefore,array=[];return array.splice.apply(array,makeArray(20)),array.splice.apply(array,makeArray(26)),lengthBefore=array.length,array.splice(5,0,"XXX"),lengthBefore+1==array.length,lengthBefore+1==array.length?!0:void 0}()){var array_splice=Array.prototype.splice;Array.prototype.splice=function(start,deleteCount){return arguments.length?array_splice.apply(this,[void 0===start?0:start,void 0===deleteCount?this.length-start:deleteCount].concat(slice.call(arguments,2))):[]}}else Array.prototype.splice=function(pos,removeCount){var length=this.length;pos>0?pos>length&&(pos=length):void 0==pos?pos=0:0>pos&&(pos=Math.max(length+pos,0)),length>pos+removeCount||(removeCount=length-pos);var removed=this.slice(pos,pos+removeCount),insert=slice.call(arguments,2),add=insert.length;if(pos===length)add&&this.push.apply(this,insert);else{var remove=Math.min(removeCount,length-pos),tailOldPos=pos+remove,tailNewPos=tailOldPos+add-remove,tailCount=length-tailOldPos,lengthAfterRemove=length-remove;if(tailOldPos>tailNewPos)for(var i=0;tailCount>i;++i)this[tailNewPos+i]=this[tailOldPos+i];else if(tailNewPos>tailOldPos)for(i=tailCount;i--;)this[tailNewPos+i]=this[tailOldPos+i];if(add&&pos===lengthAfterRemove)this.length=lengthAfterRemove,this.push.apply(this,insert);else for(this.length=lengthAfterRemove+add,i=0;add>i;++i)this[pos+i]=insert[i]}return removed};Array.isArray||(Array.isArray=function(obj){return"[object Array]"==_toString(obj)});var boxedString=Object("a"),splitString="a"!=boxedString[0]||!(0 in boxedString);if(Array.prototype.forEach||(Array.prototype.forEach=function(fun){var object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,thisp=arguments[1],i=-1,length=self.length>>>0;if("[object Function]"!=_toString(fun))throw new TypeError;for(;length>++i;)i in self&&fun.call(thisp,self[i],i,object)}),Array.prototype.map||(Array.prototype.map=function(fun){var object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,length=self.length>>>0,result=Array(length),thisp=arguments[1];if("[object Function]"!=_toString(fun))throw new TypeError(fun+" is not a function");for(var i=0;length>i;i++)i in self&&(result[i]=fun.call(thisp,self[i],i,object));return result}),Array.prototype.filter||(Array.prototype.filter=function(fun){var value,object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,length=self.length>>>0,result=[],thisp=arguments[1];if("[object Function]"!=_toString(fun))throw new TypeError(fun+" is not a function");for(var i=0;length>i;i++)i in self&&(value=self[i],fun.call(thisp,value,i,object)&&result.push(value));return result}),Array.prototype.every||(Array.prototype.every=function(fun){var object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,length=self.length>>>0,thisp=arguments[1];if("[object Function]"!=_toString(fun))throw new TypeError(fun+" is not a function");for(var i=0;length>i;i++)if(i in self&&!fun.call(thisp,self[i],i,object))return!1;return!0}),Array.prototype.some||(Array.prototype.some=function(fun){var object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,length=self.length>>>0,thisp=arguments[1];if("[object Function]"!=_toString(fun))throw new TypeError(fun+" is not a function");for(var i=0;length>i;i++)if(i in self&&fun.call(thisp,self[i],i,object))return!0;return!1}),Array.prototype.reduce||(Array.prototype.reduce=function(fun){var object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,length=self.length>>>0;if("[object Function]"!=_toString(fun))throw new TypeError(fun+" is not a function");if(!length&&1==arguments.length)throw new TypeError("reduce of empty array with no initial value");var result,i=0;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i++];break}if(++i>=length)throw new TypeError("reduce of empty array with no initial value")}for(;length>i;i++)i in self&&(result=fun.call(void 0,result,self[i],i,object));return result}),Array.prototype.reduceRight||(Array.prototype.reduceRight=function(fun){var object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,length=self.length>>>0;if("[object Function]"!=_toString(fun))throw new TypeError(fun+" is not a function");if(!length&&1==arguments.length)throw new TypeError("reduceRight of empty array with no initial value");var result,i=length-1;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i--];break}if(0>--i)throw new TypeError("reduceRight of empty array with no initial value")}do i in this&&(result=fun.call(void 0,result,self[i],i,object));while(i--);return result}),Array.prototype.indexOf&&-1==[0,1].indexOf(1,2)||(Array.prototype.indexOf=function(sought){var self=splitString&&"[object String]"==_toString(this)?this.split(""):toObject(this),length=self.length>>>0;if(!length)return-1;var i=0;for(arguments.length>1&&(i=toInteger(arguments[1])),i=i>=0?i:Math.max(0,length+i);length>i;i++)if(i in self&&self[i]===sought)return i;return-1}),Array.prototype.lastIndexOf&&-1==[0,1].lastIndexOf(0,-3)||(Array.prototype.lastIndexOf=function(sought){var self=splitString&&"[object String]"==_toString(this)?this.split(""):toObject(this),length=self.length>>>0;if(!length)return-1;var i=length-1;for(arguments.length>1&&(i=Math.min(i,toInteger(arguments[1]))),i=i>=0?i:length-Math.abs(i);i>=0;i--)if(i in self&&sought===self[i])return i;return-1}),Object.getPrototypeOf||(Object.getPrototypeOf=function(object){return object.__proto__||(object.constructor?object.constructor.prototype:prototypeOfObject)}),!Object.getOwnPropertyDescriptor){var ERR_NON_OBJECT="Object.getOwnPropertyDescriptor called on a non-object: ";Object.getOwnPropertyDescriptor=function(object,property){if("object"!=typeof object&&"function"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT+object);if(owns(object,property)){var descriptor,getter,setter;if(descriptor={enumerable:!0,configurable:!0},supportsAccessors){var prototype=object.__proto__;object.__proto__=prototypeOfObject;var getter=lookupGetter(object,property),setter=lookupSetter(object,property);if(object.__proto__=prototype,getter||setter)return getter&&(descriptor.get=getter),setter&&(descriptor.set=setter),descriptor}return descriptor.value=object[property],descriptor}}}if(Object.getOwnPropertyNames||(Object.getOwnPropertyNames=function(object){return Object.keys(object)}),!Object.create){var createEmpty;createEmpty=null===Object.prototype.__proto__?function(){return{__proto__:null}}:function(){var empty={};for(var i in empty)empty[i]=null;return empty.constructor=empty.hasOwnProperty=empty.propertyIsEnumerable=empty.isPrototypeOf=empty.toLocaleString=empty.toString=empty.valueOf=empty.__proto__=null,empty},Object.create=function(prototype,properties){var object;if(null===prototype)object=createEmpty();else{if("object"!=typeof prototype)throw new TypeError("typeof prototype["+typeof prototype+"] != 'object'");var Type=function(){};Type.prototype=prototype,object=new Type,object.__proto__=prototype}return void 0!==properties&&Object.defineProperties(object,properties),object}}if(Object.defineProperty){var definePropertyWorksOnObject=doesDefinePropertyWork({}),definePropertyWorksOnDom="undefined"==typeof document||doesDefinePropertyWork(document.createElement("div"));if(!definePropertyWorksOnObject||!definePropertyWorksOnDom)var definePropertyFallback=Object.defineProperty}if(!Object.defineProperty||definePropertyFallback){var ERR_NON_OBJECT_DESCRIPTOR="Property description must be an object: ",ERR_NON_OBJECT_TARGET="Object.defineProperty called on non-object: ",ERR_ACCESSORS_NOT_SUPPORTED="getters & setters can not be defined on this javascript engine";Object.defineProperty=function(object,property,descriptor){if("object"!=typeof object&&"function"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT_TARGET+object);if("object"!=typeof descriptor&&"function"!=typeof descriptor||null===descriptor)throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR+descriptor);if(definePropertyFallback)try{return definePropertyFallback.call(Object,object,property,descriptor)}catch(exception){}if(owns(descriptor,"value"))if(supportsAccessors&&(lookupGetter(object,property)||lookupSetter(object,property))){var prototype=object.__proto__;object.__proto__=prototypeOfObject,delete object[property],object[property]=descriptor.value,object.__proto__=prototype}else object[property]=descriptor.value;else{if(!supportsAccessors)throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);owns(descriptor,"get")&&defineGetter(object,property,descriptor.get),owns(descriptor,"set")&&defineSetter(object,property,descriptor.set)}return object}}Object.defineProperties||(Object.defineProperties=function(object,properties){for(var property in properties)owns(properties,property)&&Object.defineProperty(object,property,properties[property]);return object}),Object.seal||(Object.seal=function(object){return object}),Object.freeze||(Object.freeze=function(object){return object});try{Object.freeze(function(){})}catch(exception){Object.freeze=function(freezeObject){return function(object){return"function"==typeof object?object:freezeObject(object)}}(Object.freeze)}if(Object.preventExtensions||(Object.preventExtensions=function(object){return object}),Object.isSealed||(Object.isSealed=function(){return!1}),Object.isFrozen||(Object.isFrozen=function(){return!1}),Object.isExtensible||(Object.isExtensible=function(object){if(Object(object)===object)throw new TypeError;for(var name="";owns(object,name);)name+="?";object[name]=!0;var returnValue=owns(object,name);return delete object[name],returnValue}),!Object.keys){var hasDontEnumBug=!0,dontEnums=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],dontEnumsLength=dontEnums.length;for(var key in{toString:null})hasDontEnumBug=!1;Object.keys=function(object){if("object"!=typeof object&&"function"!=typeof object||null===object)throw new TypeError("Object.keys called on a non-object");var keys=[];for(var name in object)owns(object,name)&&keys.push(name);if(hasDontEnumBug)for(var i=0,ii=dontEnumsLength;ii>i;i++){var dontEnum=dontEnums[i];owns(object,dontEnum)&&keys.push(dontEnum)}return keys}}Date.now||(Date.now=function(){return(new Date).getTime()});var ws="	\\n\v\\f\\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\\u2028\\u2029\uFEFF";if(!String.prototype.trim||ws.trim()){ws="["+ws+"]";var trimBeginRegexp=RegExp("^"+ws+ws+"*"),trimEndRegexp=RegExp(ws+ws+"*$");String.prototype.trim=function(){return(this+"").replace(trimBeginRegexp,"").replace(trimEndRegexp,"")}}var toObject=function(o){if(null==o)throw new TypeError("can't convert "+o+" to object");return Object(o)}});`;
    }
  });

  // node_modules/brace/worker/html.js
  var require_html = __commonJS({
    "node_modules/brace/worker/html.js"(exports, module) {
      module.exports.id = "ace/mode/html_worker";
      module.exports.src = `"no use strict";!function(window){function resolveModuleId(id,paths){for(var testPath=id,tail="";testPath;){var alias=paths[testPath];if("string"==typeof alias)return alias+tail;if(alias)return alias.location.replace(/\\/*$/,"/")+(tail||alias.main||alias.name);if(alias===!1)return"";var i=testPath.lastIndexOf("/");if(-1===i)break;tail=testPath.substr(i)+tail,testPath=testPath.slice(0,i)}return id}if(!(void 0!==window.window&&window.document||window.acequire&&window.define)){window.console||(window.console=function(){var msgs=Array.prototype.slice.call(arguments,0);postMessage({type:"log",data:msgs})},window.console.error=window.console.warn=window.console.log=window.console.trace=window.console),window.window=window,window.ace=window,window.onerror=function(message,file,line,col,err){postMessage({type:"error",data:{message:message,data:err.data,file:file,line:line,col:col,stack:err.stack}})},window.normalizeModule=function(parentId,moduleName){if(-1!==moduleName.indexOf("!")){var chunks=moduleName.split("!");return window.normalizeModule(parentId,chunks[0])+"!"+window.normalizeModule(parentId,chunks[1])}if("."==moduleName.charAt(0)){var base=parentId.split("/").slice(0,-1).join("/");for(moduleName=(base?base+"/":"")+moduleName;-1!==moduleName.indexOf(".")&&previous!=moduleName;){var previous=moduleName;moduleName=moduleName.replace(/^\\.\\//,"").replace(/\\/\\.\\//,"/").replace(/[^\\/]+\\/\\.\\.\\//,"")}}return moduleName},window.acequire=function acequire(parentId,id){if(id||(id=parentId,parentId=null),!id.charAt)throw Error("worker.js acequire() accepts only (parentId, id) as arguments");id=window.normalizeModule(parentId,id);var module=window.acequire.modules[id];if(module)return module.initialized||(module.initialized=!0,module.exports=module.factory().exports),module.exports;if(!window.acequire.tlns)return console.log("unable to load "+id);var path=resolveModuleId(id,window.acequire.tlns);return".js"!=path.slice(-3)&&(path+=".js"),window.acequire.id=id,window.acequire.modules[id]={},importScripts(path),window.acequire(parentId,id)},window.acequire.modules={},window.acequire.tlns={},window.define=function(id,deps,factory){if(2==arguments.length?(factory=deps,"string"!=typeof id&&(deps=id,id=window.acequire.id)):1==arguments.length&&(factory=id,deps=[],id=window.acequire.id),"function"!=typeof factory)return window.acequire.modules[id]={exports:factory,initialized:!0},void 0;deps.length||(deps=["require","exports","module"]);var req=function(childId){return window.acequire(id,childId)};window.acequire.modules[id]={exports:{},factory:function(){var module=this,returnExports=factory.apply(this,deps.map(function(dep){switch(dep){case"require":return req;case"exports":return module.exports;case"module":return module;default:return req(dep)}}));return returnExports&&(module.exports=returnExports),module}}},window.define.amd={},acequire.tlns={},window.initBaseUrls=function(topLevelNamespaces){for(var i in topLevelNamespaces)acequire.tlns[i]=topLevelNamespaces[i]},window.initSender=function(){var EventEmitter=window.acequire("ace/lib/event_emitter").EventEmitter,oop=window.acequire("ace/lib/oop"),Sender=function(){};return function(){oop.implement(this,EventEmitter),this.callback=function(data,callbackId){postMessage({type:"call",id:callbackId,data:data})},this.emit=function(name,data){postMessage({type:"event",name:name,data:data})}}.call(Sender.prototype),new Sender};var main=window.main=null,sender=window.sender=null;window.onmessage=function(e){var msg=e.data;if(msg.event&&sender)sender._signal(msg.event,msg.data);else if(msg.command)if(main[msg.command])main[msg.command].apply(main,msg.args);else{if(!window[msg.command])throw Error("Unknown command:"+msg.command);window[msg.command].apply(window,msg.args)}else if(msg.init){window.initBaseUrls(msg.tlns),acequire("ace/lib/es5-shim"),sender=window.sender=window.initSender();var clazz=acequire(msg.module)[msg.classname];main=window.main=new clazz(sender)}}}}(this),ace.define("ace/lib/oop",["require","exports","module"],function(acequire,exports){"use strict";exports.inherits=function(ctor,superCtor){ctor.super_=superCtor,ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:!1,writable:!0,configurable:!0}})},exports.mixin=function(obj,mixin){for(var key in mixin)obj[key]=mixin[key];return obj},exports.implement=function(proto,mixin){exports.mixin(proto,mixin)}}),ace.define("ace/lib/lang",["require","exports","module"],function(acequire,exports){"use strict";exports.last=function(a){return a[a.length-1]},exports.stringReverse=function(string){return string.split("").reverse().join("")},exports.stringRepeat=function(string,count){for(var result="";count>0;)1&count&&(result+=string),(count>>=1)&&(string+=string);return result};var trimBeginRegexp=/^\\s\\s*/,trimEndRegexp=/\\s\\s*$/;exports.stringTrimLeft=function(string){return string.replace(trimBeginRegexp,"")},exports.stringTrimRight=function(string){return string.replace(trimEndRegexp,"")},exports.copyObject=function(obj){var copy={};for(var key in obj)copy[key]=obj[key];return copy},exports.copyArray=function(array){for(var copy=[],i=0,l=array.length;l>i;i++)copy[i]=array[i]&&"object"==typeof array[i]?this.copyObject(array[i]):array[i];return copy},exports.deepCopy=function deepCopy(obj){if("object"!=typeof obj||!obj)return obj;var copy;if(Array.isArray(obj)){copy=[];for(var key=0;obj.length>key;key++)copy[key]=deepCopy(obj[key]);return copy}if("[object Object]"!==Object.prototype.toString.call(obj))return obj;copy={};for(var key in obj)copy[key]=deepCopy(obj[key]);return copy},exports.arrayToMap=function(arr){for(var map={},i=0;arr.length>i;i++)map[arr[i]]=1;return map},exports.createMap=function(props){var map=Object.create(null);for(var i in props)map[i]=props[i];return map},exports.arrayRemove=function(array,value){for(var i=0;array.length>=i;i++)value===array[i]&&array.splice(i,1)},exports.escapeRegExp=function(str){return str.replace(/([.*+?^\${}()|[\\]\\/\\\\])/g,"\\\\$1")},exports.escapeHTML=function(str){return str.replace(/&/g,"&#38;").replace(/"/g,"&#34;").replace(/'/g,"&#39;").replace(/</g,"&#60;")},exports.getMatchOffsets=function(string,regExp){var matches=[];return string.replace(regExp,function(str){matches.push({offset:arguments[arguments.length-2],length:str.length})}),matches},exports.deferredCall=function(fcn){var timer=null,callback=function(){timer=null,fcn()},deferred=function(timeout){return deferred.cancel(),timer=setTimeout(callback,timeout||0),deferred};return deferred.schedule=deferred,deferred.call=function(){return this.cancel(),fcn(),deferred},deferred.cancel=function(){return clearTimeout(timer),timer=null,deferred},deferred.isPending=function(){return timer},deferred},exports.delayedCall=function(fcn,defaultTimeout){var timer=null,callback=function(){timer=null,fcn()},_self=function(timeout){null==timer&&(timer=setTimeout(callback,timeout||defaultTimeout))};return _self.delay=function(timeout){timer&&clearTimeout(timer),timer=setTimeout(callback,timeout||defaultTimeout)},_self.schedule=_self,_self.call=function(){this.cancel(),fcn()},_self.cancel=function(){timer&&clearTimeout(timer),timer=null},_self.isPending=function(){return timer},_self}}),ace.define("ace/range",["require","exports","module"],function(acequire,exports){"use strict";var comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},Range=function(startRow,startColumn,endRow,endColumn){this.start={row:startRow,column:startColumn},this.end={row:endRow,column:endColumn}};(function(){this.isEqual=function(range){return this.start.row===range.start.row&&this.end.row===range.end.row&&this.start.column===range.start.column&&this.end.column===range.end.column},this.toString=function(){return"Range: ["+this.start.row+"/"+this.start.column+"] -> ["+this.end.row+"/"+this.end.column+"]"},this.contains=function(row,column){return 0==this.compare(row,column)},this.compareRange=function(range){var cmp,end=range.end,start=range.start;return cmp=this.compare(end.row,end.column),1==cmp?(cmp=this.compare(start.row,start.column),1==cmp?2:0==cmp?1:0):-1==cmp?-2:(cmp=this.compare(start.row,start.column),-1==cmp?-1:1==cmp?42:0)},this.comparePoint=function(p){return this.compare(p.row,p.column)},this.containsRange=function(range){return 0==this.comparePoint(range.start)&&0==this.comparePoint(range.end)},this.intersects=function(range){var cmp=this.compareRange(range);return-1==cmp||0==cmp||1==cmp},this.isEnd=function(row,column){return this.end.row==row&&this.end.column==column},this.isStart=function(row,column){return this.start.row==row&&this.start.column==column},this.setStart=function(row,column){"object"==typeof row?(this.start.column=row.column,this.start.row=row.row):(this.start.row=row,this.start.column=column)},this.setEnd=function(row,column){"object"==typeof row?(this.end.column=row.column,this.end.row=row.row):(this.end.row=row,this.end.column=column)},this.inside=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)||this.isStart(row,column)?!1:!0:!1},this.insideStart=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)?!1:!0:!1},this.insideEnd=function(row,column){return 0==this.compare(row,column)?this.isStart(row,column)?!1:!0:!1},this.compare=function(row,column){return this.isMultiLine()||row!==this.start.row?this.start.row>row?-1:row>this.end.row?1:this.start.row===row?column>=this.start.column?0:-1:this.end.row===row?this.end.column>=column?0:1:0:this.start.column>column?-1:column>this.end.column?1:0},this.compareStart=function(row,column){return this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.compareEnd=function(row,column){return this.end.row==row&&this.end.column==column?1:this.compare(row,column)},this.compareInside=function(row,column){return this.end.row==row&&this.end.column==column?1:this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.clipRows=function(firstRow,lastRow){if(this.end.row>lastRow)var end={row:lastRow+1,column:0};else if(firstRow>this.end.row)var end={row:firstRow,column:0};if(this.start.row>lastRow)var start={row:lastRow+1,column:0};else if(firstRow>this.start.row)var start={row:firstRow,column:0};return Range.fromPoints(start||this.start,end||this.end)},this.extend=function(row,column){var cmp=this.compare(row,column);if(0==cmp)return this;if(-1==cmp)var start={row:row,column:column};else var end={row:row,column:column};return Range.fromPoints(start||this.start,end||this.end)},this.isEmpty=function(){return this.start.row===this.end.row&&this.start.column===this.end.column},this.isMultiLine=function(){return this.start.row!==this.end.row},this.clone=function(){return Range.fromPoints(this.start,this.end)},this.collapseRows=function(){return 0==this.end.column?new Range(this.start.row,0,Math.max(this.start.row,this.end.row-1),0):new Range(this.start.row,0,this.end.row,0)},this.toScreenRange=function(session){var screenPosStart=session.documentToScreenPosition(this.start),screenPosEnd=session.documentToScreenPosition(this.end);return new Range(screenPosStart.row,screenPosStart.column,screenPosEnd.row,screenPosEnd.column)},this.moveBy=function(row,column){this.start.row+=row,this.start.column+=column,this.end.row+=row,this.end.column+=column}}).call(Range.prototype),Range.fromPoints=function(start,end){return new Range(start.row,start.column,end.row,end.column)},Range.comparePoints=comparePoints,Range.comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},exports.Range=Range}),ace.define("ace/apply_delta",["require","exports","module"],function(acequire,exports){"use strict";exports.applyDelta=function(docLines,delta){var row=delta.start.row,startColumn=delta.start.column,line=docLines[row]||"";switch(delta.action){case"insert":var lines=delta.lines;if(1===lines.length)docLines[row]=line.substring(0,startColumn)+delta.lines[0]+line.substring(startColumn);else{var args=[row,1].concat(delta.lines);docLines.splice.apply(docLines,args),docLines[row]=line.substring(0,startColumn)+docLines[row],docLines[row+delta.lines.length-1]+=line.substring(startColumn)}break;case"remove":var endColumn=delta.end.column,endRow=delta.end.row;row===endRow?docLines[row]=line.substring(0,startColumn)+line.substring(endColumn):docLines.splice(row,endRow-row+1,line.substring(0,startColumn)+docLines[endRow].substring(endColumn))}}}),ace.define("ace/lib/event_emitter",["require","exports","module"],function(acequire,exports){"use strict";var EventEmitter={},stopPropagation=function(){this.propagationStopped=!0},preventDefault=function(){this.defaultPrevented=!0};EventEmitter._emit=EventEmitter._dispatchEvent=function(eventName,e){this._eventRegistry||(this._eventRegistry={}),this._defaultHandlers||(this._defaultHandlers={});var listeners=this._eventRegistry[eventName]||[],defaultHandler=this._defaultHandlers[eventName];if(listeners.length||defaultHandler){"object"==typeof e&&e||(e={}),e.type||(e.type=eventName),e.stopPropagation||(e.stopPropagation=stopPropagation),e.preventDefault||(e.preventDefault=preventDefault),listeners=listeners.slice();for(var i=0;listeners.length>i&&(listeners[i](e,this),!e.propagationStopped);i++);return defaultHandler&&!e.defaultPrevented?defaultHandler(e,this):void 0}},EventEmitter._signal=function(eventName,e){var listeners=(this._eventRegistry||{})[eventName];if(listeners){listeners=listeners.slice();for(var i=0;listeners.length>i;i++)listeners[i](e,this)}},EventEmitter.once=function(eventName,callback){var _self=this;callback&&this.addEventListener(eventName,function newCallback(){_self.removeEventListener(eventName,newCallback),callback.apply(null,arguments)})},EventEmitter.setDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers||(handlers=this._defaultHandlers={_disabled_:{}}),handlers[eventName]){var old=handlers[eventName],disabled=handlers._disabled_[eventName];disabled||(handlers._disabled_[eventName]=disabled=[]),disabled.push(old);var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}handlers[eventName]=callback},EventEmitter.removeDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers){var disabled=handlers._disabled_[eventName];if(handlers[eventName]==callback)handlers[eventName],disabled&&this.setDefaultHandler(eventName,disabled.pop());else if(disabled){var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}}},EventEmitter.on=EventEmitter.addEventListener=function(eventName,callback,capturing){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];return listeners||(listeners=this._eventRegistry[eventName]=[]),-1==listeners.indexOf(callback)&&listeners[capturing?"unshift":"push"](callback),callback},EventEmitter.off=EventEmitter.removeListener=EventEmitter.removeEventListener=function(eventName,callback){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];if(listeners){var index=listeners.indexOf(callback);-1!==index&&listeners.splice(index,1)}},EventEmitter.removeAllListeners=function(eventName){this._eventRegistry&&(this._eventRegistry[eventName]=[])},exports.EventEmitter=EventEmitter}),ace.define("ace/anchor",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"],function(acequire,exports){"use strict";var oop=acequire("./lib/oop"),EventEmitter=acequire("./lib/event_emitter").EventEmitter,Anchor=exports.Anchor=function(doc,row,column){this.$onChange=this.onChange.bind(this),this.attach(doc),column===void 0?this.setPosition(row.row,row.column):this.setPosition(row,column)};(function(){function $pointsInOrder(point1,point2,equalPointsInOrder){var bColIsAfter=equalPointsInOrder?point1.column<=point2.column:point1.column<point2.column;return point1.row<point2.row||point1.row==point2.row&&bColIsAfter}function $getTransformedPoint(delta,point,moveIfEqual){var deltaIsInsert="insert"==delta.action,deltaRowShift=(deltaIsInsert?1:-1)*(delta.end.row-delta.start.row),deltaColShift=(deltaIsInsert?1:-1)*(delta.end.column-delta.start.column),deltaStart=delta.start,deltaEnd=deltaIsInsert?deltaStart:delta.end;return $pointsInOrder(point,deltaStart,moveIfEqual)?{row:point.row,column:point.column}:$pointsInOrder(deltaEnd,point,!moveIfEqual)?{row:point.row+deltaRowShift,column:point.column+(point.row==deltaEnd.row?deltaColShift:0)}:{row:deltaStart.row,column:deltaStart.column}}oop.implement(this,EventEmitter),this.getPosition=function(){return this.$clipPositionToDocument(this.row,this.column)},this.getDocument=function(){return this.document},this.$insertRight=!1,this.onChange=function(delta){if(!(delta.start.row==delta.end.row&&delta.start.row!=this.row||delta.start.row>this.row)){var point=$getTransformedPoint(delta,{row:this.row,column:this.column},this.$insertRight);this.setPosition(point.row,point.column,!0)}},this.setPosition=function(row,column,noClip){var pos;if(pos=noClip?{row:row,column:column}:this.$clipPositionToDocument(row,column),this.row!=pos.row||this.column!=pos.column){var old={row:this.row,column:this.column};this.row=pos.row,this.column=pos.column,this._signal("change",{old:old,value:pos})}},this.detach=function(){this.document.removeEventListener("change",this.$onChange)},this.attach=function(doc){this.document=doc||this.document,this.document.on("change",this.$onChange)},this.$clipPositionToDocument=function(row,column){var pos={};return row>=this.document.getLength()?(pos.row=Math.max(0,this.document.getLength()-1),pos.column=this.document.getLine(pos.row).length):0>row?(pos.row=0,pos.column=0):(pos.row=row,pos.column=Math.min(this.document.getLine(pos.row).length,Math.max(0,column))),0>column&&(pos.column=0),pos}}).call(Anchor.prototype)}),ace.define("ace/document",["require","exports","module","ace/lib/oop","ace/apply_delta","ace/lib/event_emitter","ace/range","ace/anchor"],function(acequire,exports){"use strict";var oop=acequire("./lib/oop"),applyDelta=acequire("./apply_delta").applyDelta,EventEmitter=acequire("./lib/event_emitter").EventEmitter,Range=acequire("./range").Range,Anchor=acequire("./anchor").Anchor,Document=function(textOrLines){this.$lines=[""],0===textOrLines.length?this.$lines=[""]:Array.isArray(textOrLines)?this.insertMergedLines({row:0,column:0},textOrLines):this.insert({row:0,column:0},textOrLines)};(function(){oop.implement(this,EventEmitter),this.setValue=function(text){var len=this.getLength()-1;this.remove(new Range(0,0,len,this.getLine(len).length)),this.insert({row:0,column:0},text)},this.getValue=function(){return this.getAllLines().join(this.getNewLineCharacter())},this.createAnchor=function(row,column){return new Anchor(this,row,column)},this.$split=0==="aaa".split(/a/).length?function(text){return text.replace(/\\r\\n|\\r/g,"\\n").split("\\n")}:function(text){return text.split(/\\r\\n|\\r|\\n/)},this.$detectNewLine=function(text){var match=text.match(/^.*?(\\r\\n|\\r|\\n)/m);this.$autoNewLine=match?match[1]:"\\n",this._signal("changeNewLineMode")},this.getNewLineCharacter=function(){switch(this.$newLineMode){case"windows":return"\\r\\n";case"unix":return"\\n";default:return this.$autoNewLine||"\\n"}},this.$autoNewLine="",this.$newLineMode="auto",this.setNewLineMode=function(newLineMode){this.$newLineMode!==newLineMode&&(this.$newLineMode=newLineMode,this._signal("changeNewLineMode"))},this.getNewLineMode=function(){return this.$newLineMode},this.isNewLine=function(text){return"\\r\\n"==text||"\\r"==text||"\\n"==text},this.getLine=function(row){return this.$lines[row]||""},this.getLines=function(firstRow,lastRow){return this.$lines.slice(firstRow,lastRow+1)},this.getAllLines=function(){return this.getLines(0,this.getLength())},this.getLength=function(){return this.$lines.length},this.getTextRange=function(range){return this.getLinesForRange(range).join(this.getNewLineCharacter())},this.getLinesForRange=function(range){var lines;if(range.start.row===range.end.row)lines=[this.getLine(range.start.row).substring(range.start.column,range.end.column)];else{lines=this.getLines(range.start.row,range.end.row),lines[0]=(lines[0]||"").substring(range.start.column);var l=lines.length-1;range.end.row-range.start.row==l&&(lines[l]=lines[l].substring(0,range.end.column))}return lines},this.insertLines=function(row,lines){return console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead."),this.insertFullLines(row,lines)},this.removeLines=function(firstRow,lastRow){return console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead."),this.removeFullLines(firstRow,lastRow)},this.insertNewLine=function(position){return console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead."),this.insertMergedLines(position,["",""])},this.insert=function(position,text){return 1>=this.getLength()&&this.$detectNewLine(text),this.insertMergedLines(position,this.$split(text))},this.insertInLine=function(position,text){var start=this.clippedPos(position.row,position.column),end=this.pos(position.row,position.column+text.length);return this.applyDelta({start:start,end:end,action:"insert",lines:[text]},!0),this.clonePos(end)},this.clippedPos=function(row,column){var length=this.getLength();void 0===row?row=length:0>row?row=0:row>=length&&(row=length-1,column=void 0);var line=this.getLine(row);return void 0==column&&(column=line.length),column=Math.min(Math.max(column,0),line.length),{row:row,column:column}},this.clonePos=function(pos){return{row:pos.row,column:pos.column}},this.pos=function(row,column){return{row:row,column:column}},this.$clipPosition=function(position){var length=this.getLength();return position.row>=length?(position.row=Math.max(0,length-1),position.column=this.getLine(length-1).length):(position.row=Math.max(0,position.row),position.column=Math.min(Math.max(position.column,0),this.getLine(position.row).length)),position},this.insertFullLines=function(row,lines){row=Math.min(Math.max(row,0),this.getLength());var column=0;this.getLength()>row?(lines=lines.concat([""]),column=0):(lines=[""].concat(lines),row--,column=this.$lines[row].length),this.insertMergedLines({row:row,column:column},lines)},this.insertMergedLines=function(position,lines){var start=this.clippedPos(position.row,position.column),end={row:start.row+lines.length-1,column:(1==lines.length?start.column:0)+lines[lines.length-1].length};return this.applyDelta({start:start,end:end,action:"insert",lines:lines}),this.clonePos(end)},this.remove=function(range){var start=this.clippedPos(range.start.row,range.start.column),end=this.clippedPos(range.end.row,range.end.column);return this.applyDelta({start:start,end:end,action:"remove",lines:this.getLinesForRange({start:start,end:end})}),this.clonePos(start)},this.removeInLine=function(row,startColumn,endColumn){var start=this.clippedPos(row,startColumn),end=this.clippedPos(row,endColumn);return this.applyDelta({start:start,end:end,action:"remove",lines:this.getLinesForRange({start:start,end:end})},!0),this.clonePos(start)},this.removeFullLines=function(firstRow,lastRow){firstRow=Math.min(Math.max(0,firstRow),this.getLength()-1),lastRow=Math.min(Math.max(0,lastRow),this.getLength()-1);var deleteFirstNewLine=lastRow==this.getLength()-1&&firstRow>0,deleteLastNewLine=this.getLength()-1>lastRow,startRow=deleteFirstNewLine?firstRow-1:firstRow,startCol=deleteFirstNewLine?this.getLine(startRow).length:0,endRow=deleteLastNewLine?lastRow+1:lastRow,endCol=deleteLastNewLine?0:this.getLine(endRow).length,range=new Range(startRow,startCol,endRow,endCol),deletedLines=this.$lines.slice(firstRow,lastRow+1);return this.applyDelta({start:range.start,end:range.end,action:"remove",lines:this.getLinesForRange(range)}),deletedLines},this.removeNewLine=function(row){this.getLength()-1>row&&row>=0&&this.applyDelta({start:this.pos(row,this.getLine(row).length),end:this.pos(row+1,0),action:"remove",lines:["",""]})},this.replace=function(range,text){if(range instanceof Range||(range=Range.fromPoints(range.start,range.end)),0===text.length&&range.isEmpty())return range.start;if(text==this.getTextRange(range))return range.end;this.remove(range);var end;return end=text?this.insert(range.start,text):range.start},this.applyDeltas=function(deltas){for(var i=0;deltas.length>i;i++)this.applyDelta(deltas[i])},this.revertDeltas=function(deltas){for(var i=deltas.length-1;i>=0;i--)this.revertDelta(deltas[i])},this.applyDelta=function(delta,doNotValidate){var isInsert="insert"==delta.action;(isInsert?1>=delta.lines.length&&!delta.lines[0]:!Range.comparePoints(delta.start,delta.end))||(isInsert&&delta.lines.length>2e4&&this.$splitAndapplyLargeDelta(delta,2e4),applyDelta(this.$lines,delta,doNotValidate),this._signal("change",delta))},this.$splitAndapplyLargeDelta=function(delta,MAX){for(var lines=delta.lines,l=lines.length,row=delta.start.row,column=delta.start.column,from=0,to=0;;){from=to,to+=MAX-1;var chunk=lines.slice(from,to);if(to>l){delta.lines=chunk,delta.start.row=row+from,delta.start.column=column;break}chunk.push(""),this.applyDelta({start:this.pos(row+from,column),end:this.pos(row+to,column=0),action:delta.action,lines:chunk},!0)}},this.revertDelta=function(delta){this.applyDelta({start:this.clonePos(delta.start),end:this.clonePos(delta.end),action:"insert"==delta.action?"remove":"insert",lines:delta.lines.slice()})},this.indexToPosition=function(index,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,i=startRow||0,l=lines.length;l>i;i++)if(index-=lines[i].length+newlineLength,0>index)return{row:i,column:index+lines[i].length+newlineLength};return{row:l-1,column:lines[l-1].length}},this.positionToIndex=function(pos,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,index=0,row=Math.min(pos.row,lines.length),i=startRow||0;row>i;++i)index+=lines[i].length+newlineLength;return index+pos.column}}).call(Document.prototype),exports.Document=Document}),ace.define("ace/worker/mirror",["require","exports","module","ace/range","ace/document","ace/lib/lang"],function(acequire,exports){"use strict";acequire("../range").Range;var Document=acequire("../document").Document,lang=acequire("../lib/lang"),Mirror=exports.Mirror=function(sender){this.sender=sender;var doc=this.doc=new Document(""),deferredUpdate=this.deferredUpdate=lang.delayedCall(this.onUpdate.bind(this)),_self=this;sender.on("change",function(e){var data=e.data;if(data[0].start)doc.applyDeltas(data);else for(var i=0;data.length>i;i+=2){if(Array.isArray(data[i+1]))var d={action:"insert",start:data[i],lines:data[i+1]};else var d={action:"remove",start:data[i],end:data[i+1]};doc.applyDelta(d,!0)}return _self.$timeout?deferredUpdate.schedule(_self.$timeout):(_self.onUpdate(),void 0)})};(function(){this.$timeout=500,this.setTimeout=function(timeout){this.$timeout=timeout},this.setValue=function(value){this.doc.setValue(value),this.deferredUpdate.schedule(this.$timeout)},this.getValue=function(callbackId){this.sender.callback(this.doc.getValue(),callbackId)},this.onUpdate=function(){},this.isPending=function(){return this.deferredUpdate.isPending()}}).call(Mirror.prototype)}),ace.define("ace/mode/html/saxparser",["require","exports","module"],function(acequire,exports,module){module.exports=function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a="function"==typeof acequire&&acequire;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}for(var i="function"==typeof acequire&&acequire,o=0;r.length>o;o++)s(r[o]);return s}({1:[function(_dereq_,module,exports){function isScopeMarker(node){return"http://www.w3.org/1999/xhtml"===node.namespaceURI?"applet"===node.localName||"caption"===node.localName||"marquee"===node.localName||"object"===node.localName||"table"===node.localName||"td"===node.localName||"th"===node.localName:"http://www.w3.org/1998/Math/MathML"===node.namespaceURI?"mi"===node.localName||"mo"===node.localName||"mn"===node.localName||"ms"===node.localName||"mtext"===node.localName||"annotation-xml"===node.localName:"http://www.w3.org/2000/svg"===node.namespaceURI?"foreignObject"===node.localName||"desc"===node.localName||"title"===node.localName:void 0}function isListItemScopeMarker(node){return isScopeMarker(node)||"http://www.w3.org/1999/xhtml"===node.namespaceURI&&"ol"===node.localName||"http://www.w3.org/1999/xhtml"===node.namespaceURI&&"ul"===node.localName}function isTableScopeMarker(node){return"http://www.w3.org/1999/xhtml"===node.namespaceURI&&"table"===node.localName||"http://www.w3.org/1999/xhtml"===node.namespaceURI&&"html"===node.localName}function isTableBodyScopeMarker(node){return"http://www.w3.org/1999/xhtml"===node.namespaceURI&&"tbody"===node.localName||"http://www.w3.org/1999/xhtml"===node.namespaceURI&&"tfoot"===node.localName||"http://www.w3.org/1999/xhtml"===node.namespaceURI&&"thead"===node.localName||"http://www.w3.org/1999/xhtml"===node.namespaceURI&&"html"===node.localName}function isTableRowScopeMarker(node){return"http://www.w3.org/1999/xhtml"===node.namespaceURI&&"tr"===node.localName||"http://www.w3.org/1999/xhtml"===node.namespaceURI&&"html"===node.localName}function isButtonScopeMarker(node){return isScopeMarker(node)||"http://www.w3.org/1999/xhtml"===node.namespaceURI&&"button"===node.localName}function isSelectScopeMarker(node){return!("http://www.w3.org/1999/xhtml"===node.namespaceURI&&"optgroup"===node.localName||"http://www.w3.org/1999/xhtml"===node.namespaceURI&&"option"===node.localName)}function ElementStack(){this.elements=[],this.rootNode=null,this.headElement=null,this.bodyElement=null}ElementStack.prototype._inScope=function(localName,isMarker){for(var i=this.elements.length-1;i>=0;i--){var node=this.elements[i];if(node.localName===localName)return!0;if(isMarker(node))return!1}},ElementStack.prototype.push=function(item){this.elements.push(item)},ElementStack.prototype.pushHtmlElement=function(item){this.rootNode=item.node,this.push(item)},ElementStack.prototype.pushHeadElement=function(item){this.headElement=item.node,this.push(item)},ElementStack.prototype.pushBodyElement=function(item){this.bodyElement=item.node,this.push(item)},ElementStack.prototype.pop=function(){return this.elements.pop()},ElementStack.prototype.remove=function(item){this.elements.splice(this.elements.indexOf(item),1)},ElementStack.prototype.popUntilPopped=function(localName){var element;do element=this.pop();while(element.localName!=localName)},ElementStack.prototype.popUntilTableScopeMarker=function(){for(;!isTableScopeMarker(this.top);)this.pop()},ElementStack.prototype.popUntilTableBodyScopeMarker=function(){for(;!isTableBodyScopeMarker(this.top);)this.pop()},ElementStack.prototype.popUntilTableRowScopeMarker=function(){for(;!isTableRowScopeMarker(this.top);)this.pop()},ElementStack.prototype.item=function(index){return this.elements[index]},ElementStack.prototype.contains=function(element){return-1!==this.elements.indexOf(element)},ElementStack.prototype.inScope=function(localName){return this._inScope(localName,isScopeMarker)},ElementStack.prototype.inListItemScope=function(localName){return this._inScope(localName,isListItemScopeMarker)},ElementStack.prototype.inTableScope=function(localName){return this._inScope(localName,isTableScopeMarker)},ElementStack.prototype.inButtonScope=function(localName){return this._inScope(localName,isButtonScopeMarker)},ElementStack.prototype.inSelectScope=function(localName){return this._inScope(localName,isSelectScopeMarker)},ElementStack.prototype.hasNumberedHeaderElementInScope=function(){for(var i=this.elements.length-1;i>=0;i--){var node=this.elements[i];if(node.isNumberedHeader())return!0;if(isScopeMarker(node))return!1}},ElementStack.prototype.furthestBlockForFormattingElement=function(element){for(var furthestBlock=null,i=this.elements.length-1;i>=0;i--){var node=this.elements[i];
if(node.node===element)break;node.isSpecial()&&(furthestBlock=node)}return furthestBlock},ElementStack.prototype.findIndex=function(localName){for(var i=this.elements.length-1;i>=0;i--)if(this.elements[i].localName==localName)return i;return-1},ElementStack.prototype.remove_openElements_until=function(callback){for(var element,finished=!1;!finished;)element=this.elements.pop(),finished=callback(element);return element},Object.defineProperty(ElementStack.prototype,"top",{get:function(){return this.elements[this.elements.length-1]}}),Object.defineProperty(ElementStack.prototype,"length",{get:function(){return this.elements.length}}),exports.ElementStack=ElementStack},{}],2:[function(_dereq_,module,exports){function isAlphaNumeric(c){return c>="0"&&"9">=c||c>="a"&&"z">=c||c>="A"&&"Z">=c}function isHexDigit(c){return c>="0"&&"9">=c||c>="a"&&"f">=c||c>="A"&&"F">=c}function isDecimalDigit(c){return c>="0"&&"9">=c}var entities=_dereq_("html5-entities"),InputStream=_dereq_("./InputStream").InputStream,namedEntityPrefixes={};Object.keys(entities).forEach(function(entityKey){for(var i=0;entityKey.length>i;i++)namedEntityPrefixes[entityKey.substring(0,i+1)]=!0});var EntityParser={};EntityParser.consumeEntity=function(buffer,tokenizer,additionalAllowedCharacter){var decodedCharacter="",consumedCharacters="",ch=buffer.char();if(ch===InputStream.EOF)return!1;if(consumedCharacters+=ch,"	"==ch||"\\n"==ch||"\v"==ch||" "==ch||"<"==ch||"&"==ch)return buffer.unget(consumedCharacters),!1;if(additionalAllowedCharacter===ch)return buffer.unget(consumedCharacters),!1;if("#"==ch){if(ch=buffer.shift(1),ch===InputStream.EOF)return tokenizer._parseError("expected-numeric-entity-but-got-eof"),buffer.unget(consumedCharacters),!1;consumedCharacters+=ch;var radix=10,isDigit=isDecimalDigit;if("x"==ch||"X"==ch){if(radix=16,isDigit=isHexDigit,ch=buffer.shift(1),ch===InputStream.EOF)return tokenizer._parseError("expected-numeric-entity-but-got-eof"),buffer.unget(consumedCharacters),!1;consumedCharacters+=ch}if(isDigit(ch)){for(var code="";ch!==InputStream.EOF&&isDigit(ch);)code+=ch,ch=buffer.char();code=parseInt(code,radix);var replacement=this.replaceEntityNumbers(code);if(replacement&&(tokenizer._parseError("invalid-numeric-entity-replaced"),code=replacement),code>65535&&1114111>=code){code-=65536;var first=((1047552&code)>>10)+55296,second=(1023&code)+56320;decodedCharacter=String.fromCharCode(first,second)}else decodedCharacter=String.fromCharCode(code);return";"!==ch&&(tokenizer._parseError("numeric-entity-without-semicolon"),buffer.unget(ch)),decodedCharacter}return buffer.unget(consumedCharacters),tokenizer._parseError("expected-numeric-entity"),!1}if(ch>="a"&&"z">=ch||ch>="A"&&"Z">=ch){for(var mostRecentMatch="";namedEntityPrefixes[consumedCharacters]&&(entities[consumedCharacters]&&(mostRecentMatch=consumedCharacters),";"!=ch)&&(ch=buffer.char(),ch!==InputStream.EOF);)consumedCharacters+=ch;return mostRecentMatch?(decodedCharacter=entities[mostRecentMatch],";"===ch||!additionalAllowedCharacter||!isAlphaNumeric(ch)&&"="!==ch?(consumedCharacters.length>mostRecentMatch.length&&buffer.unget(consumedCharacters.substring(mostRecentMatch.length)),";"!==ch&&tokenizer._parseError("named-entity-without-semicolon"),decodedCharacter):(buffer.unget(consumedCharacters),!1)):(tokenizer._parseError("expected-named-entity"),buffer.unget(consumedCharacters),!1)}},EntityParser.replaceEntityNumbers=function(c){switch(c){case 0:return 65533;case 19:return 16;case 128:return 8364;case 129:return 129;case 130:return 8218;case 131:return 402;case 132:return 8222;case 133:return 8230;case 134:return 8224;case 135:return 8225;case 136:return 710;case 137:return 8240;case 138:return 352;case 139:return 8249;case 140:return 338;case 141:return 141;case 142:return 381;case 143:return 143;case 144:return 144;case 145:return 8216;case 146:return 8217;case 147:return 8220;case 148:return 8221;case 149:return 8226;case 150:return 8211;case 151:return 8212;case 152:return 732;case 153:return 8482;case 154:return 353;case 155:return 8250;case 156:return 339;case 157:return 157;case 158:return 382;case 159:return 376;default:if(c>=55296&&57343>=c||c>1114111)return 65533;if(c>=1&&8>=c||c>=14&&31>=c||c>=127&&159>=c||c>=64976&&65007>=c||11==c||65534==c||131070==c||3145726==c||196607==c||262142==c||262143==c||327678==c||327679==c||393214==c||393215==c||458750==c||458751==c||524286==c||524287==c||589822==c||589823==c||655358==c||655359==c||720894==c||720895==c||786430==c||786431==c||851966==c||851967==c||917502==c||917503==c||983038==c||983039==c||1048574==c||1048575==c||1114110==c||1114111==c)return c}},exports.EntityParser=EntityParser},{"./InputStream":3,"html5-entities":12}],3:[function(_dereq_,module,exports){function InputStream(){this.data="",this.start=0,this.committed=0,this.eof=!1,this.lastLocation={line:0,column:0}}InputStream.EOF=-1,InputStream.DRAIN=-2,InputStream.prototype={slice:function(){if(this.start>=this.data.length){if(!this.eof)throw InputStream.DRAIN;return InputStream.EOF}return this.data.slice(this.start,this.data.length)},"char":function(){if(!this.eof&&this.start>=this.data.length-1)throw InputStream.DRAIN;if(this.start>=this.data.length)return InputStream.EOF;var ch=this.data[this.start++];return"\\r"===ch&&(ch="\\n"),ch},advance:function(amount){if(this.start+=amount,this.start>=this.data.length){if(!this.eof)throw InputStream.DRAIN;return InputStream.EOF}this.committed>this.data.length/2&&(this.lastLocation=this.location(),this.data=this.data.slice(this.committed),this.start=this.start-this.committed,this.committed=0)},matchWhile:function(re){if(this.eof&&this.start>=this.data.length)return"";var r=RegExp("^"+re+"+"),m=r.exec(this.slice());if(m){if(!this.eof&&m[0].length==this.data.length-this.start)throw InputStream.DRAIN;return this.advance(m[0].length),m[0]}return""},matchUntil:function(re){var m,s;if(s=this.slice(),s===InputStream.EOF)return"";if(m=RegExp(re+(this.eof?"|$":"")).exec(s)){var t=this.data.slice(this.start,this.start+m.index);return this.advance(m.index),t.replace(/\\r/g,"\\n").replace(/\\n{2,}/g,"\\n")}throw InputStream.DRAIN},append:function(data){this.data+=data},shift:function(n){if(!this.eof&&this.start+n>=this.data.length)throw InputStream.DRAIN;if(this.eof&&this.start>=this.data.length)return InputStream.EOF;var d=""+this.data.slice(this.start,this.start+n);return this.advance(Math.min(n,this.data.length-this.start)),d},peek:function(n){if(!this.eof&&this.start+n>=this.data.length)throw InputStream.DRAIN;return this.eof&&this.start>=this.data.length?InputStream.EOF:""+this.data.slice(this.start,Math.min(this.start+n,this.data.length))},length:function(){return this.data.length-this.start-1},unget:function(d){d!==InputStream.EOF&&(this.start-=d.length)},undo:function(){this.start=this.committed},commit:function(){this.committed=this.start},location:function(){var lastLine=this.lastLocation.line,lastColumn=this.lastLocation.column,read=this.data.slice(0,this.committed),newlines=read.match(/\\n/g),line=newlines?lastLine+newlines.length:lastLine,column=newlines?read.length-read.lastIndexOf("\\n")-1:lastColumn+read.length;return{line:line,column:column}}},exports.InputStream=InputStream},{}],4:[function(_dereq_,module,exports){function StackItem(namespaceURI,localName,attributes,node){this.localName=localName,this.namespaceURI=namespaceURI,this.attributes=attributes,this.node=node}function getAttribute(item,name){for(var i=0;item.attributes.length>i;i++)if(item.attributes[i].nodeName==name)return item.attributes[i].nodeValue;return null}var SpecialElements={"http://www.w3.org/1999/xhtml":["address","applet","area","article","aside","base","basefont","bgsound","blockquote","body","br","button","caption","center","col","colgroup","dd","details","dir","div","dl","dt","embed","fieldset","figcaption","figure","footer","form","frame","frameset","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","iframe","img","input","isindex","li","link","listing","main","marquee","menu","menuitem","meta","nav","noembed","noframes","noscript","object","ol","p","param","plaintext","pre","script","section","select","source","style","summary","table","tbody","td","textarea","tfoot","th","thead","title","tr","track","ul","wbr","xmp"],"http://www.w3.org/1998/Math/MathML":["mi","mo","mn","ms","mtext","annotation-xml"],"http://www.w3.org/2000/svg":["foreignObject","desc","title"]};StackItem.prototype.isSpecial=function(){return this.namespaceURI in SpecialElements&&SpecialElements[this.namespaceURI].indexOf(this.localName)>-1},StackItem.prototype.isFosterParenting=function(){return"http://www.w3.org/1999/xhtml"===this.namespaceURI?"table"===this.localName||"tbody"===this.localName||"tfoot"===this.localName||"thead"===this.localName||"tr"===this.localName:!1},StackItem.prototype.isNumberedHeader=function(){return"http://www.w3.org/1999/xhtml"===this.namespaceURI?"h1"===this.localName||"h2"===this.localName||"h3"===this.localName||"h4"===this.localName||"h5"===this.localName||"h6"===this.localName:!1},StackItem.prototype.isForeign=function(){return"http://www.w3.org/1999/xhtml"!=this.namespaceURI},StackItem.prototype.isHtmlIntegrationPoint=function(){if("http://www.w3.org/1998/Math/MathML"===this.namespaceURI){if("annotation-xml"!==this.localName)return!1;var encoding=getAttribute(this,"encoding");return encoding?(encoding=encoding.toLowerCase(),"text/html"===encoding||"application/xhtml+xml"===encoding):!1}return"http://www.w3.org/2000/svg"===this.namespaceURI?"foreignObject"===this.localName||"desc"===this.localName||"title"===this.localName:!1},StackItem.prototype.isMathMLTextIntegrationPoint=function(){return"http://www.w3.org/1998/Math/MathML"===this.namespaceURI?"mi"===this.localName||"mo"===this.localName||"mn"===this.localName||"ms"===this.localName||"mtext"===this.localName:!1},exports.StackItem=StackItem},{}],5:[function(_dereq_,module,exports){function isWhitespace(c){return" "===c||"\\n"===c||"	"===c||"\\r"===c||"\\f"===c}function isAlpha(c){return c>="A"&&"Z">=c||c>="a"&&"z">=c}function Tokenizer(tokenHandler){this._tokenHandler=tokenHandler,this._state=Tokenizer.DATA,this._inputStream=new InputStream,this._currentToken=null,this._temporaryBuffer="",this._additionalAllowedCharacter=""}var InputStream=_dereq_("./InputStream").InputStream,EntityParser=_dereq_("./EntityParser").EntityParser;Tokenizer.prototype._parseError=function(code,args){this._tokenHandler.parseError(code,args)},Tokenizer.prototype._emitToken=function(token){if("StartTag"===token.type)for(var i=1;token.data.length>i;i++)token.data[i].nodeName||token.data.splice(i--,1);else"EndTag"===token.type&&(token.selfClosing&&this._parseError("self-closing-flag-on-end-tag"),0!==token.data.length&&this._parseError("attributes-in-end-tag"));this._tokenHandler.processToken(token),"StartTag"===token.type&&token.selfClosing&&!this._tokenHandler.isSelfClosingFlagAcknowledged()&&this._parseError("non-void-element-with-trailing-solidus",{name:token.name})},Tokenizer.prototype._emitCurrentToken=function(){this._state=Tokenizer.DATA,this._emitToken(this._currentToken)},Tokenizer.prototype._currentAttribute=function(){return this._currentToken.data[this._currentToken.data.length-1]},Tokenizer.prototype.setState=function(state){this._state=state},Tokenizer.prototype.tokenize=function(source){function data_state(buffer){var data=buffer.char();if(data===InputStream.EOF)return tokenizer._emitToken({type:"EOF",data:null}),!1;if("&"===data)tokenizer.setState(character_reference_in_data_state);else if("<"===data)tokenizer.setState(tag_open_state);else if("\\0"===data)tokenizer._emitToken({type:"Characters",data:data}),buffer.commit();else{var chars=buffer.matchUntil("&|<|\\0");tokenizer._emitToken({type:"Characters",data:data+chars}),buffer.commit()}return!0}function character_reference_in_data_state(buffer){var character=EntityParser.consumeEntity(buffer,tokenizer);return tokenizer.setState(data_state),tokenizer._emitToken({type:"Characters",data:character||"&"}),!0}function rcdata_state(buffer){var data=buffer.char();if(data===InputStream.EOF)return tokenizer._emitToken({type:"EOF",data:null}),!1;if("&"===data)tokenizer.setState(character_reference_in_rcdata_state);else if("<"===data)tokenizer.setState(rcdata_less_than_sign_state);else if("\\0"===data)tokenizer._parseError("invalid-codepoint"),tokenizer._emitToken({type:"Characters",data:"\uFFFD"}),buffer.commit();else{var chars=buffer.matchUntil("&|<|\\0");tokenizer._emitToken({type:"Characters",data:data+chars}),buffer.commit()}return!0}function character_reference_in_rcdata_state(buffer){var character=EntityParser.consumeEntity(buffer,tokenizer);return tokenizer.setState(rcdata_state),tokenizer._emitToken({type:"Characters",data:character||"&"}),!0}function rawtext_state(buffer){var data=buffer.char();if(data===InputStream.EOF)return tokenizer._emitToken({type:"EOF",data:null}),!1;if("<"===data)tokenizer.setState(rawtext_less_than_sign_state);else if("\\0"===data)tokenizer._parseError("invalid-codepoint"),tokenizer._emitToken({type:"Characters",data:"\uFFFD"}),buffer.commit();else{var chars=buffer.matchUntil("<|\\0");tokenizer._emitToken({type:"Characters",data:data+chars})}return!0}function plaintext_state(buffer){var data=buffer.char();if(data===InputStream.EOF)return tokenizer._emitToken({type:"EOF",data:null}),!1;if("\\0"===data)tokenizer._parseError("invalid-codepoint"),tokenizer._emitToken({type:"Characters",data:"\uFFFD"}),buffer.commit();else{var chars=buffer.matchUntil("\\0");tokenizer._emitToken({type:"Characters",data:data+chars})}return!0}function script_data_state(buffer){var data=buffer.char();if(data===InputStream.EOF)return tokenizer._emitToken({type:"EOF",data:null}),!1;if("<"===data)tokenizer.setState(script_data_less_than_sign_state);else if("\\0"===data)tokenizer._parseError("invalid-codepoint"),tokenizer._emitToken({type:"Characters",data:"\uFFFD"}),buffer.commit();else{var chars=buffer.matchUntil("<|\\0");tokenizer._emitToken({type:"Characters",data:data+chars})}return!0}function rcdata_less_than_sign_state(buffer){var data=buffer.char();return"/"===data?(this._temporaryBuffer="",tokenizer.setState(rcdata_end_tag_open_state)):(tokenizer._emitToken({type:"Characters",data:"<"}),buffer.unget(data),tokenizer.setState(rcdata_state)),!0}function rcdata_end_tag_open_state(buffer){var data=buffer.char();return isAlpha(data)?(this._temporaryBuffer+=data,tokenizer.setState(rcdata_end_tag_name_state)):(tokenizer._emitToken({type:"Characters",data:"</"}),buffer.unget(data),tokenizer.setState(rcdata_state)),!0}function rcdata_end_tag_name_state(buffer){var appropriate=tokenizer._currentToken&&tokenizer._currentToken.name===this._temporaryBuffer.toLowerCase(),data=buffer.char();return isWhitespace(data)&&appropriate?(tokenizer._currentToken={type:"EndTag",name:this._temporaryBuffer,data:[],selfClosing:!1},tokenizer.setState(before_attribute_name_state)):"/"===data&&appropriate?(tokenizer._currentToken={type:"EndTag",name:this._temporaryBuffer,data:[],selfClosing:!1},tokenizer.setState(self_closing_tag_state)):">"===data&&appropriate?(tokenizer._currentToken={type:"EndTag",name:this._temporaryBuffer,data:[],selfClosing:!1},tokenizer._emitCurrentToken(),tokenizer.setState(data_state)):isAlpha(data)?(this._temporaryBuffer+=data,buffer.commit()):(tokenizer._emitToken({type:"Characters",data:"</"+this._temporaryBuffer}),buffer.unget(data),tokenizer.setState(rcdata_state)),!0}function rawtext_less_than_sign_state(buffer){var data=buffer.char();return"/"===data?(this._temporaryBuffer="",tokenizer.setState(rawtext_end_tag_open_state)):(tokenizer._emitToken({type:"Characters",data:"<"}),buffer.unget(data),tokenizer.setState(rawtext_state)),!0}function rawtext_end_tag_open_state(buffer){var data=buffer.char();return isAlpha(data)?(this._temporaryBuffer+=data,tokenizer.setState(rawtext_end_tag_name_state)):(tokenizer._emitToken({type:"Characters",data:"</"}),buffer.unget(data),tokenizer.setState(rawtext_state)),!0}function rawtext_end_tag_name_state(buffer){var appropriate=tokenizer._currentToken&&tokenizer._currentToken.name===this._temporaryBuffer.toLowerCase(),data=buffer.char();return isWhitespace(data)&&appropriate?(tokenizer._currentToken={type:"EndTag",name:this._temporaryBuffer,data:[],selfClosing:!1},tokenizer.setState(before_attribute_name_state)):"/"===data&&appropriate?(tokenizer._currentToken={type:"EndTag",name:this._temporaryBuffer,data:[],selfClosing:!1},tokenizer.setState(self_closing_tag_state)):">"===data&&appropriate?(tokenizer._currentToken={type:"EndTag",name:this._temporaryBuffer,data:[],selfClosing:!1},tokenizer._emitCurrentToken(),tokenizer.setState(data_state)):isAlpha(data)?(this._temporaryBuffer+=data,buffer.commit()):(tokenizer._emitToken({type:"Characters",data:"</"+this._temporaryBuffer}),buffer.unget(data),tokenizer.setState(rawtext_state)),!0}function script_data_less_than_sign_state(buffer){var data=buffer.char();return"/"===data?(this._temporaryBuffer="",tokenizer.setState(script_data_end_tag_open_state)):"!"===data?(tokenizer._emitToken({type:"Characters",data:"<!"}),tokenizer.setState(script_data_escape_start_state)):(tokenizer._emitToken({type:"Characters",data:"<"}),buffer.unget(data),tokenizer.setState(script_data_state)),!0}function script_data_end_tag_open_state(buffer){var data=buffer.char();return isAlpha(data)?(this._temporaryBuffer+=data,tokenizer.setState(script_data_end_tag_name_state)):(tokenizer._emitToken({type:"Characters",data:"</"}),buffer.unget(data),tokenizer.setState(script_data_state)),!0}function script_data_end_tag_name_state(buffer){var appropriate=tokenizer._currentToken&&tokenizer._currentToken.name===this._temporaryBuffer.toLowerCase(),data=buffer.char();return isWhitespace(data)&&appropriate?(tokenizer._currentToken={type:"EndTag",name:"script",data:[],selfClosing:!1},tokenizer.setState(before_attribute_name_state)):"/"===data&&appropriate?(tokenizer._currentToken={type:"EndTag",name:"script",data:[],selfClosing:!1},tokenizer.setState(self_closing_tag_state)):">"===data&&appropriate?(tokenizer._currentToken={type:"EndTag",name:"script",data:[],selfClosing:!1},tokenizer._emitCurrentToken()):isAlpha(data)?(this._temporaryBuffer+=data,buffer.commit()):(tokenizer._emitToken({type:"Characters",data:"</"+this._temporaryBuffer}),buffer.unget(data),tokenizer.setState(script_data_state)),!0}function script_data_escape_start_state(buffer){var data=buffer.char();return"-"===data?(tokenizer._emitToken({type:"Characters",data:"-"}),tokenizer.setState(script_data_escape_start_dash_state)):(buffer.unget(data),tokenizer.setState(script_data_state)),!0}function script_data_escape_start_dash_state(buffer){var data=buffer.char();return"-"===data?(tokenizer._emitToken({type:"Characters",data:"-"}),tokenizer.setState(script_data_escaped_dash_dash_state)):(buffer.unget(data),tokenizer.setState(script_data_state)),!0}function script_data_escaped_state(buffer){var data=buffer.char();if(data===InputStream.EOF)buffer.unget(data),tokenizer.setState(data_state);else if("-"===data)tokenizer._emitToken({type:"Characters",data:"-"}),tokenizer.setState(script_data_escaped_dash_state);else if("<"===data)tokenizer.setState(script_data_escaped_less_then_sign_state);else if("\\0"===data)tokenizer._parseError("invalid-codepoint"),tokenizer._emitToken({type:"Characters",data:"\uFFFD"}),buffer.commit();else{var chars=buffer.matchUntil("<|-|\\0");tokenizer._emitToken({type:"Characters",data:data+chars})}return!0}function script_data_escaped_dash_state(buffer){var data=buffer.char();return data===InputStream.EOF?(buffer.unget(data),tokenizer.setState(data_state)):"-"===data?(tokenizer._emitToken({type:"Characters",data:"-"}),tokenizer.setState(script_data_escaped_dash_dash_state)):"<"===data?tokenizer.setState(script_data_escaped_less_then_sign_state):"\\0"===data?(tokenizer._parseError("invalid-codepoint"),tokenizer._emitToken({type:"Characters",data:"\uFFFD"}),tokenizer.setState(script_data_escaped_state)):(tokenizer._emitToken({type:"Characters",data:data}),tokenizer.setState(script_data_escaped_state)),!0}function script_data_escaped_dash_dash_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("eof-in-script"),buffer.unget(data),tokenizer.setState(data_state)):"<"===data?tokenizer.setState(script_data_escaped_less_then_sign_state):">"===data?(tokenizer._emitToken({type:"Characters",data:">"}),tokenizer.setState(script_data_state)):"\\0"===data?(tokenizer._parseError("invalid-codepoint"),tokenizer._emitToken({type:"Characters",data:"\uFFFD"}),tokenizer.setState(script_data_escaped_state)):(tokenizer._emitToken({type:"Characters",data:data}),tokenizer.setState(script_data_escaped_state)),!0}function script_data_escaped_less_then_sign_state(buffer){var data=buffer.char();return"/"===data?(this._temporaryBuffer="",tokenizer.setState(script_data_escaped_end_tag_open_state)):isAlpha(data)?(tokenizer._emitToken({type:"Characters",data:"<"+data}),this._temporaryBuffer=data,tokenizer.setState(script_data_double_escape_start_state)):(tokenizer._emitToken({type:"Characters",data:"<"}),buffer.unget(data),tokenizer.setState(script_data_escaped_state)),!0}function script_data_escaped_end_tag_open_state(buffer){var data=buffer.char();return isAlpha(data)?(this._temporaryBuffer=data,tokenizer.setState(script_data_escaped_end_tag_name_state)):(tokenizer._emitToken({type:"Characters",data:"</"}),buffer.unget(data),tokenizer.setState(script_data_escaped_state)),!0}function script_data_escaped_end_tag_name_state(buffer){var appropriate=tokenizer._currentToken&&tokenizer._currentToken.name===this._temporaryBuffer.toLowerCase(),data=buffer.char();return isWhitespace(data)&&appropriate?(tokenizer._currentToken={type:"EndTag",name:"script",data:[],selfClosing:!1},tokenizer.setState(before_attribute_name_state)):"/"===data&&appropriate?(tokenizer._currentToken={type:"EndTag",name:"script",data:[],selfClosing:!1},tokenizer.setState(self_closing_tag_state)):">"===data&&appropriate?(tokenizer._currentToken={type:"EndTag",name:"script",data:[],selfClosing:!1},tokenizer.setState(data_state),tokenizer._emitCurrentToken()):isAlpha(data)?(this._temporaryBuffer+=data,buffer.commit()):(tokenizer._emitToken({type:"Characters",data:"</"+this._temporaryBuffer}),buffer.unget(data),tokenizer.setState(script_data_escaped_state)),!0}function script_data_double_escape_start_state(buffer){var data=buffer.char();return isWhitespace(data)||"/"===data||">"===data?(tokenizer._emitToken({type:"Characters",data:data}),"script"===this._temporaryBuffer.toLowerCase()?tokenizer.setState(script_data_double_escaped_state):tokenizer.setState(script_data_escaped_state)):isAlpha(data)?(tokenizer._emitToken({type:"Characters",data:data}),this._temporaryBuffer+=data,buffer.commit()):(buffer.unget(data),tokenizer.setState(script_data_escaped_state)),!0}function script_data_double_escaped_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("eof-in-script"),buffer.unget(data),tokenizer.setState(data_state)):"-"===data?(tokenizer._emitToken({type:"Characters",data:"-"}),tokenizer.setState(script_data_double_escaped_dash_state)):"<"===data?(tokenizer._emitToken({type:"Characters",data:"<"}),tokenizer.setState(script_data_double_escaped_less_than_sign_state)):"\\0"===data?(tokenizer._parseError("invalid-codepoint"),tokenizer._emitToken({type:"Characters",data:"\uFFFD"}),buffer.commit()):(tokenizer._emitToken({type:"Characters",data:data}),buffer.commit()),!0}function script_data_double_escaped_dash_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("eof-in-script"),buffer.unget(data),tokenizer.setState(data_state)):"-"===data?(tokenizer._emitToken({type:"Characters",data:"-"}),tokenizer.setState(script_data_double_escaped_dash_dash_state)):"<"===data?(tokenizer._emitToken({type:"Characters",data:"<"}),tokenizer.setState(script_data_double_escaped_less_than_sign_state)):"\\0"===data?(tokenizer._parseError("invalid-codepoint"),tokenizer._emitToken({type:"Characters",data:"\uFFFD"}),tokenizer.setState(script_data_double_escaped_state)):(tokenizer._emitToken({type:"Characters",data:data}),tokenizer.setState(script_data_double_escaped_state)),!0}function script_data_double_escaped_dash_dash_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("eof-in-script"),buffer.unget(data),tokenizer.setState(data_state)):"-"===data?(tokenizer._emitToken({type:"Characters",data:"-"}),buffer.commit()):"<"===data?(tokenizer._emitToken({type:"Characters",data:"<"}),tokenizer.setState(script_data_double_escaped_less_than_sign_state)):">"===data?(tokenizer._emitToken({type:"Characters",data:">"}),tokenizer.setState(script_data_state)):"\\0"===data?(tokenizer._parseError("invalid-codepoint"),tokenizer._emitToken({type:"Characters",data:"\uFFFD"}),tokenizer.setState(script_data_double_escaped_state)):(tokenizer._emitToken({type:"Characters",data:data}),tokenizer.setState(script_data_double_escaped_state)),!0}function script_data_double_escaped_less_than_sign_state(buffer){var data=buffer.char();return"/"===data?(tokenizer._emitToken({type:"Characters",data:"/"}),this._temporaryBuffer="",tokenizer.setState(script_data_double_escape_end_state)):(buffer.unget(data),tokenizer.setState(script_data_double_escaped_state)),!0}function script_data_double_escape_end_state(buffer){var data=buffer.char();return isWhitespace(data)||"/"===data||">"===data?(tokenizer._emitToken({type:"Characters",data:data}),"script"===this._temporaryBuffer.toLowerCase()?tokenizer.setState(script_data_escaped_state):tokenizer.setState(script_data_double_escaped_state)):isAlpha(data)?(tokenizer._emitToken({type:"Characters",data:data}),this._temporaryBuffer+=data,buffer.commit()):(buffer.unget(data),tokenizer.setState(script_data_double_escaped_state)),!0}function tag_open_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("bare-less-than-sign-at-eof"),tokenizer._emitToken({type:"Characters",data:"<"}),buffer.unget(data),tokenizer.setState(data_state)):isAlpha(data)?(tokenizer._currentToken={type:"StartTag",name:data.toLowerCase(),data:[]},tokenizer.setState(tag_name_state)):"!"===data?tokenizer.setState(markup_declaration_open_state):"/"===data?tokenizer.setState(close_tag_open_state):">"===data?(tokenizer._parseError("expected-tag-name-but-got-right-bracket"),tokenizer._emitToken({type:"Characters",data:"<>"}),tokenizer.setState(data_state)):"?"===data?(tokenizer._parseError("expected-tag-name-but-got-question-mark"),buffer.unget(data),tokenizer.setState(bogus_comment_state)):(tokenizer._parseError("expected-tag-name"),tokenizer._emitToken({type:"Characters",data:"<"}),buffer.unget(data),tokenizer.setState(data_state)),!0}function close_tag_open_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("expected-closing-tag-but-got-eof"),tokenizer._emitToken({type:"Characters",data:"</"}),buffer.unget(data),tokenizer.setState(data_state)):isAlpha(data)?(tokenizer._currentToken={type:"EndTag",name:data.toLowerCase(),data:[]},tokenizer.setState(tag_name_state)):">"===data?(tokenizer._parseError("expected-closing-tag-but-got-right-bracket"),tokenizer.setState(data_state)):(tokenizer._parseError("expected-closing-tag-but-got-char",{data:data}),buffer.unget(data),tokenizer.setState(bogus_comment_state)),!0}function tag_name_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("eof-in-tag-name"),buffer.unget(data),tokenizer.setState(data_state)):isWhitespace(data)?tokenizer.setState(before_attribute_name_state):isAlpha(data)?tokenizer._currentToken.name+=data.toLowerCase():">"===data?tokenizer._emitCurrentToken():"/"===data?tokenizer.setState(self_closing_tag_state):"\\0"===data?(tokenizer._parseError("invalid-codepoint"),tokenizer._currentToken.name+="\uFFFD"):tokenizer._currentToken.name+=data,buffer.commit(),!0}function before_attribute_name_state(buffer){var data=buffer.char();if(data===InputStream.EOF)tokenizer._parseError("expected-attribute-name-but-got-eof"),buffer.unget(data),tokenizer.setState(data_state);else{if(isWhitespace(data))return!0;isAlpha(data)?(tokenizer._currentToken.data.push({nodeName:data.toLowerCase(),nodeValue:""}),tokenizer.setState(attribute_name_state)):">"===data?tokenizer._emitCurrentToken():"/"===data?tokenizer.setState(self_closing_tag_state):"'"===data||'"'===data||"="===data||"<"===data?(tokenizer._parseError("invalid-character-in-attribute-name"),tokenizer._currentToken.data.push({nodeName:data,nodeValue:""}),tokenizer.setState(attribute_name_state)):"\\0"===data?(tokenizer._parseError("invalid-codepoint"),tokenizer._currentToken.data.push({nodeName:"\uFFFD",nodeValue:""})):(tokenizer._currentToken.data.push({nodeName:data,nodeValue:""}),tokenizer.setState(attribute_name_state))}return!0}function attribute_name_state(buffer){var data=buffer.char(),leavingThisState=!0,shouldEmit=!1;if(data===InputStream.EOF?(tokenizer._parseError("eof-in-attribute-name"),buffer.unget(data),tokenizer.setState(data_state),shouldEmit=!0):"="===data?tokenizer.setState(before_attribute_value_state):isAlpha(data)?(tokenizer._currentAttribute().nodeName+=data.toLowerCase(),leavingThisState=!1):">"===data?shouldEmit=!0:isWhitespace(data)?tokenizer.setState(after_attribute_name_state):"/"===data?tokenizer.setState(self_closing_tag_state):"'"===data||'"'===data?(tokenizer._parseError("invalid-character-in-attribute-name"),tokenizer._currentAttribute().nodeName+=data,leavingThisState=!1):"\\0"===data?(tokenizer._parseError("invalid-codepoint"),tokenizer._currentAttribute().nodeName+="\uFFFD"):(tokenizer._currentAttribute().nodeName+=data,leavingThisState=!1),leavingThisState){for(var attributes=tokenizer._currentToken.data,currentAttribute=attributes[attributes.length-1],i=attributes.length-2;i>=0;i--)if(currentAttribute.nodeName===attributes[i].nodeName){tokenizer._parseError("duplicate-attribute",{name:currentAttribute.nodeName}),currentAttribute.nodeName=null;break}shouldEmit&&tokenizer._emitCurrentToken()}else buffer.commit();return!0}function after_attribute_name_state(buffer){var data=buffer.char();if(data===InputStream.EOF)tokenizer._parseError("expected-end-of-tag-but-got-eof"),buffer.unget(data),tokenizer.setState(data_state);else{if(isWhitespace(data))return!0;"="===data?tokenizer.setState(before_attribute_value_state):">"===data?tokenizer._emitCurrentToken():isAlpha(data)?(tokenizer._currentToken.data.push({nodeName:data,nodeValue:""}),tokenizer.setState(attribute_name_state)):"/"===data?tokenizer.setState(self_closing_tag_state):"'"===data||'"'===data||"<"===data?(tokenizer._parseError("invalid-character-after-attribute-name"),tokenizer._currentToken.data.push({nodeName:data,nodeValue:""}),tokenizer.setState(attribute_name_state)):"\\0"===data?(tokenizer._parseError("invalid-codepoint"),tokenizer._currentToken.data.push({nodeName:"\uFFFD",nodeValue:""})):(tokenizer._currentToken.data.push({nodeName:data,nodeValue:""}),tokenizer.setState(attribute_name_state))}return!0}function before_attribute_value_state(buffer){var data=buffer.char();if(data===InputStream.EOF)tokenizer._parseError("expected-attribute-value-but-got-eof"),buffer.unget(data),tokenizer.setState(data_state);else{if(isWhitespace(data))return!0;'"'===data?tokenizer.setState(attribute_value_double_quoted_state):"&"===data?(tokenizer.setState(attribute_value_unquoted_state),buffer.unget(data)):"'"===data?tokenizer.setState(attribute_value_single_quoted_state):">"===data?(tokenizer._parseError("expected-attribute-value-but-got-right-bracket"),tokenizer._emitCurrentToken()):"="===data||"<"===data||"\`"===data?(tokenizer._parseError("unexpected-character-in-unquoted-attribute-value"),tokenizer._currentAttribute().nodeValue+=data,tokenizer.setState(attribute_value_unquoted_state)):"\\0"===data?(tokenizer._parseError("invalid-codepoint"),tokenizer._currentAttribute().nodeValue+="\uFFFD"):(tokenizer._currentAttribute().nodeValue+=data,tokenizer.setState(attribute_value_unquoted_state))}return!0
}function attribute_value_double_quoted_state(buffer){var data=buffer.char();if(data===InputStream.EOF)tokenizer._parseError("eof-in-attribute-value-double-quote"),buffer.unget(data),tokenizer.setState(data_state);else if('"'===data)tokenizer.setState(after_attribute_value_state);else if("&"===data)this._additionalAllowedCharacter='"',tokenizer.setState(character_reference_in_attribute_value_state);else if("\\0"===data)tokenizer._parseError("invalid-codepoint"),tokenizer._currentAttribute().nodeValue+="\uFFFD";else{var s=buffer.matchUntil('[\\0"&]');data+=s,tokenizer._currentAttribute().nodeValue+=data}return!0}function attribute_value_single_quoted_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("eof-in-attribute-value-single-quote"),buffer.unget(data),tokenizer.setState(data_state)):"'"===data?tokenizer.setState(after_attribute_value_state):"&"===data?(this._additionalAllowedCharacter="'",tokenizer.setState(character_reference_in_attribute_value_state)):"\\0"===data?(tokenizer._parseError("invalid-codepoint"),tokenizer._currentAttribute().nodeValue+="\uFFFD"):tokenizer._currentAttribute().nodeValue+=data+buffer.matchUntil("\\0|['&]"),!0}function attribute_value_unquoted_state(buffer){var data=buffer.char();if(data===InputStream.EOF)tokenizer._parseError("eof-after-attribute-value"),buffer.unget(data),tokenizer.setState(data_state);else if(isWhitespace(data))tokenizer.setState(before_attribute_name_state);else if("&"===data)this._additionalAllowedCharacter=">",tokenizer.setState(character_reference_in_attribute_value_state);else if(">"===data)tokenizer._emitCurrentToken();else if('"'===data||"'"===data||"="===data||"\`"===data||"<"===data)tokenizer._parseError("unexpected-character-in-unquoted-attribute-value"),tokenizer._currentAttribute().nodeValue+=data,buffer.commit();else if("\\0"===data)tokenizer._parseError("invalid-codepoint"),tokenizer._currentAttribute().nodeValue+="\uFFFD";else{var o=buffer.matchUntil("\\0|[	\\n\v\\f \\r&<>\\"'=\`]");o===InputStream.EOF&&(tokenizer._parseError("eof-in-attribute-value-no-quotes"),tokenizer._emitCurrentToken()),buffer.commit(),tokenizer._currentAttribute().nodeValue+=data+o}return!0}function character_reference_in_attribute_value_state(buffer){var character=EntityParser.consumeEntity(buffer,tokenizer,this._additionalAllowedCharacter);return this._currentAttribute().nodeValue+=character||"&",'"'===this._additionalAllowedCharacter?tokenizer.setState(attribute_value_double_quoted_state):"'"===this._additionalAllowedCharacter?tokenizer.setState(attribute_value_single_quoted_state):">"===this._additionalAllowedCharacter&&tokenizer.setState(attribute_value_unquoted_state),!0}function after_attribute_value_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("eof-after-attribute-value"),buffer.unget(data),tokenizer.setState(data_state)):isWhitespace(data)?tokenizer.setState(before_attribute_name_state):">"===data?(tokenizer.setState(data_state),tokenizer._emitCurrentToken()):"/"===data?tokenizer.setState(self_closing_tag_state):(tokenizer._parseError("unexpected-character-after-attribute-value"),buffer.unget(data),tokenizer.setState(before_attribute_name_state)),!0}function self_closing_tag_state(buffer){var c=buffer.char();return c===InputStream.EOF?(tokenizer._parseError("unexpected-eof-after-solidus-in-tag"),buffer.unget(c),tokenizer.setState(data_state)):">"===c?(tokenizer._currentToken.selfClosing=!0,tokenizer.setState(data_state),tokenizer._emitCurrentToken()):(tokenizer._parseError("unexpected-character-after-solidus-in-tag"),buffer.unget(c),tokenizer.setState(before_attribute_name_state)),!0}function bogus_comment_state(buffer){var data=buffer.matchUntil(">");return data=data.replace(/\\u0000/g,"\uFFFD"),buffer.char(),tokenizer._emitToken({type:"Comment",data:data}),tokenizer.setState(data_state),!0}function markup_declaration_open_state(buffer){var chars=buffer.shift(2);if("--"===chars)tokenizer._currentToken={type:"Comment",data:""},tokenizer.setState(comment_start_state);else{var newchars=buffer.shift(5);if(newchars===InputStream.EOF||chars===InputStream.EOF)return tokenizer._parseError("expected-dashes-or-doctype"),tokenizer.setState(bogus_comment_state),buffer.unget(chars),!0;chars+=newchars,"DOCTYPE"===chars.toUpperCase()?(tokenizer._currentToken={type:"Doctype",name:"",publicId:null,systemId:null,forceQuirks:!1},tokenizer.setState(doctype_state)):tokenizer._tokenHandler.isCdataSectionAllowed()&&"[CDATA["===chars?tokenizer.setState(cdata_section_state):(tokenizer._parseError("expected-dashes-or-doctype"),buffer.unget(chars),tokenizer.setState(bogus_comment_state))}return!0}function cdata_section_state(buffer){var data=buffer.matchUntil("]]>");return buffer.shift(3),data&&tokenizer._emitToken({type:"Characters",data:data}),tokenizer.setState(data_state),!0}function comment_start_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("eof-in-comment"),tokenizer._emitToken(tokenizer._currentToken),buffer.unget(data),tokenizer.setState(data_state)):"-"===data?tokenizer.setState(comment_start_dash_state):">"===data?(tokenizer._parseError("incorrect-comment"),tokenizer._emitToken(tokenizer._currentToken),tokenizer.setState(data_state)):"\\0"===data?(tokenizer._parseError("invalid-codepoint"),tokenizer._currentToken.data+="\uFFFD"):(tokenizer._currentToken.data+=data,tokenizer.setState(comment_state)),!0}function comment_start_dash_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("eof-in-comment"),tokenizer._emitToken(tokenizer._currentToken),buffer.unget(data),tokenizer.setState(data_state)):"-"===data?tokenizer.setState(comment_end_state):">"===data?(tokenizer._parseError("incorrect-comment"),tokenizer._emitToken(tokenizer._currentToken),tokenizer.setState(data_state)):"\\0"===data?(tokenizer._parseError("invalid-codepoint"),tokenizer._currentToken.data+="\uFFFD"):(tokenizer._currentToken.data+="-"+data,tokenizer.setState(comment_state)),!0}function comment_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("eof-in-comment"),tokenizer._emitToken(tokenizer._currentToken),buffer.unget(data),tokenizer.setState(data_state)):"-"===data?tokenizer.setState(comment_end_dash_state):"\\0"===data?(tokenizer._parseError("invalid-codepoint"),tokenizer._currentToken.data+="\uFFFD"):(tokenizer._currentToken.data+=data,buffer.commit()),!0}function comment_end_dash_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("eof-in-comment-end-dash"),tokenizer._emitToken(tokenizer._currentToken),buffer.unget(data),tokenizer.setState(data_state)):"-"===data?tokenizer.setState(comment_end_state):"\\0"===data?(tokenizer._parseError("invalid-codepoint"),tokenizer._currentToken.data+="-\uFFFD",tokenizer.setState(comment_state)):(tokenizer._currentToken.data+="-"+data+buffer.matchUntil("\\0|-"),buffer.char()),!0}function comment_end_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("eof-in-comment-double-dash"),tokenizer._emitToken(tokenizer._currentToken),buffer.unget(data),tokenizer.setState(data_state)):">"===data?(tokenizer._emitToken(tokenizer._currentToken),tokenizer.setState(data_state)):"!"===data?(tokenizer._parseError("unexpected-bang-after-double-dash-in-comment"),tokenizer.setState(comment_end_bang_state)):"-"===data?(tokenizer._parseError("unexpected-dash-after-double-dash-in-comment"),tokenizer._currentToken.data+=data):"\\0"===data?(tokenizer._parseError("invalid-codepoint"),tokenizer._currentToken.data+="--\uFFFD",tokenizer.setState(comment_state)):(tokenizer._parseError("unexpected-char-in-comment"),tokenizer._currentToken.data+="--"+data,tokenizer.setState(comment_state)),!0}function comment_end_bang_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("eof-in-comment-end-bang-state"),tokenizer._emitToken(tokenizer._currentToken),buffer.unget(data),tokenizer.setState(data_state)):">"===data?(tokenizer._emitToken(tokenizer._currentToken),tokenizer.setState(data_state)):"-"===data?(tokenizer._currentToken.data+="--!",tokenizer.setState(comment_end_dash_state)):(tokenizer._currentToken.data+="--!"+data,tokenizer.setState(comment_state)),!0}function doctype_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("expected-doctype-name-but-got-eof"),tokenizer._currentToken.forceQuirks=!0,buffer.unget(data),tokenizer.setState(data_state),tokenizer._emitCurrentToken()):isWhitespace(data)?tokenizer.setState(before_doctype_name_state):(tokenizer._parseError("need-space-after-doctype"),buffer.unget(data),tokenizer.setState(before_doctype_name_state)),!0}function before_doctype_name_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("expected-doctype-name-but-got-eof"),tokenizer._currentToken.forceQuirks=!0,buffer.unget(data),tokenizer.setState(data_state),tokenizer._emitCurrentToken()):isWhitespace(data)||(">"===data?(tokenizer._parseError("expected-doctype-name-but-got-right-bracket"),tokenizer._currentToken.forceQuirks=!0,tokenizer.setState(data_state),tokenizer._emitCurrentToken()):(isAlpha(data)&&(data=data.toLowerCase()),tokenizer._currentToken.name=data,tokenizer.setState(doctype_name_state))),!0}function doctype_name_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._currentToken.forceQuirks=!0,buffer.unget(data),tokenizer._parseError("eof-in-doctype-name"),tokenizer.setState(data_state),tokenizer._emitCurrentToken()):isWhitespace(data)?tokenizer.setState(after_doctype_name_state):">"===data?(tokenizer.setState(data_state),tokenizer._emitCurrentToken()):(isAlpha(data)&&(data=data.toLowerCase()),tokenizer._currentToken.name+=data,buffer.commit()),!0}function after_doctype_name_state(buffer){var data=buffer.char();if(data===InputStream.EOF)tokenizer._currentToken.forceQuirks=!0,buffer.unget(data),tokenizer._parseError("eof-in-doctype"),tokenizer.setState(data_state),tokenizer._emitCurrentToken();else if(isWhitespace(data));else if(">"===data)tokenizer.setState(data_state),tokenizer._emitCurrentToken();else{if(["p","P"].indexOf(data)>-1){var expected=[["u","U"],["b","B"],["l","L"],["i","I"],["c","C"]],matched=expected.every(function(expected){return data=buffer.char(),expected.indexOf(data)>-1});if(matched)return tokenizer.setState(after_doctype_public_keyword_state),!0}else if(["s","S"].indexOf(data)>-1){var expected=[["y","Y"],["s","S"],["t","T"],["e","E"],["m","M"]],matched=expected.every(function(expected){return data=buffer.char(),expected.indexOf(data)>-1});if(matched)return tokenizer.setState(after_doctype_system_keyword_state),!0}buffer.unget(data),tokenizer._currentToken.forceQuirks=!0,data===InputStream.EOF?(tokenizer._parseError("eof-in-doctype"),buffer.unget(data),tokenizer.setState(data_state),tokenizer._emitCurrentToken()):(tokenizer._parseError("expected-space-or-right-bracket-in-doctype",{data:data}),tokenizer.setState(bogus_doctype_state))}return!0}function after_doctype_public_keyword_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("eof-in-doctype"),tokenizer._currentToken.forceQuirks=!0,buffer.unget(data),tokenizer.setState(data_state),tokenizer._emitCurrentToken()):isWhitespace(data)?tokenizer.setState(before_doctype_public_identifier_state):"'"===data||'"'===data?(tokenizer._parseError("unexpected-char-in-doctype"),buffer.unget(data),tokenizer.setState(before_doctype_public_identifier_state)):(buffer.unget(data),tokenizer.setState(before_doctype_public_identifier_state)),!0}function before_doctype_public_identifier_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("eof-in-doctype"),tokenizer._currentToken.forceQuirks=!0,buffer.unget(data),tokenizer.setState(data_state),tokenizer._emitCurrentToken()):isWhitespace(data)||('"'===data?(tokenizer._currentToken.publicId="",tokenizer.setState(doctype_public_identifier_double_quoted_state)):"'"===data?(tokenizer._currentToken.publicId="",tokenizer.setState(doctype_public_identifier_single_quoted_state)):">"===data?(tokenizer._parseError("unexpected-end-of-doctype"),tokenizer._currentToken.forceQuirks=!0,tokenizer.setState(data_state),tokenizer._emitCurrentToken()):(tokenizer._parseError("unexpected-char-in-doctype"),tokenizer._currentToken.forceQuirks=!0,tokenizer.setState(bogus_doctype_state))),!0}function doctype_public_identifier_double_quoted_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("eof-in-doctype"),tokenizer._currentToken.forceQuirks=!0,buffer.unget(data),tokenizer.setState(data_state),tokenizer._emitCurrentToken()):'"'===data?tokenizer.setState(after_doctype_public_identifier_state):">"===data?(tokenizer._parseError("unexpected-end-of-doctype"),tokenizer._currentToken.forceQuirks=!0,tokenizer.setState(data_state),tokenizer._emitCurrentToken()):tokenizer._currentToken.publicId+=data,!0}function doctype_public_identifier_single_quoted_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("eof-in-doctype"),tokenizer._currentToken.forceQuirks=!0,buffer.unget(data),tokenizer.setState(data_state),tokenizer._emitCurrentToken()):"'"===data?tokenizer.setState(after_doctype_public_identifier_state):">"===data?(tokenizer._parseError("unexpected-end-of-doctype"),tokenizer._currentToken.forceQuirks=!0,tokenizer.setState(data_state),tokenizer._emitCurrentToken()):tokenizer._currentToken.publicId+=data,!0}function after_doctype_public_identifier_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("eof-in-doctype"),tokenizer._currentToken.forceQuirks=!0,tokenizer._emitCurrentToken(),buffer.unget(data),tokenizer.setState(data_state)):isWhitespace(data)?tokenizer.setState(between_doctype_public_and_system_identifiers_state):">"===data?(tokenizer.setState(data_state),tokenizer._emitCurrentToken()):'"'===data?(tokenizer._parseError("unexpected-char-in-doctype"),tokenizer._currentToken.systemId="",tokenizer.setState(doctype_system_identifier_double_quoted_state)):"'"===data?(tokenizer._parseError("unexpected-char-in-doctype"),tokenizer._currentToken.systemId="",tokenizer.setState(doctype_system_identifier_single_quoted_state)):(tokenizer._parseError("unexpected-char-in-doctype"),tokenizer._currentToken.forceQuirks=!0,tokenizer.setState(bogus_doctype_state)),!0}function between_doctype_public_and_system_identifiers_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("eof-in-doctype"),tokenizer._currentToken.forceQuirks=!0,tokenizer._emitCurrentToken(),buffer.unget(data),tokenizer.setState(data_state)):isWhitespace(data)||(">"===data?(tokenizer._emitCurrentToken(),tokenizer.setState(data_state)):'"'===data?(tokenizer._currentToken.systemId="",tokenizer.setState(doctype_system_identifier_double_quoted_state)):"'"===data?(tokenizer._currentToken.systemId="",tokenizer.setState(doctype_system_identifier_single_quoted_state)):(tokenizer._parseError("unexpected-char-in-doctype"),tokenizer._currentToken.forceQuirks=!0,tokenizer.setState(bogus_doctype_state))),!0}function after_doctype_system_keyword_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("eof-in-doctype"),tokenizer._currentToken.forceQuirks=!0,tokenizer._emitCurrentToken(),buffer.unget(data),tokenizer.setState(data_state)):isWhitespace(data)?tokenizer.setState(before_doctype_system_identifier_state):"'"===data||'"'===data?(tokenizer._parseError("unexpected-char-in-doctype"),buffer.unget(data),tokenizer.setState(before_doctype_system_identifier_state)):(buffer.unget(data),tokenizer.setState(before_doctype_system_identifier_state)),!0}function before_doctype_system_identifier_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("eof-in-doctype"),tokenizer._currentToken.forceQuirks=!0,tokenizer._emitCurrentToken(),buffer.unget(data),tokenizer.setState(data_state)):isWhitespace(data)||('"'===data?(tokenizer._currentToken.systemId="",tokenizer.setState(doctype_system_identifier_double_quoted_state)):"'"===data?(tokenizer._currentToken.systemId="",tokenizer.setState(doctype_system_identifier_single_quoted_state)):">"===data?(tokenizer._parseError("unexpected-end-of-doctype"),tokenizer._currentToken.forceQuirks=!0,tokenizer._emitCurrentToken(),tokenizer.setState(data_state)):(tokenizer._parseError("unexpected-char-in-doctype"),tokenizer._currentToken.forceQuirks=!0,tokenizer.setState(bogus_doctype_state))),!0}function doctype_system_identifier_double_quoted_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("eof-in-doctype"),tokenizer._currentToken.forceQuirks=!0,tokenizer._emitCurrentToken(),buffer.unget(data),tokenizer.setState(data_state)):'"'===data?tokenizer.setState(after_doctype_system_identifier_state):">"===data?(tokenizer._parseError("unexpected-end-of-doctype"),tokenizer._currentToken.forceQuirks=!0,tokenizer._emitCurrentToken(),tokenizer.setState(data_state)):tokenizer._currentToken.systemId+=data,!0}function doctype_system_identifier_single_quoted_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("eof-in-doctype"),tokenizer._currentToken.forceQuirks=!0,tokenizer._emitCurrentToken(),buffer.unget(data),tokenizer.setState(data_state)):"'"===data?tokenizer.setState(after_doctype_system_identifier_state):">"===data?(tokenizer._parseError("unexpected-end-of-doctype"),tokenizer._currentToken.forceQuirks=!0,tokenizer._emitCurrentToken(),tokenizer.setState(data_state)):tokenizer._currentToken.systemId+=data,!0}function after_doctype_system_identifier_state(buffer){var data=buffer.char();return data===InputStream.EOF?(tokenizer._parseError("eof-in-doctype"),tokenizer._currentToken.forceQuirks=!0,tokenizer._emitCurrentToken(),buffer.unget(data),tokenizer.setState(data_state)):isWhitespace(data)||(">"===data?(tokenizer._emitCurrentToken(),tokenizer.setState(data_state)):(tokenizer._parseError("unexpected-char-in-doctype"),tokenizer.setState(bogus_doctype_state))),!0}function bogus_doctype_state(buffer){var data=buffer.char();return data===InputStream.EOF?(buffer.unget(data),tokenizer._emitCurrentToken(),tokenizer.setState(data_state)):">"===data&&(tokenizer._emitCurrentToken(),tokenizer.setState(data_state)),!0}Tokenizer.DATA=data_state,Tokenizer.RCDATA=rcdata_state,Tokenizer.RAWTEXT=rawtext_state,Tokenizer.SCRIPT_DATA=script_data_state,Tokenizer.PLAINTEXT=plaintext_state,this._state=Tokenizer.DATA,this._inputStream.append(source),this._tokenHandler.startTokenization(this),this._inputStream.eof=!0;for(var tokenizer=this;this._state.call(this,this._inputStream););},Object.defineProperty(Tokenizer.prototype,"lineNumber",{get:function(){return this._inputStream.location().line}}),Object.defineProperty(Tokenizer.prototype,"columnNumber",{get:function(){return this._inputStream.location().column}}),exports.Tokenizer=Tokenizer},{"./EntityParser":2,"./InputStream":3}],6:[function(_dereq_,module,exports){function isWhitespace(ch){return" "===ch||"\\n"===ch||"	"===ch||"\\r"===ch||"\\f"===ch}function isWhitespaceOrReplacementCharacter(ch){return isWhitespace(ch)||"\uFFFD"===ch}function isAllWhitespace(characters){for(var i=0;characters.length>i;i++){var ch=characters[i];if(!isWhitespace(ch))return!1}return!0}function isAllWhitespaceOrReplacementCharacters(characters){for(var i=0;characters.length>i;i++){var ch=characters[i];if(!isWhitespaceOrReplacementCharacter(ch))return!1}return!0}function getAttribute(node,name){for(var i=0;node.attributes.length>i;i++){var attribute=node.attributes[i];if(attribute.nodeName===name)return attribute}return null}function CharacterBuffer(characters){this.characters=characters,this.current=0,this.end=this.characters.length}function TreeBuilder(){this.tokenizer=null,this.errorHandler=null,this.scriptingEnabled=!1,this.document=null,this.head=null,this.form=null,this.openElements=new ElementStack,this.activeFormattingElements=[],this.insertionMode=null,this.insertionModeName="",this.originalInsertionMode="",this.inQuirksMode=!1,this.compatMode="no quirks",this.framesetOk=!0,this.redirectAttachToFosterParent=!1,this.selfClosingFlagAcknowledged=!1,this.context="",this.pendingTableCharacters=[],this.shouldSkipLeadingNewline=!1;var tree=this,modes=this.insertionModes={};modes.base={end_tag_handlers:{"-default":"endTagOther"},start_tag_handlers:{"-default":"startTagOther"},processEOF:function(){tree.generateImpliedEndTags(),tree.openElements.length>2?tree.parseError("expected-closing-tag-but-got-eof"):2==tree.openElements.length&&"body"!=tree.openElements.item(1).localName?tree.parseError("expected-closing-tag-but-got-eof"):tree.context&&tree.openElements.length>1},processComment:function(data){tree.insertComment(data,tree.currentStackItem().node)},processDoctype:function(){tree.parseError("unexpected-doctype")},processStartTag:function(name,attributes,selfClosing){if(this[this.start_tag_handlers[name]])this[this.start_tag_handlers[name]](name,attributes,selfClosing);else{if(!this[this.start_tag_handlers["-default"]])throw Error("No handler found for "+name);this[this.start_tag_handlers["-default"]](name,attributes,selfClosing)}},processEndTag:function(name){if(this[this.end_tag_handlers[name]])this[this.end_tag_handlers[name]](name);else{if(!this[this.end_tag_handlers["-default"]])throw Error("No handler found for "+name);this[this.end_tag_handlers["-default"]](name)}},startTagHtml:function(name,attributes){modes.inBody.startTagHtml(name,attributes)}},modes.initial=Object.create(modes.base),modes.initial.processEOF=function(){tree.parseError("expected-doctype-but-got-eof"),this.anythingElse(),tree.insertionMode.processEOF()},modes.initial.processComment=function(data){tree.insertComment(data,tree.document)},modes.initial.processDoctype=function(name,publicId,systemId,forceQuirks){function publicIdStartsWith(string){return 0===publicId.toLowerCase().indexOf(string)}tree.insertDoctype(name||"",publicId||"",systemId||""),forceQuirks||"html"!=name||null!=publicId&&(["+//silmaril//dtd html pro v0r11 19970101//","-//advasoft ltd//dtd html 3.0 aswedit + extensions//","-//as//dtd html 3.0 aswedit + extensions//","-//ietf//dtd html 2.0 level 1//","-//ietf//dtd html 2.0 level 2//","-//ietf//dtd html 2.0 strict level 1//","-//ietf//dtd html 2.0 strict level 2//","-//ietf//dtd html 2.0 strict//","-//ietf//dtd html 2.0//","-//ietf//dtd html 2.1e//","-//ietf//dtd html 3.0//","-//ietf//dtd html 3.0//","-//ietf//dtd html 3.2 final//","-//ietf//dtd html 3.2//","-//ietf//dtd html 3//","-//ietf//dtd html level 0//","-//ietf//dtd html level 0//","-//ietf//dtd html level 1//","-//ietf//dtd html level 1//","-//ietf//dtd html level 2//","-//ietf//dtd html level 2//","-//ietf//dtd html level 3//","-//ietf//dtd html level 3//","-//ietf//dtd html strict level 0//","-//ietf//dtd html strict level 0//","-//ietf//dtd html strict level 1//","-//ietf//dtd html strict level 1//","-//ietf//dtd html strict level 2//","-//ietf//dtd html strict level 2//","-//ietf//dtd html strict level 3//","-//ietf//dtd html strict level 3//","-//ietf//dtd html strict//","-//ietf//dtd html strict//","-//ietf//dtd html strict//","-//ietf//dtd html//","-//ietf//dtd html//","-//ietf//dtd html//","-//metrius//dtd metrius presentational//","-//microsoft//dtd internet explorer 2.0 html strict//","-//microsoft//dtd internet explorer 2.0 html//","-//microsoft//dtd internet explorer 2.0 tables//","-//microsoft//dtd internet explorer 3.0 html strict//","-//microsoft//dtd internet explorer 3.0 html//","-//microsoft//dtd internet explorer 3.0 tables//","-//netscape comm. corp.//dtd html//","-//netscape comm. corp.//dtd strict html//","-//o'reilly and associates//dtd html 2.0//","-//o'reilly and associates//dtd html extended 1.0//","-//spyglass//dtd html 2.0 extended//","-//sq//dtd html 2.0 hotmetal + extensions//","-//sun microsystems corp.//dtd hotjava html//","-//sun microsystems corp.//dtd hotjava strict html//","-//w3c//dtd html 3 1995-03-24//","-//w3c//dtd html 3.2 draft//","-//w3c//dtd html 3.2 final//","-//w3c//dtd html 3.2//","-//w3c//dtd html 3.2s draft//","-//w3c//dtd html 4.0 frameset//","-//w3c//dtd html 4.0 transitional//","-//w3c//dtd html experimental 19960712//","-//w3c//dtd html experimental 970421//","-//w3c//dtd w3 html//","-//w3o//dtd w3 html 3.0//","-//webtechs//dtd mozilla html 2.0//","-//webtechs//dtd mozilla html//","html"].some(publicIdStartsWith)||["-//w3o//dtd w3 html strict 3.0//en//","-/w3c/dtd html 4.0 transitional/en","html"].indexOf(publicId.toLowerCase())>-1||null==systemId&&["-//w3c//dtd html 4.01 transitional//","-//w3c//dtd html 4.01 frameset//"].some(publicIdStartsWith))||null!=systemId&&"http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd"==systemId.toLowerCase()?(tree.compatMode="quirks",tree.parseError("quirky-doctype")):null!=publicId&&(["-//w3c//dtd xhtml 1.0 transitional//","-//w3c//dtd xhtml 1.0 frameset//"].some(publicIdStartsWith)||null!=systemId&&["-//w3c//dtd html 4.01 transitional//","-//w3c//dtd html 4.01 frameset//"].indexOf(publicId.toLowerCase())>-1)?(tree.compatMode="limited quirks",tree.parseError("almost-standards-doctype")):"-//W3C//DTD HTML 4.0//EN"==publicId&&(null==systemId||"http://www.w3.org/TR/REC-html40/strict.dtd"==systemId)||"-//W3C//DTD HTML 4.01//EN"==publicId&&(null==systemId||"http://www.w3.org/TR/html4/strict.dtd"==systemId)||"-//W3C//DTD XHTML 1.0 Strict//EN"==publicId&&"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"==systemId||"-//W3C//DTD XHTML 1.1//EN"==publicId&&"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"==systemId||(null!=systemId&&"about:legacy-compat"!=systemId||null!=publicId)&&tree.parseError("unknown-doctype"),tree.setInsertionMode("beforeHTML")},modes.initial.processCharacters=function(buffer){buffer.skipLeadingWhitespace(),buffer.length&&(tree.parseError("expected-doctype-but-got-chars"),this.anythingElse(),tree.insertionMode.processCharacters(buffer))},modes.initial.processStartTag=function(name,attributes,selfClosing){tree.parseError("expected-doctype-but-got-start-tag",{name:name}),this.anythingElse(),tree.insertionMode.processStartTag(name,attributes,selfClosing)},modes.initial.processEndTag=function(name){tree.parseError("expected-doctype-but-got-end-tag",{name:name}),this.anythingElse(),tree.insertionMode.processEndTag(name)},modes.initial.anythingElse=function(){tree.compatMode="quirks",tree.setInsertionMode("beforeHTML")},modes.beforeHTML=Object.create(modes.base),modes.beforeHTML.start_tag_handlers={html:"startTagHtml","-default":"startTagOther"},modes.beforeHTML.processEOF=function(){this.anythingElse(),tree.insertionMode.processEOF()},modes.beforeHTML.processComment=function(data){tree.insertComment(data,tree.document)},modes.beforeHTML.processCharacters=function(buffer){buffer.skipLeadingWhitespace(),buffer.length&&(this.anythingElse(),tree.insertionMode.processCharacters(buffer))},modes.beforeHTML.startTagHtml=function(name,attributes){tree.insertHtmlElement(attributes),tree.setInsertionMode("beforeHead")},modes.beforeHTML.startTagOther=function(name,attributes,selfClosing){this.anythingElse(),tree.insertionMode.processStartTag(name,attributes,selfClosing)},modes.beforeHTML.processEndTag=function(name){this.anythingElse(),tree.insertionMode.processEndTag(name)},modes.beforeHTML.anythingElse=function(){tree.insertHtmlElement(),tree.setInsertionMode("beforeHead")},modes.afterAfterBody=Object.create(modes.base),modes.afterAfterBody.start_tag_handlers={html:"startTagHtml","-default":"startTagOther"},modes.afterAfterBody.processComment=function(data){tree.insertComment(data,tree.document)},modes.afterAfterBody.processDoctype=function(data){modes.inBody.processDoctype(data)},modes.afterAfterBody.startTagHtml=function(data,attributes){modes.inBody.startTagHtml(data,attributes)},modes.afterAfterBody.startTagOther=function(name,attributes,selfClosing){tree.parseError("unexpected-start-tag",{name:name}),tree.setInsertionMode("inBody"),tree.insertionMode.processStartTag(name,attributes,selfClosing)},modes.afterAfterBody.endTagOther=function(name){tree.parseError("unexpected-end-tag",{name:name}),tree.setInsertionMode("inBody"),tree.insertionMode.processEndTag(name)},modes.afterAfterBody.processCharacters=function(data){return isAllWhitespace(data.characters)?(modes.inBody.processCharacters(data),void 0):(tree.parseError("unexpected-char-after-body"),tree.setInsertionMode("inBody"),tree.insertionMode.processCharacters(data))},modes.afterBody=Object.create(modes.base),modes.afterBody.end_tag_handlers={html:"endTagHtml","-default":"endTagOther"},modes.afterBody.processComment=function(data){tree.insertComment(data,tree.openElements.rootNode)},modes.afterBody.processCharacters=function(data){return isAllWhitespace(data.characters)?(modes.inBody.processCharacters(data),void 0):(tree.parseError("unexpected-char-after-body"),tree.setInsertionMode("inBody"),tree.insertionMode.processCharacters(data))},modes.afterBody.processStartTag=function(name,attributes,selfClosing){tree.parseError("unexpected-start-tag-after-body",{name:name}),tree.setInsertionMode("inBody"),tree.insertionMode.processStartTag(name,attributes,selfClosing)},modes.afterBody.endTagHtml=function(){tree.context?tree.parseError("end-html-in-innerhtml"):tree.setInsertionMode("afterAfterBody")},modes.afterBody.endTagOther=function(name){tree.parseError("unexpected-end-tag-after-body",{name:name}),tree.setInsertionMode("inBody"),tree.insertionMode.processEndTag(name)},modes.afterFrameset=Object.create(modes.base),modes.afterFrameset.start_tag_handlers={html:"startTagHtml",noframes:"startTagNoframes","-default":"startTagOther"},modes.afterFrameset.end_tag_handlers={html:"endTagHtml","-default":"endTagOther"},modes.afterFrameset.processCharacters=function(buffer){for(var characters=buffer.takeRemaining(),whitespace="",i=0;characters.length>i;i++){var ch=characters[i];isWhitespace(ch)&&(whitespace+=ch)}whitespace&&tree.insertText(whitespace),whitespace.length<characters.length&&tree.parseError("expected-eof-but-got-char")},modes.afterFrameset.startTagNoframes=function(name,attributes){modes.inHead.processStartTag(name,attributes)},modes.afterFrameset.startTagOther=function(name){tree.parseError("unexpected-start-tag-after-frameset",{name:name})},modes.afterFrameset.endTagHtml=function(){tree.setInsertionMode("afterAfterFrameset")},modes.afterFrameset.endTagOther=function(name){tree.parseError("unexpected-end-tag-after-frameset",{name:name})},modes.beforeHead=Object.create(modes.base),modes.beforeHead.start_tag_handlers={html:"startTagHtml",head:"startTagHead","-default":"startTagOther"},modes.beforeHead.end_tag_handlers={html:"endTagImplyHead",head:"endTagImplyHead",body:"endTagImplyHead",br:"endTagImplyHead","-default":"endTagOther"},modes.beforeHead.processEOF=function(){this.startTagHead("head",[]),tree.insertionMode.processEOF()},modes.beforeHead.processCharacters=function(buffer){buffer.skipLeadingWhitespace(),buffer.length&&(this.startTagHead("head",[]),tree.insertionMode.processCharacters(buffer))},modes.beforeHead.startTagHead=function(name,attributes){tree.insertHeadElement(attributes),tree.setInsertionMode("inHead")},modes.beforeHead.startTagOther=function(name,attributes,selfClosing){this.startTagHead("head",[]),tree.insertionMode.processStartTag(name,attributes,selfClosing)},modes.beforeHead.endTagImplyHead=function(name){this.startTagHead("head",[]),tree.insertionMode.processEndTag(name)},modes.beforeHead.endTagOther=function(name){tree.parseError("end-tag-after-implied-root",{name:name})},modes.inHead=Object.create(modes.base),modes.inHead.start_tag_handlers={html:"startTagHtml",head:"startTagHead",title:"startTagTitle",script:"startTagScript",style:"startTagNoFramesStyle",noscript:"startTagNoScript",noframes:"startTagNoFramesStyle",base:"startTagBaseBasefontBgsoundLink",basefont:"startTagBaseBasefontBgsoundLink",bgsound:"startTagBaseBasefontBgsoundLink",link:"startTagBaseBasefontBgsoundLink",meta:"startTagMeta","-default":"startTagOther"},modes.inHead.end_tag_handlers={head:"endTagHead",html:"endTagHtmlBodyBr",body:"endTagHtmlBodyBr",br:"endTagHtmlBodyBr","-default":"endTagOther"},modes.inHead.processEOF=function(){var name=tree.currentStackItem().localName;
-1!=["title","style","script"].indexOf(name)&&(tree.parseError("expected-named-closing-tag-but-got-eof",{name:name}),tree.popElement()),this.anythingElse(),tree.insertionMode.processEOF()},modes.inHead.processCharacters=function(buffer){var leadingWhitespace=buffer.takeLeadingWhitespace();leadingWhitespace&&tree.insertText(leadingWhitespace),buffer.length&&(this.anythingElse(),tree.insertionMode.processCharacters(buffer))},modes.inHead.startTagHtml=function(name,attributes){modes.inBody.processStartTag(name,attributes)},modes.inHead.startTagHead=function(){tree.parseError("two-heads-are-not-better-than-one")},modes.inHead.startTagTitle=function(name,attributes){tree.processGenericRCDATAStartTag(name,attributes)},modes.inHead.startTagNoScript=function(name,attributes){return tree.scriptingEnabled?tree.processGenericRawTextStartTag(name,attributes):(tree.insertElement(name,attributes),tree.setInsertionMode("inHeadNoscript"),void 0)},modes.inHead.startTagNoFramesStyle=function(name,attributes){tree.processGenericRawTextStartTag(name,attributes)},modes.inHead.startTagScript=function(name,attributes){tree.insertElement(name,attributes),tree.tokenizer.setState(Tokenizer.SCRIPT_DATA),tree.originalInsertionMode=tree.insertionModeName,tree.setInsertionMode("text")},modes.inHead.startTagBaseBasefontBgsoundLink=function(name,attributes){tree.insertSelfClosingElement(name,attributes)},modes.inHead.startTagMeta=function(name,attributes){tree.insertSelfClosingElement(name,attributes)},modes.inHead.startTagOther=function(name,attributes,selfClosing){this.anythingElse(),tree.insertionMode.processStartTag(name,attributes,selfClosing)},modes.inHead.endTagHead=function(){"head"==tree.openElements.item(tree.openElements.length-1).localName?tree.openElements.pop():tree.parseError("unexpected-end-tag",{name:"head"}),tree.setInsertionMode("afterHead")},modes.inHead.endTagHtmlBodyBr=function(name){this.anythingElse(),tree.insertionMode.processEndTag(name)},modes.inHead.endTagOther=function(name){tree.parseError("unexpected-end-tag",{name:name})},modes.inHead.anythingElse=function(){this.endTagHead("head")},modes.afterHead=Object.create(modes.base),modes.afterHead.start_tag_handlers={html:"startTagHtml",head:"startTagHead",body:"startTagBody",frameset:"startTagFrameset",base:"startTagFromHead",link:"startTagFromHead",meta:"startTagFromHead",script:"startTagFromHead",style:"startTagFromHead",title:"startTagFromHead","-default":"startTagOther"},modes.afterHead.end_tag_handlers={body:"endTagBodyHtmlBr",html:"endTagBodyHtmlBr",br:"endTagBodyHtmlBr","-default":"endTagOther"},modes.afterHead.processEOF=function(){this.anythingElse(),tree.insertionMode.processEOF()},modes.afterHead.processCharacters=function(buffer){var leadingWhitespace=buffer.takeLeadingWhitespace();leadingWhitespace&&tree.insertText(leadingWhitespace),buffer.length&&(this.anythingElse(),tree.insertionMode.processCharacters(buffer))},modes.afterHead.startTagHtml=function(name,attributes){modes.inBody.processStartTag(name,attributes)},modes.afterHead.startTagBody=function(name,attributes){tree.framesetOk=!1,tree.insertBodyElement(attributes),tree.setInsertionMode("inBody")},modes.afterHead.startTagFrameset=function(name,attributes){tree.insertElement(name,attributes),tree.setInsertionMode("inFrameset")},modes.afterHead.startTagFromHead=function(name,attributes,selfClosing){tree.parseError("unexpected-start-tag-out-of-my-head",{name:name}),tree.openElements.push(tree.head),modes.inHead.processStartTag(name,attributes,selfClosing),tree.openElements.remove(tree.head)},modes.afterHead.startTagHead=function(name){tree.parseError("unexpected-start-tag",{name:name})},modes.afterHead.startTagOther=function(name,attributes,selfClosing){this.anythingElse(),tree.insertionMode.processStartTag(name,attributes,selfClosing)},modes.afterHead.endTagBodyHtmlBr=function(name){this.anythingElse(),tree.insertionMode.processEndTag(name)},modes.afterHead.endTagOther=function(name){tree.parseError("unexpected-end-tag",{name:name})},modes.afterHead.anythingElse=function(){tree.insertBodyElement([]),tree.setInsertionMode("inBody"),tree.framesetOk=!0},modes.inBody=Object.create(modes.base),modes.inBody.start_tag_handlers={html:"startTagHtml",head:"startTagMisplaced",base:"startTagProcessInHead",basefont:"startTagProcessInHead",bgsound:"startTagProcessInHead",link:"startTagProcessInHead",meta:"startTagProcessInHead",noframes:"startTagProcessInHead",script:"startTagProcessInHead",style:"startTagProcessInHead",title:"startTagProcessInHead",body:"startTagBody",form:"startTagForm",plaintext:"startTagPlaintext",a:"startTagA",button:"startTagButton",xmp:"startTagXmp",table:"startTagTable",hr:"startTagHr",image:"startTagImage",input:"startTagInput",textarea:"startTagTextarea",select:"startTagSelect",isindex:"startTagIsindex",applet:"startTagAppletMarqueeObject",marquee:"startTagAppletMarqueeObject",object:"startTagAppletMarqueeObject",li:"startTagListItem",dd:"startTagListItem",dt:"startTagListItem",address:"startTagCloseP",article:"startTagCloseP",aside:"startTagCloseP",blockquote:"startTagCloseP",center:"startTagCloseP",details:"startTagCloseP",dir:"startTagCloseP",div:"startTagCloseP",dl:"startTagCloseP",fieldset:"startTagCloseP",figcaption:"startTagCloseP",figure:"startTagCloseP",footer:"startTagCloseP",header:"startTagCloseP",hgroup:"startTagCloseP",main:"startTagCloseP",menu:"startTagCloseP",nav:"startTagCloseP",ol:"startTagCloseP",p:"startTagCloseP",section:"startTagCloseP",summary:"startTagCloseP",ul:"startTagCloseP",listing:"startTagPreListing",pre:"startTagPreListing",b:"startTagFormatting",big:"startTagFormatting",code:"startTagFormatting",em:"startTagFormatting",font:"startTagFormatting",i:"startTagFormatting",s:"startTagFormatting",small:"startTagFormatting",strike:"startTagFormatting",strong:"startTagFormatting",tt:"startTagFormatting",u:"startTagFormatting",nobr:"startTagNobr",area:"startTagVoidFormatting",br:"startTagVoidFormatting",embed:"startTagVoidFormatting",img:"startTagVoidFormatting",keygen:"startTagVoidFormatting",wbr:"startTagVoidFormatting",param:"startTagParamSourceTrack",source:"startTagParamSourceTrack",track:"startTagParamSourceTrack",iframe:"startTagIFrame",noembed:"startTagRawText",noscript:"startTagRawText",h1:"startTagHeading",h2:"startTagHeading",h3:"startTagHeading",h4:"startTagHeading",h5:"startTagHeading",h6:"startTagHeading",caption:"startTagMisplaced",col:"startTagMisplaced",colgroup:"startTagMisplaced",frame:"startTagMisplaced",frameset:"startTagFrameset",tbody:"startTagMisplaced",td:"startTagMisplaced",tfoot:"startTagMisplaced",th:"startTagMisplaced",thead:"startTagMisplaced",tr:"startTagMisplaced",option:"startTagOptionOptgroup",optgroup:"startTagOptionOptgroup",math:"startTagMath",svg:"startTagSVG",rt:"startTagRpRt",rp:"startTagRpRt","-default":"startTagOther"},modes.inBody.end_tag_handlers={p:"endTagP",body:"endTagBody",html:"endTagHtml",address:"endTagBlock",article:"endTagBlock",aside:"endTagBlock",blockquote:"endTagBlock",button:"endTagBlock",center:"endTagBlock",details:"endTagBlock",dir:"endTagBlock",div:"endTagBlock",dl:"endTagBlock",fieldset:"endTagBlock",figcaption:"endTagBlock",figure:"endTagBlock",footer:"endTagBlock",header:"endTagBlock",hgroup:"endTagBlock",listing:"endTagBlock",main:"endTagBlock",menu:"endTagBlock",nav:"endTagBlock",ol:"endTagBlock",pre:"endTagBlock",section:"endTagBlock",summary:"endTagBlock",ul:"endTagBlock",form:"endTagForm",applet:"endTagAppletMarqueeObject",marquee:"endTagAppletMarqueeObject",object:"endTagAppletMarqueeObject",dd:"endTagListItem",dt:"endTagListItem",li:"endTagListItem",h1:"endTagHeading",h2:"endTagHeading",h3:"endTagHeading",h4:"endTagHeading",h5:"endTagHeading",h6:"endTagHeading",a:"endTagFormatting",b:"endTagFormatting",big:"endTagFormatting",code:"endTagFormatting",em:"endTagFormatting",font:"endTagFormatting",i:"endTagFormatting",nobr:"endTagFormatting",s:"endTagFormatting",small:"endTagFormatting",strike:"endTagFormatting",strong:"endTagFormatting",tt:"endTagFormatting",u:"endTagFormatting",br:"endTagBr","-default":"endTagOther"},modes.inBody.processCharacters=function(buffer){tree.shouldSkipLeadingNewline&&(tree.shouldSkipLeadingNewline=!1,buffer.skipAtMostOneLeadingNewline()),tree.reconstructActiveFormattingElements();var characters=buffer.takeRemaining();characters=characters.replace(/\\u0000/g,function(){return tree.parseError("invalid-codepoint"),""}),characters&&(tree.insertText(characters),tree.framesetOk&&!isAllWhitespaceOrReplacementCharacters(characters)&&(tree.framesetOk=!1))},modes.inBody.startTagHtml=function(name,attributes){tree.parseError("non-html-root"),tree.addAttributesToElement(tree.openElements.rootNode,attributes)},modes.inBody.startTagProcessInHead=function(name,attributes){modes.inHead.processStartTag(name,attributes)},modes.inBody.startTagBody=function(name,attributes){tree.parseError("unexpected-start-tag",{name:"body"}),1==tree.openElements.length||"body"!=tree.openElements.item(1).localName?assert.ok(tree.context):(tree.framesetOk=!1,tree.addAttributesToElement(tree.openElements.bodyElement,attributes))},modes.inBody.startTagFrameset=function(name,attributes){if(tree.parseError("unexpected-start-tag",{name:"frameset"}),1==tree.openElements.length||"body"!=tree.openElements.item(1).localName)assert.ok(tree.context);else if(tree.framesetOk){for(tree.detachFromParent(tree.openElements.bodyElement);tree.openElements.length>1;)tree.openElements.pop();tree.insertElement(name,attributes),tree.setInsertionMode("inFrameset")}},modes.inBody.startTagCloseP=function(name,attributes){tree.openElements.inButtonScope("p")&&this.endTagP("p"),tree.insertElement(name,attributes)},modes.inBody.startTagPreListing=function(name,attributes){tree.openElements.inButtonScope("p")&&this.endTagP("p"),tree.insertElement(name,attributes),tree.framesetOk=!1,tree.shouldSkipLeadingNewline=!0},modes.inBody.startTagForm=function(name,attributes){tree.form?tree.parseError("unexpected-start-tag",{name:name}):(tree.openElements.inButtonScope("p")&&this.endTagP("p"),tree.insertElement(name,attributes),tree.form=tree.currentStackItem())},modes.inBody.startTagRpRt=function(name,attributes){tree.openElements.inScope("ruby")&&(tree.generateImpliedEndTags(),"ruby"!=tree.currentStackItem().localName&&tree.parseError("unexpected-start-tag",{name:name})),tree.insertElement(name,attributes)},modes.inBody.startTagListItem=function(name,attributes){for(var stopNames={li:["li"],dd:["dd","dt"],dt:["dd","dt"]},stopName=stopNames[name],els=tree.openElements,i=els.length-1;i>=0;i--){var node=els.item(i);if(-1!=stopName.indexOf(node.localName)){tree.insertionMode.processEndTag(node.localName);break}if(node.isSpecial()&&"p"!==node.localName&&"address"!==node.localName&&"div"!==node.localName)break}tree.openElements.inButtonScope("p")&&this.endTagP("p"),tree.insertElement(name,attributes),tree.framesetOk=!1},modes.inBody.startTagPlaintext=function(name,attributes){tree.openElements.inButtonScope("p")&&this.endTagP("p"),tree.insertElement(name,attributes),tree.tokenizer.setState(Tokenizer.PLAINTEXT)},modes.inBody.startTagHeading=function(name,attributes){tree.openElements.inButtonScope("p")&&this.endTagP("p"),tree.currentStackItem().isNumberedHeader()&&(tree.parseError("unexpected-start-tag",{name:name}),tree.popElement()),tree.insertElement(name,attributes)},modes.inBody.startTagA=function(name,attributes){var activeA=tree.elementInActiveFormattingElements("a");activeA&&(tree.parseError("unexpected-start-tag-implies-end-tag",{startName:"a",endName:"a"}),tree.adoptionAgencyEndTag("a"),tree.openElements.contains(activeA)&&tree.openElements.remove(activeA),tree.removeElementFromActiveFormattingElements(activeA)),tree.reconstructActiveFormattingElements(),tree.insertFormattingElement(name,attributes)},modes.inBody.startTagFormatting=function(name,attributes){tree.reconstructActiveFormattingElements(),tree.insertFormattingElement(name,attributes)},modes.inBody.startTagNobr=function(name,attributes){tree.reconstructActiveFormattingElements(),tree.openElements.inScope("nobr")&&(tree.parseError("unexpected-start-tag-implies-end-tag",{startName:"nobr",endName:"nobr"}),this.processEndTag("nobr"),tree.reconstructActiveFormattingElements()),tree.insertFormattingElement(name,attributes)},modes.inBody.startTagButton=function(name,attributes){tree.openElements.inScope("button")?(tree.parseError("unexpected-start-tag-implies-end-tag",{startName:"button",endName:"button"}),this.processEndTag("button"),tree.insertionMode.processStartTag(name,attributes)):(tree.framesetOk=!1,tree.reconstructActiveFormattingElements(),tree.insertElement(name,attributes))},modes.inBody.startTagAppletMarqueeObject=function(name,attributes){tree.reconstructActiveFormattingElements(),tree.insertElement(name,attributes),tree.activeFormattingElements.push(Marker),tree.framesetOk=!1},modes.inBody.endTagAppletMarqueeObject=function(name){tree.openElements.inScope(name)?(tree.generateImpliedEndTags(),tree.currentStackItem().localName!=name&&tree.parseError("end-tag-too-early",{name:name}),tree.openElements.popUntilPopped(name),tree.clearActiveFormattingElements()):tree.parseError("unexpected-end-tag",{name:name})},modes.inBody.startTagXmp=function(name,attributes){tree.openElements.inButtonScope("p")&&this.processEndTag("p"),tree.reconstructActiveFormattingElements(),tree.processGenericRawTextStartTag(name,attributes),tree.framesetOk=!1},modes.inBody.startTagTable=function(name,attributes){"quirks"!==tree.compatMode&&tree.openElements.inButtonScope("p")&&this.processEndTag("p"),tree.insertElement(name,attributes),tree.setInsertionMode("inTable"),tree.framesetOk=!1},modes.inBody.startTagVoidFormatting=function(name,attributes){tree.reconstructActiveFormattingElements(),tree.insertSelfClosingElement(name,attributes),tree.framesetOk=!1},modes.inBody.startTagParamSourceTrack=function(name,attributes){tree.insertSelfClosingElement(name,attributes)},modes.inBody.startTagHr=function(name,attributes){tree.openElements.inButtonScope("p")&&this.endTagP("p"),tree.insertSelfClosingElement(name,attributes),tree.framesetOk=!1},modes.inBody.startTagImage=function(name,attributes){tree.parseError("unexpected-start-tag-treated-as",{originalName:"image",newName:"img"}),this.processStartTag("img",attributes)},modes.inBody.startTagInput=function(name,attributes){var currentFramesetOk=tree.framesetOk;this.startTagVoidFormatting(name,attributes);for(var key in attributes)if("type"==attributes[key].nodeName){"hidden"==attributes[key].nodeValue.toLowerCase()&&(tree.framesetOk=currentFramesetOk);break}},modes.inBody.startTagIsindex=function(name,attributes){if(tree.parseError("deprecated-tag",{name:"isindex"}),tree.selfClosingFlagAcknowledged=!0,!tree.form){var formAttributes=[],inputAttributes=[],prompt="This is a searchable index. Enter search keywords: ";for(var key in attributes)switch(attributes[key].nodeName){case"action":formAttributes.push({nodeName:"action",nodeValue:attributes[key].nodeValue});break;case"prompt":prompt=attributes[key].nodeValue;break;case"name":break;default:inputAttributes.push({nodeName:attributes[key].nodeName,nodeValue:attributes[key].nodeValue})}inputAttributes.push({nodeName:"name",nodeValue:"isindex"}),this.processStartTag("form",formAttributes),this.processStartTag("hr"),this.processStartTag("label"),this.processCharacters(new CharacterBuffer(prompt)),this.processStartTag("input",inputAttributes),this.processEndTag("label"),this.processStartTag("hr"),this.processEndTag("form")}},modes.inBody.startTagTextarea=function(name,attributes){tree.insertElement(name,attributes),tree.tokenizer.setState(Tokenizer.RCDATA),tree.originalInsertionMode=tree.insertionModeName,tree.shouldSkipLeadingNewline=!0,tree.framesetOk=!1,tree.setInsertionMode("text")},modes.inBody.startTagIFrame=function(name,attributes){tree.framesetOk=!1,this.startTagRawText(name,attributes)},modes.inBody.startTagRawText=function(name,attributes){tree.processGenericRawTextStartTag(name,attributes)},modes.inBody.startTagSelect=function(name,attributes){tree.reconstructActiveFormattingElements(),tree.insertElement(name,attributes),tree.framesetOk=!1;var insertionModeName=tree.insertionModeName;"inTable"==insertionModeName||"inCaption"==insertionModeName||"inColumnGroup"==insertionModeName||"inTableBody"==insertionModeName||"inRow"==insertionModeName||"inCell"==insertionModeName?tree.setInsertionMode("inSelectInTable"):tree.setInsertionMode("inSelect")},modes.inBody.startTagMisplaced=function(name){tree.parseError("unexpected-start-tag-ignored",{name:name})},modes.inBody.endTagMisplaced=function(name){tree.parseError("unexpected-end-tag",{name:name})},modes.inBody.endTagBr=function(name){tree.parseError("unexpected-end-tag-treated-as",{originalName:"br",newName:"br element"}),tree.reconstructActiveFormattingElements(),tree.insertElement(name,[]),tree.popElement()},modes.inBody.startTagOptionOptgroup=function(name,attributes){"option"==tree.currentStackItem().localName&&tree.popElement(),tree.reconstructActiveFormattingElements(),tree.insertElement(name,attributes)},modes.inBody.startTagOther=function(name,attributes){tree.reconstructActiveFormattingElements(),tree.insertElement(name,attributes)},modes.inBody.endTagOther=function(name){for(var node,i=tree.openElements.length-1;i>0;i--){if(node=tree.openElements.item(i),node.localName==name){tree.generateImpliedEndTags(name),tree.currentStackItem().localName!=name&&tree.parseError("unexpected-end-tag",{name:name}),tree.openElements.remove_openElements_until(function(x){return x===node});break}if(node.isSpecial()){tree.parseError("unexpected-end-tag",{name:name});break}}},modes.inBody.startTagMath=function(name,attributes,selfClosing){tree.reconstructActiveFormattingElements(),attributes=tree.adjustMathMLAttributes(attributes),attributes=tree.adjustForeignAttributes(attributes),tree.insertForeignElement(name,attributes,"http://www.w3.org/1998/Math/MathML",selfClosing)},modes.inBody.startTagSVG=function(name,attributes,selfClosing){tree.reconstructActiveFormattingElements(),attributes=tree.adjustSVGAttributes(attributes),attributes=tree.adjustForeignAttributes(attributes),tree.insertForeignElement(name,attributes,"http://www.w3.org/2000/svg",selfClosing)},modes.inBody.endTagP=function(name){tree.openElements.inButtonScope("p")?(tree.generateImpliedEndTags("p"),"p"!=tree.currentStackItem().localName&&tree.parseError("unexpected-implied-end-tag",{name:"p"}),tree.openElements.popUntilPopped(name)):(tree.parseError("unexpected-end-tag",{name:"p"}),this.startTagCloseP("p",[]),this.endTagP("p"))},modes.inBody.endTagBody=function(name){return tree.openElements.inScope("body")?("body"!=tree.currentStackItem().localName&&tree.parseError("expected-one-end-tag-but-got-another",{expectedName:tree.currentStackItem().localName,gotName:name}),tree.setInsertionMode("afterBody"),void 0):(tree.parseError("unexpected-end-tag",{name:name}),void 0)},modes.inBody.endTagHtml=function(name){return tree.openElements.inScope("body")?("body"!=tree.currentStackItem().localName&&tree.parseError("expected-one-end-tag-but-got-another",{expectedName:tree.currentStackItem().localName,gotName:name}),tree.setInsertionMode("afterBody"),tree.insertionMode.processEndTag(name),void 0):(tree.parseError("unexpected-end-tag",{name:name}),void 0)},modes.inBody.endTagBlock=function(name){tree.openElements.inScope(name)?(tree.generateImpliedEndTags(),tree.currentStackItem().localName!=name&&tree.parseError("end-tag-too-early",{name:name}),tree.openElements.popUntilPopped(name)):tree.parseError("unexpected-end-tag",{name:name})},modes.inBody.endTagForm=function(name){var node=tree.form;tree.form=null,node&&tree.openElements.inScope(name)?(tree.generateImpliedEndTags(),tree.currentStackItem()!=node&&tree.parseError("end-tag-too-early-ignored",{name:"form"}),tree.openElements.remove(node)):tree.parseError("unexpected-end-tag",{name:name})},modes.inBody.endTagListItem=function(name){tree.openElements.inListItemScope(name)?(tree.generateImpliedEndTags(name),tree.currentStackItem().localName!=name&&tree.parseError("end-tag-too-early",{name:name}),tree.openElements.popUntilPopped(name)):tree.parseError("unexpected-end-tag",{name:name})},modes.inBody.endTagHeading=function(name){return tree.openElements.hasNumberedHeaderElementInScope()?(tree.generateImpliedEndTags(),tree.currentStackItem().localName!=name&&tree.parseError("end-tag-too-early",{name:name}),tree.openElements.remove_openElements_until(function(e){return e.isNumberedHeader()}),void 0):(tree.parseError("unexpected-end-tag",{name:name}),void 0)},modes.inBody.endTagFormatting=function(name,attributes){tree.adoptionAgencyEndTag(name)||this.endTagOther(name,attributes)},modes.inCaption=Object.create(modes.base),modes.inCaption.start_tag_handlers={html:"startTagHtml",caption:"startTagTableElement",col:"startTagTableElement",colgroup:"startTagTableElement",tbody:"startTagTableElement",td:"startTagTableElement",tfoot:"startTagTableElement",thead:"startTagTableElement",tr:"startTagTableElement","-default":"startTagOther"},modes.inCaption.end_tag_handlers={caption:"endTagCaption",table:"endTagTable",body:"endTagIgnore",col:"endTagIgnore",colgroup:"endTagIgnore",html:"endTagIgnore",tbody:"endTagIgnore",td:"endTagIgnore",tfood:"endTagIgnore",thead:"endTagIgnore",tr:"endTagIgnore","-default":"endTagOther"},modes.inCaption.processCharacters=function(data){modes.inBody.processCharacters(data)},modes.inCaption.startTagTableElement=function(name,attributes){tree.parseError("unexpected-end-tag",{name:name});var ignoreEndTag=!tree.openElements.inTableScope("caption");tree.insertionMode.processEndTag("caption"),ignoreEndTag||tree.insertionMode.processStartTag(name,attributes)},modes.inCaption.startTagOther=function(name,attributes,selfClosing){modes.inBody.processStartTag(name,attributes,selfClosing)},modes.inCaption.endTagCaption=function(name){tree.openElements.inTableScope("caption")?(tree.generateImpliedEndTags(),"caption"!=tree.currentStackItem().localName&&tree.parseError("expected-one-end-tag-but-got-another",{gotName:"caption",expectedName:tree.currentStackItem().localName}),tree.openElements.popUntilPopped("caption"),tree.clearActiveFormattingElements(),tree.setInsertionMode("inTable")):(assert.ok(tree.context),tree.parseError("unexpected-end-tag",{name:name}))},modes.inCaption.endTagTable=function(name){tree.parseError("unexpected-end-table-in-caption");var ignoreEndTag=!tree.openElements.inTableScope("caption");tree.insertionMode.processEndTag("caption"),ignoreEndTag||tree.insertionMode.processEndTag(name)},modes.inCaption.endTagIgnore=function(name){tree.parseError("unexpected-end-tag",{name:name})},modes.inCaption.endTagOther=function(name){modes.inBody.processEndTag(name)},modes.inCell=Object.create(modes.base),modes.inCell.start_tag_handlers={html:"startTagHtml",caption:"startTagTableOther",col:"startTagTableOther",colgroup:"startTagTableOther",tbody:"startTagTableOther",td:"startTagTableOther",tfoot:"startTagTableOther",th:"startTagTableOther",thead:"startTagTableOther",tr:"startTagTableOther","-default":"startTagOther"},modes.inCell.end_tag_handlers={td:"endTagTableCell",th:"endTagTableCell",body:"endTagIgnore",caption:"endTagIgnore",col:"endTagIgnore",colgroup:"endTagIgnore",html:"endTagIgnore",table:"endTagImply",tbody:"endTagImply",tfoot:"endTagImply",thead:"endTagImply",tr:"endTagImply","-default":"endTagOther"},modes.inCell.processCharacters=function(data){modes.inBody.processCharacters(data)},modes.inCell.startTagTableOther=function(name,attributes,selfClosing){tree.openElements.inTableScope("td")||tree.openElements.inTableScope("th")?(this.closeCell(),tree.insertionMode.processStartTag(name,attributes,selfClosing)):tree.parseError("unexpected-start-tag",{name:name})},modes.inCell.startTagOther=function(name,attributes,selfClosing){modes.inBody.processStartTag(name,attributes,selfClosing)},modes.inCell.endTagTableCell=function(name){tree.openElements.inTableScope(name)?(tree.generateImpliedEndTags(name),tree.currentStackItem().localName!=name.toLowerCase()?(tree.parseError("unexpected-cell-end-tag",{name:name}),tree.openElements.popUntilPopped(name)):tree.popElement(),tree.clearActiveFormattingElements(),tree.setInsertionMode("inRow")):tree.parseError("unexpected-end-tag",{name:name})},modes.inCell.endTagIgnore=function(name){tree.parseError("unexpected-end-tag",{name:name})},modes.inCell.endTagImply=function(name){tree.openElements.inTableScope(name)?(this.closeCell(),tree.insertionMode.processEndTag(name)):tree.parseError("unexpected-end-tag",{name:name})},modes.inCell.endTagOther=function(name){modes.inBody.processEndTag(name)},modes.inCell.closeCell=function(){tree.openElements.inTableScope("td")?this.endTagTableCell("td"):tree.openElements.inTableScope("th")&&this.endTagTableCell("th")},modes.inColumnGroup=Object.create(modes.base),modes.inColumnGroup.start_tag_handlers={html:"startTagHtml",col:"startTagCol","-default":"startTagOther"},modes.inColumnGroup.end_tag_handlers={colgroup:"endTagColgroup",col:"endTagCol","-default":"endTagOther"},modes.inColumnGroup.ignoreEndTagColgroup=function(){return"html"==tree.currentStackItem().localName},modes.inColumnGroup.processCharacters=function(buffer){var leadingWhitespace=buffer.takeLeadingWhitespace();if(leadingWhitespace&&tree.insertText(leadingWhitespace),buffer.length){var ignoreEndTag=this.ignoreEndTagColgroup();this.endTagColgroup("colgroup"),ignoreEndTag||tree.insertionMode.processCharacters(buffer)}},modes.inColumnGroup.startTagCol=function(name,attributes){tree.insertSelfClosingElement(name,attributes)},modes.inColumnGroup.startTagOther=function(name,attributes,selfClosing){var ignoreEndTag=this.ignoreEndTagColgroup();this.endTagColgroup("colgroup"),ignoreEndTag||tree.insertionMode.processStartTag(name,attributes,selfClosing)},modes.inColumnGroup.endTagColgroup=function(name){this.ignoreEndTagColgroup()?(assert.ok(tree.context),tree.parseError("unexpected-end-tag",{name:name})):(tree.popElement(),tree.setInsertionMode("inTable"))},modes.inColumnGroup.endTagCol=function(){tree.parseError("no-end-tag",{name:"col"})},modes.inColumnGroup.endTagOther=function(name){var ignoreEndTag=this.ignoreEndTagColgroup();this.endTagColgroup("colgroup"),ignoreEndTag||tree.insertionMode.processEndTag(name)},modes.inForeignContent=Object.create(modes.base),modes.inForeignContent.processStartTag=function(name,attributes,selfClosing){if(-1!=["b","big","blockquote","body","br","center","code","dd","div","dl","dt","em","embed","h1","h2","h3","h4","h5","h6","head","hr","i","img","li","listing","menu","meta","nobr","ol","p","pre","ruby","s","small","span","strong","strike","sub","sup","table","tt","u","ul","var"].indexOf(name)||"font"==name&&attributes.some(function(attr){return["color","face","size"].indexOf(attr.nodeName)>=0})){for(tree.parseError("unexpected-html-element-in-foreign-content",{name:name});tree.currentStackItem().isForeign()&&!tree.currentStackItem().isHtmlIntegrationPoint()&&!tree.currentStackItem().isMathMLTextIntegrationPoint();)tree.openElements.pop();return tree.insertionMode.processStartTag(name,attributes,selfClosing),void 0}"http://www.w3.org/1998/Math/MathML"==tree.currentStackItem().namespaceURI&&(attributes=tree.adjustMathMLAttributes(attributes)),"http://www.w3.org/2000/svg"==tree.currentStackItem().namespaceURI&&(name=tree.adjustSVGTagNameCase(name),attributes=tree.adjustSVGAttributes(attributes)),attributes=tree.adjustForeignAttributes(attributes),tree.insertForeignElement(name,attributes,tree.currentStackItem().namespaceURI,selfClosing)},modes.inForeignContent.processEndTag=function(name){var node=tree.currentStackItem(),index=tree.openElements.length-1;for(node.localName.toLowerCase()!=name&&tree.parseError("unexpected-end-tag",{name:name});;){if(0===index)break;if(node.localName.toLowerCase()==name){for(;tree.openElements.pop()!=node;);break}if(index-=1,node=tree.openElements.item(index),!node.isForeign()){tree.insertionMode.processEndTag(name);break}}},modes.inForeignContent.processCharacters=function(buffer){var characters=buffer.takeRemaining();characters=characters.replace(/\\u0000/g,function(){return tree.parseError("invalid-codepoint"),"\uFFFD"}),tree.framesetOk&&!isAllWhitespaceOrReplacementCharacters(characters)&&(tree.framesetOk=!1),tree.insertText(characters)},modes.inHeadNoscript=Object.create(modes.base),modes.inHeadNoscript.start_tag_handlers={html:"startTagHtml",basefont:"startTagBasefontBgsoundLinkMetaNoframesStyle",bgsound:"startTagBasefontBgsoundLinkMetaNoframesStyle",link:"startTagBasefontBgsoundLinkMetaNoframesStyle",meta:"startTagBasefontBgsoundLinkMetaNoframesStyle",noframes:"startTagBasefontBgsoundLinkMetaNoframesStyle",style:"startTagBasefontBgsoundLinkMetaNoframesStyle",head:"startTagHeadNoscript",noscript:"startTagHeadNoscript","-default":"startTagOther"},modes.inHeadNoscript.end_tag_handlers={noscript:"endTagNoscript",br:"endTagBr","-default":"endTagOther"},modes.inHeadNoscript.processCharacters=function(buffer){var leadingWhitespace=buffer.takeLeadingWhitespace();leadingWhitespace&&tree.insertText(leadingWhitespace),buffer.length&&(tree.parseError("unexpected-char-in-frameset"),this.anythingElse(),tree.insertionMode.processCharacters(buffer))},modes.inHeadNoscript.processComment=function(data){modes.inHead.processComment(data)},modes.inHeadNoscript.startTagBasefontBgsoundLinkMetaNoframesStyle=function(name,attributes){modes.inHead.processStartTag(name,attributes)},modes.inHeadNoscript.startTagHeadNoscript=function(name){tree.parseError("unexpected-start-tag-in-frameset",{name:name})},modes.inHeadNoscript.startTagOther=function(name,attributes){tree.parseError("unexpected-start-tag-in-frameset",{name:name}),this.anythingElse(),tree.insertionMode.processStartTag(name,attributes)},modes.inHeadNoscript.endTagBr=function(name,attributes){tree.parseError("unexpected-end-tag-in-frameset",{name:name}),this.anythingElse(),tree.insertionMode.processEndTag(name,attributes)},modes.inHeadNoscript.endTagNoscript=function(){tree.popElement(),tree.setInsertionMode("inHead")},modes.inHeadNoscript.endTagOther=function(name){tree.parseError("unexpected-end-tag-in-frameset",{name:name})},modes.inHeadNoscript.anythingElse=function(){tree.popElement(),tree.setInsertionMode("inHead")},modes.inFrameset=Object.create(modes.base),modes.inFrameset.start_tag_handlers={html:"startTagHtml",frameset:"startTagFrameset",frame:"startTagFrame",noframes:"startTagNoframes","-default":"startTagOther"},modes.inFrameset.end_tag_handlers={frameset:"endTagFrameset",noframes:"endTagNoframes","-default":"endTagOther"},modes.inFrameset.processCharacters=function(){tree.parseError("unexpected-char-in-frameset")},modes.inFrameset.startTagFrameset=function(name,attributes){tree.insertElement(name,attributes)},modes.inFrameset.startTagFrame=function(name,attributes){tree.insertSelfClosingElement(name,attributes)},modes.inFrameset.startTagNoframes=function(name,attributes){modes.inBody.processStartTag(name,attributes)},modes.inFrameset.startTagOther=function(name){tree.parseError("unexpected-start-tag-in-frameset",{name:name})},modes.inFrameset.endTagFrameset=function(){"html"==tree.currentStackItem().localName?tree.parseError("unexpected-frameset-in-frameset-innerhtml"):tree.popElement(),tree.context||"frameset"==tree.currentStackItem().localName||tree.setInsertionMode("afterFrameset")},modes.inFrameset.endTagNoframes=function(name){modes.inBody.processEndTag(name)},modes.inFrameset.endTagOther=function(name){tree.parseError("unexpected-end-tag-in-frameset",{name:name})},modes.inTable=Object.create(modes.base),modes.inTable.start_tag_handlers={html:"startTagHtml",caption:"startTagCaption",colgroup:"startTagColgroup",col:"startTagCol",table:"startTagTable",tbody:"startTagRowGroup",tfoot:"startTagRowGroup",thead:"startTagRowGroup",td:"startTagImplyTbody",th:"startTagImplyTbody",tr:"startTagImplyTbody",style:"startTagStyleScript",script:"startTagStyleScript",input:"startTagInput",form:"startTagForm","-default":"startTagOther"},modes.inTable.end_tag_handlers={table:"endTagTable",body:"endTagIgnore",caption:"endTagIgnore",col:"endTagIgnore",colgroup:"endTagIgnore",html:"endTagIgnore",tbody:"endTagIgnore",td:"endTagIgnore",tfoot:"endTagIgnore",th:"endTagIgnore",thead:"endTagIgnore",tr:"endTagIgnore","-default":"endTagOther"},modes.inTable.processCharacters=function(data){if(tree.currentStackItem().isFosterParenting()){var originalInsertionMode=tree.insertionModeName;
tree.setInsertionMode("inTableText"),tree.originalInsertionMode=originalInsertionMode,tree.insertionMode.processCharacters(data)}else tree.redirectAttachToFosterParent=!0,modes.inBody.processCharacters(data),tree.redirectAttachToFosterParent=!1},modes.inTable.startTagCaption=function(name,attributes){tree.openElements.popUntilTableScopeMarker(),tree.activeFormattingElements.push(Marker),tree.insertElement(name,attributes),tree.setInsertionMode("inCaption")},modes.inTable.startTagColgroup=function(name,attributes){tree.openElements.popUntilTableScopeMarker(),tree.insertElement(name,attributes),tree.setInsertionMode("inColumnGroup")},modes.inTable.startTagCol=function(name,attributes){this.startTagColgroup("colgroup",[]),tree.insertionMode.processStartTag(name,attributes)},modes.inTable.startTagRowGroup=function(name,attributes){tree.openElements.popUntilTableScopeMarker(),tree.insertElement(name,attributes),tree.setInsertionMode("inTableBody")},modes.inTable.startTagImplyTbody=function(name,attributes){this.startTagRowGroup("tbody",[]),tree.insertionMode.processStartTag(name,attributes)},modes.inTable.startTagTable=function(name,attributes){tree.parseError("unexpected-start-tag-implies-end-tag",{startName:"table",endName:"table"}),tree.insertionMode.processEndTag("table"),tree.context||tree.insertionMode.processStartTag(name,attributes)},modes.inTable.startTagStyleScript=function(name,attributes){modes.inHead.processStartTag(name,attributes)},modes.inTable.startTagInput=function(name,attributes){for(var key in attributes)if("type"==attributes[key].nodeName.toLowerCase()){if("hidden"==attributes[key].nodeValue.toLowerCase())return tree.parseError("unexpected-hidden-input-in-table"),tree.insertElement(name,attributes),tree.openElements.pop(),void 0;break}this.startTagOther(name,attributes)},modes.inTable.startTagForm=function(name,attributes){tree.parseError("unexpected-form-in-table"),tree.form||(tree.insertElement(name,attributes),tree.form=tree.currentStackItem(),tree.openElements.pop())},modes.inTable.startTagOther=function(name,attributes,selfClosing){tree.parseError("unexpected-start-tag-implies-table-voodoo",{name:name}),tree.redirectAttachToFosterParent=!0,modes.inBody.processStartTag(name,attributes,selfClosing),tree.redirectAttachToFosterParent=!1},modes.inTable.endTagTable=function(name){tree.openElements.inTableScope(name)?(tree.generateImpliedEndTags(),tree.currentStackItem().localName!=name&&tree.parseError("end-tag-too-early-named",{gotName:"table",expectedName:tree.currentStackItem().localName}),tree.openElements.popUntilPopped("table"),tree.resetInsertionMode()):(assert.ok(tree.context),tree.parseError("unexpected-end-tag",{name:name}))},modes.inTable.endTagIgnore=function(name){tree.parseError("unexpected-end-tag",{name:name})},modes.inTable.endTagOther=function(name){tree.parseError("unexpected-end-tag-implies-table-voodoo",{name:name}),tree.redirectAttachToFosterParent=!0,modes.inBody.processEndTag(name),tree.redirectAttachToFosterParent=!1},modes.inTableText=Object.create(modes.base),modes.inTableText.flushCharacters=function(){var characters=tree.pendingTableCharacters.join("");isAllWhitespace(characters)?tree.insertText(characters):(tree.redirectAttachToFosterParent=!0,tree.reconstructActiveFormattingElements(),tree.insertText(characters),tree.framesetOk=!1,tree.redirectAttachToFosterParent=!1),tree.pendingTableCharacters=[]},modes.inTableText.processComment=function(data){this.flushCharacters(),tree.setInsertionMode(tree.originalInsertionMode),tree.insertionMode.processComment(data)},modes.inTableText.processEOF=function(){this.flushCharacters(),tree.setInsertionMode(tree.originalInsertionMode),tree.insertionMode.processEOF()},modes.inTableText.processCharacters=function(buffer){var characters=buffer.takeRemaining();characters=characters.replace(/\\u0000/g,function(){return tree.parseError("invalid-codepoint"),""}),characters&&tree.pendingTableCharacters.push(characters)},modes.inTableText.processStartTag=function(name,attributes,selfClosing){this.flushCharacters(),tree.setInsertionMode(tree.originalInsertionMode),tree.insertionMode.processStartTag(name,attributes,selfClosing)},modes.inTableText.processEndTag=function(name,attributes){this.flushCharacters(),tree.setInsertionMode(tree.originalInsertionMode),tree.insertionMode.processEndTag(name,attributes)},modes.inTableBody=Object.create(modes.base),modes.inTableBody.start_tag_handlers={html:"startTagHtml",tr:"startTagTr",td:"startTagTableCell",th:"startTagTableCell",caption:"startTagTableOther",col:"startTagTableOther",colgroup:"startTagTableOther",tbody:"startTagTableOther",tfoot:"startTagTableOther",thead:"startTagTableOther","-default":"startTagOther"},modes.inTableBody.end_tag_handlers={table:"endTagTable",tbody:"endTagTableRowGroup",tfoot:"endTagTableRowGroup",thead:"endTagTableRowGroup",body:"endTagIgnore",caption:"endTagIgnore",col:"endTagIgnore",colgroup:"endTagIgnore",html:"endTagIgnore",td:"endTagIgnore",th:"endTagIgnore",tr:"endTagIgnore","-default":"endTagOther"},modes.inTableBody.processCharacters=function(data){modes.inTable.processCharacters(data)},modes.inTableBody.startTagTr=function(name,attributes){tree.openElements.popUntilTableBodyScopeMarker(),tree.insertElement(name,attributes),tree.setInsertionMode("inRow")},modes.inTableBody.startTagTableCell=function(name,attributes){tree.parseError("unexpected-cell-in-table-body",{name:name}),this.startTagTr("tr",[]),tree.insertionMode.processStartTag(name,attributes)},modes.inTableBody.startTagTableOther=function(name,attributes){tree.openElements.inTableScope("tbody")||tree.openElements.inTableScope("thead")||tree.openElements.inTableScope("tfoot")?(tree.openElements.popUntilTableBodyScopeMarker(),this.endTagTableRowGroup(tree.currentStackItem().localName),tree.insertionMode.processStartTag(name,attributes)):tree.parseError("unexpected-start-tag",{name:name})},modes.inTableBody.startTagOther=function(name,attributes){modes.inTable.processStartTag(name,attributes)},modes.inTableBody.endTagTableRowGroup=function(name){tree.openElements.inTableScope(name)?(tree.openElements.popUntilTableBodyScopeMarker(),tree.popElement(),tree.setInsertionMode("inTable")):tree.parseError("unexpected-end-tag-in-table-body",{name:name})},modes.inTableBody.endTagTable=function(name){tree.openElements.inTableScope("tbody")||tree.openElements.inTableScope("thead")||tree.openElements.inTableScope("tfoot")?(tree.openElements.popUntilTableBodyScopeMarker(),this.endTagTableRowGroup(tree.currentStackItem().localName),tree.insertionMode.processEndTag(name)):tree.parseError("unexpected-end-tag",{name:name})},modes.inTableBody.endTagIgnore=function(name){tree.parseError("unexpected-end-tag-in-table-body",{name:name})},modes.inTableBody.endTagOther=function(name){modes.inTable.processEndTag(name)},modes.inSelect=Object.create(modes.base),modes.inSelect.start_tag_handlers={html:"startTagHtml",option:"startTagOption",optgroup:"startTagOptgroup",select:"startTagSelect",input:"startTagInput",keygen:"startTagInput",textarea:"startTagInput",script:"startTagScript","-default":"startTagOther"},modes.inSelect.end_tag_handlers={option:"endTagOption",optgroup:"endTagOptgroup",select:"endTagSelect",caption:"endTagTableElements",table:"endTagTableElements",tbody:"endTagTableElements",tfoot:"endTagTableElements",thead:"endTagTableElements",tr:"endTagTableElements",td:"endTagTableElements",th:"endTagTableElements","-default":"endTagOther"},modes.inSelect.processCharacters=function(buffer){var data=buffer.takeRemaining();data=data.replace(/\\u0000/g,function(){return tree.parseError("invalid-codepoint"),""}),data&&tree.insertText(data)},modes.inSelect.startTagOption=function(name,attributes){"option"==tree.currentStackItem().localName&&tree.popElement(),tree.insertElement(name,attributes)},modes.inSelect.startTagOptgroup=function(name,attributes){"option"==tree.currentStackItem().localName&&tree.popElement(),"optgroup"==tree.currentStackItem().localName&&tree.popElement(),tree.insertElement(name,attributes)},modes.inSelect.endTagOption=function(name){return"option"!==tree.currentStackItem().localName?(tree.parseError("unexpected-end-tag-in-select",{name:name}),void 0):(tree.popElement(),void 0)},modes.inSelect.endTagOptgroup=function(){"option"==tree.currentStackItem().localName&&"optgroup"==tree.openElements.item(tree.openElements.length-2).localName&&tree.popElement(),"optgroup"==tree.currentStackItem().localName?tree.popElement():tree.parseError("unexpected-end-tag-in-select",{name:"optgroup"})},modes.inSelect.startTagSelect=function(){tree.parseError("unexpected-select-in-select"),this.endTagSelect("select")},modes.inSelect.endTagSelect=function(name){tree.openElements.inTableScope("select")?(tree.openElements.popUntilPopped("select"),tree.resetInsertionMode()):tree.parseError("unexpected-end-tag",{name:name})},modes.inSelect.startTagInput=function(name,attributes){tree.parseError("unexpected-input-in-select"),tree.openElements.inSelectScope("select")&&(this.endTagSelect("select"),tree.insertionMode.processStartTag(name,attributes))},modes.inSelect.startTagScript=function(name,attributes){modes.inHead.processStartTag(name,attributes)},modes.inSelect.endTagTableElements=function(name){tree.parseError("unexpected-end-tag-in-select",{name:name}),tree.openElements.inTableScope(name)&&(this.endTagSelect("select"),tree.insertionMode.processEndTag(name))},modes.inSelect.startTagOther=function(name){tree.parseError("unexpected-start-tag-in-select",{name:name})},modes.inSelect.endTagOther=function(name){tree.parseError("unexpected-end-tag-in-select",{name:name})},modes.inSelectInTable=Object.create(modes.base),modes.inSelectInTable.start_tag_handlers={caption:"startTagTable",table:"startTagTable",tbody:"startTagTable",tfoot:"startTagTable",thead:"startTagTable",tr:"startTagTable",td:"startTagTable",th:"startTagTable","-default":"startTagOther"},modes.inSelectInTable.end_tag_handlers={caption:"endTagTable",table:"endTagTable",tbody:"endTagTable",tfoot:"endTagTable",thead:"endTagTable",tr:"endTagTable",td:"endTagTable",th:"endTagTable","-default":"endTagOther"},modes.inSelectInTable.processCharacters=function(data){modes.inSelect.processCharacters(data)},modes.inSelectInTable.startTagTable=function(name,attributes){tree.parseError("unexpected-table-element-start-tag-in-select-in-table",{name:name}),this.endTagOther("select"),tree.insertionMode.processStartTag(name,attributes)},modes.inSelectInTable.startTagOther=function(name,attributes,selfClosing){modes.inSelect.processStartTag(name,attributes,selfClosing)},modes.inSelectInTable.endTagTable=function(name){tree.parseError("unexpected-table-element-end-tag-in-select-in-table",{name:name}),tree.openElements.inTableScope(name)&&(this.endTagOther("select"),tree.insertionMode.processEndTag(name))},modes.inSelectInTable.endTagOther=function(name){modes.inSelect.processEndTag(name)},modes.inRow=Object.create(modes.base),modes.inRow.start_tag_handlers={html:"startTagHtml",td:"startTagTableCell",th:"startTagTableCell",caption:"startTagTableOther",col:"startTagTableOther",colgroup:"startTagTableOther",tbody:"startTagTableOther",tfoot:"startTagTableOther",thead:"startTagTableOther",tr:"startTagTableOther","-default":"startTagOther"},modes.inRow.end_tag_handlers={tr:"endTagTr",table:"endTagTable",tbody:"endTagTableRowGroup",tfoot:"endTagTableRowGroup",thead:"endTagTableRowGroup",body:"endTagIgnore",caption:"endTagIgnore",col:"endTagIgnore",colgroup:"endTagIgnore",html:"endTagIgnore",td:"endTagIgnore",th:"endTagIgnore","-default":"endTagOther"},modes.inRow.processCharacters=function(data){modes.inTable.processCharacters(data)},modes.inRow.startTagTableCell=function(name,attributes){tree.openElements.popUntilTableRowScopeMarker(),tree.insertElement(name,attributes),tree.setInsertionMode("inCell"),tree.activeFormattingElements.push(Marker)},modes.inRow.startTagTableOther=function(name,attributes){var ignoreEndTag=this.ignoreEndTagTr();this.endTagTr("tr"),ignoreEndTag||tree.insertionMode.processStartTag(name,attributes)},modes.inRow.startTagOther=function(name,attributes,selfClosing){modes.inTable.processStartTag(name,attributes,selfClosing)},modes.inRow.endTagTr=function(name){this.ignoreEndTagTr()?(assert.ok(tree.context),tree.parseError("unexpected-end-tag",{name:name})):(tree.openElements.popUntilTableRowScopeMarker(),tree.popElement(),tree.setInsertionMode("inTableBody"))},modes.inRow.endTagTable=function(name){var ignoreEndTag=this.ignoreEndTagTr();this.endTagTr("tr"),ignoreEndTag||tree.insertionMode.processEndTag(name)},modes.inRow.endTagTableRowGroup=function(name){tree.openElements.inTableScope(name)?(this.endTagTr("tr"),tree.insertionMode.processEndTag(name)):tree.parseError("unexpected-end-tag",{name:name})},modes.inRow.endTagIgnore=function(name){tree.parseError("unexpected-end-tag-in-table-row",{name:name})},modes.inRow.endTagOther=function(name){modes.inTable.processEndTag(name)},modes.inRow.ignoreEndTagTr=function(){return!tree.openElements.inTableScope("tr")},modes.afterAfterFrameset=Object.create(modes.base),modes.afterAfterFrameset.start_tag_handlers={html:"startTagHtml",noframes:"startTagNoFrames","-default":"startTagOther"},modes.afterAfterFrameset.processEOF=function(){},modes.afterAfterFrameset.processComment=function(data){tree.insertComment(data,tree.document)},modes.afterAfterFrameset.processCharacters=function(buffer){for(var characters=buffer.takeRemaining(),whitespace="",i=0;characters.length>i;i++){var ch=characters[i];isWhitespace(ch)&&(whitespace+=ch)}whitespace&&(tree.reconstructActiveFormattingElements(),tree.insertText(whitespace)),whitespace.length<characters.length&&tree.parseError("expected-eof-but-got-char")},modes.afterAfterFrameset.startTagNoFrames=function(name,attributes){modes.inHead.processStartTag(name,attributes)},modes.afterAfterFrameset.startTagOther=function(name){tree.parseError("expected-eof-but-got-start-tag",{name:name})},modes.afterAfterFrameset.processEndTag=function(name){tree.parseError("expected-eof-but-got-end-tag",{name:name})},modes.text=Object.create(modes.base),modes.text.start_tag_handlers={"-default":"startTagOther"},modes.text.end_tag_handlers={script:"endTagScript","-default":"endTagOther"},modes.text.processCharacters=function(buffer){tree.shouldSkipLeadingNewline&&(tree.shouldSkipLeadingNewline=!1,buffer.skipAtMostOneLeadingNewline());var data=buffer.takeRemaining();data&&tree.insertText(data)},modes.text.processEOF=function(){tree.parseError("expected-named-closing-tag-but-got-eof",{name:tree.currentStackItem().localName}),tree.openElements.pop(),tree.setInsertionMode(tree.originalInsertionMode),tree.insertionMode.processEOF()},modes.text.startTagOther=function(name){throw"Tried to process start tag "+name+" in RCDATA/RAWTEXT mode"},modes.text.endTagScript=function(){var node=tree.openElements.pop();assert.ok("script"==node.localName),tree.setInsertionMode(tree.originalInsertionMode)},modes.text.endTagOther=function(){tree.openElements.pop(),tree.setInsertionMode(tree.originalInsertionMode)}}function formatMessage(format,args){return format.replace(RegExp("{[0-9a-z-]+}","gi"),function(match){return args[match.slice(1,-1)]||match})}var assert=_dereq_("assert"),messages=_dereq_("./messages.json"),constants=_dereq_("./constants");_dereq_("events").EventEmitter;var Tokenizer=_dereq_("./Tokenizer").Tokenizer,ElementStack=_dereq_("./ElementStack").ElementStack,StackItem=_dereq_("./StackItem").StackItem,Marker={};CharacterBuffer.prototype.skipAtMostOneLeadingNewline=function(){"\\n"===this.characters[this.current]&&this.current++},CharacterBuffer.prototype.skipLeadingWhitespace=function(){for(;isWhitespace(this.characters[this.current]);)if(++this.current==this.end)return},CharacterBuffer.prototype.skipLeadingNonWhitespace=function(){for(;!isWhitespace(this.characters[this.current]);)if(++this.current==this.end)return},CharacterBuffer.prototype.takeRemaining=function(){return this.characters.substring(this.current)},CharacterBuffer.prototype.takeLeadingWhitespace=function(){var start=this.current;return this.skipLeadingWhitespace(),start===this.current?"":this.characters.substring(start,this.current-start)},Object.defineProperty(CharacterBuffer.prototype,"length",{get:function(){return this.end-this.current}}),TreeBuilder.prototype.setInsertionMode=function(name){this.insertionMode=this.insertionModes[name],this.insertionModeName=name},TreeBuilder.prototype.adoptionAgencyEndTag=function(name){function isActiveFormattingElement(el){return el===formattingElement}for(var formattingElement,outerIterationLimit=8,innerIterationLimit=3,outerLoopCounter=0;outerIterationLimit>outerLoopCounter++;){if(formattingElement=this.elementInActiveFormattingElements(name),!formattingElement||this.openElements.contains(formattingElement)&&!this.openElements.inScope(formattingElement.localName))return this.parseError("adoption-agency-1.1",{name:name}),!1;if(!this.openElements.contains(formattingElement))return this.parseError("adoption-agency-1.2",{name:name}),this.removeElementFromActiveFormattingElements(formattingElement),!0;this.openElements.inScope(formattingElement.localName)||this.parseError("adoption-agency-4.4",{name:name}),formattingElement!=this.currentStackItem()&&this.parseError("adoption-agency-1.3",{name:name});var furthestBlock=this.openElements.furthestBlockForFormattingElement(formattingElement.node);if(!furthestBlock)return this.openElements.remove_openElements_until(isActiveFormattingElement),this.removeElementFromActiveFormattingElements(formattingElement),!0;for(var afeIndex=this.openElements.elements.indexOf(formattingElement),commonAncestor=this.openElements.item(afeIndex-1),bookmark=this.activeFormattingElements.indexOf(formattingElement),node=furthestBlock,lastNode=furthestBlock,index=this.openElements.elements.indexOf(node),innerLoopCounter=0;innerIterationLimit>innerLoopCounter++;)if(index-=1,node=this.openElements.item(index),0>this.activeFormattingElements.indexOf(node))this.openElements.elements.splice(index,1);else{if(node==formattingElement)break;lastNode==furthestBlock&&(bookmark=this.activeFormattingElements.indexOf(node)+1);var clone=this.createElement(node.namespaceURI,node.localName,node.attributes),newNode=new StackItem(node.namespaceURI,node.localName,node.attributes,clone);this.activeFormattingElements[this.activeFormattingElements.indexOf(node)]=newNode,this.openElements.elements[this.openElements.elements.indexOf(node)]=newNode,node=newNode,this.detachFromParent(lastNode.node),this.attachNode(lastNode.node,node.node),lastNode=node}this.detachFromParent(lastNode.node),commonAncestor.isFosterParenting()?this.insertIntoFosterParent(lastNode.node):this.attachNode(lastNode.node,commonAncestor.node);var clone=this.createElement("http://www.w3.org/1999/xhtml",formattingElement.localName,formattingElement.attributes),formattingClone=new StackItem(formattingElement.namespaceURI,formattingElement.localName,formattingElement.attributes,clone);this.reparentChildren(furthestBlock.node,clone),this.attachNode(clone,furthestBlock.node),this.removeElementFromActiveFormattingElements(formattingElement),this.activeFormattingElements.splice(Math.min(bookmark,this.activeFormattingElements.length),0,formattingClone),this.openElements.remove(formattingElement),this.openElements.elements.splice(this.openElements.elements.indexOf(furthestBlock)+1,0,formattingClone)}return!0},TreeBuilder.prototype.start=function(){throw"Not mplemented"},TreeBuilder.prototype.startTokenization=function(tokenizer){if(this.tokenizer=tokenizer,this.compatMode="no quirks",this.originalInsertionMode="initial",this.framesetOk=!0,this.openElements=new ElementStack,this.activeFormattingElements=[],this.start(),this.context){switch(this.context){case"title":case"textarea":this.tokenizer.setState(Tokenizer.RCDATA);break;case"style":case"xmp":case"iframe":case"noembed":case"noframes":this.tokenizer.setState(Tokenizer.RAWTEXT);break;case"script":this.tokenizer.setState(Tokenizer.SCRIPT_DATA);break;case"noscript":this.scriptingEnabled&&this.tokenizer.setState(Tokenizer.RAWTEXT);break;case"plaintext":this.tokenizer.setState(Tokenizer.PLAINTEXT)}this.insertHtmlElement(),this.resetInsertionMode()}else this.setInsertionMode("initial")},TreeBuilder.prototype.processToken=function(token){this.selfClosingFlagAcknowledged=!1;var insertionMode,currentNode=this.openElements.top||null;switch(insertionMode=!currentNode||!currentNode.isForeign()||currentNode.isMathMLTextIntegrationPoint()&&("StartTag"==token.type&&!(token.name in{mglyph:0,malignmark:0})||"Characters"===token.type)||"http://www.w3.org/1998/Math/MathML"==currentNode.namespaceURI&&"annotation-xml"==currentNode.localName&&"StartTag"==token.type&&"svg"==token.name||currentNode.isHtmlIntegrationPoint()&&token.type in{StartTag:0,Characters:0}||"EOF"==token.type?this.insertionMode:this.insertionModes.inForeignContent,token.type){case"Characters":var buffer=new CharacterBuffer(token.data);insertionMode.processCharacters(buffer);break;case"Comment":insertionMode.processComment(token.data);break;case"StartTag":insertionMode.processStartTag(token.name,token.data,token.selfClosing);break;case"EndTag":insertionMode.processEndTag(token.name);break;case"Doctype":insertionMode.processDoctype(token.name,token.publicId,token.systemId,token.forceQuirks);break;case"EOF":insertionMode.processEOF()}},TreeBuilder.prototype.isCdataSectionAllowed=function(){return this.openElements.length>0&&this.currentStackItem().isForeign()},TreeBuilder.prototype.isSelfClosingFlagAcknowledged=function(){return this.selfClosingFlagAcknowledged},TreeBuilder.prototype.createElement=function(){throw Error("Not implemented")},TreeBuilder.prototype.attachNode=function(){throw Error("Not implemented")},TreeBuilder.prototype.attachNodeToFosterParent=function(){throw Error("Not implemented")},TreeBuilder.prototype.detachFromParent=function(){throw Error("Not implemented")},TreeBuilder.prototype.addAttributesToElement=function(){throw Error("Not implemented")},TreeBuilder.prototype.insertHtmlElement=function(attributes){var root=this.createElement("http://www.w3.org/1999/xhtml","html",attributes);return this.attachNode(root,this.document),this.openElements.pushHtmlElement(new StackItem("http://www.w3.org/1999/xhtml","html",attributes,root)),root},TreeBuilder.prototype.insertHeadElement=function(attributes){var element=this.createElement("http://www.w3.org/1999/xhtml","head",attributes);return this.head=new StackItem("http://www.w3.org/1999/xhtml","head",attributes,element),this.attachNode(element,this.openElements.top.node),this.openElements.pushHeadElement(this.head),element},TreeBuilder.prototype.insertBodyElement=function(attributes){var element=this.createElement("http://www.w3.org/1999/xhtml","body",attributes);return this.attachNode(element,this.openElements.top.node),this.openElements.pushBodyElement(new StackItem("http://www.w3.org/1999/xhtml","body",attributes,element)),element},TreeBuilder.prototype.insertIntoFosterParent=function(node){var tableIndex=this.openElements.findIndex("table"),tableElement=this.openElements.item(tableIndex).node;return 0===tableIndex?this.attachNode(node,tableElement):(this.attachNodeToFosterParent(node,tableElement,this.openElements.item(tableIndex-1).node),void 0)},TreeBuilder.prototype.insertElement=function(name,attributes,namespaceURI,selfClosing){namespaceURI||(namespaceURI="http://www.w3.org/1999/xhtml");var element=this.createElement(namespaceURI,name,attributes);this.shouldFosterParent()?this.insertIntoFosterParent(element):this.attachNode(element,this.openElements.top.node),selfClosing||this.openElements.push(new StackItem(namespaceURI,name,attributes,element))},TreeBuilder.prototype.insertFormattingElement=function(name,attributes){this.insertElement(name,attributes,"http://www.w3.org/1999/xhtml"),this.appendElementToActiveFormattingElements(this.currentStackItem())},TreeBuilder.prototype.insertSelfClosingElement=function(name,attributes){this.selfClosingFlagAcknowledged=!0,this.insertElement(name,attributes,"http://www.w3.org/1999/xhtml",!0)},TreeBuilder.prototype.insertForeignElement=function(name,attributes,namespaceURI,selfClosing){selfClosing&&(this.selfClosingFlagAcknowledged=!0),this.insertElement(name,attributes,namespaceURI,selfClosing)},TreeBuilder.prototype.insertComment=function(){throw Error("Not implemented")},TreeBuilder.prototype.insertDoctype=function(){throw Error("Not implemented")},TreeBuilder.prototype.insertText=function(){throw Error("Not implemented")},TreeBuilder.prototype.currentStackItem=function(){return this.openElements.top},TreeBuilder.prototype.popElement=function(){return this.openElements.pop()},TreeBuilder.prototype.shouldFosterParent=function(){return this.redirectAttachToFosterParent&&this.currentStackItem().isFosterParenting()},TreeBuilder.prototype.generateImpliedEndTags=function(exclude){var name=this.openElements.top.localName;-1!=["dd","dt","li","option","optgroup","p","rp","rt"].indexOf(name)&&name!=exclude&&(this.popElement(),this.generateImpliedEndTags(exclude))},TreeBuilder.prototype.reconstructActiveFormattingElements=function(){if(0!==this.activeFormattingElements.length){var i=this.activeFormattingElements.length-1,entry=this.activeFormattingElements[i];if(entry!=Marker&&!this.openElements.contains(entry)){for(;entry!=Marker&&!this.openElements.contains(entry)&&(i-=1,entry=this.activeFormattingElements[i]););for(;;){i+=1,entry=this.activeFormattingElements[i],this.insertElement(entry.localName,entry.attributes);var element=this.currentStackItem();if(this.activeFormattingElements[i]=element,element==this.activeFormattingElements[this.activeFormattingElements.length-1])break}}}},TreeBuilder.prototype.ensureNoahsArkCondition=function(item){var kNoahsArkCapacity=3;if(!(kNoahsArkCapacity>this.activeFormattingElements.length)){for(var candidates=[],newItemAttributeCount=item.attributes.length,i=this.activeFormattingElements.length-1;i>=0;i--){var candidate=this.activeFormattingElements[i];if(candidate===Marker)break;item.localName===candidate.localName&&item.namespaceURI===candidate.namespaceURI&&candidate.attributes.length==newItemAttributeCount&&candidates.push(candidate)}if(!(kNoahsArkCapacity>candidates.length)){for(var remainingCandidates=[],attributes=item.attributes,i=0;attributes.length>i;i++){for(var attribute=attributes[i],j=0;candidates.length>j;j++){var candidate=candidates[j],candidateAttribute=getAttribute(candidate,attribute.nodeName);candidateAttribute&&candidateAttribute.nodeValue===attribute.nodeValue&&remainingCandidates.push(candidate)}if(kNoahsArkCapacity>remainingCandidates.length)return;candidates=remainingCandidates,remainingCandidates=[]}for(var i=kNoahsArkCapacity-1;candidates.length>i;i++)this.removeElementFromActiveFormattingElements(candidates[i])}}},TreeBuilder.prototype.appendElementToActiveFormattingElements=function(item){this.ensureNoahsArkCondition(item),this.activeFormattingElements.push(item)},TreeBuilder.prototype.removeElementFromActiveFormattingElements=function(item){var index=this.activeFormattingElements.indexOf(item);index>=0&&this.activeFormattingElements.splice(index,1)},TreeBuilder.prototype.elementInActiveFormattingElements=function(name){for(var els=this.activeFormattingElements,i=els.length-1;i>=0&&els[i]!=Marker;i--)if(els[i].localName==name)return els[i];return!1},TreeBuilder.prototype.clearActiveFormattingElements=function(){for(;0!==this.activeFormattingElements.length&&this.activeFormattingElements.pop()!=Marker;);},TreeBuilder.prototype.reparentChildren=function(){throw Error("Not implemented")},TreeBuilder.prototype.setFragmentContext=function(context){this.context=context},TreeBuilder.prototype.parseError=function(code,args){if(this.errorHandler){var message=formatMessage(messages[code],args);this.errorHandler.error(message,this.tokenizer._inputStream.location(),code)}},TreeBuilder.prototype.resetInsertionMode=function(){for(var last=!1,node=null,i=this.openElements.length-1;i>=0;i--){if(node=this.openElements.item(i),0===i&&(assert.ok(this.context),last=!0,node=new StackItem("http://www.w3.org/1999/xhtml",this.context,[],null)),"http://www.w3.org/1999/xhtml"===node.namespaceURI){if("select"===node.localName)return this.setInsertionMode("inSelect");if("td"===node.localName||"th"===node.localName)return this.setInsertionMode("inCell");if("tr"===node.localName)return this.setInsertionMode("inRow");if("tbody"===node.localName||"thead"===node.localName||"tfoot"===node.localName)return this.setInsertionMode("inTableBody");if("caption"===node.localName)return this.setInsertionMode("inCaption");if("colgroup"===node.localName)return this.setInsertionMode("inColumnGroup");if("table"===node.localName)return this.setInsertionMode("inTable");if("head"===node.localName&&!last)return this.setInsertionMode("inHead");if("body"===node.localName)return this.setInsertionMode("inBody");if("frameset"===node.localName)return this.setInsertionMode("inFrameset");if("html"===node.localName)return this.openElements.headElement?this.setInsertionMode("afterHead"):this.setInsertionMode("beforeHead")}if(last)return this.setInsertionMode("inBody")}},TreeBuilder.prototype.processGenericRCDATAStartTag=function(name,attributes){this.insertElement(name,attributes),this.tokenizer.setState(Tokenizer.RCDATA),this.originalInsertionMode=this.insertionModeName,this.setInsertionMode("text")},TreeBuilder.prototype.processGenericRawTextStartTag=function(name,attributes){this.insertElement(name,attributes),this.tokenizer.setState(Tokenizer.RAWTEXT),this.originalInsertionMode=this.insertionModeName,this.setInsertionMode("text")},TreeBuilder.prototype.adjustMathMLAttributes=function(attributes){return attributes.forEach(function(a){a.namespaceURI="http://www.w3.org/1998/Math/MathML",constants.MATHMLAttributeMap[a.nodeName]&&(a.nodeName=constants.MATHMLAttributeMap[a.nodeName])}),attributes},TreeBuilder.prototype.adjustSVGTagNameCase=function(name){return constants.SVGTagMap[name]||name},TreeBuilder.prototype.adjustSVGAttributes=function(attributes){return attributes.forEach(function(a){a.namespaceURI="http://www.w3.org/2000/svg",constants.SVGAttributeMap[a.nodeName]&&(a.nodeName=constants.SVGAttributeMap[a.nodeName])}),attributes},TreeBuilder.prototype.adjustForeignAttributes=function(attributes){for(var i=0;attributes.length>i;i++){var attribute=attributes[i],adjusted=constants.ForeignAttributeMap[attribute.nodeName];adjusted&&(attribute.nodeName=adjusted.localName,attribute.prefix=adjusted.prefix,attribute.namespaceURI=adjusted.namespaceURI)}return attributes},exports.TreeBuilder=TreeBuilder},{"./ElementStack":1,"./StackItem":4,"./Tokenizer":5,"./constants":7,"./messages.json":8,assert:13,events:16}],7:[function(_dereq_,module,exports){exports.SVGTagMap={altglyph:"altGlyph",altglyphdef:"altGlyphDef",altglyphitem:"altGlyphItem",animatecolor:"animateColor",animatemotion:"animateMotion",animatetransform:"animateTransform",clippath:"clipPath",feblend:"feBlend",fecolormatrix:"feColorMatrix",fecomponenttransfer:"feComponentTransfer",fecomposite:"feComposite",feconvolvematrix:"feConvolveMatrix",fediffuselighting:"feDiffuseLighting",fedisplacementmap:"feDisplacementMap",fedistantlight:"feDistantLight",feflood:"feFlood",fefunca:"feFuncA",fefuncb:"feFuncB",fefuncg:"feFuncG",fefuncr:"feFuncR",fegaussianblur:"feGaussianBlur",feimage:"feImage",femerge:"feMerge",femergenode:"feMergeNode",femorphology:"feMorphology",feoffset:"feOffset",fepointlight:"fePointLight",fespecularlighting:"feSpecularLighting",fespotlight:"feSpotLight",fetile:"feTile",feturbulence:"feTurbulence",foreignobject:"foreignObject",glyphref:"glyphRef",lineargradient:"linearGradient",radialgradient:"radialGradient",textpath:"textPath"},exports.MATHMLAttributeMap={definitionurl:"definitionURL"},exports.SVGAttributeMap={attributename:"attributeName",attributetype:"attributeType",basefrequency:"baseFrequency",baseprofile:"baseProfile",calcmode:"calcMode",clippathunits:"clipPathUnits",contentscripttype:"contentScriptType",contentstyletype:"contentStyleType",diffuseconstant:"diffuseConstant",edgemode:"edgeMode",externalresourcesacequired:"externalResourcesRequired",filterres:"filterRes",filterunits:"filterUnits",glyphref:"glyphRef",gradienttransform:"gradientTransform",gradientunits:"gradientUnits",kernelmatrix:"kernelMatrix",kernelunitlength:"kernelUnitLength",keypoints:"keyPoints",keysplines:"keySplines",keytimes:"keyTimes",lengthadjust:"lengthAdjust",limitingconeangle:"limitingConeAngle",markerheight:"markerHeight",markerunits:"markerUnits",markerwidth:"markerWidth",maskcontentunits:"maskContentUnits",maskunits:"maskUnits",numoctaves:"numOctaves",pathlength:"pathLength",patterncontentunits:"patternContentUnits",patterntransform:"patternTransform",patternunits:"patternUnits",pointsatx:"pointsAtX",pointsaty:"pointsAtY",pointsatz:"pointsAtZ",preservealpha:"preserveAlpha",preserveaspectratio:"preserveAspectRatio",primitiveunits:"primitiveUnits",refx:"refX",refy:"refY",repeatcount:"repeatCount",repeatdur:"repeatDur",acequiredextensions:"acequiredExtensions",acequiredfeatures:"acequiredFeatures",specularconstant:"specularConstant",specularexponent:"specularExponent",spreadmethod:"spreadMethod",startoffset:"startOffset",stddeviation:"stdDeviation",stitchtiles:"stitchTiles",surfacescale:"surfaceScale",systemlanguage:"systemLanguage",tablevalues:"tableValues",targetx:"targetX",targety:"targetY",textlength:"textLength",viewbox:"viewBox",viewtarget:"viewTarget",xchannelselector:"xChannelSelector",ychannelselector:"yChannelSelector",zoomandpan:"zoomAndPan"},exports.ForeignAttributeMap={"xlink:actuate":{prefix:"xlink",localName:"actuate",namespaceURI:"http://www.w3.org/1999/xlink"},"xlink:arcrole":{prefix:"xlink",localName:"arcrole",namespaceURI:"http://www.w3.org/1999/xlink"},"xlink:href":{prefix:"xlink",localName:"href",namespaceURI:"http://www.w3.org/1999/xlink"},"xlink:role":{prefix:"xlink",localName:"role",namespaceURI:"http://www.w3.org/1999/xlink"},"xlink:show":{prefix:"xlink",localName:"show",namespaceURI:"http://www.w3.org/1999/xlink"},"xlink:title":{prefix:"xlink",localName:"title",namespaceURI:"http://www.w3.org/1999/xlink"},"xlink:type":{prefix:"xlink",localName:"title",namespaceURI:"http://www.w3.org/1999/xlink"},"xml:base":{prefix:"xml",localName:"base",namespaceURI:"http://www.w3.org/XML/1998/namespace"},"xml:lang":{prefix:"xml",localName:"lang",namespaceURI:"http://www.w3.org/XML/1998/namespace"},"xml:space":{prefix:"xml",localName:"space",namespaceURI:"http://www.w3.org/XML/1998/namespace"},xmlns:{prefix:null,localName:"xmlns",namespaceURI:"http://www.w3.org/2000/xmlns/"},"xmlns:xlink":{prefix:"xmlns",localName:"xlink",namespaceURI:"http://www.w3.org/2000/xmlns/"}}
},{}],8:[function(_dereq_,module){module.exports={"null-character":"Null character in input stream, replaced with U+FFFD.","invalid-codepoint":"Invalid codepoint in stream","incorrectly-placed-solidus":"Solidus (/) incorrectly placed in tag.","incorrect-cr-newline-entity":"Incorrect CR newline entity, replaced with LF.","illegal-windows-1252-entity":"Entity used with illegal number (windows-1252 reference).","cant-convert-numeric-entity":"Numeric entity couldn't be converted to character (codepoint U+{charAsInt}).","invalid-numeric-entity-replaced":"Numeric entity represents an illegal codepoint. Expanded to the C1 controls range.","numeric-entity-without-semicolon":"Numeric entity didn't end with ';'.","expected-numeric-entity-but-got-eof":"Numeric entity expected. Got end of file instead.","expected-numeric-entity":"Numeric entity expected but none found.","named-entity-without-semicolon":"Named entity didn't end with ';'.","expected-named-entity":"Named entity expected. Got none.","attributes-in-end-tag":"End tag contains unexpected attributes.","self-closing-flag-on-end-tag":"End tag contains unexpected self-closing flag.","bare-less-than-sign-at-eof":"End of file after <.","expected-tag-name-but-got-right-bracket":"Expected tag name. Got '>' instead.","expected-tag-name-but-got-question-mark":"Expected tag name. Got '?' instead. (HTML doesn't support processing instructions.)","expected-tag-name":"Expected tag name. Got something else instead.","expected-closing-tag-but-got-right-bracket":"Expected closing tag. Got '>' instead. Ignoring '</>'.","expected-closing-tag-but-got-eof":"Expected closing tag. Unexpected end of file.","expected-closing-tag-but-got-char":"Expected closing tag. Unexpected character '{data}' found.","eof-in-tag-name":"Unexpected end of file in the tag name.","expected-attribute-name-but-got-eof":"Unexpected end of file. Expected attribute name instead.","eof-in-attribute-name":"Unexpected end of file in attribute name.","invalid-character-in-attribute-name":"Invalid character in attribute name.","duplicate-attribute":"Dropped duplicate attribute '{name}' on tag.","expected-end-of-tag-but-got-eof":"Unexpected end of file. Expected = or end of tag.","expected-attribute-value-but-got-eof":"Unexpected end of file. Expected attribute value.","expected-attribute-value-but-got-right-bracket":"Expected attribute value. Got '>' instead.","unexpected-character-in-unquoted-attribute-value":"Unexpected character in unquoted attribute","invalid-character-after-attribute-name":"Unexpected character after attribute name.","unexpected-character-after-attribute-value":"Unexpected character after attribute value.","eof-in-attribute-value-double-quote":'Unexpected end of file in attribute value (").',"eof-in-attribute-value-single-quote":"Unexpected end of file in attribute value (').","eof-in-attribute-value-no-quotes":"Unexpected end of file in attribute value.","eof-after-attribute-value":"Unexpected end of file after attribute value.","unexpected-eof-after-solidus-in-tag":"Unexpected end of file in tag. Expected >.","unexpected-character-after-solidus-in-tag":"Unexpected character after / in tag. Expected >.","expected-dashes-or-doctype":"Expected '--' or 'DOCTYPE'. Not found.","unexpected-bang-after-double-dash-in-comment":"Unexpected ! after -- in comment.","incorrect-comment":"Incorrect comment.","eof-in-comment":"Unexpected end of file in comment.","eof-in-comment-end-dash":"Unexpected end of file in comment (-).","unexpected-dash-after-double-dash-in-comment":"Unexpected '-' after '--' found in comment.","eof-in-comment-double-dash":"Unexpected end of file in comment (--).","eof-in-comment-end-bang-state":"Unexpected end of file in comment.","unexpected-char-in-comment":"Unexpected character in comment found.","need-space-after-doctype":"No space after literal string 'DOCTYPE'.","expected-doctype-name-but-got-right-bracket":"Unexpected > character. Expected DOCTYPE name.","expected-doctype-name-but-got-eof":"Unexpected end of file. Expected DOCTYPE name.","eof-in-doctype-name":"Unexpected end of file in DOCTYPE name.","eof-in-doctype":"Unexpected end of file in DOCTYPE.","expected-space-or-right-bracket-in-doctype":"Expected space or '>'. Got '{data}'.","unexpected-end-of-doctype":"Unexpected end of DOCTYPE.","unexpected-char-in-doctype":"Unexpected character in DOCTYPE.","eof-in-bogus-doctype":"Unexpected end of file in bogus doctype.","eof-in-innerhtml":"Unexpected EOF in inner html mode.","unexpected-doctype":"Unexpected DOCTYPE. Ignored.","non-html-root":"html needs to be the first start tag.","expected-doctype-but-got-eof":"Unexpected End of file. Expected DOCTYPE.","unknown-doctype":"Erroneous DOCTYPE. Expected <!DOCTYPE html>.","quirky-doctype":"Quirky doctype. Expected <!DOCTYPE html>.","almost-standards-doctype":"Almost standards mode doctype. Expected <!DOCTYPE html>.","obsolete-doctype":"Obsolete doctype. Expected <!DOCTYPE html>.","expected-doctype-but-got-chars":"Non-space characters found without seeing a doctype first. Expected e.g. <!DOCTYPE html>.","expected-doctype-but-got-start-tag":"Start tag seen without seeing a doctype first. Expected e.g. <!DOCTYPE html>.","expected-doctype-but-got-end-tag":"End tag seen without seeing a doctype first. Expected e.g. <!DOCTYPE html>.","end-tag-after-implied-root":"Unexpected end tag ({name}) after the (implied) root element.","expected-named-closing-tag-but-got-eof":"Unexpected end of file. Expected end tag ({name}).","two-heads-are-not-better-than-one":"Unexpected start tag head in existing head. Ignored.","unexpected-end-tag":"Unexpected end tag ({name}). Ignored.","unexpected-implied-end-tag":"End tag {name} implied, but there were open elements.","unexpected-start-tag-out-of-my-head":"Unexpected start tag ({name}) that can be in head. Moved.","unexpected-start-tag":"Unexpected start tag ({name}).","missing-end-tag":"Missing end tag ({name}).","missing-end-tags":"Missing end tags ({name}).","unexpected-start-tag-implies-end-tag":"Unexpected start tag ({startName}) implies end tag ({endName}).","unexpected-start-tag-treated-as":"Unexpected start tag ({originalName}). Treated as {newName}.","deprecated-tag":"Unexpected start tag {name}. Don't use it!","unexpected-start-tag-ignored":"Unexpected start tag {name}. Ignored.","expected-one-end-tag-but-got-another":"Unexpected end tag ({gotName}). Missing end tag ({expectedName}).","end-tag-too-early":"End tag ({name}) seen too early. Expected other end tag.","end-tag-too-early-named":"Unexpected end tag ({gotName}). Expected end tag ({expectedName}.","end-tag-too-early-ignored":"End tag ({name}) seen too early. Ignored.","adoption-agency-1.1":"End tag ({name}) violates step 1, paragraph 1 of the adoption agency algorithm.","adoption-agency-1.2":"End tag ({name}) violates step 1, paragraph 2 of the adoption agency algorithm.","adoption-agency-1.3":"End tag ({name}) violates step 1, paragraph 3 of the adoption agency algorithm.","adoption-agency-4.4":"End tag ({name}) violates step 4, paragraph 4 of the adoption agency algorithm.","unexpected-end-tag-treated-as":"Unexpected end tag ({originalName}). Treated as {newName}.","no-end-tag":"This element ({name}) has no end tag.","unexpected-implied-end-tag-in-table":"Unexpected implied end tag ({name}) in the table phase.","unexpected-implied-end-tag-in-table-body":"Unexpected implied end tag ({name}) in the table body phase.","unexpected-char-implies-table-voodoo":"Unexpected non-space characters in table context caused voodoo mode.","unexpected-hidden-input-in-table":"Unexpected input with type hidden in table context.","unexpected-form-in-table":"Unexpected form in table context.","unexpected-start-tag-implies-table-voodoo":"Unexpected start tag ({name}) in table context caused voodoo mode.","unexpected-end-tag-implies-table-voodoo":"Unexpected end tag ({name}) in table context caused voodoo mode.","unexpected-cell-in-table-body":"Unexpected table cell start tag ({name}) in the table body phase.","unexpected-cell-end-tag":"Got table cell end tag ({name}) while acequired end tags are missing.","unexpected-end-tag-in-table-body":"Unexpected end tag ({name}) in the table body phase. Ignored.","unexpected-implied-end-tag-in-table-row":"Unexpected implied end tag ({name}) in the table row phase.","unexpected-end-tag-in-table-row":"Unexpected end tag ({name}) in the table row phase. Ignored.","unexpected-select-in-select":"Unexpected select start tag in the select phase treated as select end tag.","unexpected-input-in-select":"Unexpected input start tag in the select phase.","unexpected-start-tag-in-select":"Unexpected start tag token ({name}) in the select phase. Ignored.","unexpected-end-tag-in-select":"Unexpected end tag ({name}) in the select phase. Ignored.","unexpected-table-element-start-tag-in-select-in-table":"Unexpected table element start tag ({name}) in the select in table phase.","unexpected-table-element-end-tag-in-select-in-table":"Unexpected table element end tag ({name}) in the select in table phase.","unexpected-char-after-body":"Unexpected non-space characters in the after body phase.","unexpected-start-tag-after-body":"Unexpected start tag token ({name}) in the after body phase.","unexpected-end-tag-after-body":"Unexpected end tag token ({name}) in the after body phase.","unexpected-char-in-frameset":"Unepxected characters in the frameset phase. Characters ignored.","unexpected-start-tag-in-frameset":"Unexpected start tag token ({name}) in the frameset phase. Ignored.","unexpected-frameset-in-frameset-innerhtml":"Unexpected end tag token (frameset in the frameset phase (innerHTML).","unexpected-end-tag-in-frameset":"Unexpected end tag token ({name}) in the frameset phase. Ignored.","unexpected-char-after-frameset":"Unexpected non-space characters in the after frameset phase. Ignored.","unexpected-start-tag-after-frameset":"Unexpected start tag ({name}) in the after frameset phase. Ignored.","unexpected-end-tag-after-frameset":"Unexpected end tag ({name}) in the after frameset phase. Ignored.","expected-eof-but-got-char":"Unexpected non-space characters. Expected end of file.","expected-eof-but-got-start-tag":"Unexpected start tag ({name}). Expected end of file.","expected-eof-but-got-end-tag":"Unexpected end tag ({name}). Expected end of file.","unexpected-end-table-in-caption":"Unexpected end table tag in caption. Generates implied end caption.","end-html-in-innerhtml":"Unexpected html end tag in inner html mode.","eof-in-table":"Unexpected end of file. Expected table content.","eof-in-script":"Unexpected end of file. Expected script content.","non-void-element-with-trailing-solidus":"Trailing solidus not allowed on element {name}.","unexpected-html-element-in-foreign-content":'HTML start tag "{name}" in a foreign namespace context.',"unexpected-start-tag-in-table":"Unexpected {name}. Expected table content."}},{}],9:[function(_dereq_,module,exports){function SAXParser(){this.contentHandler=null,this._errorHandler=null,this._treeBuilder=new SAXTreeBuilder,this._tokenizer=new Tokenizer(this._treeBuilder),this._scriptingEnabled=!1}var SAXTreeBuilder=_dereq_("./SAXTreeBuilder").SAXTreeBuilder,Tokenizer=_dereq_("../Tokenizer").Tokenizer,TreeParser=_dereq_("./TreeParser").TreeParser;SAXParser.prototype.parse=function(source){this._tokenizer.tokenize(source);var document=this._treeBuilder.document;document&&new TreeParser(this.contentHandler).parse(document)},SAXParser.prototype.parseFragment=function(source,context){this._treeBuilder.setFragmentContext(context),this._tokenizer.tokenize(source);var fragment=this._treeBuilder.getFragment();fragment&&new TreeParser(this.contentHandler).parse(fragment)},Object.defineProperty(SAXParser.prototype,"scriptingEnabled",{get:function(){return this._scriptingEnabled},set:function(value){this._scriptingEnabled=value,this._treeBuilder.scriptingEnabled=value}}),Object.defineProperty(SAXParser.prototype,"errorHandler",{get:function(){return this._errorHandler},set:function(value){this._errorHandler=value,this._treeBuilder.errorHandler=value}}),exports.SAXParser=SAXParser},{"../Tokenizer":5,"./SAXTreeBuilder":10,"./TreeParser":11}],10:[function(_dereq_,module,exports){function SAXTreeBuilder(){TreeBuilder.call(this)}function getAttribute(node,name){for(var i=0;node.attributes.length>i;i++){var attribute=node.attributes[i];if(attribute.nodeName===name)return attribute.nodeValue}}function Node(locator){locator?(this.columnNumber=locator.columnNumber,this.lineNumber=locator.lineNumber):(this.columnNumber=-1,this.lineNumber=-1),this.parentNode=null,this.nextSibling=null,this.firstChild=null}function ParentNode(locator){Node.call(this,locator),this.lastChild=null,this._endLocator=null}function Document(locator){ParentNode.call(this,locator),this.nodeType=NodeType.DOCUMENT}function DocumentFragment(){ParentNode.call(this,new Locator),this.nodeType=NodeType.DOCUMENT_FRAGMENT}function Element(locator,uri,localName,qName,atts,prefixMappings){ParentNode.call(this,locator),this.uri=uri,this.localName=localName,this.qName=qName,this.attributes=atts,this.prefixMappings=prefixMappings,this.nodeType=NodeType.ELEMENT}function Characters(locator,data){Node.call(this,locator),this.data=data,this.nodeType=NodeType.CHARACTERS}function IgnorableWhitespace(locator,data){Node.call(this,locator),this.data=data,this.nodeType=NodeType.IGNORABLE_WHITESPACE}function Comment(locator,data){Node.call(this,locator),this.data=data,this.nodeType=NodeType.COMMENT}function CDATA(locator){ParentNode.call(this,locator),this.nodeType=NodeType.CDATA}function Entity(name){ParentNode.call(this),this.name=name,this.nodeType=NodeType.ENTITY}function SkippedEntity(name){Node.call(this),this.name=name,this.nodeType=NodeType.SKIPPED_ENTITY}function ProcessingInstruction(target,data){Node.call(this),this.target=target,this.data=data}function DTD(name,publicIdentifier,systemIdentifier){ParentNode.call(this),this.name=name,this.publicIdentifier=publicIdentifier,this.systemIdentifier=systemIdentifier,this.nodeType=NodeType.DTD}var util=_dereq_("util"),TreeBuilder=_dereq_("../TreeBuilder").TreeBuilder;util.inherits(SAXTreeBuilder,TreeBuilder),SAXTreeBuilder.prototype.start=function(){this.document=new Document(this.tokenizer)},SAXTreeBuilder.prototype.end=function(){this.document.endLocator=this.tokenizer},SAXTreeBuilder.prototype.insertDoctype=function(name,publicId,systemId){var doctype=new DTD(this.tokenizer,name,publicId,systemId);doctype.endLocator=this.tokenizer,this.document.appendChild(doctype)},SAXTreeBuilder.prototype.createElement=function(namespaceURI,localName,attributes){var element=new Element(this.tokenizer,namespaceURI,localName,localName,attributes||[]);return element},SAXTreeBuilder.prototype.insertComment=function(data,parent){parent||(parent=this.currentStackItem());var comment=new Comment(this.tokenizer,data);parent.appendChild(comment)},SAXTreeBuilder.prototype.appendCharacters=function(parent,data){var text=new Characters(this.tokenizer,data);parent.appendChild(text)},SAXTreeBuilder.prototype.insertText=function(data){if(this.redirectAttachToFosterParent&&this.openElements.top.isFosterParenting()){var tableIndex=this.openElements.findIndex("table"),tableItem=this.openElements.item(tableIndex),table=tableItem.node;if(0===tableIndex)return this.appendCharacters(table,data);var text=new Characters(this.tokenizer,data),parent=table.parentNode;if(parent)return parent.insertBetween(text,table.previousSibling,table),void 0;var stackParent=this.openElements.item(tableIndex-1).node;return stackParent.appendChild(text),void 0}this.appendCharacters(this.currentStackItem().node,data)},SAXTreeBuilder.prototype.attachNode=function(node,parent){parent.appendChild(node)},SAXTreeBuilder.prototype.attachNodeToFosterParent=function(child,table,stackParent){var parent=table.parentNode;parent?parent.insertBetween(child,table.previousSibling,table):stackParent.appendChild(child)},SAXTreeBuilder.prototype.detachFromParent=function(element){element.detach()},SAXTreeBuilder.prototype.reparentChildren=function(oldParent,newParent){newParent.appendChildren(oldParent.firstChild)},SAXTreeBuilder.prototype.getFragment=function(){var fragment=new DocumentFragment;return this.reparentChildren(this.openElements.rootNode,fragment),fragment},SAXTreeBuilder.prototype.addAttributesToElement=function(element,attributes){for(var i=0;attributes.length>i;i++){var attribute=attributes[i];getAttribute(element,attribute.nodeName)||element.attributes.push(attribute)}};var NodeType={CDATA:1,CHARACTERS:2,COMMENT:3,DOCUMENT:4,DOCUMENT_FRAGMENT:5,DTD:6,ELEMENT:7,ENTITY:8,IGNORABLE_WHITESPACE:9,PROCESSING_INSTRUCTION:10,SKIPPED_ENTITY:11};Node.prototype.visit=function(){throw Error("Not Implemented")},Node.prototype.revisit=function(){},Node.prototype.detach=function(){null!==this.parentNode&&(this.parentNode.removeChild(this),this.parentNode=null)},Object.defineProperty(Node.prototype,"previousSibling",{get:function(){for(var prev=null,next=this.parentNode.firstChild;;){if(this==next)return prev;prev=next,next=next.nextSibling}}}),ParentNode.prototype=Object.create(Node.prototype),ParentNode.prototype.insertBefore=function(child,sibling){if(!sibling)return this.appendChild(child);if(child.detach(),child.parentNode=this,this.firstChild==sibling)child.nextSibling=sibling,this.firstChild=child;else{for(var prev=this.firstChild,next=this.firstChild.nextSibling;next!=sibling;)prev=next,next=next.nextSibling;prev.nextSibling=child,child.nextSibling=next}return child},ParentNode.prototype.insertBetween=function(child,prev,next){return next?(child.detach(),child.parentNode=this,child.nextSibling=next,prev?prev.nextSibling=child:firstChild=child,child):this.appendChild(child)},ParentNode.prototype.appendChild=function(child){return child.detach(),child.parentNode=this,this.firstChild?this.lastChild.nextSibling=child:this.firstChild=child,this.lastChild=child,child},ParentNode.prototype.appendChildren=function(parent){var child=parent.firstChild;if(child){var another=parent;this.firstChild?this.lastChild.nextSibling=child:this.firstChild=child,this.lastChild=another.lastChild;do child.parentNode=this;while(child=child.nextSibling);another.firstChild=null,another.lastChild=null}},ParentNode.prototype.removeChild=function(node){if(this.firstChild==node)this.firstChild=node.nextSibling,this.lastChild==node&&(this.lastChild=null);else{for(var prev=this.firstChild,next=this.firstChild.nextSibling;next!=node;)prev=next,next=next.nextSibling;prev.nextSibling=node.nextSibling,this.lastChild==node&&(this.lastChild=prev)}return node.parentNode=null,node},Object.defineProperty(ParentNode.prototype,"endLocator",{get:function(){return this._endLocator},set:function(endLocator){this._endLocator={lineNumber:endLocator.lineNumber,columnNumber:endLocator.columnNumber}}}),Document.prototype=Object.create(ParentNode.prototype),Document.prototype.visit=function(treeParser){treeParser.startDocument(this)},Document.prototype.revisit=function(treeParser){treeParser.endDocument(this.endLocator)},DocumentFragment.prototype=Object.create(ParentNode.prototype),DocumentFragment.prototype.visit=function(){},Element.prototype=Object.create(ParentNode.prototype),Element.prototype.visit=function(treeParser){if(this.prefixMappings)for(var key in prefixMappings){var mapping=prefixMappings[key];treeParser.startPrefixMapping(mapping.getPrefix(),mapping.getUri(),this)}treeParser.startElement(this.uri,this.localName,this.qName,this.attributes,this)},Element.prototype.revisit=function(treeParser){if(treeParser.endElement(this.uri,this.localName,this.qName,this.endLocator),this.prefixMappings)for(var key in prefixMappings){var mapping=prefixMappings[key];treeParser.endPrefixMapping(mapping.getPrefix(),this.endLocator)}},Characters.prototype=Object.create(Node.prototype),Characters.prototype.visit=function(treeParser){treeParser.characters(this.data,0,this.data.length,this)},IgnorableWhitespace.prototype=Object.create(Node.prototype),IgnorableWhitespace.prototype.visit=function(treeParser){treeParser.ignorableWhitespace(this.data,0,this.data.length,this)},Comment.prototype=Object.create(Node.prototype),Comment.prototype.visit=function(treeParser){treeParser.comment(this.data,0,this.data.length,this)},CDATA.prototype=Object.create(ParentNode.prototype),CDATA.prototype.visit=function(treeParser){treeParser.startCDATA(this)},CDATA.prototype.revisit=function(treeParser){treeParser.endCDATA(this.endLocator)},Entity.prototype=Object.create(ParentNode.prototype),Entity.prototype.visit=function(treeParser){treeParser.startEntity(this.name,this)},Entity.prototype.revisit=function(treeParser){treeParser.endEntity(this.name)},SkippedEntity.prototype=Object.create(Node.prototype),SkippedEntity.prototype.visit=function(treeParser){treeParser.skippedEntity(this.name,this)},ProcessingInstruction.prototype=Object.create(Node.prototype),ProcessingInstruction.prototype.visit=function(treeParser){treeParser.processingInstruction(this.target,this.data,this)},ProcessingInstruction.prototype.getNodeType=function(){return NodeType.PROCESSING_INSTRUCTION},DTD.prototype=Object.create(ParentNode.prototype),DTD.prototype.visit=function(treeParser){treeParser.startDTD(this.name,this.publicIdentifier,this.systemIdentifier,this)},DTD.prototype.revisit=function(treeParser){treeParser.endDTD()},exports.SAXTreeBuilder=SAXTreeBuilder},{"../TreeBuilder":6,util:20}],11:[function(_dereq_,module,exports){function TreeParser(contentHandler,lexicalHandler){if(this.contentHandler,this.lexicalHandler,this.locatorDelegate,!contentHandler)throw new IllegalArgumentException("contentHandler was null.");this.contentHandler=contentHandler,this.lexicalHandler=lexicalHandler?lexicalHandler:new NullLexicalHandler}function NullLexicalHandler(){}TreeParser.prototype.parse=function(node){this.contentHandler.documentLocator=this;for(var next,current=node;;)if(current.visit(this),next=current.firstChild)current=next;else for(;;){if(current.revisit(this),current==node)return;if(next=current.nextSibling){current=next;break}current=current.parentNode}},TreeParser.prototype.characters=function(ch,start,length,locator){this.locatorDelegate=locator,this.contentHandler.characters(ch,start,length)},TreeParser.prototype.endDocument=function(locator){this.locatorDelegate=locator,this.contentHandler.endDocument()},TreeParser.prototype.endElement=function(uri,localName,qName,locator){this.locatorDelegate=locator,this.contentHandler.endElement(uri,localName,qName)},TreeParser.prototype.endPrefixMapping=function(prefix,locator){this.locatorDelegate=locator,this.contentHandler.endPrefixMapping(prefix)},TreeParser.prototype.ignorableWhitespace=function(ch,start,length,locator){this.locatorDelegate=locator,this.contentHandler.ignorableWhitespace(ch,start,length)},TreeParser.prototype.processingInstruction=function(target,data,locator){this.locatorDelegate=locator,this.contentHandler.processingInstruction(target,data)},TreeParser.prototype.skippedEntity=function(name,locator){this.locatorDelegate=locator,this.contentHandler.skippedEntity(name)},TreeParser.prototype.startDocument=function(locator){this.locatorDelegate=locator,this.contentHandler.startDocument()},TreeParser.prototype.startElement=function(uri,localName,qName,atts,locator){this.locatorDelegate=locator,this.contentHandler.startElement(uri,localName,qName,atts)},TreeParser.prototype.startPrefixMapping=function(prefix,uri,locator){this.locatorDelegate=locator,this.contentHandler.startPrefixMapping(prefix,uri)},TreeParser.prototype.comment=function(ch,start,length,locator){this.locatorDelegate=locator,this.lexicalHandler.comment(ch,start,length)},TreeParser.prototype.endCDATA=function(locator){this.locatorDelegate=locator,this.lexicalHandler.endCDATA()},TreeParser.prototype.endDTD=function(locator){this.locatorDelegate=locator,this.lexicalHandler.endDTD()},TreeParser.prototype.endEntity=function(name,locator){this.locatorDelegate=locator,this.lexicalHandler.endEntity(name)},TreeParser.prototype.startCDATA=function(locator){this.locatorDelegate=locator,this.lexicalHandler.startCDATA()},TreeParser.prototype.startDTD=function(name,publicId,systemId,locator){this.locatorDelegate=locator,this.lexicalHandler.startDTD(name,publicId,systemId)},TreeParser.prototype.startEntity=function(name,locator){this.locatorDelegate=locator,this.lexicalHandler.startEntity(name)},Object.defineProperty(TreeParser.prototype,"columnNumber",{get:function(){return this.locatorDelegate?this.locatorDelegate.columnNumber:-1}}),Object.defineProperty(TreeParser.prototype,"lineNumber",{get:function(){return this.locatorDelegate?this.locatorDelegate.lineNumber:-1}}),NullLexicalHandler.prototype.comment=function(){},NullLexicalHandler.prototype.endCDATA=function(){},NullLexicalHandler.prototype.endDTD=function(){},NullLexicalHandler.prototype.endEntity=function(){},NullLexicalHandler.prototype.startCDATA=function(){},NullLexicalHandler.prototype.startDTD=function(){},NullLexicalHandler.prototype.startEntity=function(){},exports.TreeParser=TreeParser},{}],12:[function(_dereq_,module){module.exports={"Aacute;":"\xC1",Aacute:"\xC1","aacute;":"\xE1",aacute:"\xE1","Abreve;":"\u0102","abreve;":"\u0103","ac;":"\u223E","acd;":"\u223F","acE;":"\u223E\u0333","Acirc;":"\xC2",Acirc:"\xC2","acirc;":"\xE2",acirc:"\xE2","acute;":"\xB4",acute:"\xB4","Acy;":"\u0410","acy;":"\u0430","AElig;":"\xC6",AElig:"\xC6","aelig;":"\xE6",aelig:"\xE6","af;":"\u2061","Afr;":"\u{1D504}","afr;":"\u{1D51E}","Agrave;":"\xC0",Agrave:"\xC0","agrave;":"\xE0",agrave:"\xE0","alefsym;":"\u2135","aleph;":"\u2135","Alpha;":"\u0391","alpha;":"\u03B1","Amacr;":"\u0100","amacr;":"\u0101","amalg;":"\u2A3F","amp;":"&",amp:"&","AMP;":"&",AMP:"&","andand;":"\u2A55","And;":"\u2A53","and;":"\u2227","andd;":"\u2A5C","andslope;":"\u2A58","andv;":"\u2A5A","ang;":"\u2220","ange;":"\u29A4","angle;":"\u2220","angmsdaa;":"\u29A8","angmsdab;":"\u29A9","angmsdac;":"\u29AA","angmsdad;":"\u29AB","angmsdae;":"\u29AC","angmsdaf;":"\u29AD","angmsdag;":"\u29AE","angmsdah;":"\u29AF","angmsd;":"\u2221","angrt;":"\u221F","angrtvb;":"\u22BE","angrtvbd;":"\u299D","angsph;":"\u2222","angst;":"\xC5","angzarr;":"\u237C","Aogon;":"\u0104","aogon;":"\u0105","Aopf;":"\u{1D538}","aopf;":"\u{1D552}","apacir;":"\u2A6F","ap;":"\u2248","apE;":"\u2A70","ape;":"\u224A","apid;":"\u224B","apos;":"'","ApplyFunction;":"\u2061","approx;":"\u2248","approxeq;":"\u224A","Aring;":"\xC5",Aring:"\xC5","aring;":"\xE5",aring:"\xE5","Ascr;":"\u{1D49C}","ascr;":"\u{1D4B6}","Assign;":"\u2254","ast;":"*","asymp;":"\u2248","asympeq;":"\u224D","Atilde;":"\xC3",Atilde:"\xC3","atilde;":"\xE3",atilde:"\xE3","Auml;":"\xC4",Auml:"\xC4","auml;":"\xE4",auml:"\xE4","awconint;":"\u2233","awint;":"\u2A11","backcong;":"\u224C","backepsilon;":"\u03F6","backprime;":"\u2035","backsim;":"\u223D","backsimeq;":"\u22CD","Backslash;":"\u2216","Barv;":"\u2AE7","barvee;":"\u22BD","barwed;":"\u2305","Barwed;":"\u2306","barwedge;":"\u2305","bbrk;":"\u23B5","bbrktbrk;":"\u23B6","bcong;":"\u224C","Bcy;":"\u0411","bcy;":"\u0431","bdquo;":"\u201E","becaus;":"\u2235","because;":"\u2235","Because;":"\u2235","bemptyv;":"\u29B0","bepsi;":"\u03F6","bernou;":"\u212C","Bernoullis;":"\u212C","Beta;":"\u0392","beta;":"\u03B2","beth;":"\u2136","between;":"\u226C","Bfr;":"\u{1D505}","bfr;":"\u{1D51F}","bigcap;":"\u22C2","bigcirc;":"\u25EF","bigcup;":"\u22C3","bigodot;":"\u2A00","bigoplus;":"\u2A01","bigotimes;":"\u2A02","bigsqcup;":"\u2A06","bigstar;":"\u2605","bigtriangledown;":"\u25BD","bigtriangleup;":"\u25B3","biguplus;":"\u2A04","bigvee;":"\u22C1","bigwedge;":"\u22C0","bkarow;":"\u290D","blacklozenge;":"\u29EB","blacksquare;":"\u25AA","blacktriangle;":"\u25B4","blacktriangledown;":"\u25BE","blacktriangleleft;":"\u25C2","blacktriangleright;":"\u25B8","blank;":"\u2423","blk12;":"\u2592","blk14;":"\u2591","blk34;":"\u2593","block;":"\u2588","bne;":"=\u20E5","bnequiv;":"\u2261\u20E5","bNot;":"\u2AED","bnot;":"\u2310","Bopf;":"\u{1D539}","bopf;":"\u{1D553}","bot;":"\u22A5","bottom;":"\u22A5","bowtie;":"\u22C8","boxbox;":"\u29C9","boxdl;":"\u2510","boxdL;":"\u2555","boxDl;":"\u2556","boxDL;":"\u2557","boxdr;":"\u250C","boxdR;":"\u2552","boxDr;":"\u2553","boxDR;":"\u2554","boxh;":"\u2500","boxH;":"\u2550","boxhd;":"\u252C","boxHd;":"\u2564","boxhD;":"\u2565","boxHD;":"\u2566","boxhu;":"\u2534","boxHu;":"\u2567","boxhU;":"\u2568","boxHU;":"\u2569","boxminus;":"\u229F","boxplus;":"\u229E","boxtimes;":"\u22A0","boxul;":"\u2518","boxuL;":"\u255B","boxUl;":"\u255C","boxUL;":"\u255D","boxur;":"\u2514","boxuR;":"\u2558","boxUr;":"\u2559","boxUR;":"\u255A","boxv;":"\u2502","boxV;":"\u2551","boxvh;":"\u253C","boxvH;":"\u256A","boxVh;":"\u256B","boxVH;":"\u256C","boxvl;":"\u2524","boxvL;":"\u2561","boxVl;":"\u2562","boxVL;":"\u2563","boxvr;":"\u251C","boxvR;":"\u255E","boxVr;":"\u255F","boxVR;":"\u2560","bprime;":"\u2035","breve;":"\u02D8","Breve;":"\u02D8","brvbar;":"\xA6",brvbar:"\xA6","bscr;":"\u{1D4B7}","Bscr;":"\u212C","bsemi;":"\u204F","bsim;":"\u223D","bsime;":"\u22CD","bsolb;":"\u29C5","bsol;":"\\\\","bsolhsub;":"\u27C8","bull;":"\u2022","bullet;":"\u2022","bump;":"\u224E","bumpE;":"\u2AAE","bumpe;":"\u224F","Bumpeq;":"\u224E","bumpeq;":"\u224F","Cacute;":"\u0106","cacute;":"\u0107","capand;":"\u2A44","capbrcup;":"\u2A49","capcap;":"\u2A4B","cap;":"\u2229","Cap;":"\u22D2","capcup;":"\u2A47","capdot;":"\u2A40","CapitalDifferentialD;":"\u2145","caps;":"\u2229\uFE00","caret;":"\u2041","caron;":"\u02C7","Cayleys;":"\u212D","ccaps;":"\u2A4D","Ccaron;":"\u010C","ccaron;":"\u010D","Ccedil;":"\xC7",Ccedil:"\xC7","ccedil;":"\xE7",ccedil:"\xE7","Ccirc;":"\u0108","ccirc;":"\u0109","Cconint;":"\u2230","ccups;":"\u2A4C","ccupssm;":"\u2A50","Cdot;":"\u010A","cdot;":"\u010B","cedil;":"\xB8",cedil:"\xB8","Cedilla;":"\xB8","cemptyv;":"\u29B2","cent;":"\xA2",cent:"\xA2","centerdot;":"\xB7","CenterDot;":"\xB7","cfr;":"\u{1D520}","Cfr;":"\u212D","CHcy;":"\u0427","chcy;":"\u0447","check;":"\u2713","checkmark;":"\u2713","Chi;":"\u03A7","chi;":"\u03C7","circ;":"\u02C6","circeq;":"\u2257","circlearrowleft;":"\u21BA","circlearrowright;":"\u21BB","circledast;":"\u229B","circledcirc;":"\u229A","circleddash;":"\u229D","CircleDot;":"\u2299","circledR;":"\xAE","circledS;":"\u24C8","CircleMinus;":"\u2296","CirclePlus;":"\u2295","CircleTimes;":"\u2297","cir;":"\u25CB","cirE;":"\u29C3","cire;":"\u2257","cirfnint;":"\u2A10","cirmid;":"\u2AEF","cirscir;":"\u29C2","ClockwiseContourIntegral;":"\u2232","CloseCurlyDoubleQuote;":"\u201D","CloseCurlyQuote;":"\u2019","clubs;":"\u2663","clubsuit;":"\u2663","colon;":":","Colon;":"\u2237","Colone;":"\u2A74","colone;":"\u2254","coloneq;":"\u2254","comma;":",","commat;":"@","comp;":"\u2201","compfn;":"\u2218","complement;":"\u2201","complexes;":"\u2102","cong;":"\u2245","congdot;":"\u2A6D","Congruent;":"\u2261","conint;":"\u222E","Conint;":"\u222F","ContourIntegral;":"\u222E","copf;":"\u{1D554}","Copf;":"\u2102","coprod;":"\u2210","Coproduct;":"\u2210","copy;":"\xA9",copy:"\xA9","COPY;":"\xA9",COPY:"\xA9","copysr;":"\u2117","CounterClockwiseContourIntegral;":"\u2233","crarr;":"\u21B5","cross;":"\u2717","Cross;":"\u2A2F","Cscr;":"\u{1D49E}","cscr;":"\u{1D4B8}","csub;":"\u2ACF","csube;":"\u2AD1","csup;":"\u2AD0","csupe;":"\u2AD2","ctdot;":"\u22EF","cudarrl;":"\u2938","cudarrr;":"\u2935","cuepr;":"\u22DE","cuesc;":"\u22DF","cularr;":"\u21B6","cularrp;":"\u293D","cupbrcap;":"\u2A48","cupcap;":"\u2A46","CupCap;":"\u224D","cup;":"\u222A","Cup;":"\u22D3","cupcup;":"\u2A4A","cupdot;":"\u228D","cupor;":"\u2A45","cups;":"\u222A\uFE00","curarr;":"\u21B7","curarrm;":"\u293C","curlyeqprec;":"\u22DE","curlyeqsucc;":"\u22DF","curlyvee;":"\u22CE","curlywedge;":"\u22CF","curren;":"\xA4",curren:"\xA4","curvearrowleft;":"\u21B6","curvearrowright;":"\u21B7","cuvee;":"\u22CE","cuwed;":"\u22CF","cwconint;":"\u2232","cwint;":"\u2231","cylcty;":"\u232D","dagger;":"\u2020","Dagger;":"\u2021","daleth;":"\u2138","darr;":"\u2193","Darr;":"\u21A1","dArr;":"\u21D3","dash;":"\u2010","Dashv;":"\u2AE4","dashv;":"\u22A3","dbkarow;":"\u290F","dblac;":"\u02DD","Dcaron;":"\u010E","dcaron;":"\u010F","Dcy;":"\u0414","dcy;":"\u0434","ddagger;":"\u2021","ddarr;":"\u21CA","DD;":"\u2145","dd;":"\u2146","DDotrahd;":"\u2911","ddotseq;":"\u2A77","deg;":"\xB0",deg:"\xB0","Del;":"\u2207","Delta;":"\u0394","delta;":"\u03B4","demptyv;":"\u29B1","dfisht;":"\u297F","Dfr;":"\u{1D507}","dfr;":"\u{1D521}","dHar;":"\u2965","dharl;":"\u21C3","dharr;":"\u21C2","DiacriticalAcute;":"\xB4","DiacriticalDot;":"\u02D9","DiacriticalDoubleAcute;":"\u02DD","DiacriticalGrave;":"\`","DiacriticalTilde;":"\u02DC","diam;":"\u22C4","diamond;":"\u22C4","Diamond;":"\u22C4","diamondsuit;":"\u2666","diams;":"\u2666","die;":"\xA8","DifferentialD;":"\u2146","digamma;":"\u03DD","disin;":"\u22F2","div;":"\xF7","divide;":"\xF7",divide:"\xF7","divideontimes;":"\u22C7","divonx;":"\u22C7","DJcy;":"\u0402","djcy;":"\u0452","dlcorn;":"\u231E","dlcrop;":"\u230D","dollar;":"$","Dopf;":"\u{1D53B}","dopf;":"\u{1D555}","Dot;":"\xA8","dot;":"\u02D9","DotDot;":"\u20DC","doteq;":"\u2250","doteqdot;":"\u2251","DotEqual;":"\u2250","dotminus;":"\u2238","dotplus;":"\u2214","dotsquare;":"\u22A1","doublebarwedge;":"\u2306","DoubleContourIntegral;":"\u222F","DoubleDot;":"\xA8","DoubleDownArrow;":"\u21D3","DoubleLeftArrow;":"\u21D0","DoubleLeftRightArrow;":"\u21D4","DoubleLeftTee;":"\u2AE4","DoubleLongLeftArrow;":"\u27F8","DoubleLongLeftRightArrow;":"\u27FA","DoubleLongRightArrow;":"\u27F9","DoubleRightArrow;":"\u21D2","DoubleRightTee;":"\u22A8","DoubleUpArrow;":"\u21D1","DoubleUpDownArrow;":"\u21D5","DoubleVerticalBar;":"\u2225","DownArrowBar;":"\u2913","downarrow;":"\u2193","DownArrow;":"\u2193","Downarrow;":"\u21D3","DownArrowUpArrow;":"\u21F5","DownBreve;":"\u0311","downdownarrows;":"\u21CA","downharpoonleft;":"\u21C3","downharpoonright;":"\u21C2","DownLeftRightVector;":"\u2950","DownLeftTeeVector;":"\u295E","DownLeftVectorBar;":"\u2956","DownLeftVector;":"\u21BD","DownRightTeeVector;":"\u295F","DownRightVectorBar;":"\u2957","DownRightVector;":"\u21C1","DownTeeArrow;":"\u21A7","DownTee;":"\u22A4","drbkarow;":"\u2910","drcorn;":"\u231F","drcrop;":"\u230C","Dscr;":"\u{1D49F}","dscr;":"\u{1D4B9}","DScy;":"\u0405","dscy;":"\u0455","dsol;":"\u29F6","Dstrok;":"\u0110","dstrok;":"\u0111","dtdot;":"\u22F1","dtri;":"\u25BF","dtrif;":"\u25BE","duarr;":"\u21F5","duhar;":"\u296F","dwangle;":"\u29A6","DZcy;":"\u040F","dzcy;":"\u045F","dzigrarr;":"\u27FF","Eacute;":"\xC9",Eacute:"\xC9","eacute;":"\xE9",eacute:"\xE9","easter;":"\u2A6E","Ecaron;":"\u011A","ecaron;":"\u011B","Ecirc;":"\xCA",Ecirc:"\xCA","ecirc;":"\xEA",ecirc:"\xEA","ecir;":"\u2256","ecolon;":"\u2255","Ecy;":"\u042D","ecy;":"\u044D","eDDot;":"\u2A77","Edot;":"\u0116","edot;":"\u0117","eDot;":"\u2251","ee;":"\u2147","efDot;":"\u2252","Efr;":"\u{1D508}","efr;":"\u{1D522}","eg;":"\u2A9A","Egrave;":"\xC8",Egrave:"\xC8","egrave;":"\xE8",egrave:"\xE8","egs;":"\u2A96","egsdot;":"\u2A98","el;":"\u2A99","Element;":"\u2208","elinters;":"\u23E7","ell;":"\u2113","els;":"\u2A95","elsdot;":"\u2A97","Emacr;":"\u0112","emacr;":"\u0113","empty;":"\u2205","emptyset;":"\u2205","EmptySmallSquare;":"\u25FB","emptyv;":"\u2205","EmptyVerySmallSquare;":"\u25AB","emsp13;":"\u2004","emsp14;":"\u2005","emsp;":"\u2003","ENG;":"\u014A","eng;":"\u014B","ensp;":"\u2002","Eogon;":"\u0118","eogon;":"\u0119","Eopf;":"\u{1D53C}","eopf;":"\u{1D556}","epar;":"\u22D5","eparsl;":"\u29E3","eplus;":"\u2A71","epsi;":"\u03B5","Epsilon;":"\u0395","epsilon;":"\u03B5","epsiv;":"\u03F5","eqcirc;":"\u2256","eqcolon;":"\u2255","eqsim;":"\u2242","eqslantgtr;":"\u2A96","eqslantless;":"\u2A95","Equal;":"\u2A75","equals;":"=","EqualTilde;":"\u2242","equest;":"\u225F","Equilibrium;":"\u21CC","equiv;":"\u2261","equivDD;":"\u2A78","eqvparsl;":"\u29E5","erarr;":"\u2971","erDot;":"\u2253","escr;":"\u212F","Escr;":"\u2130","esdot;":"\u2250","Esim;":"\u2A73","esim;":"\u2242","Eta;":"\u0397","eta;":"\u03B7","ETH;":"\xD0",ETH:"\xD0","eth;":"\xF0",eth:"\xF0","Euml;":"\xCB",Euml:"\xCB","euml;":"\xEB",euml:"\xEB","euro;":"\u20AC","excl;":"!","exist;":"\u2203","Exists;":"\u2203","expectation;":"\u2130","exponentiale;":"\u2147","ExponentialE;":"\u2147","fallingdotseq;":"\u2252","Fcy;":"\u0424","fcy;":"\u0444","female;":"\u2640","ffilig;":"\uFB03","fflig;":"\uFB00","ffllig;":"\uFB04","Ffr;":"\u{1D509}","ffr;":"\u{1D523}","filig;":"\uFB01","FilledSmallSquare;":"\u25FC","FilledVerySmallSquare;":"\u25AA","fjlig;":"fj","flat;":"\u266D","fllig;":"\uFB02","fltns;":"\u25B1","fnof;":"\u0192","Fopf;":"\u{1D53D}","fopf;":"\u{1D557}","forall;":"\u2200","ForAll;":"\u2200","fork;":"\u22D4","forkv;":"\u2AD9","Fouriertrf;":"\u2131","fpartint;":"\u2A0D","frac12;":"\xBD",frac12:"\xBD","frac13;":"\u2153","frac14;":"\xBC",frac14:"\xBC","frac15;":"\u2155","frac16;":"\u2159","frac18;":"\u215B","frac23;":"\u2154","frac25;":"\u2156","frac34;":"\xBE",frac34:"\xBE","frac35;":"\u2157","frac38;":"\u215C","frac45;":"\u2158","frac56;":"\u215A","frac58;":"\u215D","frac78;":"\u215E","frasl;":"\u2044","frown;":"\u2322","fscr;":"\u{1D4BB}","Fscr;":"\u2131","gacute;":"\u01F5","Gamma;":"\u0393","gamma;":"\u03B3","Gammad;":"\u03DC","gammad;":"\u03DD","gap;":"\u2A86","Gbreve;":"\u011E","gbreve;":"\u011F","Gcedil;":"\u0122","Gcirc;":"\u011C","gcirc;":"\u011D","Gcy;":"\u0413","gcy;":"\u0433","Gdot;":"\u0120","gdot;":"\u0121","ge;":"\u2265","gE;":"\u2267","gEl;":"\u2A8C","gel;":"\u22DB","geq;":"\u2265","geqq;":"\u2267","geqslant;":"\u2A7E","gescc;":"\u2AA9","ges;":"\u2A7E","gesdot;":"\u2A80","gesdoto;":"\u2A82","gesdotol;":"\u2A84","gesl;":"\u22DB\uFE00","gesles;":"\u2A94","Gfr;":"\u{1D50A}","gfr;":"\u{1D524}","gg;":"\u226B","Gg;":"\u22D9","ggg;":"\u22D9","gimel;":"\u2137","GJcy;":"\u0403","gjcy;":"\u0453","gla;":"\u2AA5","gl;":"\u2277","glE;":"\u2A92","glj;":"\u2AA4","gnap;":"\u2A8A","gnapprox;":"\u2A8A","gne;":"\u2A88","gnE;":"\u2269","gneq;":"\u2A88","gneqq;":"\u2269","gnsim;":"\u22E7","Gopf;":"\u{1D53E}","gopf;":"\u{1D558}","grave;":"\`","GreaterEqual;":"\u2265","GreaterEqualLess;":"\u22DB","GreaterFullEqual;":"\u2267","GreaterGreater;":"\u2AA2","GreaterLess;":"\u2277","GreaterSlantEqual;":"\u2A7E","GreaterTilde;":"\u2273","Gscr;":"\u{1D4A2}","gscr;":"\u210A","gsim;":"\u2273","gsime;":"\u2A8E","gsiml;":"\u2A90","gtcc;":"\u2AA7","gtcir;":"\u2A7A","gt;":">",gt:">","GT;":">",GT:">","Gt;":"\u226B","gtdot;":"\u22D7","gtlPar;":"\u2995","gtquest;":"\u2A7C","gtrapprox;":"\u2A86","gtrarr;":"\u2978","gtrdot;":"\u22D7","gtreqless;":"\u22DB","gtreqqless;":"\u2A8C","gtrless;":"\u2277","gtrsim;":"\u2273","gvertneqq;":"\u2269\uFE00","gvnE;":"\u2269\uFE00","Hacek;":"\u02C7","hairsp;":"\u200A","half;":"\xBD","hamilt;":"\u210B","HARDcy;":"\u042A","hardcy;":"\u044A","harrcir;":"\u2948","harr;":"\u2194","hArr;":"\u21D4","harrw;":"\u21AD","Hat;":"^","hbar;":"\u210F","Hcirc;":"\u0124","hcirc;":"\u0125","hearts;":"\u2665","heartsuit;":"\u2665","hellip;":"\u2026","hercon;":"\u22B9","hfr;":"\u{1D525}","Hfr;":"\u210C","HilbertSpace;":"\u210B","hksearow;":"\u2925","hkswarow;":"\u2926","hoarr;":"\u21FF","homtht;":"\u223B","hookleftarrow;":"\u21A9","hookrightarrow;":"\u21AA","hopf;":"\u{1D559}","Hopf;":"\u210D","horbar;":"\u2015","HorizontalLine;":"\u2500","hscr;":"\u{1D4BD}","Hscr;":"\u210B","hslash;":"\u210F","Hstrok;":"\u0126","hstrok;":"\u0127","HumpDownHump;":"\u224E","HumpEqual;":"\u224F","hybull;":"\u2043","hyphen;":"\u2010","Iacute;":"\xCD",Iacute:"\xCD","iacute;":"\xED",iacute:"\xED","ic;":"\u2063","Icirc;":"\xCE",Icirc:"\xCE","icirc;":"\xEE",icirc:"\xEE","Icy;":"\u0418","icy;":"\u0438","Idot;":"\u0130","IEcy;":"\u0415","iecy;":"\u0435","iexcl;":"\xA1",iexcl:"\xA1","iff;":"\u21D4","ifr;":"\u{1D526}","Ifr;":"\u2111","Igrave;":"\xCC",Igrave:"\xCC","igrave;":"\xEC",igrave:"\xEC","ii;":"\u2148","iiiint;":"\u2A0C","iiint;":"\u222D","iinfin;":"\u29DC","iiota;":"\u2129","IJlig;":"\u0132","ijlig;":"\u0133","Imacr;":"\u012A","imacr;":"\u012B","image;":"\u2111","ImaginaryI;":"\u2148","imagline;":"\u2110","imagpart;":"\u2111","imath;":"\u0131","Im;":"\u2111","imof;":"\u22B7","imped;":"\u01B5","Implies;":"\u21D2","incare;":"\u2105","in;":"\u2208","infin;":"\u221E","infintie;":"\u29DD","inodot;":"\u0131","intcal;":"\u22BA","int;":"\u222B","Int;":"\u222C","integers;":"\u2124","Integral;":"\u222B","intercal;":"\u22BA","Intersection;":"\u22C2","intlarhk;":"\u2A17","intprod;":"\u2A3C","InvisibleComma;":"\u2063","InvisibleTimes;":"\u2062","IOcy;":"\u0401","iocy;":"\u0451","Iogon;":"\u012E","iogon;":"\u012F","Iopf;":"\u{1D540}","iopf;":"\u{1D55A}","Iota;":"\u0399","iota;":"\u03B9","iprod;":"\u2A3C","iquest;":"\xBF",iquest:"\xBF","iscr;":"\u{1D4BE}","Iscr;":"\u2110","isin;":"\u2208","isindot;":"\u22F5","isinE;":"\u22F9","isins;":"\u22F4","isinsv;":"\u22F3","isinv;":"\u2208","it;":"\u2062","Itilde;":"\u0128","itilde;":"\u0129","Iukcy;":"\u0406","iukcy;":"\u0456","Iuml;":"\xCF",Iuml:"\xCF","iuml;":"\xEF",iuml:"\xEF","Jcirc;":"\u0134","jcirc;":"\u0135","Jcy;":"\u0419","jcy;":"\u0439","Jfr;":"\u{1D50D}","jfr;":"\u{1D527}","jmath;":"\u0237","Jopf;":"\u{1D541}","jopf;":"\u{1D55B}","Jscr;":"\u{1D4A5}","jscr;":"\u{1D4BF}","Jsercy;":"\u0408","jsercy;":"\u0458","Jukcy;":"\u0404","jukcy;":"\u0454","Kappa;":"\u039A","kappa;":"\u03BA","kappav;":"\u03F0","Kcedil;":"\u0136","kcedil;":"\u0137","Kcy;":"\u041A","kcy;":"\u043A","Kfr;":"\u{1D50E}","kfr;":"\u{1D528}","kgreen;":"\u0138","KHcy;":"\u0425","khcy;":"\u0445","KJcy;":"\u040C","kjcy;":"\u045C","Kopf;":"\u{1D542}","kopf;":"\u{1D55C}","Kscr;":"\u{1D4A6}","kscr;":"\u{1D4C0}","lAarr;":"\u21DA","Lacute;":"\u0139","lacute;":"\u013A","laemptyv;":"\u29B4","lagran;":"\u2112","Lambda;":"\u039B","lambda;":"\u03BB","lang;":"\u27E8","Lang;":"\u27EA","langd;":"\u2991","langle;":"\u27E8","lap;":"\u2A85","Laplacetrf;":"\u2112","laquo;":"\xAB",laquo:"\xAB","larrb;":"\u21E4","larrbfs;":"\u291F","larr;":"\u2190","Larr;":"\u219E","lArr;":"\u21D0","larrfs;":"\u291D","larrhk;":"\u21A9","larrlp;":"\u21AB","larrpl;":"\u2939","larrsim;":"\u2973","larrtl;":"\u21A2","latail;":"\u2919","lAtail;":"\u291B","lat;":"\u2AAB","late;":"\u2AAD","lates;":"\u2AAD\uFE00","lbarr;":"\u290C","lBarr;":"\u290E","lbbrk;":"\u2772","lbrace;":"{","lbrack;":"[","lbrke;":"\u298B","lbrksld;":"\u298F","lbrkslu;":"\u298D","Lcaron;":"\u013D","lcaron;":"\u013E","Lcedil;":"\u013B","lcedil;":"\u013C","lceil;":"\u2308","lcub;":"{","Lcy;":"\u041B","lcy;":"\u043B","ldca;":"\u2936","ldquo;":"\u201C","ldquor;":"\u201E","ldrdhar;":"\u2967","ldrushar;":"\u294B","ldsh;":"\u21B2","le;":"\u2264","lE;":"\u2266","LeftAngleBracket;":"\u27E8","LeftArrowBar;":"\u21E4","leftarrow;":"\u2190","LeftArrow;":"\u2190","Leftarrow;":"\u21D0","LeftArrowRightArrow;":"\u21C6","leftarrowtail;":"\u21A2","LeftCeiling;":"\u2308","LeftDoubleBracket;":"\u27E6","LeftDownTeeVector;":"\u2961","LeftDownVectorBar;":"\u2959","LeftDownVector;":"\u21C3","LeftFloor;":"\u230A","leftharpoondown;":"\u21BD","leftharpoonup;":"\u21BC","leftleftarrows;":"\u21C7","leftrightarrow;":"\u2194","LeftRightArrow;":"\u2194","Leftrightarrow;":"\u21D4","leftrightarrows;":"\u21C6","leftrightharpoons;":"\u21CB","leftrightsquigarrow;":"\u21AD","LeftRightVector;":"\u294E","LeftTeeArrow;":"\u21A4","LeftTee;":"\u22A3","LeftTeeVector;":"\u295A","leftthreetimes;":"\u22CB","LeftTriangleBar;":"\u29CF","LeftTriangle;":"\u22B2","LeftTriangleEqual;":"\u22B4","LeftUpDownVector;":"\u2951","LeftUpTeeVector;":"\u2960","LeftUpVectorBar;":"\u2958","LeftUpVector;":"\u21BF","LeftVectorBar;":"\u2952","LeftVector;":"\u21BC","lEg;":"\u2A8B","leg;":"\u22DA","leq;":"\u2264","leqq;":"\u2266","leqslant;":"\u2A7D","lescc;":"\u2AA8","les;":"\u2A7D","lesdot;":"\u2A7F","lesdoto;":"\u2A81","lesdotor;":"\u2A83","lesg;":"\u22DA\uFE00","lesges;":"\u2A93","lessapprox;":"\u2A85","lessdot;":"\u22D6","lesseqgtr;":"\u22DA","lesseqqgtr;":"\u2A8B","LessEqualGreater;":"\u22DA","LessFullEqual;":"\u2266","LessGreater;":"\u2276","lessgtr;":"\u2276","LessLess;":"\u2AA1","lesssim;":"\u2272","LessSlantEqual;":"\u2A7D","LessTilde;":"\u2272","lfisht;":"\u297C","lfloor;":"\u230A","Lfr;":"\u{1D50F}","lfr;":"\u{1D529}","lg;":"\u2276","lgE;":"\u2A91","lHar;":"\u2962","lhard;":"\u21BD","lharu;":"\u21BC","lharul;":"\u296A","lhblk;":"\u2584","LJcy;":"\u0409","ljcy;":"\u0459","llarr;":"\u21C7","ll;":"\u226A","Ll;":"\u22D8","llcorner;":"\u231E","Lleftarrow;":"\u21DA","llhard;":"\u296B","lltri;":"\u25FA","Lmidot;":"\u013F","lmidot;":"\u0140","lmoustache;":"\u23B0","lmoust;":"\u23B0","lnap;":"\u2A89","lnapprox;":"\u2A89","lne;":"\u2A87","lnE;":"\u2268","lneq;":"\u2A87","lneqq;":"\u2268","lnsim;":"\u22E6","loang;":"\u27EC","loarr;":"\u21FD","lobrk;":"\u27E6","longleftarrow;":"\u27F5","LongLeftArrow;":"\u27F5","Longleftarrow;":"\u27F8","longleftrightarrow;":"\u27F7","LongLeftRightArrow;":"\u27F7","Longleftrightarrow;":"\u27FA","longmapsto;":"\u27FC","longrightarrow;":"\u27F6","LongRightArrow;":"\u27F6","Longrightarrow;":"\u27F9","looparrowleft;":"\u21AB","looparrowright;":"\u21AC","lopar;":"\u2985","Lopf;":"\u{1D543}","lopf;":"\u{1D55D}","loplus;":"\u2A2D","lotimes;":"\u2A34","lowast;":"\u2217","lowbar;":"_","LowerLeftArrow;":"\u2199","LowerRightArrow;":"\u2198","loz;":"\u25CA","lozenge;":"\u25CA","lozf;":"\u29EB","lpar;":"(","lparlt;":"\u2993","lrarr;":"\u21C6","lrcorner;":"\u231F","lrhar;":"\u21CB","lrhard;":"\u296D","lrm;":"\u200E","lrtri;":"\u22BF","lsaquo;":"\u2039","lscr;":"\u{1D4C1}","Lscr;":"\u2112","lsh;":"\u21B0","Lsh;":"\u21B0","lsim;":"\u2272","lsime;":"\u2A8D","lsimg;":"\u2A8F","lsqb;":"[","lsquo;":"\u2018","lsquor;":"\u201A","Lstrok;":"\u0141","lstrok;":"\u0142","ltcc;":"\u2AA6","ltcir;":"\u2A79","lt;":"<",lt:"<","LT;":"<",LT:"<","Lt;":"\u226A","ltdot;":"\u22D6","lthree;":"\u22CB","ltimes;":"\u22C9","ltlarr;":"\u2976","ltquest;":"\u2A7B","ltri;":"\u25C3","ltrie;":"\u22B4","ltrif;":"\u25C2","ltrPar;":"\u2996","lurdshar;":"\u294A","luruhar;":"\u2966","lvertneqq;":"\u2268\uFE00","lvnE;":"\u2268\uFE00","macr;":"\xAF",macr:"\xAF","male;":"\u2642","malt;":"\u2720","maltese;":"\u2720","Map;":"\u2905","map;":"\u21A6","mapsto;":"\u21A6","mapstodown;":"\u21A7","mapstoleft;":"\u21A4","mapstoup;":"\u21A5","marker;":"\u25AE","mcomma;":"\u2A29","Mcy;":"\u041C","mcy;":"\u043C","mdash;":"\u2014","mDDot;":"\u223A","measuredangle;":"\u2221","MediumSpace;":"\u205F","Mellintrf;":"\u2133","Mfr;":"\u{1D510}","mfr;":"\u{1D52A}","mho;":"\u2127","micro;":"\xB5",micro:"\xB5","midast;":"*","midcir;":"\u2AF0","mid;":"\u2223","middot;":"\xB7",middot:"\xB7","minusb;":"\u229F","minus;":"\u2212","minusd;":"\u2238","minusdu;":"\u2A2A","MinusPlus;":"\u2213","mlcp;":"\u2ADB","mldr;":"\u2026","mnplus;":"\u2213","models;":"\u22A7","Mopf;":"\u{1D544}","mopf;":"\u{1D55E}","mp;":"\u2213","mscr;":"\u{1D4C2}","Mscr;":"\u2133","mstpos;":"\u223E","Mu;":"\u039C","mu;":"\u03BC","multimap;":"\u22B8","mumap;":"\u22B8","nabla;":"\u2207","Nacute;":"\u0143","nacute;":"\u0144","nang;":"\u2220\u20D2","nap;":"\u2249","napE;":"\u2A70\u0338","napid;":"\u224B\u0338","napos;":"\u0149","napprox;":"\u2249","natural;":"\u266E","naturals;":"\u2115","natur;":"\u266E","nbsp;":"\xA0",nbsp:"\xA0","nbump;":"\u224E\u0338","nbumpe;":"\u224F\u0338","ncap;":"\u2A43","Ncaron;":"\u0147","ncaron;":"\u0148","Ncedil;":"\u0145","ncedil;":"\u0146","ncong;":"\u2247","ncongdot;":"\u2A6D\u0338","ncup;":"\u2A42","Ncy;":"\u041D","ncy;":"\u043D","ndash;":"\u2013","nearhk;":"\u2924","nearr;":"\u2197","neArr;":"\u21D7","nearrow;":"\u2197","ne;":"\u2260","nedot;":"\u2250\u0338","NegativeMediumSpace;":"\u200B","NegativeThickSpace;":"\u200B","NegativeThinSpace;":"\u200B","NegativeVeryThinSpace;":"\u200B","nequiv;":"\u2262","nesear;":"\u2928","nesim;":"\u2242\u0338","NestedGreaterGreater;":"\u226B","NestedLessLess;":"\u226A","NewLine;":"\\n","nexist;":"\u2204","nexists;":"\u2204","Nfr;":"\u{1D511}","nfr;":"\u{1D52B}","ngE;":"\u2267\u0338","nge;":"\u2271","ngeq;":"\u2271","ngeqq;":"\u2267\u0338","ngeqslant;":"\u2A7E\u0338","nges;":"\u2A7E\u0338","nGg;":"\u22D9\u0338","ngsim;":"\u2275","nGt;":"\u226B\u20D2","ngt;":"\u226F","ngtr;":"\u226F","nGtv;":"\u226B\u0338","nharr;":"\u21AE","nhArr;":"\u21CE","nhpar;":"\u2AF2","ni;":"\u220B","nis;":"\u22FC","nisd;":"\u22FA","niv;":"\u220B","NJcy;":"\u040A","njcy;":"\u045A","nlarr;":"\u219A","nlArr;":"\u21CD","nldr;":"\u2025","nlE;":"\u2266\u0338","nle;":"\u2270","nleftarrow;":"\u219A","nLeftarrow;":"\u21CD","nleftrightarrow;":"\u21AE","nLeftrightarrow;":"\u21CE","nleq;":"\u2270","nleqq;":"\u2266\u0338","nleqslant;":"\u2A7D\u0338","nles;":"\u2A7D\u0338","nless;":"\u226E","nLl;":"\u22D8\u0338","nlsim;":"\u2274","nLt;":"\u226A\u20D2","nlt;":"\u226E","nltri;":"\u22EA","nltrie;":"\u22EC","nLtv;":"\u226A\u0338","nmid;":"\u2224","NoBreak;":"\u2060","NonBreakingSpace;":"\xA0","nopf;":"\u{1D55F}","Nopf;":"\u2115","Not;":"\u2AEC","not;":"\xAC",not:"\xAC","NotCongruent;":"\u2262","NotCupCap;":"\u226D","NotDoubleVerticalBar;":"\u2226","NotElement;":"\u2209","NotEqual;":"\u2260","NotEqualTilde;":"\u2242\u0338","NotExists;":"\u2204","NotGreater;":"\u226F","NotGreaterEqual;":"\u2271","NotGreaterFullEqual;":"\u2267\u0338","NotGreaterGreater;":"\u226B\u0338","NotGreaterLess;":"\u2279","NotGreaterSlantEqual;":"\u2A7E\u0338","NotGreaterTilde;":"\u2275","NotHumpDownHump;":"\u224E\u0338","NotHumpEqual;":"\u224F\u0338","notin;":"\u2209","notindot;":"\u22F5\u0338","notinE;":"\u22F9\u0338","notinva;":"\u2209","notinvb;":"\u22F7","notinvc;":"\u22F6","NotLeftTriangleBar;":"\u29CF\u0338","NotLeftTriangle;":"\u22EA","NotLeftTriangleEqual;":"\u22EC","NotLess;":"\u226E","NotLessEqual;":"\u2270","NotLessGreater;":"\u2278","NotLessLess;":"\u226A\u0338","NotLessSlantEqual;":"\u2A7D\u0338","NotLessTilde;":"\u2274","NotNestedGreaterGreater;":"\u2AA2\u0338","NotNestedLessLess;":"\u2AA1\u0338","notni;":"\u220C","notniva;":"\u220C","notnivb;":"\u22FE","notnivc;":"\u22FD","NotPrecedes;":"\u2280","NotPrecedesEqual;":"\u2AAF\u0338","NotPrecedesSlantEqual;":"\u22E0","NotReverseElement;":"\u220C","NotRightTriangleBar;":"\u29D0\u0338","NotRightTriangle;":"\u22EB","NotRightTriangleEqual;":"\u22ED","NotSquareSubset;":"\u228F\u0338","NotSquareSubsetEqual;":"\u22E2","NotSquareSuperset;":"\u2290\u0338","NotSquareSupersetEqual;":"\u22E3","NotSubset;":"\u2282\u20D2","NotSubsetEqual;":"\u2288","NotSucceeds;":"\u2281","NotSucceedsEqual;":"\u2AB0\u0338","NotSucceedsSlantEqual;":"\u22E1","NotSucceedsTilde;":"\u227F\u0338","NotSuperset;":"\u2283\u20D2","NotSupersetEqual;":"\u2289","NotTilde;":"\u2241","NotTildeEqual;":"\u2244","NotTildeFullEqual;":"\u2247","NotTildeTilde;":"\u2249","NotVerticalBar;":"\u2224","nparallel;":"\u2226","npar;":"\u2226","nparsl;":"\u2AFD\u20E5","npart;":"\u2202\u0338","npolint;":"\u2A14","npr;":"\u2280","nprcue;":"\u22E0","nprec;":"\u2280","npreceq;":"\u2AAF\u0338","npre;":"\u2AAF\u0338","nrarrc;":"\u2933\u0338","nrarr;":"\u219B","nrArr;":"\u21CF","nrarrw;":"\u219D\u0338","nrightarrow;":"\u219B","nRightarrow;":"\u21CF","nrtri;":"\u22EB","nrtrie;":"\u22ED","nsc;":"\u2281","nsccue;":"\u22E1","nsce;":"\u2AB0\u0338","Nscr;":"\u{1D4A9}","nscr;":"\u{1D4C3}","nshortmid;":"\u2224","nshortparallel;":"\u2226","nsim;":"\u2241","nsime;":"\u2244","nsimeq;":"\u2244","nsmid;":"\u2224","nspar;":"\u2226","nsqsube;":"\u22E2","nsqsupe;":"\u22E3","nsub;":"\u2284","nsubE;":"\u2AC5\u0338","nsube;":"\u2288","nsubset;":"\u2282\u20D2","nsubseteq;":"\u2288","nsubseteqq;":"\u2AC5\u0338","nsucc;":"\u2281","nsucceq;":"\u2AB0\u0338","nsup;":"\u2285","nsupE;":"\u2AC6\u0338","nsupe;":"\u2289","nsupset;":"\u2283\u20D2","nsupseteq;":"\u2289","nsupseteqq;":"\u2AC6\u0338","ntgl;":"\u2279","Ntilde;":"\xD1",Ntilde:"\xD1","ntilde;":"\xF1",ntilde:"\xF1","ntlg;":"\u2278","ntriangleleft;":"\u22EA","ntrianglelefteq;":"\u22EC","ntriangleright;":"\u22EB","ntrianglerighteq;":"\u22ED","Nu;":"\u039D","nu;":"\u03BD","num;":"#","numero;":"\u2116","numsp;":"\u2007","nvap;":"\u224D\u20D2","nvdash;":"\u22AC","nvDash;":"\u22AD","nVdash;":"\u22AE","nVDash;":"\u22AF","nvge;":"\u2265\u20D2","nvgt;":">\u20D2","nvHarr;":"\u2904","nvinfin;":"\u29DE","nvlArr;":"\u2902","nvle;":"\u2264\u20D2","nvlt;":"<\u20D2","nvltrie;":"\u22B4\u20D2","nvrArr;":"\u2903","nvrtrie;":"\u22B5\u20D2","nvsim;":"\u223C\u20D2","nwarhk;":"\u2923","nwarr;":"\u2196","nwArr;":"\u21D6","nwarrow;":"\u2196","nwnear;":"\u2927","Oacute;":"\xD3",Oacute:"\xD3","oacute;":"\xF3",oacute:"\xF3","oast;":"\u229B","Ocirc;":"\xD4",Ocirc:"\xD4","ocirc;":"\xF4",ocirc:"\xF4","ocir;":"\u229A","Ocy;":"\u041E","ocy;":"\u043E","odash;":"\u229D","Odblac;":"\u0150","odblac;":"\u0151","odiv;":"\u2A38","odot;":"\u2299","odsold;":"\u29BC","OElig;":"\u0152","oelig;":"\u0153","ofcir;":"\u29BF","Ofr;":"\u{1D512}","ofr;":"\u{1D52C}","ogon;":"\u02DB","Ograve;":"\xD2",Ograve:"\xD2","ograve;":"\xF2",ograve:"\xF2","ogt;":"\u29C1","ohbar;":"\u29B5","ohm;":"\u03A9","oint;":"\u222E","olarr;":"\u21BA","olcir;":"\u29BE","olcross;":"\u29BB","oline;":"\u203E","olt;":"\u29C0","Omacr;":"\u014C","omacr;":"\u014D","Omega;":"\u03A9","omega;":"\u03C9","Omicron;":"\u039F","omicron;":"\u03BF","omid;":"\u29B6","ominus;":"\u2296","Oopf;":"\u{1D546}","oopf;":"\u{1D560}","opar;":"\u29B7","OpenCurlyDoubleQuote;":"\u201C","OpenCurlyQuote;":"\u2018","operp;":"\u29B9","oplus;":"\u2295","orarr;":"\u21BB","Or;":"\u2A54","or;":"\u2228","ord;":"\u2A5D","order;":"\u2134","orderof;":"\u2134","ordf;":"\xAA",ordf:"\xAA","ordm;":"\xBA",ordm:"\xBA","origof;":"\u22B6","oror;":"\u2A56","orslope;":"\u2A57","orv;":"\u2A5B","oS;":"\u24C8","Oscr;":"\u{1D4AA}","oscr;":"\u2134","Oslash;":"\xD8",Oslash:"\xD8","oslash;":"\xF8",oslash:"\xF8","osol;":"\u2298","Otilde;":"\xD5",Otilde:"\xD5","otilde;":"\xF5",otilde:"\xF5","otimesas;":"\u2A36","Otimes;":"\u2A37","otimes;":"\u2297","Ouml;":"\xD6",Ouml:"\xD6","ouml;":"\xF6",ouml:"\xF6","ovbar;":"\u233D","OverBar;":"\u203E","OverBrace;":"\u23DE","OverBracket;":"\u23B4","OverParenthesis;":"\u23DC","para;":"\xB6",para:"\xB6","parallel;":"\u2225","par;":"\u2225","parsim;":"\u2AF3","parsl;":"\u2AFD","part;":"\u2202","PartialD;":"\u2202","Pcy;":"\u041F","pcy;":"\u043F","percnt;":"%","period;":".","permil;":"\u2030","perp;":"\u22A5","pertenk;":"\u2031","Pfr;":"\u{1D513}","pfr;":"\u{1D52D}","Phi;":"\u03A6","phi;":"\u03C6","phiv;":"\u03D5","phmmat;":"\u2133","phone;":"\u260E","Pi;":"\u03A0","pi;":"\u03C0","pitchfork;":"\u22D4","piv;":"\u03D6","planck;":"\u210F","planckh;":"\u210E","plankv;":"\u210F","plusacir;":"\u2A23","plusb;":"\u229E","pluscir;":"\u2A22","plus;":"+","plusdo;":"\u2214","plusdu;":"\u2A25","pluse;":"\u2A72","PlusMinus;":"\xB1","plusmn;":"\xB1",plusmn:"\xB1","plussim;":"\u2A26","plustwo;":"\u2A27","pm;":"\xB1","Poincareplane;":"\u210C","pointint;":"\u2A15","popf;":"\u{1D561}","Popf;":"\u2119","pound;":"\xA3",pound:"\xA3","prap;":"\u2AB7","Pr;":"\u2ABB","pr;":"\u227A","prcue;":"\u227C","precapprox;":"\u2AB7","prec;":"\u227A","preccurlyeq;":"\u227C","Precedes;":"\u227A","PrecedesEqual;":"\u2AAF","PrecedesSlantEqual;":"\u227C","PrecedesTilde;":"\u227E","preceq;":"\u2AAF","precnapprox;":"\u2AB9","precneqq;":"\u2AB5","precnsim;":"\u22E8","pre;":"\u2AAF","prE;":"\u2AB3","precsim;":"\u227E","prime;":"\u2032","Prime;":"\u2033","primes;":"\u2119","prnap;":"\u2AB9","prnE;":"\u2AB5","prnsim;":"\u22E8","prod;":"\u220F","Product;":"\u220F","profalar;":"\u232E","profline;":"\u2312","profsurf;":"\u2313","prop;":"\u221D","Proportional;":"\u221D","Proportion;":"\u2237","propto;":"\u221D","prsim;":"\u227E","prurel;":"\u22B0","Pscr;":"\u{1D4AB}","pscr;":"\u{1D4C5}","Psi;":"\u03A8","psi;":"\u03C8","puncsp;":"\u2008","Qfr;":"\u{1D514}","qfr;":"\u{1D52E}","qint;":"\u2A0C","qopf;":"\u{1D562}","Qopf;":"\u211A","qprime;":"\u2057","Qscr;":"\u{1D4AC}","qscr;":"\u{1D4C6}","quaternions;":"\u210D","quatint;":"\u2A16","quest;":"?","questeq;":"\u225F","quot;":'"',quot:'"',"QUOT;":'"',QUOT:'"',"rAarr;":"\u21DB","race;":"\u223D\u0331","Racute;":"\u0154","racute;":"\u0155","radic;":"\u221A","raemptyv;":"\u29B3","rang;":"\u27E9","Rang;":"\u27EB","rangd;":"\u2992","range;":"\u29A5","rangle;":"\u27E9","raquo;":"\xBB",raquo:"\xBB","rarrap;":"\u2975","rarrb;":"\u21E5","rarrbfs;":"\u2920","rarrc;":"\u2933","rarr;":"\u2192","Rarr;":"\u21A0","rArr;":"\u21D2","rarrfs;":"\u291E","rarrhk;":"\u21AA","rarrlp;":"\u21AC","rarrpl;":"\u2945","rarrsim;":"\u2974","Rarrtl;":"\u2916","rarrtl;":"\u21A3","rarrw;":"\u219D","ratail;":"\u291A","rAtail;":"\u291C","ratio;":"\u2236","rationals;":"\u211A","rbarr;":"\u290D","rBarr;":"\u290F","RBarr;":"\u2910","rbbrk;":"\u2773","rbrace;":"}","rbrack;":"]","rbrke;":"\u298C","rbrksld;":"\u298E","rbrkslu;":"\u2990","Rcaron;":"\u0158","rcaron;":"\u0159","Rcedil;":"\u0156","rcedil;":"\u0157","rceil;":"\u2309","rcub;":"}","Rcy;":"\u0420","rcy;":"\u0440","rdca;":"\u2937","rdldhar;":"\u2969","rdquo;":"\u201D","rdquor;":"\u201D","rdsh;":"\u21B3","real;":"\u211C","realine;":"\u211B","realpart;":"\u211C","reals;":"\u211D","Re;":"\u211C","rect;":"\u25AD","reg;":"\xAE",reg:"\xAE","REG;":"\xAE",REG:"\xAE","ReverseElement;":"\u220B","ReverseEquilibrium;":"\u21CB","ReverseUpEquilibrium;":"\u296F","rfisht;":"\u297D","rfloor;":"\u230B","rfr;":"\u{1D52F}","Rfr;":"\u211C","rHar;":"\u2964","rhard;":"\u21C1","rharu;":"\u21C0","rharul;":"\u296C","Rho;":"\u03A1","rho;":"\u03C1","rhov;":"\u03F1","RightAngleBracket;":"\u27E9","RightArrowBar;":"\u21E5","rightarrow;":"\u2192","RightArrow;":"\u2192","Rightarrow;":"\u21D2","RightArrowLeftArrow;":"\u21C4","rightarrowtail;":"\u21A3","RightCeiling;":"\u2309","RightDoubleBracket;":"\u27E7","RightDownTeeVector;":"\u295D","RightDownVectorBar;":"\u2955","RightDownVector;":"\u21C2","RightFloor;":"\u230B","rightharpoondown;":"\u21C1","rightharpoonup;":"\u21C0","rightleftarrows;":"\u21C4","rightleftharpoons;":"\u21CC","rightrightarrows;":"\u21C9","rightsquigarrow;":"\u219D","RightTeeArrow;":"\u21A6","RightTee;":"\u22A2","RightTeeVector;":"\u295B","rightthreetimes;":"\u22CC","RightTriangleBar;":"\u29D0","RightTriangle;":"\u22B3","RightTriangleEqual;":"\u22B5","RightUpDownVector;":"\u294F","RightUpTeeVector;":"\u295C","RightUpVectorBar;":"\u2954","RightUpVector;":"\u21BE","RightVectorBar;":"\u2953","RightVector;":"\u21C0","ring;":"\u02DA","risingdotseq;":"\u2253","rlarr;":"\u21C4","rlhar;":"\u21CC","rlm;":"\u200F","rmoustache;":"\u23B1","rmoust;":"\u23B1","rnmid;":"\u2AEE","roang;":"\u27ED","roarr;":"\u21FE","robrk;":"\u27E7","ropar;":"\u2986","ropf;":"\u{1D563}","Ropf;":"\u211D","roplus;":"\u2A2E","rotimes;":"\u2A35","RoundImplies;":"\u2970","rpar;":")","rpargt;":"\u2994","rppolint;":"\u2A12","rrarr;":"\u21C9","Rrightarrow;":"\u21DB","rsaquo;":"\u203A","rscr;":"\u{1D4C7}","Rscr;":"\u211B","rsh;":"\u21B1","Rsh;":"\u21B1","rsqb;":"]","rsquo;":"\u2019","rsquor;":"\u2019","rthree;":"\u22CC","rtimes;":"\u22CA","rtri;":"\u25B9","rtrie;":"\u22B5","rtrif;":"\u25B8","rtriltri;":"\u29CE","RuleDelayed;":"\u29F4","ruluhar;":"\u2968","rx;":"\u211E","Sacute;":"\u015A","sacute;":"\u015B","sbquo;":"\u201A","scap;":"\u2AB8","Scaron;":"\u0160","scaron;":"\u0161","Sc;":"\u2ABC","sc;":"\u227B","sccue;":"\u227D","sce;":"\u2AB0","scE;":"\u2AB4","Scedil;":"\u015E","scedil;":"\u015F","Scirc;":"\u015C","scirc;":"\u015D","scnap;":"\u2ABA","scnE;":"\u2AB6","scnsim;":"\u22E9","scpolint;":"\u2A13","scsim;":"\u227F","Scy;":"\u0421","scy;":"\u0441","sdotb;":"\u22A1","sdot;":"\u22C5","sdote;":"\u2A66","searhk;":"\u2925","searr;":"\u2198","seArr;":"\u21D8","searrow;":"\u2198","sect;":"\xA7",sect:"\xA7","semi;":";","seswar;":"\u2929","setminus;":"\u2216","setmn;":"\u2216","sext;":"\u2736","Sfr;":"\u{1D516}","sfr;":"\u{1D530}","sfrown;":"\u2322","sharp;":"\u266F","SHCHcy;":"\u0429","shchcy;":"\u0449","SHcy;":"\u0428","shcy;":"\u0448","ShortDownArrow;":"\u2193","ShortLeftArrow;":"\u2190","shortmid;":"\u2223","shortparallel;":"\u2225","ShortRightArrow;":"\u2192","ShortUpArrow;":"\u2191","shy;":"\xAD",shy:"\xAD","Sigma;":"\u03A3","sigma;":"\u03C3","sigmaf;":"\u03C2","sigmav;":"\u03C2","sim;":"\u223C","simdot;":"\u2A6A","sime;":"\u2243","simeq;":"\u2243","simg;":"\u2A9E","simgE;":"\u2AA0","siml;":"\u2A9D","simlE;":"\u2A9F","simne;":"\u2246","simplus;":"\u2A24","simrarr;":"\u2972","slarr;":"\u2190","SmallCircle;":"\u2218","smallsetminus;":"\u2216","smashp;":"\u2A33","smeparsl;":"\u29E4","smid;":"\u2223","smile;":"\u2323","smt;":"\u2AAA","smte;":"\u2AAC","smtes;":"\u2AAC\uFE00","SOFTcy;":"\u042C","softcy;":"\u044C","solbar;":"\u233F","solb;":"\u29C4","sol;":"/","Sopf;":"\u{1D54A}","sopf;":"\u{1D564}","spades;":"\u2660","spadesuit;":"\u2660","spar;":"\u2225","sqcap;":"\u2293","sqcaps;":"\u2293\uFE00","sqcup;":"\u2294","sqcups;":"\u2294\uFE00","Sqrt;":"\u221A","sqsub;":"\u228F","sqsube;":"\u2291","sqsubset;":"\u228F","sqsubseteq;":"\u2291","sqsup;":"\u2290","sqsupe;":"\u2292","sqsupset;":"\u2290","sqsupseteq;":"\u2292","square;":"\u25A1","Square;":"\u25A1","SquareIntersection;":"\u2293","SquareSubset;":"\u228F","SquareSubsetEqual;":"\u2291","SquareSuperset;":"\u2290","SquareSupersetEqual;":"\u2292","SquareUnion;":"\u2294","squarf;":"\u25AA","squ;":"\u25A1","squf;":"\u25AA","srarr;":"\u2192","Sscr;":"\u{1D4AE}","sscr;":"\u{1D4C8}","ssetmn;":"\u2216","ssmile;":"\u2323","sstarf;":"\u22C6","Star;":"\u22C6","star;":"\u2606","starf;":"\u2605","straightepsilon;":"\u03F5","straightphi;":"\u03D5","strns;":"\xAF","sub;":"\u2282","Sub;":"\u22D0","subdot;":"\u2ABD","subE;":"\u2AC5","sube;":"\u2286","subedot;":"\u2AC3","submult;":"\u2AC1","subnE;":"\u2ACB","subne;":"\u228A","subplus;":"\u2ABF","subrarr;":"\u2979","subset;":"\u2282","Subset;":"\u22D0","subseteq;":"\u2286","subseteqq;":"\u2AC5","SubsetEqual;":"\u2286","subsetneq;":"\u228A","subsetneqq;":"\u2ACB","subsim;":"\u2AC7","subsub;":"\u2AD5","subsup;":"\u2AD3","succapprox;":"\u2AB8","succ;":"\u227B","succcurlyeq;":"\u227D","Succeeds;":"\u227B","SucceedsEqual;":"\u2AB0","SucceedsSlantEqual;":"\u227D","SucceedsTilde;":"\u227F","succeq;":"\u2AB0","succnapprox;":"\u2ABA","succneqq;":"\u2AB6","succnsim;":"\u22E9","succsim;":"\u227F","SuchThat;":"\u220B","sum;":"\u2211","Sum;":"\u2211","sung;":"\u266A","sup1;":"\xB9",sup1:"\xB9","sup2;":"\xB2",sup2:"\xB2","sup3;":"\xB3",sup3:"\xB3","sup;":"\u2283","Sup;":"\u22D1","supdot;":"\u2ABE","supdsub;":"\u2AD8","supE;":"\u2AC6","supe;":"\u2287","supedot;":"\u2AC4","Superset;":"\u2283","SupersetEqual;":"\u2287","suphsol;":"\u27C9","suphsub;":"\u2AD7","suplarr;":"\u297B","supmult;":"\u2AC2","supnE;":"\u2ACC","supne;":"\u228B","supplus;":"\u2AC0","supset;":"\u2283","Supset;":"\u22D1","supseteq;":"\u2287","supseteqq;":"\u2AC6","supsetneq;":"\u228B","supsetneqq;":"\u2ACC","supsim;":"\u2AC8","supsub;":"\u2AD4","supsup;":"\u2AD6","swarhk;":"\u2926","swarr;":"\u2199","swArr;":"\u21D9","swarrow;":"\u2199","swnwar;":"\u292A","szlig;":"\xDF",szlig:"\xDF","Tab;":"	","target;":"\u2316","Tau;":"\u03A4","tau;":"\u03C4","tbrk;":"\u23B4","Tcaron;":"\u0164","tcaron;":"\u0165","Tcedil;":"\u0162","tcedil;":"\u0163","Tcy;":"\u0422","tcy;":"\u0442","tdot;":"\u20DB","telrec;":"\u2315","Tfr;":"\u{1D517}","tfr;":"\u{1D531}","there4;":"\u2234","therefore;":"\u2234","Therefore;":"\u2234","Theta;":"\u0398","theta;":"\u03B8","thetasym;":"\u03D1","thetav;":"\u03D1","thickapprox;":"\u2248","thicksim;":"\u223C","ThickSpace;":"\u205F\u200A","ThinSpace;":"\u2009","thinsp;":"\u2009","thkap;":"\u2248","thksim;":"\u223C","THORN;":"\xDE",THORN:"\xDE","thorn;":"\xFE",thorn:"\xFE","tilde;":"\u02DC","Tilde;":"\u223C","TildeEqual;":"\u2243","TildeFullEqual;":"\u2245","TildeTilde;":"\u2248","timesbar;":"\u2A31","timesb;":"\u22A0","times;":"\xD7",times:"\xD7","timesd;":"\u2A30","tint;":"\u222D","toea;":"\u2928","topbot;":"\u2336","topcir;":"\u2AF1","top;":"\u22A4","Topf;":"\u{1D54B}","topf;":"\u{1D565}","topfork;":"\u2ADA","tosa;":"\u2929","tprime;":"\u2034","trade;":"\u2122","TRADE;":"\u2122","triangle;":"\u25B5","triangledown;":"\u25BF","triangleleft;":"\u25C3","trianglelefteq;":"\u22B4","triangleq;":"\u225C","triangleright;":"\u25B9","trianglerighteq;":"\u22B5","tridot;":"\u25EC","trie;":"\u225C","triminus;":"\u2A3A","TripleDot;":"\u20DB","triplus;":"\u2A39","trisb;":"\u29CD","tritime;":"\u2A3B","trpezium;":"\u23E2","Tscr;":"\u{1D4AF}","tscr;":"\u{1D4C9}","TScy;":"\u0426","tscy;":"\u0446","TSHcy;":"\u040B","tshcy;":"\u045B","Tstrok;":"\u0166","tstrok;":"\u0167","twixt;":"\u226C","twoheadleftarrow;":"\u219E","twoheadrightarrow;":"\u21A0","Uacute;":"\xDA",Uacute:"\xDA","uacute;":"\xFA",uacute:"\xFA","uarr;":"\u2191","Uarr;":"\u219F","uArr;":"\u21D1","Uarrocir;":"\u2949","Ubrcy;":"\u040E","ubrcy;":"\u045E","Ubreve;":"\u016C","ubreve;":"\u016D","Ucirc;":"\xDB",Ucirc:"\xDB","ucirc;":"\xFB",ucirc:"\xFB","Ucy;":"\u0423","ucy;":"\u0443","udarr;":"\u21C5","Udblac;":"\u0170","udblac;":"\u0171","udhar;":"\u296E","ufisht;":"\u297E","Ufr;":"\u{1D518}","ufr;":"\u{1D532}","Ugrave;":"\xD9",Ugrave:"\xD9","ugrave;":"\xF9",ugrave:"\xF9","uHar;":"\u2963","uharl;":"\u21BF","uharr;":"\u21BE","uhblk;":"\u2580","ulcorn;":"\u231C","ulcorner;":"\u231C","ulcrop;":"\u230F","ultri;":"\u25F8","Umacr;":"\u016A","umacr;":"\u016B","uml;":"\xA8",uml:"\xA8","UnderBar;":"_","UnderBrace;":"\u23DF","UnderBracket;":"\u23B5","UnderParenthesis;":"\u23DD","Union;":"\u22C3","UnionPlus;":"\u228E","Uogon;":"\u0172","uogon;":"\u0173","Uopf;":"\u{1D54C}","uopf;":"\u{1D566}","UpArrowBar;":"\u2912","uparrow;":"\u2191","UpArrow;":"\u2191","Uparrow;":"\u21D1","UpArrowDownArrow;":"\u21C5","updownarrow;":"\u2195","UpDownArrow;":"\u2195","Updownarrow;":"\u21D5","UpEquilibrium;":"\u296E","upharpoonleft;":"\u21BF","upharpoonright;":"\u21BE","uplus;":"\u228E","UpperLeftArrow;":"\u2196","UpperRightArrow;":"\u2197","upsi;":"\u03C5","Upsi;":"\u03D2","upsih;":"\u03D2","Upsilon;":"\u03A5","upsilon;":"\u03C5","UpTeeArrow;":"\u21A5","UpTee;":"\u22A5","upuparrows;":"\u21C8","urcorn;":"\u231D","urcorner;":"\u231D","urcrop;":"\u230E","Uring;":"\u016E","uring;":"\u016F","urtri;":"\u25F9","Uscr;":"\u{1D4B0}","uscr;":"\u{1D4CA}","utdot;":"\u22F0","Utilde;":"\u0168","utilde;":"\u0169","utri;":"\u25B5","utrif;":"\u25B4","uuarr;":"\u21C8","Uuml;":"\xDC",Uuml:"\xDC","uuml;":"\xFC",uuml:"\xFC","uwangle;":"\u29A7","vangrt;":"\u299C","varepsilon;":"\u03F5","varkappa;":"\u03F0","varnothing;":"\u2205","varphi;":"\u03D5","varpi;":"\u03D6","varpropto;":"\u221D","varr;":"\u2195","vArr;":"\u21D5","varrho;":"\u03F1","varsigma;":"\u03C2","varsubsetneq;":"\u228A\uFE00","varsubsetneqq;":"\u2ACB\uFE00","varsupsetneq;":"\u228B\uFE00","varsupsetneqq;":"\u2ACC\uFE00","vartheta;":"\u03D1","vartriangleleft;":"\u22B2","vartriangleright;":"\u22B3","vBar;":"\u2AE8","Vbar;":"\u2AEB","vBarv;":"\u2AE9","Vcy;":"\u0412","vcy;":"\u0432","vdash;":"\u22A2","vDash;":"\u22A8","Vdash;":"\u22A9","VDash;":"\u22AB","Vdashl;":"\u2AE6","veebar;":"\u22BB","vee;":"\u2228","Vee;":"\u22C1","veeeq;":"\u225A","vellip;":"\u22EE","verbar;":"|","Verbar;":"\u2016","vert;":"|","Vert;":"\u2016","VerticalBar;":"\u2223","VerticalLine;":"|","VerticalSeparator;":"\u2758","VerticalTilde;":"\u2240","VeryThinSpace;":"\u200A","Vfr;":"\u{1D519}","vfr;":"\u{1D533}","vltri;":"\u22B2","vnsub;":"\u2282\u20D2","vnsup;":"\u2283\u20D2","Vopf;":"\u{1D54D}","vopf;":"\u{1D567}","vprop;":"\u221D","vrtri;":"\u22B3","Vscr;":"\u{1D4B1}","vscr;":"\u{1D4CB}","vsubnE;":"\u2ACB\uFE00","vsubne;":"\u228A\uFE00","vsupnE;":"\u2ACC\uFE00","vsupne;":"\u228B\uFE00","Vvdash;":"\u22AA","vzigzag;":"\u299A","Wcirc;":"\u0174","wcirc;":"\u0175","wedbar;":"\u2A5F","wedge;":"\u2227","Wedge;":"\u22C0","wedgeq;":"\u2259","weierp;":"\u2118","Wfr;":"\u{1D51A}","wfr;":"\u{1D534}","Wopf;":"\u{1D54E}","wopf;":"\u{1D568}","wp;":"\u2118","wr;":"\u2240","wreath;":"\u2240","Wscr;":"\u{1D4B2}","wscr;":"\u{1D4CC}","xcap;":"\u22C2","xcirc;":"\u25EF","xcup;":"\u22C3","xdtri;":"\u25BD","Xfr;":"\u{1D51B}","xfr;":"\u{1D535}","xharr;":"\u27F7","xhArr;":"\u27FA","Xi;":"\u039E","xi;":"\u03BE","xlarr;":"\u27F5","xlArr;":"\u27F8","xmap;":"\u27FC","xnis;":"\u22FB","xodot;":"\u2A00","Xopf;":"\u{1D54F}","xopf;":"\u{1D569}","xoplus;":"\u2A01","xotime;":"\u2A02","xrarr;":"\u27F6","xrArr;":"\u27F9","Xscr;":"\u{1D4B3}","xscr;":"\u{1D4CD}","xsqcup;":"\u2A06","xuplus;":"\u2A04","xutri;":"\u25B3","xvee;":"\u22C1","xwedge;":"\u22C0","Yacute;":"\xDD",Yacute:"\xDD","yacute;":"\xFD",yacute:"\xFD","YAcy;":"\u042F","yacy;":"\u044F","Ycirc;":"\u0176","ycirc;":"\u0177","Ycy;":"\u042B","ycy;":"\u044B","yen;":"\xA5",yen:"\xA5","Yfr;":"\u{1D51C}","yfr;":"\u{1D536}","YIcy;":"\u0407","yicy;":"\u0457","Yopf;":"\u{1D550}","yopf;":"\u{1D56A}","Yscr;":"\u{1D4B4}","yscr;":"\u{1D4CE}","YUcy;":"\u042E","yucy;":"\u044E","yuml;":"\xFF",yuml:"\xFF","Yuml;":"\u0178","Zacute;":"\u0179","zacute;":"\u017A","Zcaron;":"\u017D","zcaron;":"\u017E","Zcy;":"\u0417","zcy;":"\u0437","Zdot;":"\u017B","zdot;":"\u017C","zeetrf;":"\u2128","ZeroWidthSpace;":"\u200B","Zeta;":"\u0396","zeta;":"\u03B6","zfr;":"\u{1D537}","Zfr;":"\u2128","ZHcy;":"\u0416","zhcy;":"\u0436","zigrarr;":"\u21DD","zopf;":"\u{1D56B}","Zopf;":"\u2124","Zscr;":"\u{1D4B5}","zscr;":"\u{1D4CF}","zwj;":"\u200D","zwnj;":"\u200C"}
},{}],13:[function(_dereq_,module){function replacer(key,value){return util.isUndefined(value)?""+value:!util.isNumber(value)||!isNaN(value)&&isFinite(value)?util.isFunction(value)||util.isRegExp(value)?""+value:value:""+value}function truncate(s,n){return util.isString(s)?n>s.length?s:s.slice(0,n):s}function getMessage(self){return truncate(JSON.stringify(self.actual,replacer),128)+" "+self.operator+" "+truncate(JSON.stringify(self.expected,replacer),128)}function fail(actual,expected,message,operator,stackStartFunction){throw new assert.AssertionError({message:message,actual:actual,expected:expected,operator:operator,stackStartFunction:stackStartFunction})}function ok(value,message){value||fail(value,!0,message,"==",assert.ok)}function _deepEqual(actual,expected){if(actual===expected)return!0;if(util.isBuffer(actual)&&util.isBuffer(expected)){if(actual.length!=expected.length)return!1;for(var i=0;actual.length>i;i++)if(actual[i]!==expected[i])return!1;return!0}return util.isDate(actual)&&util.isDate(expected)?actual.getTime()===expected.getTime():util.isRegExp(actual)&&util.isRegExp(expected)?actual.source===expected.source&&actual.global===expected.global&&actual.multiline===expected.multiline&&actual.lastIndex===expected.lastIndex&&actual.ignoreCase===expected.ignoreCase:util.isObject(actual)||util.isObject(expected)?objEquiv(actual,expected):actual==expected}function isArguments(object){return"[object Arguments]"==Object.prototype.toString.call(object)}function objEquiv(a,b){if(util.isNullOrUndefined(a)||util.isNullOrUndefined(b))return!1;if(a.prototype!==b.prototype)return!1;if(isArguments(a))return isArguments(b)?(a=pSlice.call(a),b=pSlice.call(b),_deepEqual(a,b)):!1;try{var key,i,ka=objectKeys(a),kb=objectKeys(b)}catch(e){return!1}if(ka.length!=kb.length)return!1;for(ka.sort(),kb.sort(),i=ka.length-1;i>=0;i--)if(ka[i]!=kb[i])return!1;for(i=ka.length-1;i>=0;i--)if(key=ka[i],!_deepEqual(a[key],b[key]))return!1;return!0}function expectedException(actual,expected){return actual&&expected?"[object RegExp]"==Object.prototype.toString.call(expected)?expected.test(actual):actual instanceof expected?!0:expected.call({},actual)===!0?!0:!1:!1}function _throws(shouldThrow,block,expected,message){var actual;util.isString(expected)&&(message=expected,expected=null);try{block()}catch(e){actual=e}if(message=(expected&&expected.name?" ("+expected.name+").":".")+(message?" "+message:"."),shouldThrow&&!actual&&fail(actual,expected,"Missing expected exception"+message),!shouldThrow&&expectedException(actual,expected)&&fail(actual,expected,"Got unwanted exception"+message),shouldThrow&&actual&&expected&&!expectedException(actual,expected)||!shouldThrow&&actual)throw actual}var util=_dereq_("util/"),pSlice=Array.prototype.slice,hasOwn=Object.prototype.hasOwnProperty,assert=module.exports=ok;assert.AssertionError=function(options){this.name="AssertionError",this.actual=options.actual,this.expected=options.expected,this.operator=options.operator,options.message?(this.message=options.message,this.generatedMessage=!1):(this.message=getMessage(this),this.generatedMessage=!0);var stackStartFunction=options.stackStartFunction||fail;if(Error.captureStackTrace)Error.captureStackTrace(this,stackStartFunction);else{var err=Error();if(err.stack){var out=err.stack,fn_name=stackStartFunction.name,idx=out.indexOf("\\n"+fn_name);if(idx>=0){var next_line=out.indexOf("\\n",idx+1);out=out.substring(next_line+1)}this.stack=out}}},util.inherits(assert.AssertionError,Error),assert.fail=fail,assert.ok=ok,assert.equal=function(actual,expected,message){actual!=expected&&fail(actual,expected,message,"==",assert.equal)},assert.notEqual=function(actual,expected,message){actual==expected&&fail(actual,expected,message,"!=",assert.notEqual)},assert.deepEqual=function(actual,expected,message){_deepEqual(actual,expected)||fail(actual,expected,message,"deepEqual",assert.deepEqual)},assert.notDeepEqual=function(actual,expected,message){_deepEqual(actual,expected)&&fail(actual,expected,message,"notDeepEqual",assert.notDeepEqual)},assert.strictEqual=function(actual,expected,message){actual!==expected&&fail(actual,expected,message,"===",assert.strictEqual)},assert.notStrictEqual=function(actual,expected,message){actual===expected&&fail(actual,expected,message,"!==",assert.notStrictEqual)},assert.throws=function(){_throws.apply(this,[!0].concat(pSlice.call(arguments)))},assert.doesNotThrow=function(){_throws.apply(this,[!1].concat(pSlice.call(arguments)))},assert.ifError=function(err){if(err)throw err};var objectKeys=Object.keys||function(obj){var keys=[];for(var key in obj)hasOwn.call(obj,key)&&keys.push(key);return keys}},{"util/":15}],14:[function(_dereq_,module){module.exports=function(arg){return arg&&"object"==typeof arg&&"function"==typeof arg.copy&&"function"==typeof arg.fill&&"function"==typeof arg.readUInt8}},{}],15:[function(_dereq_,module,exports){(function(process,global){function inspect(obj,opts){var ctx={seen:[],stylize:stylizeNoColor};return arguments.length>=3&&(ctx.depth=arguments[2]),arguments.length>=4&&(ctx.colors=arguments[3]),isBoolean(opts)?ctx.showHidden=opts:opts&&exports._extend(ctx,opts),isUndefined(ctx.showHidden)&&(ctx.showHidden=!1),isUndefined(ctx.depth)&&(ctx.depth=2),isUndefined(ctx.colors)&&(ctx.colors=!1),isUndefined(ctx.customInspect)&&(ctx.customInspect=!0),ctx.colors&&(ctx.stylize=stylizeWithColor),formatValue(ctx,obj,ctx.depth)}function stylizeWithColor(str,styleType){var style=inspect.styles[styleType];return style?"\x1B["+inspect.colors[style][0]+"m"+str+"\x1B["+inspect.colors[style][1]+"m":str}function stylizeNoColor(str){return str}function arrayToHash(array){var hash={};return array.forEach(function(val){hash[val]=!0}),hash}function formatValue(ctx,value,recurseTimes){if(ctx.customInspect&&value&&isFunction(value.inspect)&&value.inspect!==exports.inspect&&(!value.constructor||value.constructor.prototype!==value)){var ret=value.inspect(recurseTimes,ctx);return isString(ret)||(ret=formatValue(ctx,ret,recurseTimes)),ret}var primitive=formatPrimitive(ctx,value);if(primitive)return primitive;var keys=Object.keys(value),visibleKeys=arrayToHash(keys);if(ctx.showHidden&&(keys=Object.getOwnPropertyNames(value)),isError(value)&&(keys.indexOf("message")>=0||keys.indexOf("description")>=0))return formatError(value);if(0===keys.length){if(isFunction(value)){var name=value.name?": "+value.name:"";return ctx.stylize("[Function"+name+"]","special")}if(isRegExp(value))return ctx.stylize(RegExp.prototype.toString.call(value),"regexp");if(isDate(value))return ctx.stylize(Date.prototype.toString.call(value),"date");if(isError(value))return formatError(value)}var base="",array=!1,braces=["{","}"];if(isArray(value)&&(array=!0,braces=["[","]"]),isFunction(value)){var n=value.name?": "+value.name:"";base=" [Function"+n+"]"}if(isRegExp(value)&&(base=" "+RegExp.prototype.toString.call(value)),isDate(value)&&(base=" "+Date.prototype.toUTCString.call(value)),isError(value)&&(base=" "+formatError(value)),0===keys.length&&(!array||0==value.length))return braces[0]+base+braces[1];if(0>recurseTimes)return isRegExp(value)?ctx.stylize(RegExp.prototype.toString.call(value),"regexp"):ctx.stylize("[Object]","special");ctx.seen.push(value);var output;return output=array?formatArray(ctx,value,recurseTimes,visibleKeys,keys):keys.map(function(key){return formatProperty(ctx,value,recurseTimes,visibleKeys,key,array)}),ctx.seen.pop(),reduceToSingleString(output,base,braces)}function formatPrimitive(ctx,value){if(isUndefined(value))return ctx.stylize("undefined","undefined");if(isString(value)){var simple="'"+JSON.stringify(value).replace(/^"|"$/g,"").replace(/'/g,"\\\\'").replace(/\\\\"/g,'"')+"'";return ctx.stylize(simple,"string")}return isNumber(value)?ctx.stylize(""+value,"number"):isBoolean(value)?ctx.stylize(""+value,"boolean"):isNull(value)?ctx.stylize("null","null"):void 0}function formatError(value){return"["+Error.prototype.toString.call(value)+"]"}function formatArray(ctx,value,recurseTimes,visibleKeys,keys){for(var output=[],i=0,l=value.length;l>i;++i)hasOwnProperty(value,i+"")?output.push(formatProperty(ctx,value,recurseTimes,visibleKeys,i+"",!0)):output.push("");return keys.forEach(function(key){key.match(/^\\d+$/)||output.push(formatProperty(ctx,value,recurseTimes,visibleKeys,key,!0))}),output}function formatProperty(ctx,value,recurseTimes,visibleKeys,key,array){var name,str,desc;if(desc=Object.getOwnPropertyDescriptor(value,key)||{value:value[key]},desc.get?str=desc.set?ctx.stylize("[Getter/Setter]","special"):ctx.stylize("[Getter]","special"):desc.set&&(str=ctx.stylize("[Setter]","special")),hasOwnProperty(visibleKeys,key)||(name="["+key+"]"),str||(0>ctx.seen.indexOf(desc.value)?(str=isNull(recurseTimes)?formatValue(ctx,desc.value,null):formatValue(ctx,desc.value,recurseTimes-1),str.indexOf("\\n")>-1&&(str=array?str.split("\\n").map(function(line){return"  "+line}).join("\\n").substr(2):"\\n"+str.split("\\n").map(function(line){return"   "+line}).join("\\n"))):str=ctx.stylize("[Circular]","special")),isUndefined(name)){if(array&&key.match(/^\\d+$/))return str;name=JSON.stringify(""+key),name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(name=name.substr(1,name.length-2),name=ctx.stylize(name,"name")):(name=name.replace(/'/g,"\\\\'").replace(/\\\\"/g,'"').replace(/(^"|"$)/g,"'"),name=ctx.stylize(name,"string"))}return name+": "+str}function reduceToSingleString(output,base,braces){var numLinesEst=0,length=output.reduce(function(prev,cur){return numLinesEst++,cur.indexOf("\\n")>=0&&numLinesEst++,prev+cur.replace(/\\u001b\\[\\d\\d?m/g,"").length+1},0);return length>60?braces[0]+(""===base?"":base+"\\n ")+" "+output.join(",\\n  ")+" "+braces[1]:braces[0]+base+" "+output.join(", ")+" "+braces[1]}function isArray(ar){return Array.isArray(ar)}function isBoolean(arg){return"boolean"==typeof arg}function isNull(arg){return null===arg}function isNullOrUndefined(arg){return null==arg}function isNumber(arg){return"number"==typeof arg}function isString(arg){return"string"==typeof arg}function isSymbol(arg){return"symbol"==typeof arg}function isUndefined(arg){return void 0===arg}function isRegExp(re){return isObject(re)&&"[object RegExp]"===objectToString(re)}function isObject(arg){return"object"==typeof arg&&null!==arg}function isDate(d){return isObject(d)&&"[object Date]"===objectToString(d)}function isError(e){return isObject(e)&&("[object Error]"===objectToString(e)||e instanceof Error)}function isFunction(arg){return"function"==typeof arg}function isPrimitive(arg){return null===arg||"boolean"==typeof arg||"number"==typeof arg||"string"==typeof arg||"symbol"==typeof arg||arg===void 0}function objectToString(o){return Object.prototype.toString.call(o)}function pad(n){return 10>n?"0"+n.toString(10):n.toString(10)}function timestamp(){var d=new Date,time=[pad(d.getHours()),pad(d.getMinutes()),pad(d.getSeconds())].join(":");return[d.getDate(),months[d.getMonth()],time].join(" ")}function hasOwnProperty(obj,prop){return Object.prototype.hasOwnProperty.call(obj,prop)}var formatRegExp=/%[sdj%]/g;exports.format=function(f){if(!isString(f)){for(var objects=[],i=0;arguments.length>i;i++)objects.push(inspect(arguments[i]));return objects.join(" ")}for(var i=1,args=arguments,len=args.length,str=(f+"").replace(formatRegExp,function(x){if("%%"===x)return"%";if(i>=len)return x;switch(x){case"%s":return args[i++]+"";case"%d":return Number(args[i++]);case"%j":try{return JSON.stringify(args[i++])}catch(_){return"[Circular]"}default:return x}}),x=args[i];len>i;x=args[++i])str+=isNull(x)||!isObject(x)?" "+x:" "+inspect(x);return str},exports.deprecate=function(fn,msg){function deprecated(){if(!warned){if(process.throwDeprecation)throw Error(msg);process.traceDeprecation?console.trace(msg):console.error(msg),warned=!0}return fn.apply(this,arguments)}if(isUndefined(global.process))return function(){return exports.deprecate(fn,msg).apply(this,arguments)};if(process.noDeprecation===!0)return fn;var warned=!1;return deprecated};var debugEnviron,debugs={};exports.debuglog=function(set){if(isUndefined(debugEnviron)&&(debugEnviron=process.env.NODE_DEBUG||""),set=set.toUpperCase(),!debugs[set])if(RegExp("\\\\b"+set+"\\\\b","i").test(debugEnviron)){var pid=process.pid;debugs[set]=function(){var msg=exports.format.apply(exports,arguments);console.error("%s %d: %s",set,pid,msg)}}else debugs[set]=function(){};return debugs[set]},exports.inspect=inspect,inspect.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},inspect.styles={special:"cyan",number:"yellow","boolean":"yellow",undefined:"grey","null":"bold",string:"green",date:"magenta",regexp:"red"},exports.isArray=isArray,exports.isBoolean=isBoolean,exports.isNull=isNull,exports.isNullOrUndefined=isNullOrUndefined,exports.isNumber=isNumber,exports.isString=isString,exports.isSymbol=isSymbol,exports.isUndefined=isUndefined,exports.isRegExp=isRegExp,exports.isObject=isObject,exports.isDate=isDate,exports.isError=isError,exports.isFunction=isFunction,exports.isPrimitive=isPrimitive,exports.isBuffer=_dereq_("./support/isBuffer");var months=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];exports.log=function(){console.log("%s - %s",timestamp(),exports.format.apply(exports,arguments))},exports.inherits=_dereq_("inherits"),exports._extend=function(origin,add){if(!add||!isObject(add))return origin;for(var keys=Object.keys(add),i=keys.length;i--;)origin[keys[i]]=add[keys[i]];return origin}}).call(this,_dereq_("/usr/local/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./support/isBuffer":14,"/usr/local/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":18,inherits:17}],16:[function(_dereq_,module){function EventEmitter(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}function isFunction(arg){return"function"==typeof arg}function isNumber(arg){return"number"==typeof arg}function isObject(arg){return"object"==typeof arg&&null!==arg}function isUndefined(arg){return void 0===arg}module.exports=EventEmitter,EventEmitter.EventEmitter=EventEmitter,EventEmitter.prototype._events=void 0,EventEmitter.prototype._maxListeners=void 0,EventEmitter.defaultMaxListeners=10,EventEmitter.prototype.setMaxListeners=function(n){if(!isNumber(n)||0>n||isNaN(n))throw TypeError("n must be a positive number");return this._maxListeners=n,this},EventEmitter.prototype.emit=function(type){var er,handler,len,args,i,listeners;if(this._events||(this._events={}),"error"===type&&(!this._events.error||isObject(this._events.error)&&!this._events.error.length))throw er=arguments[1],er instanceof Error?er:TypeError('Uncaught, unspecified "error" event.');if(handler=this._events[type],isUndefined(handler))return!1;if(isFunction(handler))switch(arguments.length){case 1:handler.call(this);break;case 2:handler.call(this,arguments[1]);break;case 3:handler.call(this,arguments[1],arguments[2]);break;default:for(len=arguments.length,args=Array(len-1),i=1;len>i;i++)args[i-1]=arguments[i];handler.apply(this,args)}else if(isObject(handler)){for(len=arguments.length,args=Array(len-1),i=1;len>i;i++)args[i-1]=arguments[i];for(listeners=handler.slice(),len=listeners.length,i=0;len>i;i++)listeners[i].apply(this,args)}return!0},EventEmitter.prototype.addListener=function(type,listener){var m;if(!isFunction(listener))throw TypeError("listener must be a function");if(this._events||(this._events={}),this._events.newListener&&this.emit("newListener",type,isFunction(listener.listener)?listener.listener:listener),this._events[type]?isObject(this._events[type])?this._events[type].push(listener):this._events[type]=[this._events[type],listener]:this._events[type]=listener,isObject(this._events[type])&&!this._events[type].warned){var m;m=isUndefined(this._maxListeners)?EventEmitter.defaultMaxListeners:this._maxListeners,m&&m>0&&this._events[type].length>m&&(this._events[type].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[type].length),console.trace())}return this},EventEmitter.prototype.on=EventEmitter.prototype.addListener,EventEmitter.prototype.once=function(type,listener){function g(){this.removeListener(type,g),fired||(fired=!0,listener.apply(this,arguments))}if(!isFunction(listener))throw TypeError("listener must be a function");var fired=!1;return g.listener=listener,this.on(type,g),this},EventEmitter.prototype.removeListener=function(type,listener){var list,position,length,i;if(!isFunction(listener))throw TypeError("listener must be a function");if(!this._events||!this._events[type])return this;if(list=this._events[type],length=list.length,position=-1,list===listener||isFunction(list.listener)&&list.listener===listener)delete this._events[type],this._events.removeListener&&this.emit("removeListener",type,listener);else if(isObject(list)){for(i=length;i-->0;)if(list[i]===listener||list[i].listener&&list[i].listener===listener){position=i;break}if(0>position)return this;1===list.length?(list.length=0,delete this._events[type]):list.splice(position,1),this._events.removeListener&&this.emit("removeListener",type,listener)}return this},EventEmitter.prototype.removeAllListeners=function(type){var key,listeners;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[type]&&delete this._events[type],this;if(0===arguments.length){for(key in this._events)"removeListener"!==key&&this.removeAllListeners(key);return this.removeAllListeners("removeListener"),this._events={},this}if(listeners=this._events[type],isFunction(listeners))this.removeListener(type,listeners);else for(;listeners.length;)this.removeListener(type,listeners[listeners.length-1]);return delete this._events[type],this},EventEmitter.prototype.listeners=function(type){var ret;return ret=this._events&&this._events[type]?isFunction(this._events[type])?[this._events[type]]:this._events[type].slice():[]},EventEmitter.listenerCount=function(emitter,type){var ret;return ret=emitter._events&&emitter._events[type]?isFunction(emitter._events[type])?1:emitter._events[type].length:0}},{}],17:[function(_dereq_,module){module.exports="function"==typeof Object.create?function(ctor,superCtor){ctor.super_=superCtor,ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:!1,writable:!0,configurable:!0}})}:function(ctor,superCtor){ctor.super_=superCtor;var TempCtor=function(){};TempCtor.prototype=superCtor.prototype,ctor.prototype=new TempCtor,ctor.prototype.constructor=ctor}},{}],18:[function(_dereq_,module){function noop(){}var process=module.exports={};process.nextTick=function(){var canSetImmediate="undefined"!=typeof window&&window.setImmediate,canPost="undefined"!=typeof window&&window.postMessage&&window.addEventListener;if(canSetImmediate)return function(f){return window.setImmediate(f)};if(canPost){var queue=[];return window.addEventListener("message",function(ev){var source=ev.source;if((source===window||null===source)&&"process-tick"===ev.data&&(ev.stopPropagation(),queue.length>0)){var fn=queue.shift();fn()}},!0),function(fn){queue.push(fn),window.postMessage("process-tick","*")}}return function(fn){setTimeout(fn,0)}}(),process.title="browser",process.browser=!0,process.env={},process.argv=[],process.on=noop,process.once=noop,process.off=noop,process.emit=noop,process.binding=function(){throw Error("process.binding is not supported")},process.cwd=function(){return"/"},process.chdir=function(){throw Error("process.chdir is not supported")}},{}],19:[function(_dereq_,module){module.exports=_dereq_(14)},{}],20:[function(_dereq_,module){module.exports=_dereq_(15)},{"./support/isBuffer":19,"/usr/local/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":18,inherits:17}]},{},[9])(9)}),ace.define("ace/mode/html_worker",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/worker/mirror","ace/mode/html/saxparser"],function(acequire,exports){"use strict";var oop=acequire("../lib/oop");acequire("../lib/lang");var Mirror=acequire("../worker/mirror").Mirror,SAXParser=acequire("./html/saxparser").SAXParser,errorTypes={"expected-doctype-but-got-start-tag":"info","expected-doctype-but-got-chars":"info","non-html-root":"info"},Worker=exports.Worker=function(sender){Mirror.call(this,sender),this.setTimeout(400),this.context=null};oop.inherits(Worker,Mirror),function(){this.setOptions=function(options){this.context=options.context},this.onUpdate=function(){var value=this.doc.getValue();if(value){var parser=new SAXParser,errors=[],noop=function(){};parser.contentHandler={startDocument:noop,endDocument:noop,startElement:noop,endElement:noop,characters:noop},parser.errorHandler={error:function(message,location,code){errors.push({row:location.line,column:location.column,text:message,type:errorTypes[code]||"error"})}},this.context?parser.parseFragment(value,this.context):parser.parse(value),this.sender.emit("error",errors)}}}.call(Worker.prototype)}),ace.define("ace/lib/es5-shim",["require","exports","module"],function(){function Empty(){}function doesDefinePropertyWork(object){try{return Object.defineProperty(object,"sentinel",{}),"sentinel"in object}catch(exception){}}function toInteger(n){return n=+n,n!==n?n=0:0!==n&&n!==1/0&&n!==-(1/0)&&(n=(n>0||-1)*Math.floor(Math.abs(n))),n}Function.prototype.bind||(Function.prototype.bind=function(that){var target=this;if("function"!=typeof target)throw new TypeError("Function.prototype.bind called on incompatible "+target);var args=slice.call(arguments,1),bound=function(){if(this instanceof bound){var result=target.apply(this,args.concat(slice.call(arguments)));return Object(result)===result?result:this}return target.apply(that,args.concat(slice.call(arguments)))};return target.prototype&&(Empty.prototype=target.prototype,bound.prototype=new Empty,Empty.prototype=null),bound});var defineGetter,defineSetter,lookupGetter,lookupSetter,supportsAccessors,call=Function.prototype.call,prototypeOfArray=Array.prototype,prototypeOfObject=Object.prototype,slice=prototypeOfArray.slice,_toString=call.bind(prototypeOfObject.toString),owns=call.bind(prototypeOfObject.hasOwnProperty);if((supportsAccessors=owns(prototypeOfObject,"__defineGetter__"))&&(defineGetter=call.bind(prototypeOfObject.__defineGetter__),defineSetter=call.bind(prototypeOfObject.__defineSetter__),lookupGetter=call.bind(prototypeOfObject.__lookupGetter__),lookupSetter=call.bind(prototypeOfObject.__lookupSetter__)),2!=[1,2].splice(0).length)if(function(){function makeArray(l){var a=Array(l+2);return a[0]=a[1]=0,a}var lengthBefore,array=[];return array.splice.apply(array,makeArray(20)),array.splice.apply(array,makeArray(26)),lengthBefore=array.length,array.splice(5,0,"XXX"),lengthBefore+1==array.length,lengthBefore+1==array.length?!0:void 0}()){var array_splice=Array.prototype.splice;Array.prototype.splice=function(start,deleteCount){return arguments.length?array_splice.apply(this,[void 0===start?0:start,void 0===deleteCount?this.length-start:deleteCount].concat(slice.call(arguments,2))):[]}}else Array.prototype.splice=function(pos,removeCount){var length=this.length;pos>0?pos>length&&(pos=length):void 0==pos?pos=0:0>pos&&(pos=Math.max(length+pos,0)),length>pos+removeCount||(removeCount=length-pos);var removed=this.slice(pos,pos+removeCount),insert=slice.call(arguments,2),add=insert.length;if(pos===length)add&&this.push.apply(this,insert);else{var remove=Math.min(removeCount,length-pos),tailOldPos=pos+remove,tailNewPos=tailOldPos+add-remove,tailCount=length-tailOldPos,lengthAfterRemove=length-remove;if(tailOldPos>tailNewPos)for(var i=0;tailCount>i;++i)this[tailNewPos+i]=this[tailOldPos+i];else if(tailNewPos>tailOldPos)for(i=tailCount;i--;)this[tailNewPos+i]=this[tailOldPos+i];if(add&&pos===lengthAfterRemove)this.length=lengthAfterRemove,this.push.apply(this,insert);else for(this.length=lengthAfterRemove+add,i=0;add>i;++i)this[pos+i]=insert[i]}return removed};Array.isArray||(Array.isArray=function(obj){return"[object Array]"==_toString(obj)});var boxedString=Object("a"),splitString="a"!=boxedString[0]||!(0 in boxedString);if(Array.prototype.forEach||(Array.prototype.forEach=function(fun){var object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,thisp=arguments[1],i=-1,length=self.length>>>0;if("[object Function]"!=_toString(fun))throw new TypeError;for(;length>++i;)i in self&&fun.call(thisp,self[i],i,object)}),Array.prototype.map||(Array.prototype.map=function(fun){var object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,length=self.length>>>0,result=Array(length),thisp=arguments[1];if("[object Function]"!=_toString(fun))throw new TypeError(fun+" is not a function");for(var i=0;length>i;i++)i in self&&(result[i]=fun.call(thisp,self[i],i,object));return result}),Array.prototype.filter||(Array.prototype.filter=function(fun){var value,object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,length=self.length>>>0,result=[],thisp=arguments[1];if("[object Function]"!=_toString(fun))throw new TypeError(fun+" is not a function");for(var i=0;length>i;i++)i in self&&(value=self[i],fun.call(thisp,value,i,object)&&result.push(value));return result}),Array.prototype.every||(Array.prototype.every=function(fun){var object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,length=self.length>>>0,thisp=arguments[1];if("[object Function]"!=_toString(fun))throw new TypeError(fun+" is not a function");for(var i=0;length>i;i++)if(i in self&&!fun.call(thisp,self[i],i,object))return!1;return!0}),Array.prototype.some||(Array.prototype.some=function(fun){var object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,length=self.length>>>0,thisp=arguments[1];if("[object Function]"!=_toString(fun))throw new TypeError(fun+" is not a function");for(var i=0;length>i;i++)if(i in self&&fun.call(thisp,self[i],i,object))return!0;return!1}),Array.prototype.reduce||(Array.prototype.reduce=function(fun){var object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,length=self.length>>>0;if("[object Function]"!=_toString(fun))throw new TypeError(fun+" is not a function");if(!length&&1==arguments.length)throw new TypeError("reduce of empty array with no initial value");var result,i=0;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i++];break}if(++i>=length)throw new TypeError("reduce of empty array with no initial value")}for(;length>i;i++)i in self&&(result=fun.call(void 0,result,self[i],i,object));return result}),Array.prototype.reduceRight||(Array.prototype.reduceRight=function(fun){var object=toObject(this),self=splitString&&"[object String]"==_toString(this)?this.split(""):object,length=self.length>>>0;if("[object Function]"!=_toString(fun))throw new TypeError(fun+" is not a function");if(!length&&1==arguments.length)throw new TypeError("reduceRight of empty array with no initial value");var result,i=length-1;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i--];break}if(0>--i)throw new TypeError("reduceRight of empty array with no initial value")}do i in this&&(result=fun.call(void 0,result,self[i],i,object));while(i--);return result}),Array.prototype.indexOf&&-1==[0,1].indexOf(1,2)||(Array.prototype.indexOf=function(sought){var self=splitString&&"[object String]"==_toString(this)?this.split(""):toObject(this),length=self.length>>>0;if(!length)return-1;var i=0;for(arguments.length>1&&(i=toInteger(arguments[1])),i=i>=0?i:Math.max(0,length+i);length>i;i++)if(i in self&&self[i]===sought)return i;return-1}),Array.prototype.lastIndexOf&&-1==[0,1].lastIndexOf(0,-3)||(Array.prototype.lastIndexOf=function(sought){var self=splitString&&"[object String]"==_toString(this)?this.split(""):toObject(this),length=self.length>>>0;if(!length)return-1;var i=length-1;for(arguments.length>1&&(i=Math.min(i,toInteger(arguments[1]))),i=i>=0?i:length-Math.abs(i);i>=0;i--)if(i in self&&sought===self[i])return i;return-1}),Object.getPrototypeOf||(Object.getPrototypeOf=function(object){return object.__proto__||(object.constructor?object.constructor.prototype:prototypeOfObject)}),!Object.getOwnPropertyDescriptor){var ERR_NON_OBJECT="Object.getOwnPropertyDescriptor called on a non-object: ";Object.getOwnPropertyDescriptor=function(object,property){if("object"!=typeof object&&"function"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT+object);if(owns(object,property)){var descriptor,getter,setter;if(descriptor={enumerable:!0,configurable:!0},supportsAccessors){var prototype=object.__proto__;object.__proto__=prototypeOfObject;var getter=lookupGetter(object,property),setter=lookupSetter(object,property);if(object.__proto__=prototype,getter||setter)return getter&&(descriptor.get=getter),setter&&(descriptor.set=setter),descriptor}return descriptor.value=object[property],descriptor}}}if(Object.getOwnPropertyNames||(Object.getOwnPropertyNames=function(object){return Object.keys(object)}),!Object.create){var createEmpty;createEmpty=null===Object.prototype.__proto__?function(){return{__proto__:null}}:function(){var empty={};for(var i in empty)empty[i]=null;return empty.constructor=empty.hasOwnProperty=empty.propertyIsEnumerable=empty.isPrototypeOf=empty.toLocaleString=empty.toString=empty.valueOf=empty.__proto__=null,empty},Object.create=function(prototype,properties){var object;if(null===prototype)object=createEmpty();else{if("object"!=typeof prototype)throw new TypeError("typeof prototype["+typeof prototype+"] != 'object'");var Type=function(){};Type.prototype=prototype,object=new Type,object.__proto__=prototype}return void 0!==properties&&Object.defineProperties(object,properties),object}}if(Object.defineProperty){var definePropertyWorksOnObject=doesDefinePropertyWork({}),definePropertyWorksOnDom="undefined"==typeof document||doesDefinePropertyWork(document.createElement("div"));if(!definePropertyWorksOnObject||!definePropertyWorksOnDom)var definePropertyFallback=Object.defineProperty}if(!Object.defineProperty||definePropertyFallback){var ERR_NON_OBJECT_DESCRIPTOR="Property description must be an object: ",ERR_NON_OBJECT_TARGET="Object.defineProperty called on non-object: ",ERR_ACCESSORS_NOT_SUPPORTED="getters & setters can not be defined on this javascript engine";Object.defineProperty=function(object,property,descriptor){if("object"!=typeof object&&"function"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT_TARGET+object);if("object"!=typeof descriptor&&"function"!=typeof descriptor||null===descriptor)throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR+descriptor);if(definePropertyFallback)try{return definePropertyFallback.call(Object,object,property,descriptor)}catch(exception){}if(owns(descriptor,"value"))if(supportsAccessors&&(lookupGetter(object,property)||lookupSetter(object,property))){var prototype=object.__proto__;object.__proto__=prototypeOfObject,delete object[property],object[property]=descriptor.value,object.__proto__=prototype}else object[property]=descriptor.value;else{if(!supportsAccessors)throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);owns(descriptor,"get")&&defineGetter(object,property,descriptor.get),owns(descriptor,"set")&&defineSetter(object,property,descriptor.set)}return object}}Object.defineProperties||(Object.defineProperties=function(object,properties){for(var property in properties)owns(properties,property)&&Object.defineProperty(object,property,properties[property]);return object}),Object.seal||(Object.seal=function(object){return object}),Object.freeze||(Object.freeze=function(object){return object
});try{Object.freeze(function(){})}catch(exception){Object.freeze=function(freezeObject){return function(object){return"function"==typeof object?object:freezeObject(object)}}(Object.freeze)}if(Object.preventExtensions||(Object.preventExtensions=function(object){return object}),Object.isSealed||(Object.isSealed=function(){return!1}),Object.isFrozen||(Object.isFrozen=function(){return!1}),Object.isExtensible||(Object.isExtensible=function(object){if(Object(object)===object)throw new TypeError;for(var name="";owns(object,name);)name+="?";object[name]=!0;var returnValue=owns(object,name);return delete object[name],returnValue}),!Object.keys){var hasDontEnumBug=!0,dontEnums=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],dontEnumsLength=dontEnums.length;for(var key in{toString:null})hasDontEnumBug=!1;Object.keys=function(object){if("object"!=typeof object&&"function"!=typeof object||null===object)throw new TypeError("Object.keys called on a non-object");var keys=[];for(var name in object)owns(object,name)&&keys.push(name);if(hasDontEnumBug)for(var i=0,ii=dontEnumsLength;ii>i;i++){var dontEnum=dontEnums[i];owns(object,dontEnum)&&keys.push(dontEnum)}return keys}}Date.now||(Date.now=function(){return(new Date).getTime()});var ws="	\\n\v\\f\\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\\u2028\\u2029\uFEFF";if(!String.prototype.trim||ws.trim()){ws="["+ws+"]";var trimBeginRegexp=RegExp("^"+ws+ws+"*"),trimEndRegexp=RegExp(ws+ws+"*$");String.prototype.trim=function(){return(this+"").replace(trimBeginRegexp,"").replace(trimEndRegexp,"")}}var toObject=function(o){if(null==o)throw new TypeError("can't convert "+o+" to object");return Object(o)}});`;
    }
  });

  // node_modules/brace/mode/html.js
  var require_html2 = __commonJS({
    "node_modules/brace/mode/html.js"() {
      ace.define("ace/mode/doc_comment_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text_highlight_rules"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("../lib/oop");
        var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;
        var DocCommentHighlightRules = function() {
          this.$rules = {
            "start": [
              {
                token: "comment.doc.tag",
                regex: "@[\\w\\d_]+"
                // TODO: fix email addresses
              },
              DocCommentHighlightRules.getTagRule(),
              {
                defaultToken: "comment.doc",
                caseInsensitive: true
              }
            ]
          };
        };
        oop.inherits(DocCommentHighlightRules, TextHighlightRules);
        DocCommentHighlightRules.getTagRule = function(start) {
          return {
            token: "comment.doc.tag.storage.type",
            regex: "\\b(?:TODO|FIXME|XXX|HACK)\\b"
          };
        };
        DocCommentHighlightRules.getStartRule = function(start) {
          return {
            token: "comment.doc",
            // doc comment
            regex: "\\/\\*(?=\\*)",
            next: start
          };
        };
        DocCommentHighlightRules.getEndRule = function(start) {
          return {
            token: "comment.doc",
            // closing comment
            regex: "\\*\\/",
            next: start
          };
        };
        exports2.DocCommentHighlightRules = DocCommentHighlightRules;
      });
      ace.define("ace/mode/javascript_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/doc_comment_highlight_rules", "ace/mode/text_highlight_rules"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("../lib/oop");
        var DocCommentHighlightRules = acequire("./doc_comment_highlight_rules").DocCommentHighlightRules;
        var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;
        var identifierRe = "[a-zA-Z\\$_\xA1-\uFFFF][a-zA-Z\\d\\$_\xA1-\uFFFF]*";
        var JavaScriptHighlightRules = function(options) {
          var keywordMapper = this.createKeywordMapper({
            "variable.language": "Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|Namespace|QName|XML|XMLList|ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|SyntaxError|TypeError|URIError|decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|isNaN|parseFloat|parseInt|JSON|Math|this|arguments|prototype|window|document",
            // Pseudo
            "keyword": "const|yield|import|get|set|async|await|break|case|catch|continue|default|delete|do|else|finally|for|function|if|in|of|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|__parent__|__count__|escape|unescape|with|__proto__|class|enum|extends|super|export|implements|private|public|interface|package|protected|static",
            "storage.type": "const|let|var|function",
            "constant.language": "null|Infinity|NaN|undefined",
            "support.function": "alert",
            "constant.language.boolean": "true|false"
          }, "identifier");
          var kwBeforeRe = "case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void";
          var escapedRe = "\\\\(?:x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|u{[0-9a-fA-F]{1,6}}|[0-2][0-7]{0,2}|3[0-7][0-7]?|[4-7][0-7]?|.)";
          this.$rules = {
            "no_regex": [
              DocCommentHighlightRules.getStartRule("doc-start"),
              comments("no_regex"),
              {
                token: "string",
                regex: "'(?=.)",
                next: "qstring"
              },
              {
                token: "string",
                regex: '"(?=.)',
                next: "qqstring"
              },
              {
                token: "constant.numeric",
                // hexadecimal, octal and binary
                regex: /0(?:[xX][0-9a-fA-F]+|[oO][0-7]+|[bB][01]+)\b/
              },
              {
                token: "constant.numeric",
                // decimal integers and floats
                regex: /(?:\d\d*(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+\b)?/
              },
              {
                token: [
                  "storage.type",
                  "punctuation.operator",
                  "support.function",
                  "punctuation.operator",
                  "entity.name.function",
                  "text",
                  "keyword.operator"
                ],
                regex: "(" + identifierRe + ")(\\.)(prototype)(\\.)(" + identifierRe + ")(\\s*)(=)",
                next: "function_arguments"
              },
              {
                token: [
                  "storage.type",
                  "punctuation.operator",
                  "entity.name.function",
                  "text",
                  "keyword.operator",
                  "text",
                  "storage.type",
                  "text",
                  "paren.lparen"
                ],
                regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
              },
              {
                token: [
                  "entity.name.function",
                  "text",
                  "keyword.operator",
                  "text",
                  "storage.type",
                  "text",
                  "paren.lparen"
                ],
                regex: "(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
              },
              {
                token: [
                  "storage.type",
                  "punctuation.operator",
                  "entity.name.function",
                  "text",
                  "keyword.operator",
                  "text",
                  "storage.type",
                  "text",
                  "entity.name.function",
                  "text",
                  "paren.lparen"
                ],
                regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s+)(\\w+)(\\s*)(\\()",
                next: "function_arguments"
              },
              {
                token: [
                  "storage.type",
                  "text",
                  "entity.name.function",
                  "text",
                  "paren.lparen"
                ],
                regex: "(function)(\\s+)(" + identifierRe + ")(\\s*)(\\()",
                next: "function_arguments"
              },
              {
                token: [
                  "entity.name.function",
                  "text",
                  "punctuation.operator",
                  "text",
                  "storage.type",
                  "text",
                  "paren.lparen"
                ],
                regex: "(" + identifierRe + ")(\\s*)(:)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
              },
              {
                token: [
                  "text",
                  "text",
                  "storage.type",
                  "text",
                  "paren.lparen"
                ],
                regex: "(:)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
              },
              {
                token: "keyword",
                regex: `from(?=\\s*('|"))`
              },
              {
                token: "keyword",
                regex: "(?:" + kwBeforeRe + ")\\b",
                next: "start"
              },
              {
                token: ["support.constant"],
                regex: /that\b/
              },
              {
                token: ["storage.type", "punctuation.operator", "support.function.firebug"],
                regex: /(console)(\.)(warn|info|log|error|time|trace|timeEnd|assert)\b/
              },
              {
                token: keywordMapper,
                regex: identifierRe
              },
              {
                token: "punctuation.operator",
                regex: /[.](?![.])/,
                next: "property"
              },
              {
                token: "storage.type",
                regex: /=>/
              },
              {
                token: "keyword.operator",
                regex: /--|\+\+|\.{3}|===|==|=|!=|!==|<+=?|>+=?|!|&&|\|\||\?:|[!$%&*+\-~\/^]=?/,
                next: "start"
              },
              {
                token: "punctuation.operator",
                regex: /[?:,;.]/,
                next: "start"
              },
              {
                token: "paren.lparen",
                regex: /[\[({]/,
                next: "start"
              },
              {
                token: "paren.rparen",
                regex: /[\])}]/
              },
              {
                token: "comment",
                regex: /^#!.*$/
              }
            ],
            property: [
              {
                token: "text",
                regex: "\\s+"
              },
              {
                token: [
                  "storage.type",
                  "punctuation.operator",
                  "entity.name.function",
                  "text",
                  "keyword.operator",
                  "text",
                  "storage.type",
                  "text",
                  "entity.name.function",
                  "text",
                  "paren.lparen"
                ],
                regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(?:(\\s+)(\\w+))?(\\s*)(\\()",
                next: "function_arguments"
              },
              {
                token: "punctuation.operator",
                regex: /[.](?![.])/
              },
              {
                token: "support.function",
                regex: /(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\b(?=\()/
              },
              {
                token: "support.function.dom",
                regex: /(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName|ClassName)|ById)|Attribute(?:Node)?)|blur)\b(?=\()/
              },
              {
                token: "support.constant",
                regex: /(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\b/
              },
              {
                token: "identifier",
                regex: identifierRe
              },
              {
                regex: "",
                token: "empty",
                next: "no_regex"
              }
            ],
            "start": [
              DocCommentHighlightRules.getStartRule("doc-start"),
              comments("start"),
              {
                token: "string.regexp",
                regex: "\\/",
                next: "regex"
              },
              {
                token: "text",
                regex: "\\s+|^$",
                next: "start"
              },
              {
                token: "empty",
                regex: "",
                next: "no_regex"
              }
            ],
            "regex": [
              {
                token: "regexp.keyword.operator",
                regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
              },
              {
                token: "string.regexp",
                regex: "/[sxngimy]*",
                next: "no_regex"
              },
              {
                token: "invalid",
                regex: /\{\d+\b,?\d*\}[+*]|[+*$^?][+*]|[$^][?]|\?{3,}/
              },
              {
                token: "constant.language.escape",
                regex: /\(\?[:=!]|\)|\{\d+\b,?\d*\}|[+*]\?|[()$^+*?.]/
              },
              {
                token: "constant.language.delimiter",
                regex: /\|/
              },
              {
                token: "constant.language.escape",
                regex: /\[\^?/,
                next: "regex_character_class"
              },
              {
                token: "empty",
                regex: "$",
                next: "no_regex"
              },
              {
                defaultToken: "string.regexp"
              }
            ],
            "regex_character_class": [
              {
                token: "regexp.charclass.keyword.operator",
                regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
              },
              {
                token: "constant.language.escape",
                regex: "]",
                next: "regex"
              },
              {
                token: "constant.language.escape",
                regex: "-"
              },
              {
                token: "empty",
                regex: "$",
                next: "no_regex"
              },
              {
                defaultToken: "string.regexp.charachterclass"
              }
            ],
            "function_arguments": [
              {
                token: "variable.parameter",
                regex: identifierRe
              },
              {
                token: "punctuation.operator",
                regex: "[, ]+"
              },
              {
                token: "punctuation.operator",
                regex: "$"
              },
              {
                token: "empty",
                regex: "",
                next: "no_regex"
              }
            ],
            "qqstring": [
              {
                token: "constant.language.escape",
                regex: escapedRe
              },
              {
                token: "string",
                regex: "\\\\$",
                consumeLineEnd: true
              },
              {
                token: "string",
                regex: '"|$',
                next: "no_regex"
              },
              {
                defaultToken: "string"
              }
            ],
            "qstring": [
              {
                token: "constant.language.escape",
                regex: escapedRe
              },
              {
                token: "string",
                regex: "\\\\$",
                consumeLineEnd: true
              },
              {
                token: "string",
                regex: "'|$",
                next: "no_regex"
              },
              {
                defaultToken: "string"
              }
            ]
          };
          if (!options || !options.noES6) {
            this.$rules.no_regex.unshift({
              regex: "[{}]",
              onMatch: function(val, state, stack) {
                this.next = val == "{" ? this.nextState : "";
                if (val == "{" && stack.length) {
                  stack.unshift("start", state);
                } else if (val == "}" && stack.length) {
                  stack.shift();
                  this.next = stack.shift();
                  if (this.next.indexOf("string") != -1 || this.next.indexOf("jsx") != -1)
                    return "paren.quasi.end";
                }
                return val == "{" ? "paren.lparen" : "paren.rparen";
              },
              nextState: "start"
            }, {
              token: "string.quasi.start",
              regex: /`/,
              push: [{
                token: "constant.language.escape",
                regex: escapedRe
              }, {
                token: "paren.quasi.start",
                regex: /\${/,
                push: "start"
              }, {
                token: "string.quasi.end",
                regex: /`/,
                next: "pop"
              }, {
                defaultToken: "string.quasi"
              }]
            });
            if (!options || options.jsx != false)
              JSX.call(this);
          }
          this.embedRules(
            DocCommentHighlightRules,
            "doc-",
            [DocCommentHighlightRules.getEndRule("no_regex")]
          );
          this.normalizeRules();
        };
        oop.inherits(JavaScriptHighlightRules, TextHighlightRules);
        function JSX() {
          var tagRegex = identifierRe.replace("\\d", "\\d\\-");
          var jsxTag = {
            onMatch: function(val, state, stack) {
              var offset = val.charAt(1) == "/" ? 2 : 1;
              if (offset == 1) {
                if (state != this.nextState)
                  stack.unshift(this.next, this.nextState, 0);
                else
                  stack.unshift(this.next);
                stack[2]++;
              } else if (offset == 2) {
                if (state == this.nextState) {
                  stack[1]--;
                  if (!stack[1] || stack[1] < 0) {
                    stack.shift();
                    stack.shift();
                  }
                }
              }
              return [{
                type: "meta.tag.punctuation." + (offset == 1 ? "" : "end-") + "tag-open.xml",
                value: val.slice(0, offset)
              }, {
                type: "meta.tag.tag-name.xml",
                value: val.substr(offset)
              }];
            },
            regex: "</?" + tagRegex,
            next: "jsxAttributes",
            nextState: "jsx"
          };
          this.$rules.start.unshift(jsxTag);
          var jsxJsRule = {
            regex: "{",
            token: "paren.quasi.start",
            push: "start"
          };
          this.$rules.jsx = [
            jsxJsRule,
            jsxTag,
            { include: "reference" },
            { defaultToken: "string" }
          ];
          this.$rules.jsxAttributes = [
            {
              token: "meta.tag.punctuation.tag-close.xml",
              regex: "/?>",
              onMatch: function(value, currentState, stack) {
                if (currentState == stack[0])
                  stack.shift();
                if (value.length == 2) {
                  if (stack[0] == this.nextState)
                    stack[1]--;
                  if (!stack[1] || stack[1] < 0) {
                    stack.splice(0, 2);
                  }
                }
                this.next = stack[0] || "start";
                return [{ type: this.token, value }];
              },
              nextState: "jsx"
            },
            jsxJsRule,
            comments("jsxAttributes"),
            {
              token: "entity.other.attribute-name.xml",
              regex: tagRegex
            },
            {
              token: "keyword.operator.attribute-equals.xml",
              regex: "="
            },
            {
              token: "text.tag-whitespace.xml",
              regex: "\\s+"
            },
            {
              token: "string.attribute-value.xml",
              regex: "'",
              stateName: "jsx_attr_q",
              push: [
                { token: "string.attribute-value.xml", regex: "'", next: "pop" },
                { include: "reference" },
                { defaultToken: "string.attribute-value.xml" }
              ]
            },
            {
              token: "string.attribute-value.xml",
              regex: '"',
              stateName: "jsx_attr_qq",
              push: [
                { token: "string.attribute-value.xml", regex: '"', next: "pop" },
                { include: "reference" },
                { defaultToken: "string.attribute-value.xml" }
              ]
            },
            jsxTag
          ];
          this.$rules.reference = [{
            token: "constant.language.escape.reference.xml",
            regex: "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
          }];
        }
        function comments(next) {
          return [
            {
              token: "comment",
              // multi line comment
              regex: /\/\*/,
              next: [
                DocCommentHighlightRules.getTagRule(),
                { token: "comment", regex: "\\*\\/", next: next || "pop" },
                { defaultToken: "comment", caseInsensitive: true }
              ]
            },
            {
              token: "comment",
              regex: "\\/\\/",
              next: [
                DocCommentHighlightRules.getTagRule(),
                { token: "comment", regex: "$|^", next: next || "pop" },
                { defaultToken: "comment", caseInsensitive: true }
              ]
            }
          ];
        }
        exports2.JavaScriptHighlightRules = JavaScriptHighlightRules;
      });
      ace.define("ace/mode/matching_brace_outdent", ["require", "exports", "module", "ace/range"], function(acequire, exports2, module2) {
        "use strict";
        var Range = acequire("../range").Range;
        var MatchingBraceOutdent = function() {
        };
        (function() {
          this.checkOutdent = function(line, input) {
            if (!/^\s+$/.test(line))
              return false;
            return /^\s*\}/.test(input);
          };
          this.autoOutdent = function(doc, row) {
            var line = doc.getLine(row);
            var match = line.match(/^(\s*\})/);
            if (!match)
              return 0;
            var column = match[1].length;
            var openBracePos = doc.findMatchingBracket({ row, column });
            if (!openBracePos || openBracePos.row == row)
              return 0;
            var indent = this.$getIndent(doc.getLine(openBracePos.row));
            doc.replace(new Range(row, 0, row, column - 1), indent);
          };
          this.$getIndent = function(line) {
            return line.match(/^\s*/)[0];
          };
        }).call(MatchingBraceOutdent.prototype);
        exports2.MatchingBraceOutdent = MatchingBraceOutdent;
      });
      ace.define("ace/mode/folding/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/range", "ace/mode/folding/fold_mode"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("../../lib/oop");
        var Range = acequire("../../range").Range;
        var BaseFoldMode = acequire("./fold_mode").FoldMode;
        var FoldMode = exports2.FoldMode = function(commentRegex) {
          if (commentRegex) {
            this.foldingStartMarker = new RegExp(
              this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start)
            );
            this.foldingStopMarker = new RegExp(
              this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end)
            );
          }
        };
        oop.inherits(FoldMode, BaseFoldMode);
        (function() {
          this.foldingStartMarker = /([\{\[\(])[^\}\]\)]*$|^\s*(\/\*)/;
          this.foldingStopMarker = /^[^\[\{\(]*([\}\]\)])|^[\s\*]*(\*\/)/;
          this.singleLineBlockCommentRe = /^\s*(\/\*).*\*\/\s*$/;
          this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
          this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
          this._getFoldWidgetBase = this.getFoldWidget;
          this.getFoldWidget = function(session, foldStyle, row) {
            var line = session.getLine(row);
            if (this.singleLineBlockCommentRe.test(line)) {
              if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))
                return "";
            }
            var fw = this._getFoldWidgetBase(session, foldStyle, row);
            if (!fw && this.startRegionRe.test(line))
              return "start";
            return fw;
          };
          this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
            var line = session.getLine(row);
            if (this.startRegionRe.test(line))
              return this.getCommentRegionBlock(session, line, row);
            var match = line.match(this.foldingStartMarker);
            if (match) {
              var i = match.index;
              if (match[1])
                return this.openingBracketBlock(session, match[1], row, i);
              var range = session.getCommentFoldRange(row, i + match[0].length, 1);
              if (range && !range.isMultiLine()) {
                if (forceMultiline) {
                  range = this.getSectionRange(session, row);
                } else if (foldStyle != "all")
                  range = null;
              }
              return range;
            }
            if (foldStyle === "markbegin")
              return;
            var match = line.match(this.foldingStopMarker);
            if (match) {
              var i = match.index + match[0].length;
              if (match[1])
                return this.closingBracketBlock(session, match[1], row, i);
              return session.getCommentFoldRange(row, i, -1);
            }
          };
          this.getSectionRange = function(session, row) {
            var line = session.getLine(row);
            var startIndent = line.search(/\S/);
            var startRow = row;
            var startColumn = line.length;
            row = row + 1;
            var endRow = row;
            var maxRow = session.getLength();
            while (++row < maxRow) {
              line = session.getLine(row);
              var indent = line.search(/\S/);
              if (indent === -1)
                continue;
              if (startIndent > indent)
                break;
              var subRange = this.getFoldWidgetRange(session, "all", row);
              if (subRange) {
                if (subRange.start.row <= startRow) {
                  break;
                } else if (subRange.isMultiLine()) {
                  row = subRange.end.row;
                } else if (startIndent == indent) {
                  break;
                }
              }
              endRow = row;
            }
            return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
          };
          this.getCommentRegionBlock = function(session, line, row) {
            var startColumn = line.search(/\s*$/);
            var maxRow = session.getLength();
            var startRow = row;
            var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
            var depth = 1;
            while (++row < maxRow) {
              line = session.getLine(row);
              var m = re.exec(line);
              if (!m)
                continue;
              if (m[1])
                depth--;
              else
                depth++;
              if (!depth)
                break;
            }
            var endRow = row;
            if (endRow > startRow) {
              return new Range(startRow, startColumn, endRow, line.length);
            }
          };
        }).call(FoldMode.prototype);
      });
      ace.define("ace/mode/javascript", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/javascript_highlight_rules", "ace/mode/matching_brace_outdent", "ace/worker/worker_client", "ace/mode/behaviour/cstyle", "ace/mode/folding/cstyle"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("../lib/oop");
        var TextMode = acequire("./text").Mode;
        var JavaScriptHighlightRules = acequire("./javascript_highlight_rules").JavaScriptHighlightRules;
        var MatchingBraceOutdent = acequire("./matching_brace_outdent").MatchingBraceOutdent;
        var WorkerClient = acequire("../worker/worker_client").WorkerClient;
        var CstyleBehaviour = acequire("./behaviour/cstyle").CstyleBehaviour;
        var CStyleFoldMode = acequire("./folding/cstyle").FoldMode;
        var Mode = function() {
          this.HighlightRules = JavaScriptHighlightRules;
          this.$outdent = new MatchingBraceOutdent();
          this.$behaviour = new CstyleBehaviour();
          this.foldingRules = new CStyleFoldMode();
        };
        oop.inherits(Mode, TextMode);
        (function() {
          this.lineCommentStart = "//";
          this.blockComment = { start: "/*", end: "*/" };
          this.$quotes = { '"': '"', "'": "'", "`": "`" };
          this.getNextLineIndent = function(state, line, tab) {
            var indent = this.$getIndent(line);
            var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
            var tokens = tokenizedLine.tokens;
            var endState = tokenizedLine.state;
            if (tokens.length && tokens[tokens.length - 1].type == "comment") {
              return indent;
            }
            if (state == "start" || state == "no_regex") {
              var match = line.match(/^.*(?:\bcase\b.*:|[\{\(\[])\s*$/);
              if (match) {
                indent += tab;
              }
            } else if (state == "doc-start") {
              if (endState == "start" || endState == "no_regex") {
                return "";
              }
              var match = line.match(/^\s*(\/?)\*/);
              if (match) {
                if (match[1]) {
                  indent += " ";
                }
                indent += "* ";
              }
            }
            return indent;
          };
          this.checkOutdent = function(state, line, input) {
            return this.$outdent.checkOutdent(line, input);
          };
          this.autoOutdent = function(state, doc, row) {
            this.$outdent.autoOutdent(doc, row);
          };
          this.createWorker = function(session) {
            var worker = new WorkerClient(["ace"], require_javascript(), "JavaScriptWorker");
            worker.attachToDocument(session.getDocument());
            worker.on("annotate", function(results) {
              session.setAnnotations(results.data);
            });
            worker.on("terminate", function() {
              session.clearAnnotations();
            });
            return worker;
          };
          this.$id = "ace/mode/javascript";
        }).call(Mode.prototype);
        exports2.Mode = Mode;
      });
      ace.define("ace/mode/css_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/mode/text_highlight_rules"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("../lib/oop");
        var lang = acequire("../lib/lang");
        var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;
        var supportType = exports2.supportType = "align-content|align-items|align-self|all|animation|animation-delay|animation-direction|animation-duration|animation-fill-mode|animation-iteration-count|animation-name|animation-play-state|animation-timing-function|backface-visibility|background|background-attachment|background-blend-mode|background-clip|background-color|background-image|background-origin|background-position|background-repeat|background-size|border|border-bottom|border-bottom-color|border-bottom-left-radius|border-bottom-right-radius|border-bottom-style|border-bottom-width|border-collapse|border-color|border-image|border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-left|border-left-color|border-left-style|border-left-width|border-radius|border-right|border-right-color|border-right-style|border-right-width|border-spacing|border-style|border-top|border-top-color|border-top-left-radius|border-top-right-radius|border-top-style|border-top-width|border-width|bottom|box-shadow|box-sizing|caption-side|clear|clip|color|column-count|column-fill|column-gap|column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columns|content|counter-increment|counter-reset|cursor|direction|display|empty-cells|filter|flex|flex-basis|flex-direction|flex-flow|flex-grow|flex-shrink|flex-wrap|float|font|font-family|font-size|font-size-adjust|font-stretch|font-style|font-variant|font-weight|hanging-punctuation|height|justify-content|left|letter-spacing|line-height|list-style|list-style-image|list-style-position|list-style-type|margin|margin-bottom|margin-left|margin-right|margin-top|max-height|max-width|min-height|min-width|nav-down|nav-index|nav-left|nav-right|nav-up|opacity|order|outline|outline-color|outline-offset|outline-style|outline-width|overflow|overflow-x|overflow-y|padding|padding-bottom|padding-left|padding-right|padding-top|page-break-after|page-break-before|page-break-inside|perspective|perspective-origin|position|quotes|resize|right|tab-size|table-layout|text-align|text-align-last|text-decoration|text-decoration-color|text-decoration-line|text-decoration-style|text-indent|text-justify|text-overflow|text-shadow|text-transform|top|transform|transform-origin|transform-style|transition|transition-delay|transition-duration|transition-property|transition-timing-function|unicode-bidi|vertical-align|visibility|white-space|width|word-break|word-spacing|word-wrap|z-index";
        var supportFunction = exports2.supportFunction = "rgb|rgba|url|attr|counter|counters";
        var supportConstant = exports2.supportConstant = "absolute|after-edge|after|all-scroll|all|alphabetic|always|antialiased|armenian|auto|avoid-column|avoid-page|avoid|balance|baseline|before-edge|before|below|bidi-override|block-line-height|block|bold|bolder|border-box|both|bottom|box|break-all|break-word|capitalize|caps-height|caption|center|central|char|circle|cjk-ideographic|clone|close-quote|col-resize|collapse|column|consider-shifts|contain|content-box|cover|crosshair|cubic-bezier|dashed|decimal-leading-zero|decimal|default|disabled|disc|disregard-shifts|distribute-all-lines|distribute-letter|distribute-space|distribute|dotted|double|e-resize|ease-in|ease-in-out|ease-out|ease|ellipsis|end|exclude-ruby|fill|fixed|georgian|glyphs|grid-height|groove|hand|hanging|hebrew|help|hidden|hiragana-iroha|hiragana|horizontal|icon|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space|ideographic|inactive|include-ruby|inherit|initial|inline-block|inline-box|inline-line-height|inline-table|inline|inset|inside|inter-ideograph|inter-word|invert|italic|justify|katakana-iroha|katakana|keep-all|last|left|lighter|line-edge|line-through|line|linear|list-item|local|loose|lower-alpha|lower-greek|lower-latin|lower-roman|lowercase|lr-tb|ltr|mathematical|max-height|max-size|medium|menu|message-box|middle|move|n-resize|ne-resize|newspaper|no-change|no-close-quote|no-drop|no-open-quote|no-repeat|none|normal|not-allowed|nowrap|nw-resize|oblique|open-quote|outset|outside|overline|padding-box|page|pointer|pre-line|pre-wrap|pre|preserve-3d|progress|relative|repeat-x|repeat-y|repeat|replaced|reset-size|ridge|right|round|row-resize|rtl|s-resize|scroll|se-resize|separate|slice|small-caps|small-caption|solid|space|square|start|static|status-bar|step-end|step-start|steps|stretch|strict|sub|super|sw-resize|table-caption|table-cell|table-column-group|table-column|table-footer-group|table-header-group|table-row-group|table-row|table|tb-rl|text-after-edge|text-before-edge|text-bottom|text-size|text-top|text|thick|thin|transparent|underline|upper-alpha|upper-latin|upper-roman|uppercase|use-script|vertical-ideographic|vertical-text|visible|w-resize|wait|whitespace|z-index|zero";
        var supportConstantColor = exports2.supportConstantColor = "aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen";
        var supportConstantFonts = exports2.supportConstantFonts = "arial|century|comic|courier|cursive|fantasy|garamond|georgia|helvetica|impact|lucida|symbol|system|tahoma|times|trebuchet|utopia|verdana|webdings|sans-serif|serif|monospace";
        var numRe = exports2.numRe = "\\-?(?:(?:[0-9]+(?:\\.[0-9]+)?)|(?:\\.[0-9]+))";
        var pseudoElements = exports2.pseudoElements = "(\\:+)\\b(after|before|first-letter|first-line|moz-selection|selection)\\b";
        var pseudoClasses = exports2.pseudoClasses = "(:)\\b(active|checked|disabled|empty|enabled|first-child|first-of-type|focus|hover|indeterminate|invalid|last-child|last-of-type|link|not|nth-child|nth-last-child|nth-last-of-type|nth-of-type|only-child|only-of-type|acequired|root|target|valid|visited)\\b";
        var CssHighlightRules = function() {
          var keywordMapper = this.createKeywordMapper({
            "support.function": supportFunction,
            "support.constant": supportConstant,
            "support.type": supportType,
            "support.constant.color": supportConstantColor,
            "support.constant.fonts": supportConstantFonts
          }, "text", true);
          this.$rules = {
            "start": [{
              include: ["strings", "url", "comments"]
            }, {
              token: "paren.lparen",
              regex: "\\{",
              next: "ruleset"
            }, {
              token: "paren.rparen",
              regex: "\\}"
            }, {
              token: "string",
              regex: "@",
              next: "media"
            }, {
              token: "keyword",
              regex: "#[a-z0-9-_]+"
            }, {
              token: "keyword",
              regex: "%"
            }, {
              token: "variable",
              regex: "\\.[a-z0-9-_]+"
            }, {
              token: "string",
              regex: ":[a-z0-9-_]+"
            }, {
              token: "constant.numeric",
              regex: numRe
            }, {
              token: "constant",
              regex: "[a-z0-9-_]+"
            }, {
              caseInsensitive: true
            }],
            "media": [{
              include: ["strings", "url", "comments"]
            }, {
              token: "paren.lparen",
              regex: "\\{",
              next: "start"
            }, {
              token: "paren.rparen",
              regex: "\\}",
              next: "start"
            }, {
              token: "string",
              regex: ";",
              next: "start"
            }, {
              token: "keyword",
              regex: "(?:media|supports|document|charset|import|namespace|media|supports|document|page|font|keyframes|viewport|counter-style|font-feature-values|swash|ornaments|annotation|stylistic|styleset|character-variant)"
            }],
            "comments": [{
              token: "comment",
              // multi line comment
              regex: "\\/\\*",
              push: [{
                token: "comment",
                regex: "\\*\\/",
                next: "pop"
              }, {
                defaultToken: "comment"
              }]
            }],
            "ruleset": [{
              regex: "-(webkit|ms|moz|o)-",
              token: "text"
            }, {
              token: "paren.rparen",
              regex: "\\}",
              next: "start"
            }, {
              include: ["strings", "url", "comments"]
            }, {
              token: ["constant.numeric", "keyword"],
              regex: "(" + numRe + ")(ch|cm|deg|em|ex|fr|gd|grad|Hz|in|kHz|mm|ms|pc|pt|px|rad|rem|s|turn|vh|vm|vw|%)"
            }, {
              token: "constant.numeric",
              regex: numRe
            }, {
              token: "constant.numeric",
              // hex6 color
              regex: "#[a-f0-9]{6}"
            }, {
              token: "constant.numeric",
              // hex3 color
              regex: "#[a-f0-9]{3}"
            }, {
              token: ["punctuation", "entity.other.attribute-name.pseudo-element.css"],
              regex: pseudoElements
            }, {
              token: ["punctuation", "entity.other.attribute-name.pseudo-class.css"],
              regex: pseudoClasses
            }, {
              include: "url"
            }, {
              token: keywordMapper,
              regex: "\\-?[a-zA-Z_][a-zA-Z0-9_\\-]*"
            }, {
              caseInsensitive: true
            }],
            url: [{
              token: "support.function",
              regex: "(?:url(:?-prefix)?|domain|regexp)\\(",
              push: [{
                token: "support.function",
                regex: "\\)",
                next: "pop"
              }, {
                defaultToken: "string"
              }]
            }],
            strings: [{
              token: "string.start",
              regex: "'",
              push: [{
                token: "string.end",
                regex: "'|$",
                next: "pop"
              }, {
                include: "escapes"
              }, {
                token: "constant.language.escape",
                regex: /\\$/,
                consumeLineEnd: true
              }, {
                defaultToken: "string"
              }]
            }, {
              token: "string.start",
              regex: '"',
              push: [{
                token: "string.end",
                regex: '"|$',
                next: "pop"
              }, {
                include: "escapes"
              }, {
                token: "constant.language.escape",
                regex: /\\$/,
                consumeLineEnd: true
              }, {
                defaultToken: "string"
              }]
            }],
            escapes: [{
              token: "constant.language.escape",
              regex: /\\([a-fA-F\d]{1,6}|[^a-fA-F\d])/
            }]
          };
          this.normalizeRules();
        };
        oop.inherits(CssHighlightRules, TextHighlightRules);
        exports2.CssHighlightRules = CssHighlightRules;
      });
      ace.define("ace/mode/css_completions", ["require", "exports", "module"], function(acequire, exports2, module2) {
        "use strict";
        var propertyMap = {
          "background": { "#$0": 1 },
          "background-color": { "#$0": 1, "transparent": 1, "fixed": 1 },
          "background-image": { "url('/$0')": 1 },
          "background-repeat": { "repeat": 1, "repeat-x": 1, "repeat-y": 1, "no-repeat": 1, "inherit": 1 },
          "background-position": { "bottom": 2, "center": 2, "left": 2, "right": 2, "top": 2, "inherit": 2 },
          "background-attachment": { "scroll": 1, "fixed": 1 },
          "background-size": { "cover": 1, "contain": 1 },
          "background-clip": { "border-box": 1, "padding-box": 1, "content-box": 1 },
          "background-origin": { "border-box": 1, "padding-box": 1, "content-box": 1 },
          "border": { "solid $0": 1, "dashed $0": 1, "dotted $0": 1, "#$0": 1 },
          "border-color": { "#$0": 1 },
          "border-style": { "solid": 2, "dashed": 2, "dotted": 2, "double": 2, "groove": 2, "hidden": 2, "inherit": 2, "inset": 2, "none": 2, "outset": 2, "ridged": 2 },
          "border-collapse": { "collapse": 1, "separate": 1 },
          "bottom": { "px": 1, "em": 1, "%": 1 },
          "clear": { "left": 1, "right": 1, "both": 1, "none": 1 },
          "color": { "#$0": 1, "rgb(#$00,0,0)": 1 },
          "cursor": { "default": 1, "pointer": 1, "move": 1, "text": 1, "wait": 1, "help": 1, "progress": 1, "n-resize": 1, "ne-resize": 1, "e-resize": 1, "se-resize": 1, "s-resize": 1, "sw-resize": 1, "w-resize": 1, "nw-resize": 1 },
          "display": { "none": 1, "block": 1, "inline": 1, "inline-block": 1, "table-cell": 1 },
          "empty-cells": { "show": 1, "hide": 1 },
          "float": { "left": 1, "right": 1, "none": 1 },
          "font-family": { "Arial": 2, "Comic Sans MS": 2, "Consolas": 2, "Courier New": 2, "Courier": 2, "Georgia": 2, "Monospace": 2, "Sans-Serif": 2, "Segoe UI": 2, "Tahoma": 2, "Times New Roman": 2, "Trebuchet MS": 2, "Verdana": 1 },
          "font-size": { "px": 1, "em": 1, "%": 1 },
          "font-weight": { "bold": 1, "normal": 1 },
          "font-style": { "italic": 1, "normal": 1 },
          "font-variant": { "normal": 1, "small-caps": 1 },
          "height": { "px": 1, "em": 1, "%": 1 },
          "left": { "px": 1, "em": 1, "%": 1 },
          "letter-spacing": { "normal": 1 },
          "line-height": { "normal": 1 },
          "list-style-type": { "none": 1, "disc": 1, "circle": 1, "square": 1, "decimal": 1, "decimal-leading-zero": 1, "lower-roman": 1, "upper-roman": 1, "lower-greek": 1, "lower-latin": 1, "upper-latin": 1, "georgian": 1, "lower-alpha": 1, "upper-alpha": 1 },
          "margin": { "px": 1, "em": 1, "%": 1 },
          "margin-right": { "px": 1, "em": 1, "%": 1 },
          "margin-left": { "px": 1, "em": 1, "%": 1 },
          "margin-top": { "px": 1, "em": 1, "%": 1 },
          "margin-bottom": { "px": 1, "em": 1, "%": 1 },
          "max-height": { "px": 1, "em": 1, "%": 1 },
          "max-width": { "px": 1, "em": 1, "%": 1 },
          "min-height": { "px": 1, "em": 1, "%": 1 },
          "min-width": { "px": 1, "em": 1, "%": 1 },
          "overflow": { "hidden": 1, "visible": 1, "auto": 1, "scroll": 1 },
          "overflow-x": { "hidden": 1, "visible": 1, "auto": 1, "scroll": 1 },
          "overflow-y": { "hidden": 1, "visible": 1, "auto": 1, "scroll": 1 },
          "padding": { "px": 1, "em": 1, "%": 1 },
          "padding-top": { "px": 1, "em": 1, "%": 1 },
          "padding-right": { "px": 1, "em": 1, "%": 1 },
          "padding-bottom": { "px": 1, "em": 1, "%": 1 },
          "padding-left": { "px": 1, "em": 1, "%": 1 },
          "page-break-after": { "auto": 1, "always": 1, "avoid": 1, "left": 1, "right": 1 },
          "page-break-before": { "auto": 1, "always": 1, "avoid": 1, "left": 1, "right": 1 },
          "position": { "absolute": 1, "relative": 1, "fixed": 1, "static": 1 },
          "right": { "px": 1, "em": 1, "%": 1 },
          "table-layout": { "fixed": 1, "auto": 1 },
          "text-decoration": { "none": 1, "underline": 1, "line-through": 1, "blink": 1 },
          "text-align": { "left": 1, "right": 1, "center": 1, "justify": 1 },
          "text-transform": { "capitalize": 1, "uppercase": 1, "lowercase": 1, "none": 1 },
          "top": { "px": 1, "em": 1, "%": 1 },
          "vertical-align": { "top": 1, "bottom": 1 },
          "visibility": { "hidden": 1, "visible": 1 },
          "white-space": { "nowrap": 1, "normal": 1, "pre": 1, "pre-line": 1, "pre-wrap": 1 },
          "width": { "px": 1, "em": 1, "%": 1 },
          "word-spacing": { "normal": 1 },
          "filter": { "alpha(opacity=$0100)": 1 },
          "text-shadow": { "$02px 2px 2px #777": 1 },
          "text-overflow": { "ellipsis-word": 1, "clip": 1, "ellipsis": 1 },
          "-moz-border-radius": 1,
          "-moz-border-radius-topright": 1,
          "-moz-border-radius-bottomright": 1,
          "-moz-border-radius-topleft": 1,
          "-moz-border-radius-bottomleft": 1,
          "-webkit-border-radius": 1,
          "-webkit-border-top-right-radius": 1,
          "-webkit-border-top-left-radius": 1,
          "-webkit-border-bottom-right-radius": 1,
          "-webkit-border-bottom-left-radius": 1,
          "-moz-box-shadow": 1,
          "-webkit-box-shadow": 1,
          "transform": { "rotate($00deg)": 1, "skew($00deg)": 1 },
          "-moz-transform": { "rotate($00deg)": 1, "skew($00deg)": 1 },
          "-webkit-transform": { "rotate($00deg)": 1, "skew($00deg)": 1 }
        };
        var CssCompletions = function() {
        };
        (function() {
          this.completionsDefined = false;
          this.defineCompletions = function() {
            if (document) {
              var style = document.createElement("c").style;
              for (var i in style) {
                if (typeof style[i] !== "string")
                  continue;
                var name = i.replace(/[A-Z]/g, function(x) {
                  return "-" + x.toLowerCase();
                });
                if (!propertyMap.hasOwnProperty(name))
                  propertyMap[name] = 1;
              }
            }
            this.completionsDefined = true;
          };
          this.getCompletions = function(state, session, pos, prefix) {
            if (!this.completionsDefined) {
              this.defineCompletions();
            }
            var token = session.getTokenAt(pos.row, pos.column);
            if (!token)
              return [];
            if (state === "ruleset") {
              var line = session.getLine(pos.row).substr(0, pos.column);
              if (/:[^;]+$/.test(line)) {
                /([\w\-]+):[^:]*$/.test(line);
                return this.getPropertyValueCompletions(state, session, pos, prefix);
              } else {
                return this.getPropertyCompletions(state, session, pos, prefix);
              }
            }
            return [];
          };
          this.getPropertyCompletions = function(state, session, pos, prefix) {
            var properties = Object.keys(propertyMap);
            return properties.map(function(property) {
              return {
                caption: property,
                snippet: property + ": $0;",
                meta: "property",
                score: Number.MAX_VALUE
              };
            });
          };
          this.getPropertyValueCompletions = function(state, session, pos, prefix) {
            var line = session.getLine(pos.row).substr(0, pos.column);
            var property = (/([\w\-]+):[^:]*$/.exec(line) || {})[1];
            if (!property)
              return [];
            var values = [];
            if (property in propertyMap && typeof propertyMap[property] === "object") {
              values = Object.keys(propertyMap[property]);
            }
            return values.map(function(value) {
              return {
                caption: value,
                snippet: value,
                meta: "property value",
                score: Number.MAX_VALUE
              };
            });
          };
        }).call(CssCompletions.prototype);
        exports2.CssCompletions = CssCompletions;
      });
      ace.define("ace/mode/behaviour/css", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/mode/behaviour/cstyle", "ace/token_iterator"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("../../lib/oop");
        var Behaviour = acequire("../behaviour").Behaviour;
        var CstyleBehaviour = acequire("./cstyle").CstyleBehaviour;
        var TokenIterator = acequire("../../token_iterator").TokenIterator;
        var CssBehaviour = function() {
          this.inherit(CstyleBehaviour);
          this.add("colon", "insertion", function(state, action, editor, session, text) {
            if (text === ":") {
              var cursor = editor.getCursorPosition();
              var iterator = new TokenIterator(session, cursor.row, cursor.column);
              var token = iterator.getCurrentToken();
              if (token && token.value.match(/\s+/)) {
                token = iterator.stepBackward();
              }
              if (token && token.type === "support.type") {
                var line = session.doc.getLine(cursor.row);
                var rightChar = line.substring(cursor.column, cursor.column + 1);
                if (rightChar === ":") {
                  return {
                    text: "",
                    selection: [1, 1]
                  };
                }
                if (!line.substring(cursor.column).match(/^\s*;/)) {
                  return {
                    text: ":;",
                    selection: [1, 1]
                  };
                }
              }
            }
          });
          this.add("colon", "deletion", function(state, action, editor, session, range) {
            var selected = session.doc.getTextRange(range);
            if (!range.isMultiLine() && selected === ":") {
              var cursor = editor.getCursorPosition();
              var iterator = new TokenIterator(session, cursor.row, cursor.column);
              var token = iterator.getCurrentToken();
              if (token && token.value.match(/\s+/)) {
                token = iterator.stepBackward();
              }
              if (token && token.type === "support.type") {
                var line = session.doc.getLine(range.start.row);
                var rightChar = line.substring(range.end.column, range.end.column + 1);
                if (rightChar === ";") {
                  range.end.column++;
                  return range;
                }
              }
            }
          });
          this.add("semicolon", "insertion", function(state, action, editor, session, text) {
            if (text === ";") {
              var cursor = editor.getCursorPosition();
              var line = session.doc.getLine(cursor.row);
              var rightChar = line.substring(cursor.column, cursor.column + 1);
              if (rightChar === ";") {
                return {
                  text: "",
                  selection: [1, 1]
                };
              }
            }
          });
        };
        oop.inherits(CssBehaviour, CstyleBehaviour);
        exports2.CssBehaviour = CssBehaviour;
      });
      ace.define("ace/mode/css", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/css_highlight_rules", "ace/mode/matching_brace_outdent", "ace/worker/worker_client", "ace/mode/css_completions", "ace/mode/behaviour/css", "ace/mode/folding/cstyle"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("../lib/oop");
        var TextMode = acequire("./text").Mode;
        var CssHighlightRules = acequire("./css_highlight_rules").CssHighlightRules;
        var MatchingBraceOutdent = acequire("./matching_brace_outdent").MatchingBraceOutdent;
        var WorkerClient = acequire("../worker/worker_client").WorkerClient;
        var CssCompletions = acequire("./css_completions").CssCompletions;
        var CssBehaviour = acequire("./behaviour/css").CssBehaviour;
        var CStyleFoldMode = acequire("./folding/cstyle").FoldMode;
        var Mode = function() {
          this.HighlightRules = CssHighlightRules;
          this.$outdent = new MatchingBraceOutdent();
          this.$behaviour = new CssBehaviour();
          this.$completer = new CssCompletions();
          this.foldingRules = new CStyleFoldMode();
        };
        oop.inherits(Mode, TextMode);
        (function() {
          this.foldingRules = "cStyle";
          this.blockComment = { start: "/*", end: "*/" };
          this.getNextLineIndent = function(state, line, tab) {
            var indent = this.$getIndent(line);
            var tokens = this.getTokenizer().getLineTokens(line, state).tokens;
            if (tokens.length && tokens[tokens.length - 1].type == "comment") {
              return indent;
            }
            var match = line.match(/^.*\{\s*$/);
            if (match) {
              indent += tab;
            }
            return indent;
          };
          this.checkOutdent = function(state, line, input) {
            return this.$outdent.checkOutdent(line, input);
          };
          this.autoOutdent = function(state, doc, row) {
            this.$outdent.autoOutdent(doc, row);
          };
          this.getCompletions = function(state, session, pos, prefix) {
            return this.$completer.getCompletions(state, session, pos, prefix);
          };
          this.createWorker = function(session) {
            var worker = new WorkerClient(["ace"], require_css(), "Worker");
            worker.attachToDocument(session.getDocument());
            worker.on("annotate", function(e) {
              session.setAnnotations(e.data);
            });
            worker.on("terminate", function() {
              session.clearAnnotations();
            });
            return worker;
          };
          this.$id = "ace/mode/css";
        }).call(Mode.prototype);
        exports2.Mode = Mode;
      });
      ace.define("ace/mode/xml_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text_highlight_rules"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("../lib/oop");
        var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;
        var XmlHighlightRules = function(normalize) {
          var tagRegex = "[_:a-zA-Z\xC0-\uFFFF][-_:.a-zA-Z0-9\xC0-\uFFFF]*";
          this.$rules = {
            start: [
              { token: "string.cdata.xml", regex: "<\\!\\[CDATA\\[", next: "cdata" },
              {
                token: ["punctuation.instruction.xml", "keyword.instruction.xml"],
                regex: "(<\\?)(" + tagRegex + ")",
                next: "processing_instruction"
              },
              { token: "comment.start.xml", regex: "<\\!--", next: "comment" },
              {
                token: ["xml-pe.doctype.xml", "xml-pe.doctype.xml"],
                regex: "(<\\!)(DOCTYPE)(?=[\\s])",
                next: "doctype",
                caseInsensitive: true
              },
              { include: "tag" },
              { token: "text.end-tag-open.xml", regex: "</" },
              { token: "text.tag-open.xml", regex: "<" },
              { include: "reference" },
              { defaultToken: "text.xml" }
            ],
            processing_instruction: [{
              token: "entity.other.attribute-name.decl-attribute-name.xml",
              regex: tagRegex
            }, {
              token: "keyword.operator.decl-attribute-equals.xml",
              regex: "="
            }, {
              include: "whitespace"
            }, {
              include: "string"
            }, {
              token: "punctuation.xml-decl.xml",
              regex: "\\?>",
              next: "start"
            }],
            doctype: [
              { include: "whitespace" },
              { include: "string" },
              { token: "xml-pe.doctype.xml", regex: ">", next: "start" },
              { token: "xml-pe.xml", regex: "[-_a-zA-Z0-9:]+" },
              { token: "punctuation.int-subset", regex: "\\[", push: "int_subset" }
            ],
            int_subset: [{
              token: "text.xml",
              regex: "\\s+"
            }, {
              token: "punctuation.int-subset.xml",
              regex: "]",
              next: "pop"
            }, {
              token: ["punctuation.markup-decl.xml", "keyword.markup-decl.xml"],
              regex: "(<\\!)(" + tagRegex + ")",
              push: [
                {
                  token: "text",
                  regex: "\\s+"
                },
                {
                  token: "punctuation.markup-decl.xml",
                  regex: ">",
                  next: "pop"
                },
                { include: "string" }
              ]
            }],
            cdata: [
              { token: "string.cdata.xml", regex: "\\]\\]>", next: "start" },
              { token: "text.xml", regex: "\\s+" },
              { token: "text.xml", regex: "(?:[^\\]]|\\](?!\\]>))+" }
            ],
            comment: [
              { token: "comment.end.xml", regex: "-->", next: "start" },
              { defaultToken: "comment.xml" }
            ],
            reference: [{
              token: "constant.language.escape.reference.xml",
              regex: "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
            }],
            attr_reference: [{
              token: "constant.language.escape.reference.attribute-value.xml",
              regex: "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
            }],
            tag: [{
              token: ["meta.tag.punctuation.tag-open.xml", "meta.tag.punctuation.end-tag-open.xml", "meta.tag.tag-name.xml"],
              regex: "(?:(<)|(</))((?:" + tagRegex + ":)?" + tagRegex + ")",
              next: [
                { include: "attributes" },
                { token: "meta.tag.punctuation.tag-close.xml", regex: "/?>", next: "start" }
              ]
            }],
            tag_whitespace: [
              { token: "text.tag-whitespace.xml", regex: "\\s+" }
            ],
            whitespace: [
              { token: "text.whitespace.xml", regex: "\\s+" }
            ],
            string: [{
              token: "string.xml",
              regex: "'",
              push: [
                { token: "string.xml", regex: "'", next: "pop" },
                { defaultToken: "string.xml" }
              ]
            }, {
              token: "string.xml",
              regex: '"',
              push: [
                { token: "string.xml", regex: '"', next: "pop" },
                { defaultToken: "string.xml" }
              ]
            }],
            attributes: [{
              token: "entity.other.attribute-name.xml",
              regex: tagRegex
            }, {
              token: "keyword.operator.attribute-equals.xml",
              regex: "="
            }, {
              include: "tag_whitespace"
            }, {
              include: "attribute_value"
            }],
            attribute_value: [{
              token: "string.attribute-value.xml",
              regex: "'",
              push: [
                { token: "string.attribute-value.xml", regex: "'", next: "pop" },
                { include: "attr_reference" },
                { defaultToken: "string.attribute-value.xml" }
              ]
            }, {
              token: "string.attribute-value.xml",
              regex: '"',
              push: [
                { token: "string.attribute-value.xml", regex: '"', next: "pop" },
                { include: "attr_reference" },
                { defaultToken: "string.attribute-value.xml" }
              ]
            }]
          };
          if (this.constructor === XmlHighlightRules)
            this.normalizeRules();
        };
        (function() {
          this.embedTagRules = function(HighlightRules, prefix, tag) {
            this.$rules.tag.unshift({
              token: ["meta.tag.punctuation.tag-open.xml", "meta.tag." + tag + ".tag-name.xml"],
              regex: "(<)(" + tag + "(?=\\s|>|$))",
              next: [
                { include: "attributes" },
                { token: "meta.tag.punctuation.tag-close.xml", regex: "/?>", next: prefix + "start" }
              ]
            });
            this.$rules[tag + "-end"] = [
              { include: "attributes" },
              {
                token: "meta.tag.punctuation.tag-close.xml",
                regex: "/?>",
                next: "start",
                onMatch: function(value, currentState, stack) {
                  stack.splice(0);
                  return this.token;
                }
              }
            ];
            this.embedRules(HighlightRules, prefix, [{
              token: ["meta.tag.punctuation.end-tag-open.xml", "meta.tag." + tag + ".tag-name.xml"],
              regex: "(</)(" + tag + "(?=\\s|>|$))",
              next: tag + "-end"
            }, {
              token: "string.cdata.xml",
              regex: "<\\!\\[CDATA\\["
            }, {
              token: "string.cdata.xml",
              regex: "\\]\\]>"
            }]);
          };
        }).call(TextHighlightRules.prototype);
        oop.inherits(XmlHighlightRules, TextHighlightRules);
        exports2.XmlHighlightRules = XmlHighlightRules;
      });
      ace.define("ace/mode/html_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/mode/css_highlight_rules", "ace/mode/javascript_highlight_rules", "ace/mode/xml_highlight_rules"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("../lib/oop");
        var lang = acequire("../lib/lang");
        var CssHighlightRules = acequire("./css_highlight_rules").CssHighlightRules;
        var JavaScriptHighlightRules = acequire("./javascript_highlight_rules").JavaScriptHighlightRules;
        var XmlHighlightRules = acequire("./xml_highlight_rules").XmlHighlightRules;
        var tagMap = lang.createMap({
          a: "anchor",
          button: "form",
          form: "form",
          img: "image",
          input: "form",
          label: "form",
          option: "form",
          script: "script",
          select: "form",
          textarea: "form",
          style: "style",
          table: "table",
          tbody: "table",
          td: "table",
          tfoot: "table",
          th: "table",
          tr: "table"
        });
        var HtmlHighlightRules = function() {
          XmlHighlightRules.call(this);
          this.addRules({
            attributes: [{
              include: "tag_whitespace"
            }, {
              token: "entity.other.attribute-name.xml",
              regex: "[-_a-zA-Z0-9:.]+"
            }, {
              token: "keyword.operator.attribute-equals.xml",
              regex: "=",
              push: [{
                include: "tag_whitespace"
              }, {
                token: "string.unquoted.attribute-value.html",
                regex: "[^<>='\"`\\s]+",
                next: "pop"
              }, {
                token: "empty",
                regex: "",
                next: "pop"
              }]
            }, {
              include: "attribute_value"
            }],
            tag: [{
              token: function(start, tag) {
                var group = tagMap[tag];
                return [
                  "meta.tag.punctuation." + (start == "<" ? "" : "end-") + "tag-open.xml",
                  "meta.tag" + (group ? "." + group : "") + ".tag-name.xml"
                ];
              },
              regex: "(</?)([-_a-zA-Z0-9:.]+)",
              next: "tag_stuff"
            }],
            tag_stuff: [
              { include: "attributes" },
              { token: "meta.tag.punctuation.tag-close.xml", regex: "/?>", next: "start" }
            ]
          });
          this.embedTagRules(CssHighlightRules, "css-", "style");
          this.embedTagRules(new JavaScriptHighlightRules({ jsx: false }).getRules(), "js-", "script");
          if (this.constructor === HtmlHighlightRules)
            this.normalizeRules();
        };
        oop.inherits(HtmlHighlightRules, XmlHighlightRules);
        exports2.HtmlHighlightRules = HtmlHighlightRules;
      });
      ace.define("ace/mode/behaviour/xml", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/token_iterator", "ace/lib/lang"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("../../lib/oop");
        var Behaviour = acequire("../behaviour").Behaviour;
        var TokenIterator = acequire("../../token_iterator").TokenIterator;
        var lang = acequire("../../lib/lang");
        function is(token, type) {
          return token.type.lastIndexOf(type + ".xml") > -1;
        }
        var XmlBehaviour = function() {
          this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
            if (text == '"' || text == "'") {
              var quote = text;
              var selected = session.doc.getTextRange(editor.getSelectionRange());
              if (selected !== "" && selected !== "'" && selected != '"' && editor.getWrapBehavioursEnabled()) {
                return {
                  text: quote + selected + quote,
                  selection: false
                };
              }
              var cursor = editor.getCursorPosition();
              var line = session.doc.getLine(cursor.row);
              var rightChar = line.substring(cursor.column, cursor.column + 1);
              var iterator = new TokenIterator(session, cursor.row, cursor.column);
              var token = iterator.getCurrentToken();
              if (rightChar == quote && (is(token, "attribute-value") || is(token, "string"))) {
                return {
                  text: "",
                  selection: [1, 1]
                };
              }
              if (!token)
                token = iterator.stepBackward();
              if (!token)
                return;
              while (is(token, "tag-whitespace") || is(token, "whitespace")) {
                token = iterator.stepBackward();
              }
              var rightSpace = !rightChar || rightChar.match(/\s/);
              if (is(token, "attribute-equals") && (rightSpace || rightChar == ">") || is(token, "decl-attribute-equals") && (rightSpace || rightChar == "?")) {
                return {
                  text: quote + quote,
                  selection: [1, 1]
                };
              }
            }
          });
          this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
            var selected = session.doc.getTextRange(range);
            if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
              var line = session.doc.getLine(range.start.row);
              var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
              if (rightChar == selected) {
                range.end.column++;
                return range;
              }
            }
          });
          this.add("autoclosing", "insertion", function(state, action, editor, session, text) {
            if (text == ">") {
              var position = editor.getSelectionRange().start;
              var iterator = new TokenIterator(session, position.row, position.column);
              var token = iterator.getCurrentToken() || iterator.stepBackward();
              if (!token || !(is(token, "tag-name") || is(token, "tag-whitespace") || is(token, "attribute-name") || is(token, "attribute-equals") || is(token, "attribute-value")))
                return;
              if (is(token, "reference.attribute-value"))
                return;
              if (is(token, "attribute-value")) {
                var firstChar = token.value.charAt(0);
                if (firstChar == '"' || firstChar == "'") {
                  var lastChar = token.value.charAt(token.value.length - 1);
                  var tokenEnd = iterator.getCurrentTokenColumn() + token.value.length;
                  if (tokenEnd > position.column || tokenEnd == position.column && firstChar != lastChar)
                    return;
                }
              }
              while (!is(token, "tag-name")) {
                token = iterator.stepBackward();
                if (token.value == "<") {
                  token = iterator.stepForward();
                  break;
                }
              }
              var tokenRow = iterator.getCurrentTokenRow();
              var tokenColumn = iterator.getCurrentTokenColumn();
              if (is(iterator.stepBackward(), "end-tag-open"))
                return;
              var element = token.value;
              if (tokenRow == position.row)
                element = element.substring(0, position.column - tokenColumn);
              if (this.voidElements.hasOwnProperty(element.toLowerCase()))
                return;
              return {
                text: "></" + element + ">",
                selection: [1, 1]
              };
            }
          });
          this.add("autoindent", "insertion", function(state, action, editor, session, text) {
            if (text == "\n") {
              var cursor = editor.getCursorPosition();
              var line = session.getLine(cursor.row);
              var iterator = new TokenIterator(session, cursor.row, cursor.column);
              var token = iterator.getCurrentToken();
              if (token && token.type.indexOf("tag-close") !== -1) {
                if (token.value == "/>")
                  return;
                while (token && token.type.indexOf("tag-name") === -1) {
                  token = iterator.stepBackward();
                }
                if (!token) {
                  return;
                }
                var tag = token.value;
                var row = iterator.getCurrentTokenRow();
                token = iterator.stepBackward();
                if (!token || token.type.indexOf("end-tag") !== -1) {
                  return;
                }
                if (this.voidElements && !this.voidElements[tag]) {
                  var nextToken = session.getTokenAt(cursor.row, cursor.column + 1);
                  var line = session.getLine(row);
                  var nextIndent = this.$getIndent(line);
                  var indent = nextIndent + session.getTabString();
                  if (nextToken && nextToken.value === "</") {
                    return {
                      text: "\n" + indent + "\n" + nextIndent,
                      selection: [1, indent.length, 1, indent.length]
                    };
                  } else {
                    return {
                      text: "\n" + indent
                    };
                  }
                }
              }
            }
          });
        };
        oop.inherits(XmlBehaviour, Behaviour);
        exports2.XmlBehaviour = XmlBehaviour;
      });
      ace.define("ace/mode/folding/mixed", ["require", "exports", "module", "ace/lib/oop", "ace/mode/folding/fold_mode"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("../../lib/oop");
        var BaseFoldMode = acequire("./fold_mode").FoldMode;
        var FoldMode = exports2.FoldMode = function(defaultMode, subModes) {
          this.defaultMode = defaultMode;
          this.subModes = subModes;
        };
        oop.inherits(FoldMode, BaseFoldMode);
        (function() {
          this.$getMode = function(state) {
            if (typeof state != "string")
              state = state[0];
            for (var key in this.subModes) {
              if (state.indexOf(key) === 0)
                return this.subModes[key];
            }
            return null;
          };
          this.$tryMode = function(state, session, foldStyle, row) {
            var mode = this.$getMode(state);
            return mode ? mode.getFoldWidget(session, foldStyle, row) : "";
          };
          this.getFoldWidget = function(session, foldStyle, row) {
            return this.$tryMode(session.getState(row - 1), session, foldStyle, row) || this.$tryMode(session.getState(row), session, foldStyle, row) || this.defaultMode.getFoldWidget(session, foldStyle, row);
          };
          this.getFoldWidgetRange = function(session, foldStyle, row) {
            var mode = this.$getMode(session.getState(row - 1));
            if (!mode || !mode.getFoldWidget(session, foldStyle, row))
              mode = this.$getMode(session.getState(row));
            if (!mode || !mode.getFoldWidget(session, foldStyle, row))
              mode = this.defaultMode;
            return mode.getFoldWidgetRange(session, foldStyle, row);
          };
        }).call(FoldMode.prototype);
      });
      ace.define("ace/mode/folding/xml", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/range", "ace/mode/folding/fold_mode", "ace/token_iterator"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("../../lib/oop");
        var lang = acequire("../../lib/lang");
        var Range = acequire("../../range").Range;
        var BaseFoldMode = acequire("./fold_mode").FoldMode;
        var TokenIterator = acequire("../../token_iterator").TokenIterator;
        var FoldMode = exports2.FoldMode = function(voidElements, optionalEndTags) {
          BaseFoldMode.call(this);
          this.voidElements = voidElements || {};
          this.optionalEndTags = oop.mixin({}, this.voidElements);
          if (optionalEndTags)
            oop.mixin(this.optionalEndTags, optionalEndTags);
        };
        oop.inherits(FoldMode, BaseFoldMode);
        var Tag = function() {
          this.tagName = "";
          this.closing = false;
          this.selfClosing = false;
          this.start = { row: 0, column: 0 };
          this.end = { row: 0, column: 0 };
        };
        function is(token, type) {
          return token.type.lastIndexOf(type + ".xml") > -1;
        }
        (function() {
          this.getFoldWidget = function(session, foldStyle, row) {
            var tag = this._getFirstTagInLine(session, row);
            if (!tag)
              return this.getCommentFoldWidget(session, row);
            if (tag.closing || !tag.tagName && tag.selfClosing)
              return foldStyle == "markbeginend" ? "end" : "";
            if (!tag.tagName || tag.selfClosing || this.voidElements.hasOwnProperty(tag.tagName.toLowerCase()))
              return "";
            if (this._findEndTagInLine(session, row, tag.tagName, tag.end.column))
              return "";
            return "start";
          };
          this.getCommentFoldWidget = function(session, row) {
            if (/comment/.test(session.getState(row)) && /<!-/.test(session.getLine(row)))
              return "start";
            return "";
          };
          this._getFirstTagInLine = function(session, row) {
            var tokens = session.getTokens(row);
            var tag = new Tag();
            for (var i = 0; i < tokens.length; i++) {
              var token = tokens[i];
              if (is(token, "tag-open")) {
                tag.end.column = tag.start.column + token.value.length;
                tag.closing = is(token, "end-tag-open");
                token = tokens[++i];
                if (!token)
                  return null;
                tag.tagName = token.value;
                tag.end.column += token.value.length;
                for (i++; i < tokens.length; i++) {
                  token = tokens[i];
                  tag.end.column += token.value.length;
                  if (is(token, "tag-close")) {
                    tag.selfClosing = token.value == "/>";
                    break;
                  }
                }
                return tag;
              } else if (is(token, "tag-close")) {
                tag.selfClosing = token.value == "/>";
                return tag;
              }
              tag.start.column += token.value.length;
            }
            return null;
          };
          this._findEndTagInLine = function(session, row, tagName, startColumn) {
            var tokens = session.getTokens(row);
            var column = 0;
            for (var i = 0; i < tokens.length; i++) {
              var token = tokens[i];
              column += token.value.length;
              if (column < startColumn)
                continue;
              if (is(token, "end-tag-open")) {
                token = tokens[i + 1];
                if (token && token.value == tagName)
                  return true;
              }
            }
            return false;
          };
          this._readTagForward = function(iterator) {
            var token = iterator.getCurrentToken();
            if (!token)
              return null;
            var tag = new Tag();
            do {
              if (is(token, "tag-open")) {
                tag.closing = is(token, "end-tag-open");
                tag.start.row = iterator.getCurrentTokenRow();
                tag.start.column = iterator.getCurrentTokenColumn();
              } else if (is(token, "tag-name")) {
                tag.tagName = token.value;
              } else if (is(token, "tag-close")) {
                tag.selfClosing = token.value == "/>";
                tag.end.row = iterator.getCurrentTokenRow();
                tag.end.column = iterator.getCurrentTokenColumn() + token.value.length;
                iterator.stepForward();
                return tag;
              }
            } while (token = iterator.stepForward());
            return null;
          };
          this._readTagBackward = function(iterator) {
            var token = iterator.getCurrentToken();
            if (!token)
              return null;
            var tag = new Tag();
            do {
              if (is(token, "tag-open")) {
                tag.closing = is(token, "end-tag-open");
                tag.start.row = iterator.getCurrentTokenRow();
                tag.start.column = iterator.getCurrentTokenColumn();
                iterator.stepBackward();
                return tag;
              } else if (is(token, "tag-name")) {
                tag.tagName = token.value;
              } else if (is(token, "tag-close")) {
                tag.selfClosing = token.value == "/>";
                tag.end.row = iterator.getCurrentTokenRow();
                tag.end.column = iterator.getCurrentTokenColumn() + token.value.length;
              }
            } while (token = iterator.stepBackward());
            return null;
          };
          this._pop = function(stack, tag) {
            while (stack.length) {
              var top = stack[stack.length - 1];
              if (!tag || top.tagName == tag.tagName) {
                return stack.pop();
              } else if (this.optionalEndTags.hasOwnProperty(top.tagName)) {
                stack.pop();
                continue;
              } else {
                return null;
              }
            }
          };
          this.getFoldWidgetRange = function(session, foldStyle, row) {
            var firstTag = this._getFirstTagInLine(session, row);
            if (!firstTag) {
              return this.getCommentFoldWidget(session, row) && session.getCommentFoldRange(row, session.getLine(row).length);
            }
            var isBackward = firstTag.closing || firstTag.selfClosing;
            var stack = [];
            var tag;
            if (!isBackward) {
              var iterator = new TokenIterator(session, row, firstTag.start.column);
              var start = {
                row,
                column: firstTag.start.column + firstTag.tagName.length + 2
              };
              if (firstTag.start.row == firstTag.end.row)
                start.column = firstTag.end.column;
              while (tag = this._readTagForward(iterator)) {
                if (tag.selfClosing) {
                  if (!stack.length) {
                    tag.start.column += tag.tagName.length + 2;
                    tag.end.column -= 2;
                    return Range.fromPoints(tag.start, tag.end);
                  } else
                    continue;
                }
                if (tag.closing) {
                  this._pop(stack, tag);
                  if (stack.length == 0)
                    return Range.fromPoints(start, tag.start);
                } else {
                  stack.push(tag);
                }
              }
            } else {
              var iterator = new TokenIterator(session, row, firstTag.end.column);
              var end = {
                row,
                column: firstTag.start.column
              };
              while (tag = this._readTagBackward(iterator)) {
                if (tag.selfClosing) {
                  if (!stack.length) {
                    tag.start.column += tag.tagName.length + 2;
                    tag.end.column -= 2;
                    return Range.fromPoints(tag.start, tag.end);
                  } else
                    continue;
                }
                if (!tag.closing) {
                  this._pop(stack, tag);
                  if (stack.length == 0) {
                    tag.start.column += tag.tagName.length + 2;
                    if (tag.start.row == tag.end.row && tag.start.column < tag.end.column)
                      tag.start.column = tag.end.column;
                    return Range.fromPoints(tag.start, end);
                  }
                } else {
                  stack.push(tag);
                }
              }
            }
          };
        }).call(FoldMode.prototype);
      });
      ace.define("ace/mode/folding/html", ["require", "exports", "module", "ace/lib/oop", "ace/mode/folding/mixed", "ace/mode/folding/xml", "ace/mode/folding/cstyle"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("../../lib/oop");
        var MixedFoldMode = acequire("./mixed").FoldMode;
        var XmlFoldMode = acequire("./xml").FoldMode;
        var CStyleFoldMode = acequire("./cstyle").FoldMode;
        var FoldMode = exports2.FoldMode = function(voidElements, optionalTags) {
          MixedFoldMode.call(this, new XmlFoldMode(voidElements, optionalTags), {
            "js-": new CStyleFoldMode(),
            "css-": new CStyleFoldMode()
          });
        };
        oop.inherits(FoldMode, MixedFoldMode);
      });
      ace.define("ace/mode/html_completions", ["require", "exports", "module", "ace/token_iterator"], function(acequire, exports2, module2) {
        "use strict";
        var TokenIterator = acequire("../token_iterator").TokenIterator;
        var commonAttributes = [
          "accesskey",
          "class",
          "contenteditable",
          "contextmenu",
          "dir",
          "draggable",
          "dropzone",
          "hidden",
          "id",
          "inert",
          "itemid",
          "itemprop",
          "itemref",
          "itemscope",
          "itemtype",
          "lang",
          "spellcheck",
          "style",
          "tabindex",
          "title",
          "translate"
        ];
        var eventAttributes = [
          "onabort",
          "onblur",
          "oncancel",
          "oncanplay",
          "oncanplaythrough",
          "onchange",
          "onclick",
          "onclose",
          "oncontextmenu",
          "oncuechange",
          "ondblclick",
          "ondrag",
          "ondragend",
          "ondragenter",
          "ondragleave",
          "ondragover",
          "ondragstart",
          "ondrop",
          "ondurationchange",
          "onemptied",
          "onended",
          "onerror",
          "onfocus",
          "oninput",
          "oninvalid",
          "onkeydown",
          "onkeypress",
          "onkeyup",
          "onload",
          "onloadeddata",
          "onloadedmetadata",
          "onloadstart",
          "onmousedown",
          "onmousemove",
          "onmouseout",
          "onmouseover",
          "onmouseup",
          "onmousewheel",
          "onpause",
          "onplay",
          "onplaying",
          "onprogress",
          "onratechange",
          "onreset",
          "onscroll",
          "onseeked",
          "onseeking",
          "onselect",
          "onshow",
          "onstalled",
          "onsubmit",
          "onsuspend",
          "ontimeupdate",
          "onvolumechange",
          "onwaiting"
        ];
        var globalAttributes = commonAttributes.concat(eventAttributes);
        var attributeMap = {
          "html": { "manifest": 1 },
          "head": {},
          "title": {},
          "base": { "href": 1, "target": 1 },
          "link": { "href": 1, "hreflang": 1, "rel": { "stylesheet": 1, "icon": 1 }, "media": { "all": 1, "screen": 1, "print": 1 }, "type": { "text/css": 1, "image/png": 1, "image/jpeg": 1, "image/gif": 1 }, "sizes": 1 },
          "meta": { "http-equiv": { "content-type": 1 }, "name": { "description": 1, "keywords": 1 }, "content": { "text/html; charset=UTF-8": 1 }, "charset": 1 },
          "style": { "type": 1, "media": { "all": 1, "screen": 1, "print": 1 }, "scoped": 1 },
          "script": { "charset": 1, "type": { "text/javascript": 1 }, "src": 1, "defer": 1, "async": 1 },
          "noscript": { "href": 1 },
          "body": { "onafterprint": 1, "onbeforeprint": 1, "onbeforeunload": 1, "onhashchange": 1, "onmessage": 1, "onoffline": 1, "onpopstate": 1, "onredo": 1, "onresize": 1, "onstorage": 1, "onundo": 1, "onunload": 1 },
          "section": {},
          "nav": {},
          "article": { "pubdate": 1 },
          "aside": {},
          "h1": {},
          "h2": {},
          "h3": {},
          "h4": {},
          "h5": {},
          "h6": {},
          "header": {},
          "footer": {},
          "address": {},
          "main": {},
          "p": {},
          "hr": {},
          "pre": {},
          "blockquote": { "cite": 1 },
          "ol": { "start": 1, "reversed": 1 },
          "ul": {},
          "li": { "value": 1 },
          "dl": {},
          "dt": {},
          "dd": {},
          "figure": {},
          "figcaption": {},
          "div": {},
          "a": { "href": 1, "target": { "_blank": 1, "top": 1 }, "ping": 1, "rel": { "nofollow": 1, "alternate": 1, "author": 1, "bookmark": 1, "help": 1, "license": 1, "next": 1, "noreferrer": 1, "prefetch": 1, "prev": 1, "search": 1, "tag": 1 }, "media": 1, "hreflang": 1, "type": 1 },
          "em": {},
          "strong": {},
          "small": {},
          "s": {},
          "cite": {},
          "q": { "cite": 1 },
          "dfn": {},
          "abbr": {},
          "data": {},
          "time": { "datetime": 1 },
          "code": {},
          "var": {},
          "samp": {},
          "kbd": {},
          "sub": {},
          "sup": {},
          "i": {},
          "b": {},
          "u": {},
          "mark": {},
          "ruby": {},
          "rt": {},
          "rp": {},
          "bdi": {},
          "bdo": {},
          "span": {},
          "br": {},
          "wbr": {},
          "ins": { "cite": 1, "datetime": 1 },
          "del": { "cite": 1, "datetime": 1 },
          "img": { "alt": 1, "src": 1, "height": 1, "width": 1, "usemap": 1, "ismap": 1 },
          "iframe": { "name": 1, "src": 1, "height": 1, "width": 1, "sandbox": { "allow-same-origin": 1, "allow-top-navigation": 1, "allow-forms": 1, "allow-scripts": 1 }, "seamless": { "seamless": 1 } },
          "embed": { "src": 1, "height": 1, "width": 1, "type": 1 },
          "object": { "param": 1, "data": 1, "type": 1, "height": 1, "width": 1, "usemap": 1, "name": 1, "form": 1, "classid": 1 },
          "param": { "name": 1, "value": 1 },
          "video": { "src": 1, "autobuffer": 1, "autoplay": { "autoplay": 1 }, "loop": { "loop": 1 }, "controls": { "controls": 1 }, "width": 1, "height": 1, "poster": 1, "muted": { "muted": 1 }, "preload": { "auto": 1, "metadata": 1, "none": 1 } },
          "audio": { "src": 1, "autobuffer": 1, "autoplay": { "autoplay": 1 }, "loop": { "loop": 1 }, "controls": { "controls": 1 }, "muted": { "muted": 1 }, "preload": { "auto": 1, "metadata": 1, "none": 1 } },
          "source": { "src": 1, "type": 1, "media": 1 },
          "track": { "kind": 1, "src": 1, "srclang": 1, "label": 1, "default": 1 },
          "canvas": { "width": 1, "height": 1 },
          "map": { "name": 1 },
          "area": { "shape": 1, "coords": 1, "href": 1, "hreflang": 1, "alt": 1, "target": 1, "media": 1, "rel": 1, "ping": 1, "type": 1 },
          "svg": {},
          "math": {},
          "table": { "summary": 1 },
          "caption": {},
          "colgroup": { "span": 1 },
          "col": { "span": 1 },
          "tbody": {},
          "thead": {},
          "tfoot": {},
          "tr": {},
          "td": { "headers": 1, "rowspan": 1, "colspan": 1 },
          "th": { "headers": 1, "rowspan": 1, "colspan": 1, "scope": 1 },
          "form": { "accept-charset": 1, "action": 1, "autocomplete": 1, "enctype": { "multipart/form-data": 1, "application/x-www-form-urlencoded": 1 }, "method": { "get": 1, "post": 1 }, "name": 1, "novalidate": 1, "target": { "_blank": 1, "top": 1 } },
          "fieldset": { "disabled": 1, "form": 1, "name": 1 },
          "legend": {},
          "label": { "form": 1, "for": 1 },
          "input": {
            "type": { "text": 1, "password": 1, "hidden": 1, "checkbox": 1, "submit": 1, "radio": 1, "file": 1, "button": 1, "reset": 1, "image": 31, "color": 1, "date": 1, "datetime": 1, "datetime-local": 1, "email": 1, "month": 1, "number": 1, "range": 1, "search": 1, "tel": 1, "time": 1, "url": 1, "week": 1 },
            "accept": 1,
            "alt": 1,
            "autocomplete": { "on": 1, "off": 1 },
            "autofocus": { "autofocus": 1 },
            "checked": { "checked": 1 },
            "disabled": { "disabled": 1 },
            "form": 1,
            "formaction": 1,
            "formenctype": { "application/x-www-form-urlencoded": 1, "multipart/form-data": 1, "text/plain": 1 },
            "formmethod": { "get": 1, "post": 1 },
            "formnovalidate": { "formnovalidate": 1 },
            "formtarget": { "_blank": 1, "_self": 1, "_parent": 1, "_top": 1 },
            "height": 1,
            "list": 1,
            "max": 1,
            "maxlength": 1,
            "min": 1,
            "multiple": { "multiple": 1 },
            "name": 1,
            "pattern": 1,
            "placeholder": 1,
            "readonly": { "readonly": 1 },
            "acequired": { "acequired": 1 },
            "size": 1,
            "src": 1,
            "step": 1,
            "width": 1,
            "files": 1,
            "value": 1
          },
          "button": { "autofocus": 1, "disabled": { "disabled": 1 }, "form": 1, "formaction": 1, "formenctype": 1, "formmethod": 1, "formnovalidate": 1, "formtarget": 1, "name": 1, "value": 1, "type": { "button": 1, "submit": 1 } },
          "select": { "autofocus": 1, "disabled": 1, "form": 1, "multiple": { "multiple": 1 }, "name": 1, "size": 1, "readonly": { "readonly": 1 } },
          "datalist": {},
          "optgroup": { "disabled": 1, "label": 1 },
          "option": { "disabled": 1, "selected": 1, "label": 1, "value": 1 },
          "textarea": { "autofocus": { "autofocus": 1 }, "disabled": { "disabled": 1 }, "form": 1, "maxlength": 1, "name": 1, "placeholder": 1, "readonly": { "readonly": 1 }, "acequired": { "acequired": 1 }, "rows": 1, "cols": 1, "wrap": { "on": 1, "off": 1, "hard": 1, "soft": 1 } },
          "keygen": { "autofocus": 1, "challenge": { "challenge": 1 }, "disabled": { "disabled": 1 }, "form": 1, "keytype": { "rsa": 1, "dsa": 1, "ec": 1 }, "name": 1 },
          "output": { "for": 1, "form": 1, "name": 1 },
          "progress": { "value": 1, "max": 1 },
          "meter": { "value": 1, "min": 1, "max": 1, "low": 1, "high": 1, "optimum": 1 },
          "details": { "open": 1 },
          "summary": {},
          "command": { "type": 1, "label": 1, "icon": 1, "disabled": 1, "checked": 1, "radiogroup": 1, "command": 1 },
          "menu": { "type": 1, "label": 1 },
          "dialog": { "open": 1 }
        };
        var elements = Object.keys(attributeMap);
        function is(token, type) {
          return token.type.lastIndexOf(type + ".xml") > -1;
        }
        function findTagName(session, pos) {
          var iterator = new TokenIterator(session, pos.row, pos.column);
          var token = iterator.getCurrentToken();
          while (token && !is(token, "tag-name")) {
            token = iterator.stepBackward();
          }
          if (token)
            return token.value;
        }
        function findAttributeName(session, pos) {
          var iterator = new TokenIterator(session, pos.row, pos.column);
          var token = iterator.getCurrentToken();
          while (token && !is(token, "attribute-name")) {
            token = iterator.stepBackward();
          }
          if (token)
            return token.value;
        }
        var HtmlCompletions = function() {
        };
        (function() {
          this.getCompletions = function(state, session, pos, prefix) {
            var token = session.getTokenAt(pos.row, pos.column);
            if (!token)
              return [];
            if (is(token, "tag-name") || is(token, "tag-open") || is(token, "end-tag-open"))
              return this.getTagCompletions(state, session, pos, prefix);
            if (is(token, "tag-whitespace") || is(token, "attribute-name"))
              return this.getAttributeCompletions(state, session, pos, prefix);
            if (is(token, "attribute-value"))
              return this.getAttributeValueCompletions(state, session, pos, prefix);
            var line = session.getLine(pos.row).substr(0, pos.column);
            if (/&[a-z]*$/i.test(line))
              return this.getHTMLEntityCompletions(state, session, pos, prefix);
            return [];
          };
          this.getTagCompletions = function(state, session, pos, prefix) {
            return elements.map(function(element) {
              return {
                value: element,
                meta: "tag",
                score: Number.MAX_VALUE
              };
            });
          };
          this.getAttributeCompletions = function(state, session, pos, prefix) {
            var tagName = findTagName(session, pos);
            if (!tagName)
              return [];
            var attributes = globalAttributes;
            if (tagName in attributeMap) {
              attributes = attributes.concat(Object.keys(attributeMap[tagName]));
            }
            return attributes.map(function(attribute) {
              return {
                caption: attribute,
                snippet: attribute + '="$0"',
                meta: "attribute",
                score: Number.MAX_VALUE
              };
            });
          };
          this.getAttributeValueCompletions = function(state, session, pos, prefix) {
            var tagName = findTagName(session, pos);
            var attributeName = findAttributeName(session, pos);
            if (!tagName)
              return [];
            var values = [];
            if (tagName in attributeMap && attributeName in attributeMap[tagName] && typeof attributeMap[tagName][attributeName] === "object") {
              values = Object.keys(attributeMap[tagName][attributeName]);
            }
            return values.map(function(value) {
              return {
                caption: value,
                snippet: value,
                meta: "attribute value",
                score: Number.MAX_VALUE
              };
            });
          };
          this.getHTMLEntityCompletions = function(state, session, pos, prefix) {
            var values = ["Aacute;", "aacute;", "Acirc;", "acirc;", "acute;", "AElig;", "aelig;", "Agrave;", "agrave;", "alefsym;", "Alpha;", "alpha;", "amp;", "and;", "ang;", "Aring;", "aring;", "asymp;", "Atilde;", "atilde;", "Auml;", "auml;", "bdquo;", "Beta;", "beta;", "brvbar;", "bull;", "cap;", "Ccedil;", "ccedil;", "cedil;", "cent;", "Chi;", "chi;", "circ;", "clubs;", "cong;", "copy;", "crarr;", "cup;", "curren;", "Dagger;", "dagger;", "dArr;", "darr;", "deg;", "Delta;", "delta;", "diams;", "divide;", "Eacute;", "eacute;", "Ecirc;", "ecirc;", "Egrave;", "egrave;", "empty;", "emsp;", "ensp;", "Epsilon;", "epsilon;", "equiv;", "Eta;", "eta;", "ETH;", "eth;", "Euml;", "euml;", "euro;", "exist;", "fnof;", "forall;", "frac12;", "frac14;", "frac34;", "frasl;", "Gamma;", "gamma;", "ge;", "gt;", "hArr;", "harr;", "hearts;", "hellip;", "Iacute;", "iacute;", "Icirc;", "icirc;", "iexcl;", "Igrave;", "igrave;", "image;", "infin;", "int;", "Iota;", "iota;", "iquest;", "isin;", "Iuml;", "iuml;", "Kappa;", "kappa;", "Lambda;", "lambda;", "lang;", "laquo;", "lArr;", "larr;", "lceil;", "ldquo;", "le;", "lfloor;", "lowast;", "loz;", "lrm;", "lsaquo;", "lsquo;", "lt;", "macr;", "mdash;", "micro;", "middot;", "minus;", "Mu;", "mu;", "nabla;", "nbsp;", "ndash;", "ne;", "ni;", "not;", "notin;", "nsub;", "Ntilde;", "ntilde;", "Nu;", "nu;", "Oacute;", "oacute;", "Ocirc;", "ocirc;", "OElig;", "oelig;", "Ograve;", "ograve;", "oline;", "Omega;", "omega;", "Omicron;", "omicron;", "oplus;", "or;", "ordf;", "ordm;", "Oslash;", "oslash;", "Otilde;", "otilde;", "otimes;", "Ouml;", "ouml;", "para;", "part;", "permil;", "perp;", "Phi;", "phi;", "Pi;", "pi;", "piv;", "plusmn;", "pound;", "Prime;", "prime;", "prod;", "prop;", "Psi;", "psi;", "quot;", "radic;", "rang;", "raquo;", "rArr;", "rarr;", "rceil;", "rdquo;", "real;", "reg;", "rfloor;", "Rho;", "rho;", "rlm;", "rsaquo;", "rsquo;", "sbquo;", "Scaron;", "scaron;", "sdot;", "sect;", "shy;", "Sigma;", "sigma;", "sigmaf;", "sim;", "spades;", "sub;", "sube;", "sum;", "sup;", "sup1;", "sup2;", "sup3;", "supe;", "szlig;", "Tau;", "tau;", "there4;", "Theta;", "theta;", "thetasym;", "thinsp;", "THORN;", "thorn;", "tilde;", "times;", "trade;", "Uacute;", "uacute;", "uArr;", "uarr;", "Ucirc;", "ucirc;", "Ugrave;", "ugrave;", "uml;", "upsih;", "Upsilon;", "upsilon;", "Uuml;", "uuml;", "weierp;", "Xi;", "xi;", "Yacute;", "yacute;", "yen;", "Yuml;", "yuml;", "Zeta;", "zeta;", "zwj;", "zwnj;"];
            return values.map(function(value) {
              return {
                caption: value,
                snippet: value,
                meta: "html entity",
                score: Number.MAX_VALUE
              };
            });
          };
        }).call(HtmlCompletions.prototype);
        exports2.HtmlCompletions = HtmlCompletions;
      });
      ace.define("ace/mode/html", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/mode/text", "ace/mode/javascript", "ace/mode/css", "ace/mode/html_highlight_rules", "ace/mode/behaviour/xml", "ace/mode/folding/html", "ace/mode/html_completions", "ace/worker/worker_client"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("../lib/oop");
        var lang = acequire("../lib/lang");
        var TextMode = acequire("./text").Mode;
        var JavaScriptMode = acequire("./javascript").Mode;
        var CssMode = acequire("./css").Mode;
        var HtmlHighlightRules = acequire("./html_highlight_rules").HtmlHighlightRules;
        var XmlBehaviour = acequire("./behaviour/xml").XmlBehaviour;
        var HtmlFoldMode = acequire("./folding/html").FoldMode;
        var HtmlCompletions = acequire("./html_completions").HtmlCompletions;
        var WorkerClient = acequire("../worker/worker_client").WorkerClient;
        var voidElements = ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "meta", "menuitem", "param", "source", "track", "wbr"];
        var optionalEndTags = ["li", "dt", "dd", "p", "rt", "rp", "optgroup", "option", "colgroup", "td", "th"];
        var Mode = function(options) {
          this.fragmentContext = options && options.fragmentContext;
          this.HighlightRules = HtmlHighlightRules;
          this.$behaviour = new XmlBehaviour();
          this.$completer = new HtmlCompletions();
          this.createModeDelegates({
            "js-": JavaScriptMode,
            "css-": CssMode
          });
          this.foldingRules = new HtmlFoldMode(this.voidElements, lang.arrayToMap(optionalEndTags));
        };
        oop.inherits(Mode, TextMode);
        (function() {
          this.blockComment = { start: "<!--", end: "-->" };
          this.voidElements = lang.arrayToMap(voidElements);
          this.getNextLineIndent = function(state, line, tab) {
            return this.$getIndent(line);
          };
          this.checkOutdent = function(state, line, input) {
            return false;
          };
          this.getCompletions = function(state, session, pos, prefix) {
            return this.$completer.getCompletions(state, session, pos, prefix);
          };
          this.createWorker = function(session) {
            if (this.constructor != Mode)
              return;
            var worker = new WorkerClient(["ace"], require_html(), "Worker");
            worker.attachToDocument(session.getDocument());
            if (this.fragmentContext)
              worker.call("setOptions", [{ context: this.fragmentContext }]);
            worker.on("error", function(e) {
              session.setAnnotations(e.data);
            });
            worker.on("terminate", function() {
              session.clearAnnotations();
            });
            return worker;
          };
          this.$id = "ace/mode/html";
        }).call(Mode.prototype);
        exports2.Mode = Mode;
      });
    }
  });

  // node_modules/brace/mode/javascript.js
  var require_javascript2 = __commonJS({
    "node_modules/brace/mode/javascript.js"() {
      ace.define("ace/mode/doc_comment_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text_highlight_rules"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("../lib/oop");
        var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;
        var DocCommentHighlightRules = function() {
          this.$rules = {
            "start": [
              {
                token: "comment.doc.tag",
                regex: "@[\\w\\d_]+"
                // TODO: fix email addresses
              },
              DocCommentHighlightRules.getTagRule(),
              {
                defaultToken: "comment.doc",
                caseInsensitive: true
              }
            ]
          };
        };
        oop.inherits(DocCommentHighlightRules, TextHighlightRules);
        DocCommentHighlightRules.getTagRule = function(start) {
          return {
            token: "comment.doc.tag.storage.type",
            regex: "\\b(?:TODO|FIXME|XXX|HACK)\\b"
          };
        };
        DocCommentHighlightRules.getStartRule = function(start) {
          return {
            token: "comment.doc",
            // doc comment
            regex: "\\/\\*(?=\\*)",
            next: start
          };
        };
        DocCommentHighlightRules.getEndRule = function(start) {
          return {
            token: "comment.doc",
            // closing comment
            regex: "\\*\\/",
            next: start
          };
        };
        exports2.DocCommentHighlightRules = DocCommentHighlightRules;
      });
      ace.define("ace/mode/javascript_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/doc_comment_highlight_rules", "ace/mode/text_highlight_rules"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("../lib/oop");
        var DocCommentHighlightRules = acequire("./doc_comment_highlight_rules").DocCommentHighlightRules;
        var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;
        var identifierRe = "[a-zA-Z\\$_\xA1-\uFFFF][a-zA-Z\\d\\$_\xA1-\uFFFF]*";
        var JavaScriptHighlightRules = function(options) {
          var keywordMapper = this.createKeywordMapper({
            "variable.language": "Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|Namespace|QName|XML|XMLList|ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|SyntaxError|TypeError|URIError|decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|isNaN|parseFloat|parseInt|JSON|Math|this|arguments|prototype|window|document",
            // Pseudo
            "keyword": "const|yield|import|get|set|async|await|break|case|catch|continue|default|delete|do|else|finally|for|function|if|in|of|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|__parent__|__count__|escape|unescape|with|__proto__|class|enum|extends|super|export|implements|private|public|interface|package|protected|static",
            "storage.type": "const|let|var|function",
            "constant.language": "null|Infinity|NaN|undefined",
            "support.function": "alert",
            "constant.language.boolean": "true|false"
          }, "identifier");
          var kwBeforeRe = "case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void";
          var escapedRe = "\\\\(?:x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|u{[0-9a-fA-F]{1,6}}|[0-2][0-7]{0,2}|3[0-7][0-7]?|[4-7][0-7]?|.)";
          this.$rules = {
            "no_regex": [
              DocCommentHighlightRules.getStartRule("doc-start"),
              comments("no_regex"),
              {
                token: "string",
                regex: "'(?=.)",
                next: "qstring"
              },
              {
                token: "string",
                regex: '"(?=.)',
                next: "qqstring"
              },
              {
                token: "constant.numeric",
                // hexadecimal, octal and binary
                regex: /0(?:[xX][0-9a-fA-F]+|[oO][0-7]+|[bB][01]+)\b/
              },
              {
                token: "constant.numeric",
                // decimal integers and floats
                regex: /(?:\d\d*(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+\b)?/
              },
              {
                token: [
                  "storage.type",
                  "punctuation.operator",
                  "support.function",
                  "punctuation.operator",
                  "entity.name.function",
                  "text",
                  "keyword.operator"
                ],
                regex: "(" + identifierRe + ")(\\.)(prototype)(\\.)(" + identifierRe + ")(\\s*)(=)",
                next: "function_arguments"
              },
              {
                token: [
                  "storage.type",
                  "punctuation.operator",
                  "entity.name.function",
                  "text",
                  "keyword.operator",
                  "text",
                  "storage.type",
                  "text",
                  "paren.lparen"
                ],
                regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
              },
              {
                token: [
                  "entity.name.function",
                  "text",
                  "keyword.operator",
                  "text",
                  "storage.type",
                  "text",
                  "paren.lparen"
                ],
                regex: "(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
              },
              {
                token: [
                  "storage.type",
                  "punctuation.operator",
                  "entity.name.function",
                  "text",
                  "keyword.operator",
                  "text",
                  "storage.type",
                  "text",
                  "entity.name.function",
                  "text",
                  "paren.lparen"
                ],
                regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s+)(\\w+)(\\s*)(\\()",
                next: "function_arguments"
              },
              {
                token: [
                  "storage.type",
                  "text",
                  "entity.name.function",
                  "text",
                  "paren.lparen"
                ],
                regex: "(function)(\\s+)(" + identifierRe + ")(\\s*)(\\()",
                next: "function_arguments"
              },
              {
                token: [
                  "entity.name.function",
                  "text",
                  "punctuation.operator",
                  "text",
                  "storage.type",
                  "text",
                  "paren.lparen"
                ],
                regex: "(" + identifierRe + ")(\\s*)(:)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
              },
              {
                token: [
                  "text",
                  "text",
                  "storage.type",
                  "text",
                  "paren.lparen"
                ],
                regex: "(:)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
              },
              {
                token: "keyword",
                regex: `from(?=\\s*('|"))`
              },
              {
                token: "keyword",
                regex: "(?:" + kwBeforeRe + ")\\b",
                next: "start"
              },
              {
                token: ["support.constant"],
                regex: /that\b/
              },
              {
                token: ["storage.type", "punctuation.operator", "support.function.firebug"],
                regex: /(console)(\.)(warn|info|log|error|time|trace|timeEnd|assert)\b/
              },
              {
                token: keywordMapper,
                regex: identifierRe
              },
              {
                token: "punctuation.operator",
                regex: /[.](?![.])/,
                next: "property"
              },
              {
                token: "storage.type",
                regex: /=>/
              },
              {
                token: "keyword.operator",
                regex: /--|\+\+|\.{3}|===|==|=|!=|!==|<+=?|>+=?|!|&&|\|\||\?:|[!$%&*+\-~\/^]=?/,
                next: "start"
              },
              {
                token: "punctuation.operator",
                regex: /[?:,;.]/,
                next: "start"
              },
              {
                token: "paren.lparen",
                regex: /[\[({]/,
                next: "start"
              },
              {
                token: "paren.rparen",
                regex: /[\])}]/
              },
              {
                token: "comment",
                regex: /^#!.*$/
              }
            ],
            property: [
              {
                token: "text",
                regex: "\\s+"
              },
              {
                token: [
                  "storage.type",
                  "punctuation.operator",
                  "entity.name.function",
                  "text",
                  "keyword.operator",
                  "text",
                  "storage.type",
                  "text",
                  "entity.name.function",
                  "text",
                  "paren.lparen"
                ],
                regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(?:(\\s+)(\\w+))?(\\s*)(\\()",
                next: "function_arguments"
              },
              {
                token: "punctuation.operator",
                regex: /[.](?![.])/
              },
              {
                token: "support.function",
                regex: /(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\b(?=\()/
              },
              {
                token: "support.function.dom",
                regex: /(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName|ClassName)|ById)|Attribute(?:Node)?)|blur)\b(?=\()/
              },
              {
                token: "support.constant",
                regex: /(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\b/
              },
              {
                token: "identifier",
                regex: identifierRe
              },
              {
                regex: "",
                token: "empty",
                next: "no_regex"
              }
            ],
            "start": [
              DocCommentHighlightRules.getStartRule("doc-start"),
              comments("start"),
              {
                token: "string.regexp",
                regex: "\\/",
                next: "regex"
              },
              {
                token: "text",
                regex: "\\s+|^$",
                next: "start"
              },
              {
                token: "empty",
                regex: "",
                next: "no_regex"
              }
            ],
            "regex": [
              {
                token: "regexp.keyword.operator",
                regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
              },
              {
                token: "string.regexp",
                regex: "/[sxngimy]*",
                next: "no_regex"
              },
              {
                token: "invalid",
                regex: /\{\d+\b,?\d*\}[+*]|[+*$^?][+*]|[$^][?]|\?{3,}/
              },
              {
                token: "constant.language.escape",
                regex: /\(\?[:=!]|\)|\{\d+\b,?\d*\}|[+*]\?|[()$^+*?.]/
              },
              {
                token: "constant.language.delimiter",
                regex: /\|/
              },
              {
                token: "constant.language.escape",
                regex: /\[\^?/,
                next: "regex_character_class"
              },
              {
                token: "empty",
                regex: "$",
                next: "no_regex"
              },
              {
                defaultToken: "string.regexp"
              }
            ],
            "regex_character_class": [
              {
                token: "regexp.charclass.keyword.operator",
                regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
              },
              {
                token: "constant.language.escape",
                regex: "]",
                next: "regex"
              },
              {
                token: "constant.language.escape",
                regex: "-"
              },
              {
                token: "empty",
                regex: "$",
                next: "no_regex"
              },
              {
                defaultToken: "string.regexp.charachterclass"
              }
            ],
            "function_arguments": [
              {
                token: "variable.parameter",
                regex: identifierRe
              },
              {
                token: "punctuation.operator",
                regex: "[, ]+"
              },
              {
                token: "punctuation.operator",
                regex: "$"
              },
              {
                token: "empty",
                regex: "",
                next: "no_regex"
              }
            ],
            "qqstring": [
              {
                token: "constant.language.escape",
                regex: escapedRe
              },
              {
                token: "string",
                regex: "\\\\$",
                consumeLineEnd: true
              },
              {
                token: "string",
                regex: '"|$',
                next: "no_regex"
              },
              {
                defaultToken: "string"
              }
            ],
            "qstring": [
              {
                token: "constant.language.escape",
                regex: escapedRe
              },
              {
                token: "string",
                regex: "\\\\$",
                consumeLineEnd: true
              },
              {
                token: "string",
                regex: "'|$",
                next: "no_regex"
              },
              {
                defaultToken: "string"
              }
            ]
          };
          if (!options || !options.noES6) {
            this.$rules.no_regex.unshift({
              regex: "[{}]",
              onMatch: function(val, state, stack) {
                this.next = val == "{" ? this.nextState : "";
                if (val == "{" && stack.length) {
                  stack.unshift("start", state);
                } else if (val == "}" && stack.length) {
                  stack.shift();
                  this.next = stack.shift();
                  if (this.next.indexOf("string") != -1 || this.next.indexOf("jsx") != -1)
                    return "paren.quasi.end";
                }
                return val == "{" ? "paren.lparen" : "paren.rparen";
              },
              nextState: "start"
            }, {
              token: "string.quasi.start",
              regex: /`/,
              push: [{
                token: "constant.language.escape",
                regex: escapedRe
              }, {
                token: "paren.quasi.start",
                regex: /\${/,
                push: "start"
              }, {
                token: "string.quasi.end",
                regex: /`/,
                next: "pop"
              }, {
                defaultToken: "string.quasi"
              }]
            });
            if (!options || options.jsx != false)
              JSX.call(this);
          }
          this.embedRules(
            DocCommentHighlightRules,
            "doc-",
            [DocCommentHighlightRules.getEndRule("no_regex")]
          );
          this.normalizeRules();
        };
        oop.inherits(JavaScriptHighlightRules, TextHighlightRules);
        function JSX() {
          var tagRegex = identifierRe.replace("\\d", "\\d\\-");
          var jsxTag = {
            onMatch: function(val, state, stack) {
              var offset = val.charAt(1) == "/" ? 2 : 1;
              if (offset == 1) {
                if (state != this.nextState)
                  stack.unshift(this.next, this.nextState, 0);
                else
                  stack.unshift(this.next);
                stack[2]++;
              } else if (offset == 2) {
                if (state == this.nextState) {
                  stack[1]--;
                  if (!stack[1] || stack[1] < 0) {
                    stack.shift();
                    stack.shift();
                  }
                }
              }
              return [{
                type: "meta.tag.punctuation." + (offset == 1 ? "" : "end-") + "tag-open.xml",
                value: val.slice(0, offset)
              }, {
                type: "meta.tag.tag-name.xml",
                value: val.substr(offset)
              }];
            },
            regex: "</?" + tagRegex,
            next: "jsxAttributes",
            nextState: "jsx"
          };
          this.$rules.start.unshift(jsxTag);
          var jsxJsRule = {
            regex: "{",
            token: "paren.quasi.start",
            push: "start"
          };
          this.$rules.jsx = [
            jsxJsRule,
            jsxTag,
            { include: "reference" },
            { defaultToken: "string" }
          ];
          this.$rules.jsxAttributes = [
            {
              token: "meta.tag.punctuation.tag-close.xml",
              regex: "/?>",
              onMatch: function(value, currentState, stack) {
                if (currentState == stack[0])
                  stack.shift();
                if (value.length == 2) {
                  if (stack[0] == this.nextState)
                    stack[1]--;
                  if (!stack[1] || stack[1] < 0) {
                    stack.splice(0, 2);
                  }
                }
                this.next = stack[0] || "start";
                return [{ type: this.token, value }];
              },
              nextState: "jsx"
            },
            jsxJsRule,
            comments("jsxAttributes"),
            {
              token: "entity.other.attribute-name.xml",
              regex: tagRegex
            },
            {
              token: "keyword.operator.attribute-equals.xml",
              regex: "="
            },
            {
              token: "text.tag-whitespace.xml",
              regex: "\\s+"
            },
            {
              token: "string.attribute-value.xml",
              regex: "'",
              stateName: "jsx_attr_q",
              push: [
                { token: "string.attribute-value.xml", regex: "'", next: "pop" },
                { include: "reference" },
                { defaultToken: "string.attribute-value.xml" }
              ]
            },
            {
              token: "string.attribute-value.xml",
              regex: '"',
              stateName: "jsx_attr_qq",
              push: [
                { token: "string.attribute-value.xml", regex: '"', next: "pop" },
                { include: "reference" },
                { defaultToken: "string.attribute-value.xml" }
              ]
            },
            jsxTag
          ];
          this.$rules.reference = [{
            token: "constant.language.escape.reference.xml",
            regex: "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
          }];
        }
        function comments(next) {
          return [
            {
              token: "comment",
              // multi line comment
              regex: /\/\*/,
              next: [
                DocCommentHighlightRules.getTagRule(),
                { token: "comment", regex: "\\*\\/", next: next || "pop" },
                { defaultToken: "comment", caseInsensitive: true }
              ]
            },
            {
              token: "comment",
              regex: "\\/\\/",
              next: [
                DocCommentHighlightRules.getTagRule(),
                { token: "comment", regex: "$|^", next: next || "pop" },
                { defaultToken: "comment", caseInsensitive: true }
              ]
            }
          ];
        }
        exports2.JavaScriptHighlightRules = JavaScriptHighlightRules;
      });
      ace.define("ace/mode/matching_brace_outdent", ["require", "exports", "module", "ace/range"], function(acequire, exports2, module2) {
        "use strict";
        var Range = acequire("../range").Range;
        var MatchingBraceOutdent = function() {
        };
        (function() {
          this.checkOutdent = function(line, input) {
            if (!/^\s+$/.test(line))
              return false;
            return /^\s*\}/.test(input);
          };
          this.autoOutdent = function(doc, row) {
            var line = doc.getLine(row);
            var match = line.match(/^(\s*\})/);
            if (!match)
              return 0;
            var column = match[1].length;
            var openBracePos = doc.findMatchingBracket({ row, column });
            if (!openBracePos || openBracePos.row == row)
              return 0;
            var indent = this.$getIndent(doc.getLine(openBracePos.row));
            doc.replace(new Range(row, 0, row, column - 1), indent);
          };
          this.$getIndent = function(line) {
            return line.match(/^\s*/)[0];
          };
        }).call(MatchingBraceOutdent.prototype);
        exports2.MatchingBraceOutdent = MatchingBraceOutdent;
      });
      ace.define("ace/mode/folding/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/range", "ace/mode/folding/fold_mode"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("../../lib/oop");
        var Range = acequire("../../range").Range;
        var BaseFoldMode = acequire("./fold_mode").FoldMode;
        var FoldMode = exports2.FoldMode = function(commentRegex) {
          if (commentRegex) {
            this.foldingStartMarker = new RegExp(
              this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start)
            );
            this.foldingStopMarker = new RegExp(
              this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end)
            );
          }
        };
        oop.inherits(FoldMode, BaseFoldMode);
        (function() {
          this.foldingStartMarker = /([\{\[\(])[^\}\]\)]*$|^\s*(\/\*)/;
          this.foldingStopMarker = /^[^\[\{\(]*([\}\]\)])|^[\s\*]*(\*\/)/;
          this.singleLineBlockCommentRe = /^\s*(\/\*).*\*\/\s*$/;
          this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
          this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
          this._getFoldWidgetBase = this.getFoldWidget;
          this.getFoldWidget = function(session, foldStyle, row) {
            var line = session.getLine(row);
            if (this.singleLineBlockCommentRe.test(line)) {
              if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))
                return "";
            }
            var fw = this._getFoldWidgetBase(session, foldStyle, row);
            if (!fw && this.startRegionRe.test(line))
              return "start";
            return fw;
          };
          this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
            var line = session.getLine(row);
            if (this.startRegionRe.test(line))
              return this.getCommentRegionBlock(session, line, row);
            var match = line.match(this.foldingStartMarker);
            if (match) {
              var i = match.index;
              if (match[1])
                return this.openingBracketBlock(session, match[1], row, i);
              var range = session.getCommentFoldRange(row, i + match[0].length, 1);
              if (range && !range.isMultiLine()) {
                if (forceMultiline) {
                  range = this.getSectionRange(session, row);
                } else if (foldStyle != "all")
                  range = null;
              }
              return range;
            }
            if (foldStyle === "markbegin")
              return;
            var match = line.match(this.foldingStopMarker);
            if (match) {
              var i = match.index + match[0].length;
              if (match[1])
                return this.closingBracketBlock(session, match[1], row, i);
              return session.getCommentFoldRange(row, i, -1);
            }
          };
          this.getSectionRange = function(session, row) {
            var line = session.getLine(row);
            var startIndent = line.search(/\S/);
            var startRow = row;
            var startColumn = line.length;
            row = row + 1;
            var endRow = row;
            var maxRow = session.getLength();
            while (++row < maxRow) {
              line = session.getLine(row);
              var indent = line.search(/\S/);
              if (indent === -1)
                continue;
              if (startIndent > indent)
                break;
              var subRange = this.getFoldWidgetRange(session, "all", row);
              if (subRange) {
                if (subRange.start.row <= startRow) {
                  break;
                } else if (subRange.isMultiLine()) {
                  row = subRange.end.row;
                } else if (startIndent == indent) {
                  break;
                }
              }
              endRow = row;
            }
            return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
          };
          this.getCommentRegionBlock = function(session, line, row) {
            var startColumn = line.search(/\s*$/);
            var maxRow = session.getLength();
            var startRow = row;
            var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
            var depth = 1;
            while (++row < maxRow) {
              line = session.getLine(row);
              var m = re.exec(line);
              if (!m)
                continue;
              if (m[1])
                depth--;
              else
                depth++;
              if (!depth)
                break;
            }
            var endRow = row;
            if (endRow > startRow) {
              return new Range(startRow, startColumn, endRow, line.length);
            }
          };
        }).call(FoldMode.prototype);
      });
      ace.define("ace/mode/javascript", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/javascript_highlight_rules", "ace/mode/matching_brace_outdent", "ace/worker/worker_client", "ace/mode/behaviour/cstyle", "ace/mode/folding/cstyle"], function(acequire, exports2, module2) {
        "use strict";
        var oop = acequire("../lib/oop");
        var TextMode = acequire("./text").Mode;
        var JavaScriptHighlightRules = acequire("./javascript_highlight_rules").JavaScriptHighlightRules;
        var MatchingBraceOutdent = acequire("./matching_brace_outdent").MatchingBraceOutdent;
        var WorkerClient = acequire("../worker/worker_client").WorkerClient;
        var CstyleBehaviour = acequire("./behaviour/cstyle").CstyleBehaviour;
        var CStyleFoldMode = acequire("./folding/cstyle").FoldMode;
        var Mode = function() {
          this.HighlightRules = JavaScriptHighlightRules;
          this.$outdent = new MatchingBraceOutdent();
          this.$behaviour = new CstyleBehaviour();
          this.foldingRules = new CStyleFoldMode();
        };
        oop.inherits(Mode, TextMode);
        (function() {
          this.lineCommentStart = "//";
          this.blockComment = { start: "/*", end: "*/" };
          this.$quotes = { '"': '"', "'": "'", "`": "`" };
          this.getNextLineIndent = function(state, line, tab) {
            var indent = this.$getIndent(line);
            var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
            var tokens = tokenizedLine.tokens;
            var endState = tokenizedLine.state;
            if (tokens.length && tokens[tokens.length - 1].type == "comment") {
              return indent;
            }
            if (state == "start" || state == "no_regex") {
              var match = line.match(/^.*(?:\bcase\b.*:|[\{\(\[])\s*$/);
              if (match) {
                indent += tab;
              }
            } else if (state == "doc-start") {
              if (endState == "start" || endState == "no_regex") {
                return "";
              }
              var match = line.match(/^\s*(\/?)\*/);
              if (match) {
                if (match[1]) {
                  indent += " ";
                }
                indent += "* ";
              }
            }
            return indent;
          };
          this.checkOutdent = function(state, line, input) {
            return this.$outdent.checkOutdent(line, input);
          };
          this.autoOutdent = function(state, doc, row) {
            this.$outdent.autoOutdent(doc, row);
          };
          this.createWorker = function(session) {
            var worker = new WorkerClient(["ace"], require_javascript(), "JavaScriptWorker");
            worker.attachToDocument(session.getDocument());
            worker.on("annotate", function(results) {
              session.setAnnotations(results.data);
            });
            worker.on("terminate", function() {
              session.clearAnnotations();
            });
            return worker;
          };
          this.$id = "ace/mode/javascript";
        }).call(Mode.prototype);
        exports2.Mode = Mode;
      });
    }
  });

  // node_modules/brace/theme/tomorrow.js
  var require_tomorrow = __commonJS({
    "node_modules/brace/theme/tomorrow.js"() {
      ace.define("ace/theme/tomorrow", ["require", "exports", "module", "ace/lib/dom"], function(acequire, exports2, module2) {
        exports2.isDark = false;
        exports2.cssClass = "ace-tomorrow";
        exports2.cssText = ".ace-tomorrow .ace_gutter {background: #f6f6f6;color: #4D4D4C}.ace-tomorrow .ace_print-margin {width: 1px;background: #f6f6f6}.ace-tomorrow {background-color: #FFFFFF;color: #4D4D4C}.ace-tomorrow .ace_cursor {color: #AEAFAD}.ace-tomorrow .ace_marker-layer .ace_selection {background: #D6D6D6}.ace-tomorrow.ace_multiselect .ace_selection.ace_start {box-shadow: 0 0 3px 0px #FFFFFF;}.ace-tomorrow .ace_marker-layer .ace_step {background: rgb(255, 255, 0)}.ace-tomorrow .ace_marker-layer .ace_bracket {margin: -1px 0 0 -1px;border: 1px solid #D1D1D1}.ace-tomorrow .ace_marker-layer .ace_active-line {background: #EFEFEF}.ace-tomorrow .ace_gutter-active-line {background-color : #dcdcdc}.ace-tomorrow .ace_marker-layer .ace_selected-word {border: 1px solid #D6D6D6}.ace-tomorrow .ace_invisible {color: #D1D1D1}.ace-tomorrow .ace_keyword,.ace-tomorrow .ace_meta,.ace-tomorrow .ace_storage,.ace-tomorrow .ace_storage.ace_type,.ace-tomorrow .ace_support.ace_type {color: #8959A8}.ace-tomorrow .ace_keyword.ace_operator {color: #3E999F}.ace-tomorrow .ace_constant.ace_character,.ace-tomorrow .ace_constant.ace_language,.ace-tomorrow .ace_constant.ace_numeric,.ace-tomorrow .ace_keyword.ace_other.ace_unit,.ace-tomorrow .ace_support.ace_constant,.ace-tomorrow .ace_variable.ace_parameter {color: #F5871F}.ace-tomorrow .ace_constant.ace_other {color: #666969}.ace-tomorrow .ace_invalid {color: #FFFFFF;background-color: #C82829}.ace-tomorrow .ace_invalid.ace_deprecated {color: #FFFFFF;background-color: #8959A8}.ace-tomorrow .ace_fold {background-color: #4271AE;border-color: #4D4D4C}.ace-tomorrow .ace_entity.ace_name.ace_function,.ace-tomorrow .ace_support.ace_function,.ace-tomorrow .ace_variable {color: #4271AE}.ace-tomorrow .ace_support.ace_class,.ace-tomorrow .ace_support.ace_type {color: #C99E00}.ace-tomorrow .ace_heading,.ace-tomorrow .ace_markup.ace_heading,.ace-tomorrow .ace_string {color: #718C00}.ace-tomorrow .ace_entity.ace_name.ace_tag,.ace-tomorrow .ace_entity.ace_other.ace_attribute-name,.ace-tomorrow .ace_meta.ace_tag,.ace-tomorrow .ace_string.ace_regexp,.ace-tomorrow .ace_variable {color: #C82829}.ace-tomorrow .ace_comment {color: #8E908C}.ace-tomorrow .ace_indent-guide {background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bdu3f/BwAlfgctduB85QAAAABJRU5ErkJggg==) right repeat-y}";
        var dom = acequire("../lib/dom");
        dom.importCssString(exports2.cssText, exports2.cssClass);
      });
    }
  });

  // demo/res/js/src/gt-editor.js
  var require_gt_editor = __commonJS({
    "demo/res/js/src/gt-editor.js"(exports, module) {
      var { GuidedTrackMode } = require_gt_mode();
      var lodash = require_lodash();
      var ace2 = require_brace();
      require_css2();
      require_html2();
      require_javascript2();
      require_tomorrow();
      module.exports = {
        name: "gt-editor",
        props: {
          code: {
            type: String,
            required: true,
            default: () => ""
          }
        },
        template: (
          /* html */
          `
    <div class="gt-editor">
      <div class="gt-editor-inner" ref="editor">
      </div>
    </div>
  `
        ),
        data() {
          return {
            readOnly: false,
            editor: null
          };
        },
        watch: {
          code() {
            const self2 = this;
            self2.onCodeChange();
          }
        },
        methods: {
          onCodeChange() {
            const self2 = this;
            self2.editor.setValue(self2.code);
            self2.editor.clearSelection();
            self2.editor.scrollToLine(0);
          }
        },
        mounted() {
          const self2 = this;
          const editor = ace2.edit(self2.$refs.editor);
          editor.setTheme("ace/theme/tomorrow");
          editor.setReadOnly(self2.readOnly);
          editor.renderer.setOption("printMargin", false);
          const session = editor.getSession();
          session.setMode(new GuidedTrackMode());
          session.setUseSoftTabs(false);
          session.setValue(self2.code);
          session.setUseWrapMode(true);
          session.setWrapLimitRange();
          this.editor = editor;
          self2.$el.classList.add("language-gt");
          editor.on(
            "change",
            lodash.debounce(() => {
              self2.$emit("updated", editor.getValue());
            }, 100)
          );
        },
        unmounted() {
          const self2 = this;
          self2.editor.destroy();
        }
      };
    }
  });

  // demo/res/js/src/main.js
  var { createApp } = require_vue();
  var { saveCSV } = require_src2();
  var gt = require_src4();
  var GTEditorComponent = require_gt_editor();
  function downloadTextAsJSON(text, filename) {
    const a = document.createElement("a");
    a.href = `data:application/json;charset=utf-8,${encodeURIComponent(text)}`;
    a.download = filename;
    a.dispatchEvent(new MouseEvent("click"));
  }
  var app = createApp({
    components: {
      "gt-editor": GTEditorComponent
    },
    template: (
      /* html */
      `
		<div class="notification is-danger floating-notification" ref="message">
			<button
				@click="$refs.message.classList.remove('is-active')"
				class="delete"></button>

			{{ message }}
		</div>

		<gt-editor :code="source" @updated="onSourceUpdate"></gt-editor>

		<p>
			<button @click="downloadCSV" class="button">Download CSV</button>
			<button @click="downloadJSON" class="button">Download JSON</button>
		</p>
	`
    ),
    data() {
      return {
        message: "",
        source: "",
        newSource: ""
      };
    },
    watch: {
      newSource() {
        const self2 = this;
        if (self2.newSource.trim().length > 0) {
          self2.$refs.message.classList.remove("is-active");
        }
      }
    },
    methods: {
      async downloadCSV() {
        const self2 = this;
        if (self2.newSource.trim().length === 0) {
          self2.message = "Please enter some GT code first.";
          self2.$refs.message.classList.add("is-active");
          return;
        }
        try {
          const out = gt.program.extractQuestions(self2.newSource);
          await saveCSV("questions.csv", out);
        } catch (e) {
          self2.message = e;
        }
      },
      downloadJSON() {
        const self2 = this;
        if (self2.newSource.trim().length === 0) {
          self2.message = "Please enter some GT code first.";
          self2.$refs.message.classList.add("is-active");
          return;
        }
        try {
          const out = gt.program.extractQuestions(self2.newSource);
          out.index = out.index.map((v) => v.replaceAll("row", "question"));
          const obj = out.toObject(0);
          Object.keys(obj).forEach((key) => {
            const item = obj[key];
            if (item.answers) {
              try {
                item.answers = JSON.parse(item.answers);
              } catch (e) {
              }
            }
            obj[key] = item;
          });
          downloadTextAsJSON(JSON.stringify(obj, null, 2), "questions.json");
        } catch (e) {
          self2.message = e;
        }
      },
      onSourceUpdate(newSource) {
        const self2 = this;
        self2.newSource = newSource;
      }
    },
    async mounted() {
      const self2 = this;
      const response = await fetch("sample.gt");
      self2.source = await response.text();
      self2.newSource = self2.source;
    }
  });
  app.mount("#app");
})();
/*! Bundled license information:

papaparse/papaparse.min.js:
  (* @license
  Papa Parse
  v5.3.2
  https://github.com/mholt/PapaParse
  License: MIT
  *)

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
